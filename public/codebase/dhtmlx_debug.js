/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/* dhtmlx.com */

if (typeof(window.dhx) == "undefined") {
	
	window.dhx = window.dhx4 = {
		
		version: "5.0.2",
		
		skin: null, // allow to be set by user
		
		skinDetect: function(comp) {
			var i = Math.floor(dhx4.readFromCss(comp+"_skin_detect")/10)*10;
			return {10:"dhx_skyblue",20:"dhx_web",30:"dhx_terrace",40:"material"}[i]||null;
		},
		
		// read value from css
		readFromCss: function(className, property, innerHTML) {
			var t = document.createElement("DIV");
			t.className = className;
			if (document.body.firstChild != null) document.body.insertBefore(t, document.body.firstChild); else document.body.appendChild(t);
			if (typeof(innerHTML) == "string") t.innerHTML = innerHTML;
			var w = t[property||"offsetWidth"];
			t.parentNode.removeChild(t);
			t = null;
			return w;
		},
		
		// id manager
		lastId: 1,
		newId: function() {
			return this.lastId++;
		},
		
		// z-index manager
		zim: {
			data: {},
			step: 5,
			first: function() {
				return 100;
			},
			last: function() {
				var t = this.first();
				for (var a in this.data) t = Math.max(t, this.data[a]);
				return t;
			},
			reserve: function(id) {
				this.data[id] = this.last()+this.step;
				return this.data[id];
			},
			clear: function(id) {
				if (this.data[id] != null) {
					this.data[id] = null;
					delete this.data[id];
				}
			}
		},
		
		// string to boolean
		s2b: function(r) {
			if (typeof(r) == "string") r = r.toLowerCase();
			return (r == true || r == 1 || r == "true" || r == "1" || r == "yes" || r == "y" || r == "on");
		},
		
		// string to json
		s2j: function(s) {
			var obj = null;
			dhx4.temp = null;
			try { eval("dhx4.temp="+s); } catch(e) { dhx4.temp = null; }
			obj = dhx4.temp;
			dhx4.temp = null;
			return obj;
		},
		
		// absolute top/left position on screen
		absLeft: function(obj) {
			if (typeof(obj) == "string") obj = document.getElementById(obj);
			return this.getOffset(obj).left;
		},
		absTop: function(obj) {
			if (typeof(obj) == "string") obj = document.getElementById(obj);
			return this.getOffset(obj).top;
		},
		_aOfs: function(elem) {
			var top = 0, left = 0;
			while (elem) {
				top = top + parseInt(elem.offsetTop);
				left = left + parseInt(elem.offsetLeft);
				elem = elem.offsetParent;
			}
			return {top: top, left: left};
		},
		_aOfsRect: function(elem) {
			var box = elem.getBoundingClientRect();
			var body = document.body;
			var docElem = document.documentElement;
			var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
			var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
			var clientTop = docElem.clientTop || body.clientTop || 0;
			var clientLeft = docElem.clientLeft || body.clientLeft || 0;
			var top  = box.top +  scrollTop - clientTop;
			var left = box.left + scrollLeft - clientLeft;
			return { top: Math.round(top), left: Math.round(left) };
		},
		getOffset: function(elem) {
			if (elem.getBoundingClientRect) {
				return this._aOfsRect(elem);
			} else {
				return this._aOfs(elem);
			}
		},
		
		// copy obj
		_isObj: function(k) {
			return (k != null && typeof(k) == "object" && typeof(k.length) == "undefined");
		},
		_copyObj: function(r) {
			if (this._isObj(r)) {
				var t = {};
				for (var a in r) {
					if (typeof(r[a]) == "object" && r[a] != null) t[a] = this._copyObj(r[a]); else t[a] = r[a];
				}
			} else {
				var t = [];
				for (var a=0; a<r.length; a++) {
					if (typeof(r[a]) == "object" && r[a] != null) t[a] = this._copyObj(r[a]); else t[a] = r[a];
				}
			}
			return t;
		},
		
		// screen dim
		screenDim: function() {
			var isIE = (navigator.userAgent.indexOf("MSIE") >= 0);
			var dim = {};
			dim.left = document.body.scrollLeft;
			dim.right = dim.left+(window.innerWidth||document.body.clientWidth);
			dim.top = Math.max((isIE?document.documentElement:document.getElementsByTagName("html")[0]).scrollTop, document.body.scrollTop);
			dim.bottom = dim.top+(isIE?Math.max(document.documentElement.clientHeight||0,document.documentElement.offsetHeight||0):window.innerHeight);
			return dim;
		},
		
		// input/textarea range selection
		selectTextRange: function(inp, start, end) {
			
			inp = (typeof(inp)=="string"?document.getElementById(inp):inp);
			
			var len = inp.value.length;
			start = Math.max(Math.min(start, len), 0);
			end = Math.min(end, len);
			
			if (inp.setSelectionRange) {
				try {inp.setSelectionRange(start, end);} catch(e){}; // combo in grid under IE requires try/catch
			} else if (inp.createTextRange) {
				var range = inp.createTextRange();
				range.moveStart("character", start);
				range.moveEnd("character", end-len);
				try {range.select();} catch(e){};
			}
		},
		// transition
		transData: null,
		transDetect: function() {
			
			if (this.transData == null) {
				
				this.transData = {transProp: false, transEv: null};
				
				// transition, MozTransition, WebkitTransition, msTransition, OTransition
				var k = {
					"MozTransition": "transitionend",
					"WebkitTransition": "webkitTransitionEnd",
					"OTransition": "oTransitionEnd",
					"msTransition": "transitionend",
					"transition": "transitionend"
				};
				
				for (var a in k) {
					if (this.transData.transProp == false && document.documentElement.style[a] != null) {
						this.transData.transProp = a;
						this.transData.transEv = k[a];
					}
				}
				k = null;
			}
			
			return this.transData;
			
		},
		
		// xml parser
		_xmlNodeValue: function(node) {
			var value = "";
			for (var q=0; q<node.childNodes.length; q++) {
				value += (node.childNodes[q].nodeValue!=null?node.childNodes[q].nodeValue.toString().replace(/^[\n\r\s]{0,}/,"").replace(/[\n\r\s]{0,}$/,""):"");
			}
			return value;
		}
		
	};
	
	// browser
	window.dhx4.isIE = (navigator.userAgent.indexOf("MSIE") >= 0 || navigator.userAgent.indexOf("Trident") >= 0);
	window.dhx4.isIE6 = (window.XMLHttpRequest == null && navigator.userAgent.indexOf("MSIE") >= 0);
	window.dhx4.isIE7 = (navigator.userAgent.indexOf("MSIE 7.0") >= 0 && navigator.userAgent.indexOf("Trident") < 0);
	window.dhx4.isIE8 = (navigator.userAgent.indexOf("MSIE 8.0") >= 0 && navigator.userAgent.indexOf("Trident") >= 0);
	window.dhx4.isIE9 = (navigator.userAgent.indexOf("MSIE 9.0") >= 0 && navigator.userAgent.indexOf("Trident") >= 0);
	window.dhx4.isIE10 = (navigator.userAgent.indexOf("MSIE 10.0") >= 0 && navigator.userAgent.indexOf("Trident") >= 0 && window.navigator.pointerEnabled != true);
	window.dhx4.isIE11 = (navigator.userAgent.indexOf("Trident") >= 0 && window.navigator.pointerEnabled == true);
	window.dhx4.isEdge = (navigator.userAgent.indexOf("Edge") >= 0);
	window.dhx4.isOpera = (navigator.userAgent.indexOf("Opera") >= 0);
	window.dhx4.isChrome = (navigator.userAgent.indexOf("Chrome") >= 0) && !window.dhx4.isEdge;
	window.dhx4.isKHTML = (navigator.userAgent.indexOf("Safari") >= 0 || navigator.userAgent.indexOf("Konqueror") >= 0) && !window.dhx4.isEdge;
	window.dhx4.isFF = (navigator.userAgent.indexOf("Firefox") >= 0);
	window.dhx4.isIPad = (navigator.userAgent.search(/iPad/gi) >= 0);
	
	// dnd data
	window.dhx4.dnd = {
		evs: {},
		p_en: ((window.dhx4.isIE || window.dhx4.isEdge) && (window.navigator.pointerEnabled || window.navigator.msPointerEnabled)), // touch/pointer
		_mTouch: function(e) {
			// mouse touch type in ie10/11/Edge
			return (window.dhx4.isIE10 && e.pointerType == e.MSPOINTER_TYPE_MOUSE || window.dhx4.isIE11 && e.pointerType == "mouse" || window.dhx4.isEdge && e.pointerType == "mouse");
		},
		_touchOn: function(obj) {
			if (obj == null) obj = document.body;
			obj.style.touchAction = obj.style.msTouchAction = "";
			obj = null;
		},
		_touchOff: function(obj) {
			if (obj == null) obj = document.body;
			obj.style.touchAction = obj.style.msTouchAction = "none";
			obj = null;
		}
	};
	
	// dnd events
	if (window.navigator.pointerEnabled == true) { // edge/ie11
		window.dhx4.dnd.evs = {start: "pointerdown", move: "pointermove", end: "pointerup"};
	} else if (window.navigator.msPointerEnabled == true) { // ie10-
		window.dhx4.dnd.evs = {start: "MSPointerDown", move: "MSPointerMove", end: "MSPointerUp"};
	} else if (typeof(window.addEventListener) != "undefined") { // rest touch devices
		window.dhx4.dnd.evs = {start: "touchstart", move: "touchmove", end: "touchend"};
	};
	
};

if (typeof(window.dhx4.template) == "undefined") {
	
	// trim
	window.dhx4.trim = function(t) {
		return String(t).replace(/^\s{1,}/,"").replace(/\s{1,}$/,"");
	};
	
	// template parsing
	window.dhx4.template = function(tpl, data, trim) {
		
		// tpl - template text, #value|func:param0:param1:paramX#
		// data - object with key-value
		// trim - true/false, trim values
		return tpl.replace(/#([a-z0-9_-]{1,})(\|([^#]*))?#/gi, function(){
			
			var key = arguments[1];
			
			var t = window.dhx4.trim(arguments[3]);
			var func = null;
			var args = [data[key]];
			
			if (t.length > 0) {
				
				t = t.split(":");
				var k = [];
				
				// check escaped colon
				for (var q=0; q<t.length; q++) {
					if (q > 0 && k[k.length-1].match(/\\$/) != null) {
						k[k.length-1] = k[k.length-1].replace(/\\$/,"")+":"+t[q];
					} else {
						k.push(t[q]);
					}
				}
				
				func = k[0];
				for (var q=1; q<k.length; q++) args.push(k[q]);
				
			}
			
			// via inner function
			if (typeof(func) == "string" && typeof(window.dhx4.template[func]) == "function") {
				return window.dhx4.template[func].apply(window.dhx4.template, args);
			}
			
			// value only
			if (key.length > 0 && typeof(data[key]) != "undefined") {
				if (trim == true) return window.dhx4.trim(data[key]);
				return String(data[key]);
			}
			
			// key not found
			return "";
			
		});
		
	};
	
	window.dhx4.template.date = function(value, format) {
		// Date obj + format	=> convert to string
		// timestamp + format	=> convert to string
		// string		=> no convert
		// any other value	=> empty string
		if (value != null) {
			if (value instanceof Date) {
				return window.dhx4.date2str(value, format);
			} else {
				value = value.toString();
				if (value.match(/^\d*$/) != null) return window.dhx4.date2str(new Date(parseInt(value)), format);
				return value;
			}
		}
		return "";
	};
	
	window.dhx4.template.maxlength = function(value, limit) {
		return String(value).substr(0, limit);
	};
	
	window.dhx4.template.number_format = function(value, format, group_sep, dec_sep) {
		var fmt = window.dhx4.template._parseFmt(format, group_sep, dec_sep);
		if (fmt == false) return value;
		return window.dhx4.template._getFmtValue(value, fmt);
	};
	
	window.dhx4.template.lowercase = function(value) {
		if (typeof(value) == "undefined" || value == null) value = "";
		return String(value).toLowerCase();
	};
	window.dhx4.template.uppercase = function(value) {
		if (typeof(value) == "undefined" || value == null) value = "";
		return String(value).toUpperCase();
	};
	
	// number format helpers
	window.dhx4.template._parseFmt = function(format, group_sep, dec_sep) {
		
		var t = format.match(/^([^\.\,0-9]*)([0\.\,]*)([^\.\,0-9]*)/);
		if (t == null || t.length != 4) return false; // invalid format
		
		var fmt = {
			// int group
			i_len: false,
			i_sep: (typeof(group_sep)=="string"?group_sep:","),
			// decimal
			d_len: false,
			d_sep: (typeof(dec_sep)=="string"?dec_sep:"."),
			// chars before and after
			s_bef: (typeof(t[1])=="string"?t[1]:""),
			s_aft: (typeof(t[3])=="string"?t[3]:"")
		};
		
		var f = t[2].split(".");
		if (f[1] != null) fmt.d_len = f[1].length;
		
		var r = f[0].split(",");
		if (r.length > 1) fmt.i_len = r[r.length-1].length;
		
		return fmt;
		
	};
	
	window.dhx4.template._getFmtValue = function(value, fmt) {
		
		var r = String(value).match(/^(-)?([0-9]{1,})(\.([0-9]{1,}))?$/); // r = [complete value, minus sign, integer, full decimal, decimal]
		
		if (r != null && r.length == 5) {
			var v0 = "";
			// minus sign
			if (r[1] != null) v0 += r[1];
			// chars before
			v0 += fmt.s_bef;
			// int part
			if (fmt.i_len !== false) {
				var i = 0; var v1 = "";
				for (var q=r[2].length-1; q>=0; q--) {
					v1 = ""+r[2].charAt(q)+v1;
					if (++i == fmt.i_len && q > 0) { v1=fmt.i_sep+v1; i=0; }
				}
				v0 += v1;
			} else {
				v0 += r[2];
			}
			// dec part
			if (fmt.d_len !== false) {
				if (r[4] == null) r[4] = "";
				while (r[4].length < fmt.d_len) r[4] += "0";
				eval("dhx4.temp = new RegExp(/\\d{"+fmt.d_len+"}/);");
				var t1 = (r[4]).match(dhx4.temp);
				if (t1 != null) v0 += fmt.d_sep+t1;
				dhx4.temp = t1 = null;
			}
			// chars after
			v0 += fmt.s_aft;
			
			return v0;
		}
		
		return value;
	};
	
};

if (typeof(window.dhx4.dateLang) == "undefined") {
	
	window.dhx4.dateLang = "en";
	window.dhx4.dateStrings = {
		en: {
			monthFullName:	["January","February","March","April","May","June","July","August","September","October","November","December"],
			monthShortName:	["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],
			dayFullName:	["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],
			dayShortName:	["Su","Mo","Tu","We","Th","Fr","Sa"]
		}
	};
	window.dhx4.dateFormat = {
		en: "%Y-%m-%d"
	};
	
	window.dhx4.date2str = function(val, format, strings) {
		
		if (format == null || typeof(format) == "undefined") format = window.dhx4.dateFormat[window.dhx4.dateLang];
		if (strings == null || typeof(strings) == "undefined") strings = window.dhx4.dateStrings[window.dhx4.dateLang];
		
		if (val instanceof Date) {
			var z = function(t) {
				return (String(t).length==1?"0"+String(t):t);
			}
			var k = function(t) {
				switch(t) {
					case "%d": return z(val.getDate());
					case "%j": return val.getDate();
					case "%D": return strings.dayShortName[val.getDay()];
					case "%l": return strings.dayFullName[val.getDay()];
					case "%m": return z(val.getMonth()+1);
					case "%n": return val.getMonth()+1;
					case "%M": return strings.monthShortName[val.getMonth()];
					case "%F": return strings.monthFullName[val.getMonth()];
					case "%y": return z(val.getYear()%100);
					case "%Y": return val.getFullYear();
					case "%g": return (val.getHours()+11)%12+1;
					case "%h": return z((val.getHours()+11)%12+1);
					case "%G": return val.getHours();
					case "%H": return z(val.getHours());
					case "%i": return z(val.getMinutes());
					case "%s": return z(val.getSeconds());
					case "%a": return (val.getHours()>11?"pm":"am");
					case "%A": return (val.getHours()>11?"PM":"AM");
					case "%%": return "%";
					case "%u": return val.getMilliseconds();
					case "%P":
						if (window.dhx4.temp_calendar != null && window.dhx4.temp_calendar.tz != null) return window.dhx4.temp_calendar.tz;
						var ofs = val.getTimezoneOffset();
						var h = Math.abs(Math.floor(ofs/60));
						var m = Math.abs(ofs)-h*60;
						return (ofs>0?"-":"+")+z(h)+":"+z(m);
					default: return t;
				}
			}
			var t = String(format||window.dhx4.dateFormat).replace(/%[a-zA-Z]/g, k);
		}
		
		return (t||String(val));
		
	};
	
	window.dhx4.str2date = function(val, format, strings) {
		
		if (format == null || typeof(format) == "undefined") format = window.dhx4.dateFormat[window.dhx4.dateLang];
		if (strings == null || typeof(strings) == "undefined") strings = window.dhx4.dateStrings[window.dhx4.dateLang];
		
		// escape custom chars
		format = format.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\\:|]/g, "\\$&");
		
		var v = [];
		var f = [];
		
		// escape required chars
		format = format.replace(/%[a-z]/gi, function(t){
			switch (t) {
				case "%d": case "%m": case "%y": case "%h": case "%H": case "%i": case "%s": f.push(t); return "(\\d{2})"; // 2 digits
				case "%D": case "%l": case "%M": case "%F": f.push(t); return "([a-zéûä\u0430-\u044F\u0451]{1,})"; // chars
				case "%j": case "%n": case "%g": case "%G": f.push(t); return "(\\d{1,2})"; // 1-2 digits
				case "%Y": f.push(t); return "(\\d{4})"; // 4 digits
				case "%a": f.push(t); return "([a|p]m)"; // am/pm
				case "%A": f.push(t); return "([A|P]M)"; // AM/PM
				case "%u": f.push(t); return "(\\d{1,6})"; // 1-6 digits, micro/milliseconds
				case "%P": f.push(t); return "([+-]\\d{1,2}:\\d{1,2})"; // zone offset
			}
			return t;
		});
		
		var re = new RegExp(format, "i");
		var e = val.match(re);
		
		if (e == null || e.length-1 != f.length) return "Invalid Date";
		
		// sorting
		/*
		Year	y,Y	1
		Month	n,m,M,F	2
		Day	d,j	3
		AM/PM	a,A	4
		Hours	H,G,h,g	5
		Minutes	i	6
		Seconds	s	7
		MSec	u	7
		Zone 	P	7
		*/
		
		for (var q=1; q<e.length; q++) v.push(e[q]);
		
		var p = {"%y":1,"%Y":1,"%n":2,"%m":2,"%M":2,"%F":2,"%d":3,"%j":3,"%a":4,"%A":4,"%H":5,"%G":5,"%h":5,"%g":5,"%i":6,"%s":7,"%u":7,"%P":7};
		var v2 = {};
		var f2 = {};
		for (var q=0; q<f.length; q++) {
			if (typeof(p[f[q]]) != "undefined") {
				var ind = p[f[q]];
				if (!v2[ind]){v2[ind]=[];f2[ind]=[];}
				v2[ind].push(v[q]);
				f2[ind].push(f[q]);
			}
		}
		v = [];
		f = [];
		for (var q=1; q<=7; q++) {
			if (v2[q] != null) {
				for (var w=0; w<v2[q].length; w++) {
					v.push(v2[q][w]);
					f.push(f2[q][w]);
				}
			}
		}
		
		// parsing date
		var r = new Date();
		r.setDate(1); // fix for 31th
		r.setHours(0);
		r.setMinutes(0);
		r.setSeconds(0);
		r.setMilliseconds(0);
		
		// get index by value
		var getInd = function(val, ar) {
			for (var q=0; q<ar.length; q++) if (ar[q].toLowerCase() == val) return q;
			return -1;
		}
		
		for (var q=0; q<v.length; q++) {
			switch (f[q]) {
				case "%d": case "%j": case "%n": case "%m": case "%Y": case "%H": case "%G": case "%i": case "%s": case "%u":
					if (!isNaN(v[q])) r[{"%d":"setDate","%j":"setDate","%n":"setMonth","%m":"setMonth","%Y":"setFullYear","%H":"setHours","%G":"setHours","%i":"setMinutes","%s":"setSeconds","%u":"setMilliseconds"}[f[q]]](Number(v[q])+(f[q]=="%m"||f[q]=="%n"?-1:0));
					break;
				//
				case "%M": case "%F":
					var k = getInd(v[q].toLowerCase(),strings[{"%M":"monthShortName","%F":"monthFullName"}[f[q]]]);
					if (k >= 0) r.setMonth(k);
					break;
				//
				case "%y":
					if (!isNaN(v[q])) {
						var v0 = Number(v[q]);
						r.setFullYear(v0+(v0>50?1900:2000));
					}
					break;
				//
				case "%g": case "%h":
					if (!isNaN(v[q])) {
						var v0 = Number(v[q]);
						if (v0 <= 12 && v0 >= 0) r.setHours(v0+(getInd("pm",v)>=0?(v0==12?0:12):(v0==12?-12:0))); // 12:00 AM -> midnight, 12:00 PM -> noon
					}
					break;
				//
				case "%P":
					if (window.dhx4.temp_calendar != null) {
						window.dhx4.temp_calendar.tz = v[q];
					}
					break;
			}
		}
		return r;
	};
	
};

if (typeof(window.dhx4.ajax) == "undefined") {
	
	window.dhx4.ajax = {
		
		// if false - dhxr param will added to prevent caching on client side (default),
		// if true - do not add extra params
		cache: false,
		
		// default method for load/loadStruct, post/get allowed
		// get - since 4.1.1, this should fix 412 error for macos safari
		method: "get",
		
		parse: function(data) {
			if (typeof data !== "string") return data;
			
			data = data.replace(/^[\s]+/,"");
			if (window.DOMParser && !dhx4.isIE) { // ff,ie9
				var obj = (new window.DOMParser()).parseFromString(data, "text/xml");
			} else if (window.ActiveXObject !== window.undefined) {
				var obj = new window.ActiveXObject("Microsoft.XMLDOM");
				obj.async = "false";
				obj.loadXML(data);
			}
			return obj;
		},
		xmltop: function(tagname, xhr, obj) {
			if (typeof xhr.status == "undefined" || xhr.status < 400) {
				xml = (!xhr.responseXML) ? dhx4.ajax.parse(xhr.responseText || xhr) : (xhr.responseXML || xhr);
				if (xml && xml.documentElement !== null) {
					try {
						if (!xml.getElementsByTagName("parsererror").length)
							return xml.getElementsByTagName(tagname)[0];
					} catch(e){}
				}
			}
			if (obj !== -1) dhx4.callEvent("onLoadXMLError",["Incorrect XML", arguments[1], obj]);
			return document.createElement("DIV");
		},
		xpath: function(xpathExp, docObj) {
			if (!docObj.nodeName) docObj = docObj.responseXML || docObj;
			if (dhx4.isIE) {
				try {
					return docObj.selectNodes(xpathExp)||[];
				} catch(e){ return []; }
			} else {
				var rows = [];
				var first;
				var col = (docObj.ownerDocument||docObj).evaluate(xpathExp, docObj, null, XPathResult.ANY_TYPE, null);
				while (first = col.iterateNext()) rows.push(first);
				return rows;
			}
		},
		query: function(config) {
			dhx4.ajax._call(
				(config.method || "GET"),
				config.url,
				config.data || "",
				(config.async || true),
				config.callback,
				null,
				config.headers
			);
		},
		get: function(url, onLoad) {
			return this._call("GET", url, null, true, onLoad);
		},
		getSync: function(url) {
			return this._call("GET", url, null, false);
		},
		put: function(url, postData, onLoad) {
			return this._call("PUT", url, postData, true, onLoad);
		},
		del: function(url, postData, onLoad) {
			return this._call("DELETE", url, postData, true, onLoad);
		},
		post: function(url, postData, onLoad) {
			if (arguments.length == 1) {
				postData = "";
			} else if (arguments.length == 2 && (typeof(postData) == "function" || typeof(window[postData]) == "function")) {
				onLoad = postData;
				postData = "";
			} else {
				postData = String(postData);
			}
			return this._call("POST", url, postData, true, onLoad);
		},
		postSync: function(url, postData) {
			postData = (postData == null ? "" : String(postData));
			return this._call("POST", url, postData, false);
		},
		getLong: function(url, onLoad) {
			this._call("GET", url, null, true, onLoad, {url:url});
		},
		postLong: function(url, postData, onLoad) {
			if (arguments.length == 2 && (typeof(postData) == "function" || typeof(window[postData]))) {
				onLoad = postData;
				postData = "";
			}
			this._call("POST", url, postData, true, onLoad, {url:url, postData:postData});
		},
		_call: function(method, url, postData, async, onLoad, longParams, headers) {
			
			var t = (window.XMLHttpRequest && !dhx4.isIE ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP"));
			var isQt = (navigator.userAgent.match(/AppleWebKit/) != null && navigator.userAgent.match(/Qt/) != null && navigator.userAgent.match(/Safari/) != null);
			
			if (async == true) {
				t.onreadystatechange = function() {
					if ((t.readyState == 4) || (isQt == true && t.readyState == 3)) { // what for long response and status 404?
						if (t.status != 200 || t.responseText == "")
							if (!dhx4.callEvent("onAjaxError", [{xmlDoc:t, filePath:url, async:async}])) return;

						window.setTimeout(function(){
							if (typeof(onLoad) == "function") {
								onLoad.apply(window, [{xmlDoc:t, filePath:url, async:async}]); // dhtmlx-compat, response.xmlDoc.responseXML/responseText
							}
							if (longParams != null) {
								if (typeof(longParams.postData) != "undefined") {
									dhx4.ajax.postLong(longParams.url, longParams.postData, onLoad);
								} else {
									dhx4.ajax.getLong(longParams.url, onLoad);
								}
							}
							onLoad = null;
							t = null;
						},1);
					}
				}
			}
			
			if (method == "GET") {
				url += this._dhxr(url);
			}
			
			t.open(method, url, async);
			
			if (headers != null) {
				for (var key in headers) t.setRequestHeader(key, headers[key]);
			} else if (method == "POST" || method == "PUT" || method == "DELETE") {
				t.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
			} else if (method == "GET") {
				postData = null;
			}
			
			t.setRequestHeader("X-Requested-With", "XMLHttpRequest");
			
			t.send(postData);
			
			if (async != true) {
				if ((t.readyState == 4) || (isQt == true && t.readyState == 3)) {
					if (t.status != 200 || t.responseText == "") dhx4.callEvent("onAjaxError", [{xmlDoc:t, filePath:url, async:async}]);
				}
			}
			
			return {xmlDoc:t, filePath:url, async:async}; // dhtmlx-compat, response.xmlDoc.responseXML/responseText
			
		},
		
		_dhxr: function(sign, value) {
			if (this.cache != true) {
				if (sign.match(/^[\?\&]$/) == null) sign = (sign.indexOf("?")>=0?"&":"?");
				if (typeof(value) == "undefined") value = true;
				return sign+"dhxr"+new Date().getTime()+(value==true?"=1":"");
			}
			return "";
		}
	};
	
};

if (typeof(window.dhx4._enableDataLoading) == "undefined") {
	
	window.dhx4._enableDataLoading = function(obj, initObj, xmlToJson, xmlRootTag, mode) {
		
		if (mode == "clear") {
			
			// clear attached functionality
			
			for (var a in obj._dhxdataload) {
				obj._dhxdataload[a] = null;
				delete obj._dhxdataload[a];
			};
			
			obj._loadData = null;
			obj._dhxdataload = null;
			obj.load = null;
			obj.loadStruct = null;
			
			obj = null;
			
			return;
			
		}
		
		obj._dhxdataload = { // move to obj.conf?
			initObj: initObj,
			xmlToJson: xmlToJson,
			xmlRootTag: xmlRootTag,
			onBeforeXLS: null
		};
		
		obj._loadData = function(data, loadParams, onLoad) {
			
			if (arguments.length == 2) {
				onLoad = loadParams;
				loadParams = null;
			}
			
			var obj = null;
			
			// deprecated from 4.0, compatability with version (url, type[json|xml], onLoad)
			if (arguments.length == 3) onLoad = arguments[2];
			
			if (typeof(data) == "string") {
				
				var k = data.replace(/^\s{1,}/,"").replace(/\s{1,}$/,"");
				
				var tag = new RegExp("^<"+this._dhxdataload.xmlRootTag);
				
				// xml
				if (tag.test(k.replace(/^<\?xml[^\?]*\?>\s*/, ""))) { // remove leading <?xml ...?> if any, \n can be also present
					obj = dhx4.ajax.parse(data);
					if (obj != null) obj = this[this._dhxdataload.xmlToJson].apply(this, [obj]); // xml to json
				}
				
				if (obj == null && (k.match(/^[\s\S]*{[.\s\S]*}[\s\S]*$/) != null || k.match(/^[\s\S]*\[[.\s\S]*\][\s\S]*$/) != null)) { // check for '{...}' or '[...]', cut leading/trailing \n\r with \s\S
					obj = dhx4.s2j(k);
				}
				
				if (obj == null) {
					
					this.callEvent("onXLS",[]);
					
					var params = [];
					
					// allow to modify url and add params
					if (typeof(this._dhxdataload.onBeforeXLS) == "function") {
						var k = this._dhxdataload.onBeforeXLS.apply(this,[data]);
						if (k != null && typeof(k) == "object") {
							if (k.url != null) data = k.url;
							if (k.params != null) { for (var a in k.params) params.push(a+"="+encodeURIComponent(k.params[a])); }
						}
					}
					
					var t = this;
					var callBack = function(r) {
						
						var obj = null;
						
						if ((r.xmlDoc.getResponseHeader("Content-Type")||"").search(/xml/gi) >= 0 || (r.xmlDoc.responseText.replace(/^\s{1,}/,"")).match(/^</) != null) {
							obj = t[t._dhxdataload.xmlToJson].apply(t,[r.xmlDoc.responseXML]);
						} else {
							obj = dhx4.s2j(r.xmlDoc.responseText);
						}
						
						// init
						if (obj != null) t[t._dhxdataload.initObj].apply(t,[obj,data]); // data => url
						
						t.callEvent("onXLE",[]);
						
						if (onLoad != null) {
							if (typeof(onLoad) == "function") {
								onLoad.apply(t,[]);
							} else if (typeof(window[onLoad]) == "function") {
								window[onLoad].apply(t,[]);
							}
						}
						
						callBack = onLoad = null;
						obj = r = t = null;
						
					};
					
					params = params.join("&")+(typeof(loadParams)=="string"?"&"+loadParams:"");
					
					if (dhx4.ajax.method == "post") {
						dhx4.ajax.post(data, params, callBack);
					} else if (dhx4.ajax.method == "get") {
						dhx4.ajax.get(data+(params.length>0?(data.indexOf("?")>0?"&":"?")+params:""), callBack);
					}
					
					return;
				}
				
			} else {
				if (typeof(data.documentElement) == "object" || (typeof(data.tagName) != "undefined" && typeof(data.getElementsByTagName) != "undefined" && data.getElementsByTagName(this._dhxdataload.xmlRootTag).length > 0)) { // xml
					obj = this[this._dhxdataload.xmlToJson].apply(this, [data]);
				} else { // json
					obj = window.dhx4._copyObj(data);
				}
				
			}
			
			// init
			if (obj != null) this[this._dhxdataload.initObj].apply(this,[obj]);
			
			if (onLoad != null) {
				if (typeof(onLoad) == "function") {
					onLoad.apply(this, []);
				} else if (typeof(window[onLoad]) == "function") {
					window[onLoad].apply(this, []);
				}
				onLoad = null;
			}
			
		};
		
		// loadStruct for hdr/conf
		// load for data
		if (mode != null) {
			var k = {struct: "loadStruct", data: "load"};
			for (var a in mode) {
				if (mode[a] == true) obj[k[a]] = function() {return this._loadData.apply(this, arguments);}
			}
		}
		
		obj = null;
		
	};
};

if (typeof(window.dhx4._eventable) == "undefined") {
	
	window.dhx4._eventable = function(obj, mode) {
		
		if (mode == "clear") {
			
			obj.detachAllEvents();
			
			obj.dhxevs = null;
			
			obj.attachEvent = null;
			obj.detachEvent = null;
			obj.checkEvent = null;
			obj.callEvent = null;
			obj.detachAllEvents = null;
			
			obj = null;
			
			return;
			
		}
		
		obj.dhxevs = { data: {} };
		
		obj.attachEvent = function(name, func) {
			name = String(name).toLowerCase();
			if (!this.dhxevs.data[name]) this.dhxevs.data[name] = {};
			var eventId = window.dhx4.newId();
			this.dhxevs.data[name][eventId] = func;
			return eventId;
		}
		
		obj.detachEvent = function(eventId) {
			for (var a in this.dhxevs.data) {
				var k = 0;
				for (var b in this.dhxevs.data[a]) {
					if (b == eventId) {
						this.dhxevs.data[a][b] = null;
						delete this.dhxevs.data[a][b];
					} else {
						k++;
					}
				}
				if (k == 0) {
					this.dhxevs.data[a] = null;
					delete this.dhxevs.data[a];
				}
			}
		}
		
		obj.checkEvent = function(name) {
			name = String(name).toLowerCase();
			return (this.dhxevs.data[name] != null);
		}
		
		obj.callEvent = function(name, params) {
			name = String(name).toLowerCase();
			if (this.dhxevs.data[name] == null) return true;
			var r = true;
			for (var a in this.dhxevs.data[name]) {
				r = this.dhxevs.data[name][a].apply(this, params) && r;
			}
			return r;
		}
		
		obj.detachAllEvents = function() {
			for (var a in this.dhxevs.data) {
				for (var b in this.dhxevs.data[a]) {
					this.dhxevs.data[a][b] = null;
					delete this.dhxevs.data[a][b];
				}
				this.dhxevs.data[a] = null;
				delete this.dhxevs.data[a];
			}
		}
		
		obj = null;
	};
	
	dhx4._eventable(dhx4);
	
};

// validation
// all purpose set of rules, based on http://code.google.com/p/validation-js
if (!window.dhtmlxValidation) {
	dhtmlxValidation = function(){};
	dhtmlxValidation.prototype = {
		isEmpty: function(value) {
			return value == '';
		},
		isNotEmpty: function(value) {
			return (value instanceof Array?value.length>0:!value == ''); // array in case of multiselect
		},
		isValidBoolean: function(value) {
			return !!value.toString().match(/^(0|1|true|false)$/);
		},
		isValidEmail: function(value) {
			return !!value.toString().match(/(^[a-z0-9]([0-9a-z\-_\.]*)@([0-9a-z_\-\.]*)([.][a-z]{3})$)|(^[a-z]([0-9a-z_\.\-]*)@([0-9a-z_\-\.]*)(\.[a-z]{2,5})$)/i);
		},
		isValidInteger: function(value) {
			return !!value.toString().match(/(^-?\d+$)/);
		},
		isValidNumeric: function(value) {
			return !!value.toString().match(/(^-?\d\d*[\.|,]\d*$)|(^-?\d\d*$)|(^-?[\.|,]\d\d*$)/);
		},
		isValidAplhaNumeric: function(value) {
			return !!value.toString().match(/^[_\-a-z0-9]+$/gi);
		},
		// 0000-00-00 00:00:00 to 9999:12:31 59:59:59 (no it is not a "valid DATE" function)
		isValidDatetime: function(value) {
			var dt = value.toString().match(/^(\d{4})-(\d{2})-(\d{2})\s(\d{2}):(\d{2}):(\d{2})$/);
			return dt && !!(dt[1]<=9999 && dt[2]<=12 && dt[3]<=31 && dt[4]<=59 && dt[5]<=59 && dt[6]<=59) || false;
		},
		// 0000-00-00 to 9999-12-31
		isValidDate: function(value) {
			var d = value.toString().match(/^(\d{4})-(\d{2})-(\d{2})$/);
			return d && !!(d[1]<=9999 && d[2]<=12 && d[3]<=31) || false;
		},
		// 00:00:00 to 59:59:59
		isValidTime: function(value) {
			var t = value.toString().match(/^(\d{1,2}):(\d{1,2}):(\d{1,2})$/);
			return t && !!(t[1]<=24 && t[2]<=59 && t[3]<=59) || false;
		},
		// 0.0.0.0 to 255.255.255.255
		isValidIPv4: function(value) { 
			var ip = value.toString().match(/^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/);
			return ip && !!(ip[1]<=255 && ip[2]<=255 && ip[3]<=255 && ip[4]<=255) || false;
		},
		isValidCurrency: function(value) { // Q: Should I consider those signs valid too ? : ¢|€|₤|₦|¥
			return value.toString().match(/^\$?\s?\d+?([\.,\,]?\d+)?\s?\$?$/) && true || false;
		},
		// Social Security Number (999-99-9999 or 999999999)
		isValidSSN: function(value) {
			return value.toString().match(/^\d{3}\-?\d{2}\-?\d{4}$/) && true || false;
		},
		// Social Insurance Number (999999999)
		isValidSIN: function(value) {
			return value.toString().match(/^\d{9}$/) && true || false;
		}
	};
	dhtmlxValidation = new dhtmlxValidation();
};


if (typeof(window.dhtmlx) == "undefined") {
	window.dhtmlx={
		extend:function(a, b){
			for (var key in b)
				if (!a[key])
					a[key]=b[key];
			return a;
		},
		extend_api:function(name,map,ext){
			var t = window[name];
			if (!t) return; //component not defined
			window[name]=function(obj){
				if (obj && typeof obj == "object" && !obj.tagName){
					var that = t.apply(this,(map._init?map._init(obj):arguments));
					//global settings
					for (var a in dhtmlx)
						if (map[a]) this[map[a]](dhtmlx[a]);			
					//local settings
					for (var a in obj){
						if (map[a]) this[map[a]](obj[a]);
						else if (a.indexOf("on")===0){
							this.attachEvent(a,obj[a]);
						}
					}
				} else
					var that = t.apply(this,arguments);
				if (map._patch) map._patch(this);
				return that||this;
			};
			window[name].prototype=t.prototype;
			if (ext)
				dhtmlx.extend(window[name].prototype,ext);
		},
		url:function(str){
			if (str.indexOf("?") != -1)
				return "&";
			else
				return "?";
		}
	};
};

/**  
*     @desc: find out what symbol to use as url param delimiters in further params
*     @type: private
*     @param: str - current url string
*     @topic: 0  
*/


function dhtmlDragAndDropObject(){
	if (window.dhtmlDragAndDrop)
		return window.dhtmlDragAndDrop;

	this.lastLanding=0;
	this.dragNode=0;
	this.dragStartNode=0;
	this.dragStartObject=0;
	this.tempDOMU=null;
	this.tempDOMM=null;
	this.waitDrag=0;
	window.dhtmlDragAndDrop=this;

	return this;
};

dhtmlDragAndDropObject.prototype.removeDraggableItem=function(htmlNode){
	htmlNode.onmousedown=null;
	htmlNode.dragStarter=null;
	htmlNode.dragLanding=null;
}
dhtmlDragAndDropObject.prototype.addDraggableItem=function(htmlNode, dhtmlObject){
	htmlNode.onmousedown=this.preCreateDragCopy;
	htmlNode.dragStarter=dhtmlObject;
	this.addDragLanding(htmlNode, dhtmlObject);
}
dhtmlDragAndDropObject.prototype.addDragLanding=function(htmlNode, dhtmlObject){
	htmlNode.dragLanding=dhtmlObject;
}
dhtmlDragAndDropObject.prototype.preCreateDragCopy=function(e){
	if ((e||window.event) && (e||event).button == 2)
		return;

	if (window.dhtmlDragAndDrop.waitDrag){
		window.dhtmlDragAndDrop.waitDrag=0;
		document.body.onmouseup=window.dhtmlDragAndDrop.tempDOMU;
		document.body.onmousemove=window.dhtmlDragAndDrop.tempDOMM;
		return false;
	}
	
	if (window.dhtmlDragAndDrop.dragNode)
		window.dhtmlDragAndDrop.stopDrag(e);	

	window.dhtmlDragAndDrop.waitDrag=1;
	window.dhtmlDragAndDrop.tempDOMU=document.body.onmouseup;
	window.dhtmlDragAndDrop.tempDOMM=document.body.onmousemove;
	window.dhtmlDragAndDrop.dragStartNode=this;
	window.dhtmlDragAndDrop.dragStartObject=this.dragStarter;
	document.body.onmouseup=window.dhtmlDragAndDrop.preCreateDragCopy;
	document.body.onmousemove=window.dhtmlDragAndDrop.callDrag;
	window.dhtmlDragAndDrop.downtime = new Date().valueOf();
	

	if ((e)&&(e.preventDefault)){
		e.preventDefault();
		return false;
	}
	return false;
};
dhtmlDragAndDropObject.prototype.callDrag=function(e){
	if (!e)
		e=window.event;
	dragger=window.dhtmlDragAndDrop;
	if ((new Date()).valueOf()-dragger.downtime<100) return;

	//if ((e.button == 0)&&(_isIE))
	//	return dragger.stopDrag();

	if (!dragger.dragNode){
		if (dragger.waitDrag){
			dragger.dragNode=dragger.dragStartObject._createDragNode(dragger.dragStartNode, e);
	
			if (!dragger.dragNode)
				return dragger.stopDrag();
	
			dragger.dragNode.onselectstart=function(){return false;}
			dragger.gldragNode=dragger.dragNode;
			document.body.appendChild(dragger.dragNode);
			document.body.onmouseup=dragger.stopDrag;
			dragger.waitDrag=0;
			dragger.dragNode.pWindow=window;
			dragger.initFrameRoute();
		} 
		else return dragger.stopDrag(e, true);
	}

	if (dragger.dragNode.parentNode != window.document.body && dragger.gldragNode){
		var grd = dragger.gldragNode;

		if (dragger.gldragNode.old)
			grd=dragger.gldragNode.old;

		//if (!document.all) dragger.calculateFramePosition();
		grd.parentNode.removeChild(grd);
		var oldBody = dragger.dragNode.pWindow;

		if (grd.pWindow &&	grd.pWindow.dhtmlDragAndDrop.lastLanding)
			grd.pWindow.dhtmlDragAndDrop.lastLanding.dragLanding._dragOut(grd.pWindow.dhtmlDragAndDrop.lastLanding);	
			
		//		var oldp=dragger.dragNode.parentObject;
		if (_isIE){
			var div = document.createElement("Div");
			div.innerHTML=dragger.dragNode.outerHTML;
			dragger.dragNode=div.childNodes[0];
		} else
			dragger.dragNode=dragger.dragNode.cloneNode(true);

		dragger.dragNode.pWindow=window;
		//		dragger.dragNode.parentObject=oldp;

		dragger.gldragNode.old=dragger.dragNode;
		document.body.appendChild(dragger.dragNode);
		oldBody.dhtmlDragAndDrop.dragNode=dragger.dragNode;
	}

	dragger.dragNode.style.left=e.clientX+15+(dragger.fx
		? dragger.fx*(-1)
		: 0)
		+(document.body.scrollLeft||document.documentElement.scrollLeft)+"px";
	dragger.dragNode.style.top=e.clientY+3+(dragger.fy
		? dragger.fy*(-1)
		: 0)
		+(document.body.scrollTop||document.documentElement.scrollTop)+"px";

	if (!e.srcElement)
		var z = e.target;
	else
		z=e.srcElement;
	dragger.checkLanding(z, e);
}

dhtmlDragAndDropObject.prototype.calculateFramePosition=function(n){
	//this.fx = 0, this.fy = 0;
	if (window.name){
		var el = parent.frames[window.name].frameElement.offsetParent;
		var fx = 0;
		var fy = 0;

		while (el){
			fx+=el.offsetLeft;
			fy+=el.offsetTop;
			el=el.offsetParent;
		}

		if ((parent.dhtmlDragAndDrop)){
			var ls = parent.dhtmlDragAndDrop.calculateFramePosition(1);
			fx+=ls.split('_')[0]*1;
			fy+=ls.split('_')[1]*1;
		}

		if (n)
			return fx+"_"+fy;
		else
			this.fx=fx;
		this.fy=fy;
	}
	return "0_0";
}
dhtmlDragAndDropObject.prototype.checkLanding=function(htmlObject, e){
	if ((htmlObject)&&(htmlObject.dragLanding)){
		if (this.lastLanding)
			this.lastLanding.dragLanding._dragOut(this.lastLanding);
		this.lastLanding=htmlObject;
		this.lastLanding=this.lastLanding.dragLanding._dragIn(this.lastLanding, this.dragStartNode, e.clientX,
			e.clientY, e);
		this.lastLanding_scr=(_isIE ? e.srcElement : e.target);
	} else {
		if ((htmlObject)&&(htmlObject.tagName != "BODY"))
			this.checkLanding(htmlObject.parentNode, e);
		else {
			if (this.lastLanding)
				this.lastLanding.dragLanding._dragOut(this.lastLanding, e.clientX, e.clientY, e);
			this.lastLanding=0;

			if (this._onNotFound)
				this._onNotFound();
		}
	}
}
dhtmlDragAndDropObject.prototype.stopDrag=function(e, mode){
	dragger=window.dhtmlDragAndDrop;

	if (!mode){
		dragger.stopFrameRoute();
		var temp = dragger.lastLanding;
		dragger.lastLanding=null;

		if (temp)
			temp.dragLanding._drag(dragger.dragStartNode, dragger.dragStartObject, temp, (_isIE
				? event.srcElement
				: e.target));
	}
	dragger.lastLanding=null;

	if ((dragger.dragNode)&&(dragger.dragNode.parentNode == document.body))
		dragger.dragNode.parentNode.removeChild(dragger.dragNode);
	dragger.dragNode=0;
	dragger.gldragNode=0;
	dragger.fx=0;
	dragger.fy=0;
	dragger.dragStartNode=0;
	dragger.dragStartObject=0;
	document.body.onmouseup=dragger.tempDOMU;
	document.body.onmousemove=dragger.tempDOMM;
	dragger.tempDOMU=null;
	dragger.tempDOMM=null;
	dragger.waitDrag=0;
}

dhtmlDragAndDropObject.prototype.stopFrameRoute=function(win){
	if (win)
		window.dhtmlDragAndDrop.stopDrag(1, 1);

	for (var i = 0; i < window.frames.length; i++){
		try{
		if ((window.frames[i] != win)&&(window.frames[i].dhtmlDragAndDrop))
			window.frames[i].dhtmlDragAndDrop.stopFrameRoute(window);
		} catch(e){}
	}

	try{
	if ((parent.dhtmlDragAndDrop)&&(parent != window)&&(parent != win))
		parent.dhtmlDragAndDrop.stopFrameRoute(window);
	} catch(e){}
}
dhtmlDragAndDropObject.prototype.initFrameRoute=function(win, mode){
	if (win){
		window.dhtmlDragAndDrop.preCreateDragCopy();
		window.dhtmlDragAndDrop.dragStartNode=win.dhtmlDragAndDrop.dragStartNode;
		window.dhtmlDragAndDrop.dragStartObject=win.dhtmlDragAndDrop.dragStartObject;
		window.dhtmlDragAndDrop.dragNode=win.dhtmlDragAndDrop.dragNode;
		window.dhtmlDragAndDrop.gldragNode=win.dhtmlDragAndDrop.dragNode;
		window.document.body.onmouseup=window.dhtmlDragAndDrop.stopDrag;
		window.waitDrag=0;

		if (((!_isIE)&&(mode))&&((!_isFF)||(_FFrv < 1.8)))
			window.dhtmlDragAndDrop.calculateFramePosition();
	}
	try{
	if ((parent.dhtmlDragAndDrop)&&(parent != window)&&(parent != win))
		parent.dhtmlDragAndDrop.initFrameRoute(window);
	}catch(e){}

	for (var i = 0; i < window.frames.length; i++){
		try{
		if ((window.frames[i] != win)&&(window.frames[i].dhtmlDragAndDrop))
			window.frames[i].dhtmlDragAndDrop.initFrameRoute(window, ((!win||mode) ? 1 : 0));
		} catch(e){}
	}
}

 _isFF = false;
 _isIE = false;
 _isOpera = false;
 _isKHTML = false;
 _isMacOS = false;
 _isChrome = false;
 _FFrv = false;
 _KHTMLrv = false;
 _OperaRv = false;

if (navigator.userAgent.indexOf('Macintosh') != -1)
	_isMacOS=true;


if (navigator.userAgent.toLowerCase().indexOf('chrome')>-1)
	_isChrome=true;

if ((navigator.userAgent.indexOf('Safari') != -1)||(navigator.userAgent.indexOf('Konqueror') != -1)){
	 _KHTMLrv = parseFloat(navigator.userAgent.substr(navigator.userAgent.indexOf('Safari')+7, 5));

	if (_KHTMLrv > 525){ //mimic FF behavior for Safari 3.1+
		_isFF=true;
		 _FFrv = 1.9;
	} else
		_isKHTML=true;
} else if (navigator.userAgent.indexOf('Opera') != -1){
	_isOpera=true;
	_OperaRv=parseFloat(navigator.userAgent.substr(navigator.userAgent.indexOf('Opera')+6, 3));
}


else if (navigator.appName.indexOf("Microsoft") != -1){
	_isIE=true;
	if ((navigator.appVersion.indexOf("MSIE 8.0")!= -1 || 
		 navigator.appVersion.indexOf("MSIE 9.0")!= -1 || 
		 navigator.appVersion.indexOf("MSIE 10.0")!= -1 ||
		 document.documentMode > 7) && 
			document.compatMode != "BackCompat"){
		_isIE=8;
	}
} else if (navigator.appName  == 'Netscape' && navigator.userAgent.indexOf("Trident") != -1){
	//ie11
	_isIE=8;
} else {
	_isFF=true;
	 _FFrv = parseFloat(navigator.userAgent.split("rv:")[1])
}

if (typeof(window.dhtmlxEvent) == "undefined") {
	
	function dhtmlxEvent(el, event, handler){
		if (el.addEventListener)
			el.addEventListener(event, handler, false);
	
		else if (el.attachEvent)
			el.attachEvent("on"+event, handler);
	}
};

if (dhtmlxEvent.touchDelay == null) {
	dhtmlxEvent.touchDelay = 2000;
};

if (typeof(dhtmlxEvent.initTouch) == "undefined") {
	
	dhtmlxEvent.initTouch = function(){
		var longtouch;
		var target;
		var tx, ty;
	
		dhtmlxEvent(document.body, "touchstart", function(ev){
			target = ev.touches[0].target;
			tx = ev.touches[0].clientX;
			ty = ev.touches[0].clientY;
			longtouch = window.setTimeout(touch_event, dhtmlxEvent.touchDelay);
		});
		function touch_event(){
			if (target){
				var ev = document.createEvent("HTMLEvents"); // for chrome and firefox
				ev.initEvent("dblclick", true, true);
				target.dispatchEvent(ev);
				longtouch = target = null;
			}
		};
		dhtmlxEvent(document.body, "touchmove", function(ev){
			if (longtouch){
				if (Math.abs(ev.touches[0].clientX - tx) > 50 || Math.abs(ev.touches[0].clientY - ty) > 50 ){
					window.clearTimeout(longtouch);
					longtouch = target = false;
				}
			}
		});
		dhtmlxEvent(document.body, "touchend", function(ev){
			if (longtouch){
				window.clearTimeout(longtouch);
				longtouch = target = false;
			}
		});
	
		dhtmlxEvent.initTouch = function(){};
	};
};

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
You allowed to use this component or parts of it under GPL terms
To use it on other terms or get Professional edition of the component please contact us at sales@dhtmlx.com
*/
/*
2014 March 19
*/



/* DHX DEPEND FROM FILE 'assert.js'*/


if (!window.dhtmlx) 
	dhtmlx={};

//check some rule, show message as error if rule is not correct
dhtmlx.assert = function(test, message){
	if (!test)	dhtmlx.error(message);
};
dhtmlx.assert_enabled=function(){ return false; };

//register names of event, which can be triggered by the object
dhtmlx.assert_event = function(obj, evs){
	if (!obj._event_check){
		obj._event_check = {};
		obj._event_check_size = {};
	}
		
	for (var a in evs){
		obj._event_check[a.toLowerCase()]=evs[a];
		var count=-1; for (var t in evs[a]) count++;
		obj._event_check_size[a.toLowerCase()]=count;
	}
};
dhtmlx.assert_method_info=function(obj, name, descr, rules){
	var args = [];
	for (var i=0; i < rules.length; i++) {
		args.push(rules[i][0]+" : "+rules[i][1]+"\n   "+rules[i][2].describe()+(rules[i][3]?"; optional":""));
	}
	return obj.name+"."+name+"\n"+descr+"\n Arguments:\n - "+args.join("\n - ");
};
dhtmlx.assert_method = function(obj, config){
	for (var key in config)
		dhtmlx.assert_method_process(obj, key, config[key].descr, config[key].args, (config[key].min||99), config[key].skip);
};
dhtmlx.assert_method_process = function (obj, name, descr, rules, min, skip){
	var old = obj[name];
	if (!skip)
		obj[name] = function(){
			if (arguments.length !=	rules.length && arguments.length < min) 
				dhtmlx.log("warn","Incorrect count of parameters\n"+obj[name].describe()+"\n\nExpecting "+rules.length+" but have only "+arguments.length);
			else
				for (var i=0; i<rules.length; i++)
					if (!rules[i][3] && !rules[i][2](arguments[i]))
						dhtmlx.log("warn","Incorrect method call\n"+obj[name].describe()+"\n\nActual value of "+(i+1)+" parameter: {"+(typeof arguments[i])+"} "+arguments[i]);
			
			return old.apply(this, arguments);
		};
	obj[name].describe = function(){	return dhtmlx.assert_method_info(obj, name, descr, rules);	};
};
dhtmlx.assert_event_call = function(obj, name, args){
	if (obj._event_check){
		if (!obj._event_check[name])
			dhtmlx.log("warn","Not expected event call :"+name);
		else if (dhtmlx.isNotDefined(args))
			dhtmlx.log("warn","Event without parameters :"+name);
		else if (obj._event_check_size[name] != args.length)
			dhtmlx.log("warn","Incorrect event call, expected "+obj._event_check_size[name]+" parameter(s), but have "+args.length +" parameter(s), for "+name+" event");
	}		
};
dhtmlx.assert_event_attach = function(obj, name){
	if (obj._event_check && !obj._event_check[name]) 
			dhtmlx.log("warn","Unknown event name: "+name);
};
//register names of properties, which can be used in object's configuration
dhtmlx.assert_property = function(obj, evs){
	if (!obj._settings_check)
		obj._settings_check={};
	dhtmlx.extend(obj._settings_check, evs);		
};
//check all options in collection, against list of allowed properties
dhtmlx.assert_check = function(data,coll){
	if (typeof data == "object"){
		for (var key in data){
			dhtmlx.assert_settings(key,data[key],coll);
		}
	}
};
//check if type and value of property is the same as in scheme
dhtmlx.assert_settings = function(mode,value,coll){
	coll = coll || this._settings_check;

	//if value is not in collection of defined ones
	if (coll){
		if (!coll[mode])	//not registered property
			return dhtmlx.log("warn","Unknown propery: "+mode);
			
		var descr = "";
		var error = "";
		var check = false;
		for (var i=0; i<coll[mode].length; i++){
			var rule = coll[mode][i];
			if (typeof rule == "string")
				continue;
			if (typeof rule == "function")
				check = check || rule(value);
			else if (typeof rule == "object" && typeof rule[1] == "function"){
				check = check || rule[1](value);
				if (check && rule[2])
					dhtmlx["assert_check"](value, rule[2]); //temporary fix , for sources generator
			}
			if (check) break;
		}
		if (!check )
			dhtmlx.log("warn","Invalid configuration\n"+dhtmlx.assert_info(mode,coll)+"\nActual value: {"+(typeof value)+"} "+value);
	}
};

dhtmlx.assert_info=function(name, set){ 
	var ruleset = set[name];
	var descr = "";
	var expected = [];
	for (var i=0; i<ruleset.length; i++){
		if (typeof rule == "string")
			descr = ruleset[i];
		else if (ruleset[i].describe)
			expected.push(ruleset[i].describe());
		else if (ruleset[i][1] && ruleset[i][1].describe)
			expected.push(ruleset[i][1].describe());
	}
	return "Property: "+name+", "+descr+" \nExpected value: \n - "+expected.join("\n - ");
};


if (dhtmlx.assert_enabled()){
	
	dhtmlx.assert_rule_color=function(check){
		if (typeof check != "string") return false;
		if (check.indexOf("#")!==0) return false;
		if (check.substr(1).replace(/[0-9A-F]/gi,"")!=="") return false;
		return true;
	};
	dhtmlx.assert_rule_color.describe = function(){
		return "{String} Value must start from # and contain hexadecimal code of color";
	};
	
	dhtmlx.assert_rule_template=function(check){
		if (typeof check == "function") return true;
		if (typeof check == "string") return true;
		return false;
	};
	dhtmlx.assert_rule_template.describe = function(){
		return "{Function},{String} Value must be a function which accepts data object and return text string, or a sting with optional template markers";
	};
	
	dhtmlx.assert_rule_boolean=function(check){
		if (typeof check == "boolean") return true;
		return false;
	};
	dhtmlx.assert_rule_boolean.describe = function(){
		return "{Boolean} true or false";
	};
	
	dhtmlx.assert_rule_object=function(check, sub){
		if (typeof check == "object") return true;
		return false;
	};
	dhtmlx.assert_rule_object.describe = function(){
		return "{Object} Configuration object";
	};
	
	
	dhtmlx.assert_rule_string=function(check){
		if (typeof check == "string") return true;
		return false;
	};
	dhtmlx.assert_rule_string.describe = function(){
		return "{String} Plain string";
	};
	
	
	dhtmlx.assert_rule_htmlpt=function(check){
		return !!dhtmlx.toNode(check);
	};
	dhtmlx.assert_rule_htmlpt.describe = function(){
		return "{Object},{String} HTML node or ID of HTML Node";
	};
	
	dhtmlx.assert_rule_notdocumented=function(check){
		return false;
	};
	dhtmlx.assert_rule_notdocumented.describe = function(){
		return "This options wasn't documented";
	};
	
	dhtmlx.assert_rule_key=function(obj){
		var t = function (check){
			return obj[check];
		};
		t.describe=function(){
			var opts = [];
			for(var key in obj)
				opts.push(key);
			return  "{String} can take one of next values: "+opts.join(", ");
		};
		return t;
	};
	
	dhtmlx.assert_rule_dimension=function(check){
		if (check*1 == check && !isNaN(check) && check >= 0) return true;
		return false;
	};
	dhtmlx.assert_rule_dimension.describe=function(){
		return "{Integer} value must be a positive number";
	};
	
	dhtmlx.assert_rule_number=function(check){
		if (typeof check == "number") return true;
		return false;
	};
	dhtmlx.assert_rule_number.describe=function(){
		return "{Integer} value must be a number";
	};
	
	dhtmlx.assert_rule_function=function(check){
		if (typeof check == "function") return true;
		return false;
	};
	dhtmlx.assert_rule_function.describe=function(){
		return "{Function} value must be a custom function";
	};
	
	dhtmlx.assert_rule_any=function(check){
		return true;
	};
	dhtmlx.assert_rule_any.describe=function(){
		return "Any value";
	};
	
	dhtmlx.assert_rule_mix=function(a,b){
		var t = function(check){
			if (a(check)||b(check)) return true;
			return false;
		};
		t.describe = function(){
			return a.describe();
		};
		return t;
	};

}


/* DHX DEPEND FROM FILE 'dhtmlx.js'*/


/*DHX:Depend assert.js*/

/*
	Common helpers
*/
dhtmlx.codebase="./";

//coding helpers

dhtmlx.copy = function(source){
	var f = dhtmlx.copy._function;
	f.prototype = source;
	return new f();
};
dhtmlx.copy._function = function(){};

//copies methods and properties from source to the target
dhtmlx.extend = function(target, source){
	for (var method in source)
		target[method] = source[method];
		
	//applying asserts
	if (dhtmlx.assert_enabled() && source._assert){
		target._assert();
		target._assert=null;
	}
	
	dhtmlx.assert(target,"Invalid nesting target");
	dhtmlx.assert(source,"Invalid nesting source");
	//if source object has init code - call init against target
	if (source._init)	
		target._init();
				
	return target;	
};
dhtmlx.proto_extend = function(){
	var origins = arguments;
	var compilation = origins[0];
	var construct = [];
	
	for (var i=origins.length-1; i>0; i--) {
		if (typeof origins[i]== "function")
			origins[i]=origins[i].prototype;
		for (var key in origins[i]){
			if (key == "_init") 
				construct.push(origins[i][key]);
			else if (!compilation[key])
				compilation[key] = origins[i][key];
		}
	};
	
	if (origins[0]._init)
		construct.push(origins[0]._init);
	
	compilation._init = function(){
		for (var i=0; i<construct.length; i++)
			construct[i].apply(this, arguments);
	};
	compilation.base = origins[1];
	var result = function(config){
		this._init(config);
		if (this._parseSettings)
			this._parseSettings(config, this.defaults);
	};
	result.prototype = compilation;
	
	compilation = origins = null;
	return result;
};
//creates function with specified "this" pointer
dhtmlx.bind=function(functor, object){ 
	return function(){ return functor.apply(object,arguments); };  
};

//loads module from external js file
dhtmlx.require=function(module){
	if (!dhtmlx._modules[module]){
		dhtmlx.assert(dhtmlx.ajax,"load module is required");
		
		//load and exec the required module
		dhtmlx.exec( dhtmlx.ajax().sync().get(dhtmlx.codebase+module).responseText );
		dhtmlx._modules[module]=true;	
	}
};
dhtmlx._modules = {};	//hash of already loaded modules

//evaluate javascript code in the global scoope
dhtmlx.exec=function(code){
	if (window.execScript)	//special handling for IE
		window.execScript(code);
	else window.eval(code);
};

/*
	creates method in the target object which will transfer call to the source object
	if event parameter was provided , each call of method will generate onBefore and onAfter events
*/
dhtmlx.methodPush=function(object,method,event){
	return function(){
		var res = false;
		//if (!event || this.callEvent("onBefore"+event,arguments)){ //not used anymore, probably can be removed
			res=object[method].apply(object,arguments);
		//	if (event) this.callEvent("onAfter"+event,arguments);
		//}
		return res;	//result of wrapped method
	};
};
//check === undefined
dhtmlx.isNotDefined=function(a){
	return typeof a == "undefined";
};
//delay call to after-render time
dhtmlx.delay=function(method, obj, params, delay){
	setTimeout(function(){
		var ret = method.apply(obj,params);
		method = obj = params = null;
		return ret;
	},delay||1);
};

//common helpers

//generates unique ID (unique per window, nog GUID)
dhtmlx.uid = function(){
	if (!this._seed) this._seed=(new Date).valueOf();	//init seed with timestemp
	this._seed++;
	return this._seed;
};
//resolve ID as html object
dhtmlx.toNode = function(node){
	if (typeof node == "string") return document.getElementById(node);
	return node;
};
//adds extra methods for the array
dhtmlx.toArray = function(array){ 
	return dhtmlx.extend((array||[]),dhtmlx.PowerArray);
};
//resolve function name
dhtmlx.toFunctor=function(str){ 
	return (typeof(str)=="string") ? eval(str) : str; 
};

//dom helpers

//hash of attached events
dhtmlx._events = {};
//attach event to the DOM element
dhtmlx.event=function(node,event,handler,master){
	node = dhtmlx.toNode(node);
	
	var id = dhtmlx.uid();
	dhtmlx._events[id]=[node,event,handler];	//store event info, for detaching
	
	if (master) 
		handler=dhtmlx.bind(handler,master);	
		
	//use IE's of FF's way of event's attaching
	if (node.addEventListener)
		node.addEventListener(event, handler, false);
	else if (node.attachEvent)
		node.attachEvent("on"+event, handler);

	return id;	//return id of newly created event, can be used in eventRemove
};

//remove previously attached event
dhtmlx.eventRemove=function(id){
	
	if (!id) return;
	dhtmlx.assert(this._events[id],"Removing non-existing event");
		
	var ev = dhtmlx._events[id];
	//browser specific event removing
	if (ev[0].removeEventListener)
		ev[0].removeEventListener(ev[1],ev[2],false);
	else if (ev[0].detachEvent)
		ev[0].detachEvent("on"+ev[1],ev[2]);
		
	delete this._events[id];	//delete all traces
};


//debugger helpers
//anything starting from error or log will be removed during code compression

//add message in the log
dhtmlx.log = function(type,message,details){
	if (window.console && console.log){
		type=type.toLowerCase();
		if (window.console[type])
			window.console[type](message||"unknown error");
		else
			window.console.log(type +": "+message);
		if (details) 
			window.console.log(details);
	}	
};
//register rendering time from call point 
dhtmlx.log_full_time = function(name){
	dhtmlx._start_time_log = new Date();
	dhtmlx.log("Info","Timing start ["+name+"]");
	window.setTimeout(function(){
		var time = new Date();
		dhtmlx.log("Info","Timing end ["+name+"]:"+(time.valueOf()-dhtmlx._start_time_log.valueOf())/1000+"s");
	},1);
};
//register execution time from call point
dhtmlx.log_time = function(name){
	var fname = "_start_time_log"+name;
	if (!dhtmlx[fname]){
		dhtmlx[fname] = new Date();
		dhtmlx.log("Info","Timing start ["+name+"]");
	} else {
		var time = new Date();
		dhtmlx.log("Info","Timing end ["+name+"]:"+(time.valueOf()-dhtmlx[fname].valueOf())/1000+"s");
		dhtmlx[fname] = null;
	}
};
//log message with type=error
dhtmlx.error = function(message,details){
	dhtmlx.log("error",message,details);
};
//event system
dhtmlx.EventSystem={
	_init:function(){
		this._events = {};		//hash of event handlers, name => handler
		this._handlers = {};	//hash of event handlers, ID => handler
		this._map = {};
	},
	//temporary block event triggering
	block : function(){
		this._events._block = true;
	},
	//re-enable event triggering
	unblock : function(){
		this._events._block = false;
	},
	mapEvent:function(map){
		dhtmlx.extend(this._map, map);
	},
	//trigger event
	callEvent:function(type,params){
		if (this._events._block) return true;
		
		type = type.toLowerCase();
		dhtmlx.assert_event_call(this, type, params);
		
		var event_stack =this._events[type.toLowerCase()];	//all events for provided name
		var return_value = true;

		if (dhtmlx.debug)	//can slowdown a lot
			dhtmlx.log("info","["+this.name+"] event:"+type,params);
		
		if (event_stack)
			for(var i=0; i<event_stack.length; i++)
				/*
					Call events one by one
					If any event return false - result of whole event will be false
					Handlers which are not returning anything - counted as positive
				*/
				if (event_stack[i].apply(this,(params||[]))===false) return_value=false;
				
		if (this._map[type] && !this._map[type].callEvent(type,params))
			return_value =	false;
			
		return return_value;
	},
	//assign handler for some named event
	attachEvent:function(type,functor,id){
		type=type.toLowerCase();
		dhtmlx.assert_event_attach(this, type);
		
		id=id||dhtmlx.uid(); //ID can be used for detachEvent
		functor = dhtmlx.toFunctor(functor);	//functor can be a name of method

		var event_stack=this._events[type]||dhtmlx.toArray();
		//save new event handler
		event_stack.push(functor);
		this._events[type]=event_stack;
		this._handlers[id]={ f:functor,t:type };
		
		return id;
	},
	//remove event handler
	detachEvent:function(id){
		if(this._handlers[id]){
			var type=this._handlers[id].t;
			var functor=this._handlers[id].f;
			
			//remove from all collections
			var event_stack=this._events[type];
			event_stack.remove(functor);
			delete this._handlers[id];
		}
	} 
};

//array helper
//can be used by dhtmlx.toArray()
dhtmlx.PowerArray={
	//remove element at specified position
	removeAt:function(pos,len){
		if (pos>=0) this.splice(pos,(len||1));
	},
	//find element in collection and remove it 
	remove:function(value){
		this.removeAt(this.find(value));
	},	
	//add element to collection at specific position
	insertAt:function(data,pos){
		if (!pos && pos!==0) 	//add to the end by default
			this.push(data);
		else {	
			var b = this.splice(pos,(this.length-pos));
  			this[pos] = data;
  			this.push.apply(this,b); //reconstruct array without loosing this pointer
  		}
  	},  	
  	//return index of element, -1 if it doesn't exists
  	find:function(data){ 
  		for (i=0; i<this.length; i++) 
  			if (data==this[i]) return i; 	
  		return -1; 
  	},
  	//execute some method for each element of array
  	each:function(functor,master){
		for (var i=0; i < this.length; i++)
			functor.call((master||this),this[i]);
	},
	//create new array from source, by using results of functor 
	map:function(functor,master){
		for (var i=0; i < this.length; i++)
			this[i]=functor.call((master||this),this[i]);
		return this;
	}
};

dhtmlx.env = {};

//environment detection
if (navigator.userAgent.indexOf('Opera') != -1)
	dhtmlx._isOpera=true;
else{
	//very rough detection, but it is enough for current goals
	dhtmlx._isIE=!!document.all;
	dhtmlx._isFF=!document.all;
	dhtmlx._isWebKit=(navigator.userAgent.indexOf("KHTML")!=-1);
	if (navigator.appVersion.indexOf("MSIE 8.0")!= -1 && document.compatMode != "BackCompat") 
		dhtmlx._isIE=8;
	if (navigator.appVersion.indexOf("MSIE 9.0")!= -1 && document.compatMode != "BackCompat") 
		dhtmlx._isIE=9;
}

dhtmlx.env = {};

// dhtmlx.env.transform 
// dhtmlx.env.transition
(function(){
	dhtmlx.env.transform = false;
	dhtmlx.env.transition = false;
	var options = {};
	options.names = ['transform', 'transition'];
	options.transform = ['transform', 'WebkitTransform', 'MozTransform', 'oTransform','msTransform'];
	options.transition = ['transition', 'WebkitTransition', 'MozTransition', 'oTransition'];
	
	var d = document.createElement("DIV");
	var property;
	for(var i=0; i<options.names.length; i++) {
		while (p = options[options.names[i]].pop()) {
			if(typeof d.style[p] != 'undefined')
				dhtmlx.env[options.names[i]] = true;
		}
	}
})();
dhtmlx.env.transform_prefix = (function(){
		var prefix;
		if(dhtmlx._isOpera)
			prefix = '-o-';
		else {
			prefix = ''; // default option
			if(dhtmlx._isFF) 
				prefix = '-moz-';
			if(dhtmlx._isWebKit) 
					prefix = '-webkit-';
		}
		return prefix;
})();
dhtmlx.env.svg = (function(){
		return document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
})();

//store maximum used z-index
dhtmlx.zIndex={ drag : 10000 };

//html helpers
dhtmlx.html={
	create:function(name,attrs,html){
		attrs = attrs || {};
		var node = document.createElement(name);
		for (var attr_name in attrs)
			node.setAttribute(attr_name, attrs[attr_name]);
		if (attrs.style)
			node.style.cssText = attrs.style;
		if (attrs["class"])
			node.className = attrs["class"];
		if (html)
			node.innerHTML=html;
		return node;
	},
	//return node value, different logic for different html elements
	getValue:function(node){
		node = dhtmlx.toNode(node);
		if (!node) return "";
		return dhtmlx.isNotDefined(node.value)?node.innerHTML:node.value;
	},
	//remove html node, can process an array of nodes at once
	remove:function(node){
		if (node instanceof Array)
			for (var i=0; i < node.length; i++)
				this.remove(node[i]);
		else
			if (node && node.parentNode)
				node.parentNode.removeChild(node);
	},
	//insert new node before sibling, or at the end if sibling doesn't exist
	insertBefore: function(node,before,rescue){
		if (!node) return;
		if (before)
			before.parentNode.insertBefore(node, before);
		else
			rescue.appendChild(node);
	},
	//return custom ID from html element 
	//will check all parents starting from event's target
	locate:function(e,id){
		e=e||event;
		var trg=e.target||e.srcElement;
		while (trg){
			if (trg.getAttribute){	//text nodes has not getAttribute
				var test = trg.getAttribute(id);
				if (test) return test;
			}
			trg=trg.parentNode;
		}	
		return null;
	},
	//returns position of html element on the page
	offset:function(elem) {
		if (elem.getBoundingClientRect) { //HTML5 method
			var box = elem.getBoundingClientRect();
			var body = document.body;
			var docElem = document.documentElement;
			var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
			var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
			var clientTop = docElem.clientTop || body.clientTop || 0;
			var clientLeft = docElem.clientLeft || body.clientLeft || 0;
			var top  = box.top +  scrollTop - clientTop;
			var left = box.left + scrollLeft - clientLeft;
			return { y: Math.round(top), x: Math.round(left) };
		} else { //fallback to naive approach
			var top=0, left=0;
			while(elem) {
				top = top + parseInt(elem.offsetTop,10);
				left = left + parseInt(elem.offsetLeft,10);
				elem = elem.offsetParent;
			}
			return {y: top, x: left};
		}
	},
	//returns position of event
	pos:function(ev){
		ev = ev || event;
        if(ev.pageX || ev.pageY)	//FF, KHTML
            return {x:ev.pageX, y:ev.pageY};
        //IE
        var d  =  ((dhtmlx._isIE)&&(document.compatMode != "BackCompat"))?document.documentElement:document.body;
        return {
                x:ev.clientX + d.scrollLeft - d.clientLeft,
                y:ev.clientY + d.scrollTop  - d.clientTop
        };
	},
	//prevent event action
	preventEvent:function(e){
		if (e && e.preventDefault) e.preventDefault();
		dhtmlx.html.stopEvent(e);
	},
	//stop event bubbling
	stopEvent:function(e){
		(e||event).cancelBubble=true;
		return false;
	},
	//add css class to the node
	addCss:function(node,name){
        node.className+=" "+name;
    },
    //remove css class from the node
    removeCss:function(node,name){
        node.className=node.className.replace(RegExp(name,"g"),"");
    }
};

//autodetect codebase folder
(function(){
	var temp = document.getElementsByTagName("SCRIPT");	//current script, most probably
	dhtmlx.assert(temp.length,"Can't locate codebase");
	if (temp.length){
		//full path to script
		temp = (temp[temp.length-1].getAttribute("src")||"").split("/");
		//get folder name
		temp.splice(temp.length-1, 1);
		dhtmlx.codebase = temp.slice(0, temp.length).join("/")+"/";
	}
})();

if (!dhtmlx.ui)
	dhtmlx.ui={};


/* DHX DEPEND FROM FILE 'destructor.js'*/


/*
	Behavior:Destruction
	
	@export
		destructor
*/

/*DHX:Depend dhtmlx.js*/

dhtmlx.Destruction = {
	_init:function(){
		//register self in global list of destructors
		dhtmlx.destructors.push(this);
	},
	//will be called automatically on unload, can be called manually
	//simplifies job of GC
	destructor:function(){
		this.destructor=function(){}; //destructor can be called only once
		
		//html collection
		this._htmlmap  = null;
		this._htmlrows = null;
		
		//temp html element, used by toHTML
		if (this._html)
			document.body.appendChild(this._html);	//need to attach, for IE's GC

		this._html = null;
		if (this._obj) {
			this._obj.innerHTML="";
			this._obj._htmlmap = null;
		}
		this._obj = this._dataobj=null;
		this.data = null;
		this._events = this._handlers = {};
		if(this.render)
			this.render = function(){};//need in case of delayed method calls (virtual render case)
	}
};
//global list of destructors
dhtmlx.destructors = [];
dhtmlx.event(window,"unload",function(){
	//call all registered destructors
	if (dhtmlx.destructors){
		for (var i=0; i<dhtmlx.destructors.length; i++)
			dhtmlx.destructors[i].destructor();
		dhtmlx.destructors = [];
	}
	
	//detach all known DOM events
	for (var a in dhtmlx._events){
		var ev = dhtmlx._events[a];
		if (ev[0].removeEventListener)
			ev[0].removeEventListener(ev[1],ev[2],false);
		else if (ev[0].detachEvent)
			ev[0].detachEvent("on"+ev[1],ev[2]);
		delete dhtmlx._events[a];
	}
});





/* DHX DEPEND FROM FILE 'load.js'*/


/* 
	ajax operations 
	
	can be used for direct loading as
		dhtmlx.ajax(ulr, callback)
	or
		dhtmlx.ajax().item(url)
		dhtmlx.ajax().post(url)

*/

/*DHX:Depend dhtmlx.js*/

dhtmlx.ajax = function(url,call,master){
	//if parameters was provided - made fast call
	if (arguments.length!==0){
		var http_request = new dhtmlx.ajax();
		if (master) http_request.master=master;
		http_request.get(url,null,call);
	}
	if (!this.getXHR) return new dhtmlx.ajax(); //allow to create new instance without direct new declaration
	
	return this;
};
dhtmlx.ajax.prototype={
	//creates xmlHTTP object
	getXHR:function(){
		if (dhtmlx._isIE)
		 return new ActiveXObject("Microsoft.xmlHTTP");
		else 
		 return new XMLHttpRequest();
	},
	/*
		send data to the server
		params - hash of properties which will be added to the url
		call - callback, can be an array of functions
	*/
	send:function(url,params,call){
		var x=this.getXHR();
		if (typeof call == "function")
		 call = [call];
		//add extra params to the url
		if (typeof params == "object"){
			var t=[];
			for (var a in params){
				var value = params[a];
				if (value === null || value === dhtmlx.undefined)
					value = "";
				t.push(a+"="+encodeURIComponent(value));// utf-8 escaping
		 	}
			params=t.join("&");
		}
		if (params && !this.post){
			url=url+(url.indexOf("?")!=-1 ? "&" : "?")+params;
			params=null;
		}
		
		x.open(this.post?"POST":"GET",url,!this._sync);
		if (this.post)
		 x.setRequestHeader('Content-type','application/x-www-form-urlencoded');
		 
		//async mode, define loading callback
		//if (!this._sync){
		 var self=this;
		 x.onreadystatechange= function(){
			if (!x.readyState || x.readyState == 4){
				//dhtmlx.log_full_time("data_loading");	//log rendering time
				if (call && self) 
					for (var i=0; i < call.length; i++)	//there can be multiple callbacks
					 if (call[i])
						call[i].call((self.master||self),x.responseText,x.responseXML,x);
				self.master=null;
				call=self=null;	//anti-leak
			}
		 };
		//}
		
		x.send(params||null);
		return x; //return XHR, which can be used in case of sync. mode
	},
	//GET request
	get:function(url,params,call){
		this.post=false;
		return this.send(url,params,call);
	},
	//POST request
	post:function(url,params,call){
		this.post=true;
		return this.send(url,params,call);
	}, 
	sync:function(){
		this._sync = true;
		return this;
	}
};


dhtmlx.AtomDataLoader={
	_init:function(config){
		//prepare data store
		this.data = {}; 
		if (config){
			this._settings.datatype = config.datatype||"json";
			this._after_init.push(this._load_when_ready);
		}
	},
	_load_when_ready:function(){
		this._ready_for_data = true;
		
		if (this._settings.url)
			this.url_setter(this._settings.url);
		if (this._settings.data)
			this.data_setter(this._settings.data);
	},
	url_setter:function(value){
		if (!this._ready_for_data) return value;
		this.load(value, this._settings.datatype);	
		return value;
	},
	data_setter:function(value){
		if (!this._ready_for_data) return value;
		this.parse(value, this._settings.datatype);
		return true;
	},
	//loads data from external URL
	load:function(url,call){
		this.callEvent("onXLS",[]);
		if (typeof call == "string"){	//second parameter can be a loading type or callback
			this.data.driver = dhtmlx.DataDriver[call];
			call = arguments[2];
		}
		else
			this.data.driver = dhtmlx.DataDriver[this._settings.datatype||"xml"];
		//load data by async ajax call
		if (window.dhx4){
			dhx4.ajax.get(url,dhtmlx.bind(function(x){
				var loader = x.xmlDoc;
				var text = loader.responseText;
				var xml = loader.responseXML;

				if (this._onLoad)
					this._onLoad.call(this, text, xml, loader);
				if (call)
					call.call(this, text, xml, loader);
			},this));
		} else
			dhtmlx.ajax(url,[this._onLoad,call],this);
	},
	//loads data from object
	parse:function(data,type){
		this.callEvent("onXLS",[]);
		this.data.driver = dhtmlx.DataDriver[type||"xml"];
		this._onLoad(data,null);
	},
	//default after loading callback
	_onLoad:function(text,xml,loader){
		var driver = this.data.driver;
		var top = driver.getRecords(driver.toObject(text,xml))[0];
		this.data=(driver?driver.getDetails(top):text);
		this.callEvent("onXLE",[]);
	},
	_check_data_feed:function(data){
		if (!this._settings.dataFeed || this._ignore_feed || !data) return true;
		var url = this._settings.dataFeed;
		if (typeof url == "function")
			return url.call(this, (data.id||data), data);
		url = url+(url.indexOf("?")==-1?"?":"&")+"action=get&id="+encodeURIComponent(data.id||data);
		this.callEvent("onXLS",[]);
		dhtmlx.ajax(url, function(text,xml){
			this._ignore_feed=true;
			this.setValues(dhtmlx.DataDriver.json.toObject(text)[0]);
			this._ignore_feed=false;
			this.callEvent("onXLE",[]);
		}, this);
		return false;
	}
};

/*
	Abstraction layer for different data types
*/

dhtmlx.DataDriver={};
dhtmlx.DataDriver.json={
	//convert json string to json object if necessary
	toObject:function(data){
		if (!data) data="[]";
		if (typeof data == "string"){
		 eval ("dhtmlx.temp="+data);
		 return dhtmlx.temp;
		}
		return data;
	},
	//get array of records
	getRecords:function(data){
		if (data && data.data)
			data = data.data;
		if (data && !(data instanceof Array))
		 return [data];
		return data;
	},
	//get hash of properties for single record
	getDetails:function(data){
		return data;
	},
	//get count of data and position at which new data need to be inserted
	getInfo:function(data){
		return { 
		 _size:(data.total_count||0),
		 _from:(data.pos||0),
		 _key:(data.dhx_security)
		};
	}
};

dhtmlx.DataDriver.json_ext={
	//convert json string to json object if necessary
	toObject:function(data){
		if (!data) data="[]";
		if (typeof data == "string"){
			var temp;
			eval ("temp="+data);
			dhtmlx.temp = [];
			var header  = temp.header;
			for (var i = 0; i < temp.data.length; i++) {
				var item = {};
				for (var j = 0; j < header.length; j++) {
					if (typeof(temp.data[i][j]) != "undefined")
						item[header[j]] = temp.data[i][j];
				}
				dhtmlx.temp.push(item);
			}
			return dhtmlx.temp;
		}
		return data;
	},
	//get array of records
	getRecords:function(data){
		if (data && !(data instanceof Array))
		 return [data];
		return data;
	},
	//get hash of properties for single record
	getDetails:function(data){
		return data;
	},
	//get count of data and position at which new data need to be inserted
	getInfo:function(data){
		return {
		 _size:(data.total_count||0),
		 _from:(data.pos||0)
		};
	}
};

dhtmlx.DataDriver.html={
	/*
		incoming data can be
		 - collection of nodes
		 - ID of parent container
		 - HTML text
	*/
	toObject:function(data){
		if (typeof data == "string"){
		 var t=null;
		 if (data.indexOf("<")==-1)	//if no tags inside - probably its an ID
			t = dhtmlx.toNode(data);
		 if (!t){
			t=document.createElement("DIV");
			t.innerHTML = data;
		 }
		 
		 return t.getElementsByTagName(this.tag);
		}
		return data;
	},
	//get array of records
	getRecords:function(data){
		if (data.tagName)
		 return data.childNodes;
		return data;
	},
	//get hash of properties for single record
	getDetails:function(data){
		return dhtmlx.DataDriver.xml.tagToObject(data);
	},
	//dyn loading is not supported by HTML data source
	getInfo:function(data){
		return { 
		 _size:0,
		 _from:0
		};
	},
	tag: "LI"
};

dhtmlx.DataDriver.jsarray={
	//eval jsarray string to jsarray object if necessary
	toObject:function(data){
		if (typeof data == "string"){
		 eval ("dhtmlx.temp="+data);
		 return dhtmlx.temp;
		}
		return data;
	},
	//get array of records
	getRecords:function(data){
		return data;
	},
	//get hash of properties for single record, in case of array they will have names as "data{index}"
	getDetails:function(data){
		var result = {};
		for (var i=0; i < data.length; i++) 
		 result["data"+i]=data[i];
		 
		return result;
	},
	//dyn loading is not supported by js-array data source
	getInfo:function(data){
		return { 
		 _size:0,
		 _from:0
		};
	}
};

dhtmlx.DataDriver.csv={
	//incoming data always a string
	toObject:function(data){
		return data;
	},
	//get array of records
	getRecords:function(data){
		return data.split(this.row);
	},
	//get hash of properties for single record, data named as "data{index}"
	getDetails:function(data){
		data = this.stringToArray(data);
		var result = {};
		for (var i=0; i < data.length; i++) 
		 result["data"+i]=data[i];
		 
		return result;
	},
	//dyn loading is not supported by csv data source
	getInfo:function(data){
		return { 
		 _size:0,
		 _from:0
		};
	},
	//split string in array, takes string surrounding quotes in account
	stringToArray:function(data){
		data = data.split(this.cell);
		for (var i=0; i < data.length; i++)
		 data[i] = data[i].replace(/^[ \t\n\r]*(\"|)/g,"").replace(/(\"|)[ \t\n\r]*$/g,"");
		return data;
	},
	row:"\n",	//default row separator
	cell:","	//default cell separator
};

dhtmlx.DataDriver.xml={
	//convert xml string to xml object if necessary
	toObject:function(text,xml){
		if (xml && (xml=this.checkResponse(text,xml)))	//checkResponse - fix incorrect content type and extra whitespaces errors
		 return xml;
		if (typeof text == "string"){
		 return this.fromString(text);
		}
		return text;
	},
	//get array of records
	getRecords:function(data){
		return this.xpath(data,this.records);
	},
	records:"/*/item",
	//get hash of properties for single record
	getDetails:function(data){
		return this.tagToObject(data,{});
	},
	//get count of data and position at which new data_loading need to be inserted
	getInfo:function(data){
		return { 
		 _size:(data.documentElement.getAttribute("total_count")||0),
		 _from:(data.documentElement.getAttribute("pos")||0),
		 _key:(data.documentElement.getAttribute("dhx_security"))
		};
	},
	//xpath helper
	xpath:function(xml,path){
		if (window.XPathResult){	//FF, KHTML, Opera
		 var node=xml;
		 if(xml.nodeName.indexOf("document")==-1)
		 xml=xml.ownerDocument;
		 var res = [];
		 var col = xml.evaluate(path, node, null, XPathResult.ANY_TYPE, null);
		 var temp = col.iterateNext();
		 while (temp){ 
			res.push(temp);
			temp = col.iterateNext();
		}
		return res;
		}	
		else {
			var test = true;
			try {
				if (typeof(xml.selectNodes)=="undefined")
					test = false;
			} catch(e){ /*IE7 and below can't operate with xml object*/ }
			//IE
			if (test)
				return xml.selectNodes(path);
			else {
				//Google hate us, there is no interface to do XPath
				//use naive approach
				var name = path.split("/").pop();
				return xml.getElementsByTagName(name);
			}
		}
	},
	//convert xml tag to js object, all subtags and attributes are mapped to the properties of result object
	tagToObject:function(tag,z){
		z=z||{};
		var flag=false;
		

		//map subtags
		var b=tag.childNodes;
		var state = {};
		for (var i=0; i<b.length; i++){
			if (b[i].nodeType==1){
				var name = b[i].tagName;
				if (typeof z[name] != "undefined"){
					if (!(z[name] instanceof Array))
						z[name]=[z[name]];
					z[name].push(this.tagToObject(b[i],{}));
				}
				else
					z[b[i].tagName]=this.tagToObject(b[i],{});	//sub-object for complex subtags
				flag=true;
			}
		}

		//map attributes
		var a=tag.attributes;
		if(a && a.length){
			for (var i=0; i<a.length; i++)
		 		z[a[i].name]=a[i].value;
		 	flag = true;
	 	}
		
		if (!flag)
			return this.nodeValue(tag);
		//each object will have its text content as "value" property
		z.value = this.nodeValue(tag);
		return z;
	},
	//get value of xml node 
	nodeValue:function(node){
		if (node.firstChild)
			return node.firstChild.wholeText||node.firstChild.data;
		return "";
	},
	//convert XML string to XML object
	fromString:function(xmlString){
		if (window.DOMParser && !dhtmlx._isIE)		// FF, KHTML, Opera
		 return (new DOMParser()).parseFromString(xmlString,"text/xml");
		if (window.ActiveXObject){	// IE, utf-8 only 
		 var temp=new ActiveXObject("Microsoft.xmlDOM");
		 temp.loadXML(xmlString);
		 return temp;
		}
		dhtmlx.error("Load from xml string is not supported");
	},
	//check is XML correct and try to reparse it if its invalid
	checkResponse:function(text,xml){ 
		if (xml && ( xml.firstChild && xml.firstChild.tagName != "parsererror") )
			return xml;
		//parsing as string resolves incorrect content type
		//regexp removes whitespaces before xml declaration, which is vital for FF
		var a=this.fromString(text.replace(/^[\s]+/,""));
		if (a) return a;
		
		dhtmlx.error("xml can't be parsed",text);
	}
};




/* DHX DEPEND FROM FILE 'datastore.js'*/


/*DHX:Depend load.js*/
/*DHX:Depend dhtmlx.js*/

/*
	Behavior:DataLoader - load data in the component
	
	@export
		load
		parse
*/
dhtmlx.DataLoader={
	_init:function(config){
		//prepare data store
		config = config || "";
		this.name = "DataStore";
		this.data = (config.datastore)||(new dhtmlx.DataStore());
		this._readyHandler = this.data.attachEvent("onStoreLoad",dhtmlx.bind(this._call_onready,this));
	},
	//loads data from external URL
	load:function(url,call){
		dhtmlx.AtomDataLoader.load.apply(this, arguments);
		//prepare data feed for dyn. loading
		if (!this.data.feed)
		 this.data.feed = function(from,count){
			//allow only single request at same time
			if (this._load_count)
				return this._load_count=[from,count];	//save last ignored request
			else
				this._load_count=true;
				
			this.load(url+((url.indexOf("?")==-1)?"?":"&")+"posStart="+from+"&count="+count,function(){
				//after loading check if we have some ignored requests
				var temp = this._load_count;
				this._load_count = false;
				if (typeof temp =="object")
					this.data.feed.apply(this, temp);	//load last ignored request
			});
		};
	},
	//default after loading callback
	_onLoad:function(text,xml,loader){
		this.data._parse(this.data.driver.toObject(text,xml));
		this.callEvent("onXLE",[]);
		if(this._readyHandler){
			this.data.detachEvent(this._readyHandler);
			this._readyHandler = null;
		}
	},
	dataFeed_setter:function(value){
		this.data.attachEvent("onBeforeFilter", dhtmlx.bind(function(text, value){
			if (this._settings.dataFeed){
				var filter = {};
				if (!text && !filter) return;
				if (typeof text == "function"){
					if (!value) return;
					text(value, filter);
				} else 
					filter = { text:value };

				this.clearAll();
				var url = this._settings.dataFeed;
				if (typeof url == "function")
					return url.call(this, value, filter);
				var urldata = [];
				for (var key in filter)
					urldata.push("dhx_filter["+key+"]="+encodeURIComponent(filter[key]));
				this.load(url+(url.indexOf("?")<0?"?":"&")+urldata.join("&"), this._settings.datatype);
				return false;
			}
		},this));
		return value;
	},
	_call_onready:function(){
		if (this._settings.ready){
			var code = dhtmlx.toFunctor(this._settings.ready);
			if (code && code.call) code.apply(this, arguments);
		}
	}
};


/*
	DataStore is not a behavior, it standalone object, which represents collection of data.
	Call provideAPI to map data API

	@export
		exists
		idByIndex
		indexById
		get
		set
		refresh
		dataCount
		sort
		filter
		next
		previous
		clearAll
		first
		last
*/
dhtmlx.DataStore = function(){
	this.name = "DataStore";
	
	dhtmlx.extend(this, dhtmlx.EventSystem);
	
	this.setDriver("xml");	//default data source is an XML
	this.pull = {};						//hash of IDs
	this.order = dhtmlx.toArray();		//order of IDs
};

dhtmlx.DataStore.prototype={
	//defines type of used data driver
	//data driver is an abstraction other different data formats - xml, json, csv, etc.
	setDriver:function(type){
		dhtmlx.assert(dhtmlx.DataDriver[type],"incorrect DataDriver");
		this.driver = dhtmlx.DataDriver[type];
	},
	//process incoming raw data
	_parse:function(data){
		this.callEvent("onParse", [this.driver, data]);
		if (this._filter_order)
			this.filter();
			
		//get size and position of data
		var info = this.driver.getInfo(data);
		if (info._key)
			dhtmlx.security_key = info._key;
		//get array of records

		var recs = this.driver.getRecords(data);
		var from = (info._from||0)*1;
		
		if (from === 0 && this.order[0]) //update mode
			from = this.order.length;
		
		var j=0;
		for (var i=0; i<recs.length; i++){
			//get has of details for each record
			var temp = this.driver.getDetails(recs[i]);
			var id = this.id(temp); 	//generate ID for the record
			if (!this.pull[id]){		//if such ID already exists - update instead of insert
				this.order[j+from]=id;	
				j++;
			}
			this.pull[id]=temp;
			//if (this._format)	this._format(temp);
			
			if (this.extraParser)
				this.extraParser(temp);
			if (this._scheme){ 
				if (this._scheme.$init)
					this._scheme.$update(temp);
				else if (this._scheme.$update)
					this._scheme.$update(temp);
			}
		}

		//for all not loaded data
		for (var i=0; i < info._size; i++)
			if (!this.order[i]){
				var id = dhtmlx.uid();
				var temp = {id:id, $template:"loading"};	//create fake records
				this.pull[id]=temp;
				this.order[i]=id;
			}

		this.callEvent("onStoreLoad",[this.driver, data]);
		//repaint self after data loading
		this.refresh();
	},
	//generate id for data object
	id:function(data){
		return data.id||(data.id=dhtmlx.uid());
	},
	changeId:function(old, newid){
		dhtmlx.assert(this.pull[old],"Can't change id, for non existing item: "+old);
		this.pull[newid] = this.pull[old];
		this.pull[newid].id = newid;
		this.order[this.order.find(old)]=newid;
		if (this._filter_order)
			this._filter_order[this._filter_order.find(old)]=newid;
		this.callEvent("onIdChange", [old, newid]);
		if (this._render_change_id)
			this._render_change_id(old, newid);
	},
	get:function(id){
		return this.item(id);
	},
	set:function(id, data){
		return this.update(id, data);
	},
	//get data from hash by id
	item:function(id){
		return this.pull[id];
	},
	//assigns data by id
	update:function(id,data){
		if (this._scheme && this._scheme.$update)
			this._scheme.$update(data);
		if (this.callEvent("onBeforeUpdate", [id, data]) === false) return false;
		this.pull[id]=data;
		this.refresh(id);
	},
	//sends repainting signal
	refresh:function(id){
		if (this._skip_refresh) return; 
		
		if (id)
			this.callEvent("onStoreUpdated",[id, this.pull[id], "update"]);
		else
			this.callEvent("onStoreUpdated",[null,null,null]);
	},
	silent:function(code){
		this._skip_refresh = true;
		code.call(this);
		this._skip_refresh = false;
	},
	//converts range IDs to array of all IDs between them
	getRange:function(from,to){		
		//if some point is not defined - use first or last id
		//BEWARE - do not use empty or null ID
		if (from)
			from = this.indexById(from);
		else 
			from = this.startOffset||0;
		if (to)
			to = this.indexById(to);
		else {
			to = Math.min((this.endOffset||Infinity),(this.dataCount()-1));
			if (to<0) to = 0; //we have not data in the store
		}

		if (this.min)
			from = this.min;
		if (this.max)
			to = this.max;

		if (from>to){ //can be in case of backward shift-selection
			var a=to; to=from; from=a;
		}
				
		return this.getIndexRange(from,to);
	},
	//converts range of indexes to array of all IDs between them
	getIndexRange:function(from,to){
		to=Math.min((to||Infinity),this.dataCount()-1);
		
		var ret=dhtmlx.toArray(); //result of method is rich-array
		for (var i=(from||0); i <= to; i++)
			ret.push(this.item(this.order[i]));
		return ret;
	},
	//returns total count of elements
	dataCount:function(){
		return this.order.length;
	},
	//returns truy if item with such ID exists
	exists:function(id){
		return !!(this.pull[id]);
	},
	//nextmethod is not visible on component level, check DataMove.move
	//moves item from source index to the target index
	move:function(sindex,tindex){
		if (sindex<0 || tindex<0){
			dhtmlx.error("DataStore::move","Incorrect indexes");
			return;
		}
		
		var id = this.idByIndex(sindex);
		var obj = this.item(id);
		
		this.order.removeAt(sindex);	//remove at old position
		//if (sindex<tindex) tindex--;	//correct shift, caused by element removing
		this.order.insertAt(id,Math.min(this.order.length, tindex));	//insert at new position
		
		//repaint signal
		this.callEvent("onStoreUpdated",[id,obj,"move"]);
	},
	scheme:function(config){
		/*
			some.scheme({
				order:1,
				name:"dummy",
				title:""
			})
		*/
		this._scheme = config;
		
	},
	sync:function(source, filter, silent){
		if (typeof filter != "function"){
			silent = filter;
			filter = null;
		}
		
		if (dhtmlx.debug_bind){
			this.debug_sync_master = source; 
			dhtmlx.log("[sync] "+this.debug_bind_master.name+"@"+this.debug_bind_master._settings.id+" <= "+this.debug_sync_master.name+"@"+this.debug_sync_master._settings.id);
		}
		
		var topsource = source;
		if (source.name != "DataStore")
			source = source.data;

		var sync_logic = dhtmlx.bind(function(id, data, mode){
			if (mode != "update" || filter) 
				id = null;

			if (!id){
				this.order = dhtmlx.toArray([].concat(source.order));
				this._filter_order = null;
				this.pull = source.pull;
				
				if (filter)
					this.silent(filter);
				
				if (this._on_sync)
					this._on_sync();
			}

			if (dhtmlx.debug_bind)
				dhtmlx.log("[sync:request] "+this.debug_sync_master.name+"@"+this.debug_sync_master._settings.id + " <= "+this.debug_bind_master.name+"@"+this.debug_bind_master._settings.id);
			if (!silent) 
				this.refresh(id);
			else
				silent = false;
		}, this);
		
		source.attachEvent("onStoreUpdated", sync_logic);
		this.feed = function(from, count){
			topsource.loadNext(count, from);
		};
		sync_logic();
	},
	//adds item to the store
	add:function(obj,index){
		
		if (this._scheme){
			obj = obj||{};
			for (var key in this._scheme)
				obj[key] = obj[key]||this._scheme[key];
			if (this._scheme){ 
				if (this._scheme.$init)
					this._scheme.$update(obj);
				else if (this._scheme.$update)
					this._scheme.$update(obj);
			}
		}
		
		//generate id for the item
		var id = this.id(obj);
		
		//by default item is added to the end of the list
		var data_size = this.dataCount();
		
		if (dhtmlx.isNotDefined(index) || index < 0)
			index = data_size; 
		//check to prevent too big indexes			
		if (index > data_size){
			dhtmlx.log("Warning","DataStore:add","Index of out of bounds");
			index = Math.min(this.order.length,index);
		}
		if (this.callEvent("onBeforeAdd", [id, obj, index]) === false) return false;

		if (this.exists(id)) return dhtmlx.error("Not unique ID");
		
		this.pull[id]=obj;
		this.order.insertAt(id,index);
		if (this._filter_order){	//adding during filtering
			//we can't know the location of new item in full dataset, making suggestion
			//put at end by default
			var original_index = this._filter_order.length;
			//put at start only if adding to the start and some data exists
			if (!index && this.order.length)
				original_index = 0;
			
			this._filter_order.insertAt(id,original_index);
		}
		this.callEvent("onafterAdd",[id,index]);
		//repaint signal
		this.callEvent("onStoreUpdated",[id,obj,"add"]);
		return id;
	},
	
	//removes element from datastore
	remove:function(id){
		//id can be an array of IDs - result of getSelect, for example
		if (id instanceof Array){
			for (var i=0; i < id.length; i++)
				this.remove(id[i]);
			return;
		}
		if (this.callEvent("onBeforeDelete",[id]) === false) return false;
		if (!this.exists(id)) return dhtmlx.error("Not existing ID",id);
		var obj = this.item(id);	//save for later event
		//clear from collections
		this.order.remove(id);
		if (this._filter_order) 
			this._filter_order.remove(id);
			
		delete this.pull[id];
		this.callEvent("onafterdelete",[id]);
		//repaint signal
		this.callEvent("onStoreUpdated",[id,obj,"delete"]);
	},
	//deletes all records in datastore
	clearAll:function(){
		//instead of deleting one by one - just reset inner collections
		this.pull = {};
		this.order = dhtmlx.toArray();
		this.feed = null;
		this._filter_order = null;
		this.callEvent("onClearAll",[]);
		this.refresh();
	},
	//converts id to index
	idByIndex:function(index){
		if (index>=this.order.length || index<0)
			dhtmlx.log("Warning","DataStore::idByIndex Incorrect index");
			
		return this.order[index];
	},
	//converts index to id
	indexById:function(id){
		var res = this.order.find(id);	//slower than idByIndex
		
		//if (!this.pull[id])
		//	dhtmlx.log("Warning","DataStore::indexById Non-existing ID: "+ id);
			
		return res;
	},
	//returns ID of next element
	next:function(id,step){
		return this.order[this.indexById(id)+(step||1)];
	},
	//returns ID of first element
	first:function(){
		return this.order[0];
	},
	//returns ID of last element
	last:function(){
		return this.order[this.order.length-1];
	},
	//returns ID of previous element
	previous:function(id,step){
		return this.order[this.indexById(id)-(step||1)];
	},
	/*
		sort data in collection
			by - settings of sorting
		
		or
		
			by - sorting function
			dir - "asc" or "desc"
			
		or
		
			by - property
			dir - "asc" or "desc"
			as - type of sortings
		
		Sorting function will accept 2 parameters and must return 1,0,-1, based on desired order
	*/
	sort:function(by, dir, as){
		var sort = by;	
		if (typeof by == "function")
			sort = {as:by, dir:dir};
		else if (typeof by == "string")
			sort = {by:by, dir:dir, as:as};		
		
		
		var parameters = [sort.by, sort.dir, sort.as];
		if (!this.callEvent("onbeforesort",parameters)) return;	
		
		if (this.order.length){
			var sorter = dhtmlx.sort.create(sort);
			//get array of IDs
			var neworder = this.getRange(this.first(), this.last());
			neworder.sort(sorter);
			this.order = neworder.map(function(obj){ return this.id(obj); },this);
		}
		
		//repaint self
		this.refresh();
		
		this.callEvent("onaftersort",parameters);
	},
	/*
		Filter datasource
		
		text - property, by which filter
		value - filter mask
		
		or
		
		text  - filter method
		
		Filter method will receive data object and must return true or false
	*/
	filter:function(text,value){
		if (!this.callEvent("onBeforeFilter", [text, value])) return;
		
		//remove previous filtering , if any
		if (this._filter_order){
			this.order = this._filter_order;
			delete this._filter_order;
		}
		
		if (!this.order.length) return;
		
		//if text not define -just unfilter previous state and exit
		if (text){
			var filter = text;
			value = value||"";
			if (typeof text == "string"){
				text = dhtmlx.Template.fromHTML(text);
				value = value.toString().toLowerCase();
				filter = function(obj,value){	//default filter - string start from, case in-sensitive
					return text(obj).toLowerCase().indexOf(value)!=-1;
				};
			}
			
					
			var neworder = dhtmlx.toArray();
			for (var i=0; i < this.order.length; i++){
				var id = this.order[i];
				if (filter(this.item(id),value))
					neworder.push(id);
			}
			//set new order of items, store original
			this._filter_order = this.order;
			this.order = neworder;
		}
		//repaint self
		this.refresh();
		
		this.callEvent("onAfterFilter", []);
	},
	/*
		Iterate through collection
	*/
	each:function(method,master){
		for (var i=0; i<this.order.length; i++)
			method.call((master||this), this.item(this.order[i]));
	},
	/*
		map inner methods to some distant object
	*/
	provideApi:function(target,eventable){
		this.debug_bind_master = target;
			
		if (eventable){
			this.mapEvent({
				onbeforesort:	target,
				onaftersort:	target,
				onbeforeadd:	target,
				onafteradd:		target,
				onbeforedelete:	target,
				onafterdelete:	target,
				onbeforeupdate: target/*,
				onafterfilter:	target,
				onbeforefilter:	target*/
			});
		}
			
		var list = ["get","set","sort","add","remove","exists","idByIndex","indexById","item","update","refresh","dataCount","filter","next","previous","clearAll","first","last","serialize"];
		for (var i=0; i < list.length; i++)
			target[list[i]]=dhtmlx.methodPush(this,list[i]);
			
		if (dhtmlx.assert_enabled())		
			this.assert_event(target);
	},
	/*
		serializes data to a json object
	*/
	serialize: function(){
		var ids = this.order;
		var result = [];
		for(var i=0; i< ids.length;i++)
			result.push(this.pull[ids[i]]); 
		return result;
	}
};

dhtmlx.sort = {
	create:function(config){
		return dhtmlx.sort.dir(config.dir, dhtmlx.sort.by(config.by, config.as));
	},
	as:{
		"int":function(a,b){
			a = a*1; b=b*1;
			return a>b?1:(a<b?-1:0);
		},
		"string_strict":function(a,b){
			a = a.toString(); b=b.toString();
			return a>b?1:(a<b?-1:0);
		},
		"string":function(a,b){
			a = a.toString().toLowerCase(); b=b.toString().toLowerCase();
			return a>b?1:(a<b?-1:0);
		}
	},
	by:function(prop, method){
		if (!prop)
			return method;
		if (typeof method != "function")
			method = dhtmlx.sort.as[method||"string"];
		prop = dhtmlx.Template.fromHTML(prop);
		return function(a,b){
			return method(prop(a),prop(b));
		};
	},
	dir:function(prop, method){
		if (prop == "asc")
			return method;
		return function(a,b){
			return method(a,b)*-1;
		};
	}
};



/* DHX DEPEND FROM FILE 'key.js'*/


/*
	Behavior:KeyEvents - hears keyboard 
*/
dhtmlx.KeyEvents = {
	_init:function(){
		//attach handler to the main container
		dhtmlx.event(this._obj,"keypress",this._onKeyPress,this);
	},
	//called on each key press , when focus is inside of related component
	_onKeyPress:function(e){
		e=e||event;
		var code = e.which||e.keyCode; //FIXME  better solution is required
		this.callEvent((this._edit_id?"onEditKeyPress":"onKeyPress"),[code,e.ctrlKey,e.shiftKey,e]);
	}
};


/* DHX DEPEND FROM FILE 'mouse.js'*/


/*
	Behavior:MouseEvents - provides inner evnets for  mouse actions
*/
dhtmlx.MouseEvents={
	_init: function(){
		//attach dom events if related collection is defined
		if (this.on_click){
			dhtmlx.event(this._obj,"click",this._onClick,this);
			dhtmlx.event(this._obj,"contextmenu",this._onContext,this);
		}
		if (this.on_dblclick)
			dhtmlx.event(this._obj,"dblclick",this._onDblClick,this);
		if (this.on_mouse_move){
			dhtmlx.event(this._obj,"mousemove",this._onMouse,this);
			dhtmlx.event(this._obj,(dhtmlx._isIE?"mouseleave":"mouseout"),this._onMouse,this);
		}

	},
	//inner onclick object handler
	_onClick: function(e) {
		return this._mouseEvent(e,this.on_click,"ItemClick");
	},
	//inner ondblclick object handler
	_onDblClick: function(e) {
		return this._mouseEvent(e,this.on_dblclick,"ItemDblClick");
	},
	//process oncontextmenu events
	_onContext: function(e) {
		var id = dhtmlx.html.locate(e, this._id);
		if (id && !this.callEvent("onBeforeContextMenu", [id,e]))
			return dhtmlx.html.preventEvent(e);
	},
	/*
		event throttler - ignore events which occurs too fast
		during mouse moving there are a lot of event firing - we need no so much
		also, mouseout can fire when moving inside the same html container - we need to ignore such fake calls
	*/
	_onMouse:function(e){
		if (dhtmlx._isIE)	//make a copy of event, will be used in timed call
			e = document.createEventObject(event);
			
		if (this._mouse_move_timer)	//clear old event timer
			window.clearTimeout(this._mouse_move_timer);
				
		//this event just inform about moving operation, we don't care about details
		this.callEvent("onMouseMoving",[e]);
		//set new event timer
		this._mouse_move_timer = window.setTimeout(dhtmlx.bind(function(){
			//called only when we have at least 100ms after previous event
			if (e.type == "mousemove")
				this._onMouseMove(e);
			else
				this._onMouseOut(e);
		},this),500);
	},
	//inner mousemove object handler
	_onMouseMove: function(e) {
		if (!this._mouseEvent(e,this.on_mouse_move,"MouseMove"))
			this.callEvent("onMouseOut",[e||event]);
	},
	//inner mouseout object handler
	_onMouseOut: function(e) {
		this.callEvent("onMouseOut",[e||event]);
	},
	//common logic for click and dbl-click processing
	_mouseEvent:function(e,hash,name){
		e=e||event;
		var trg=e.target||e.srcElement;
		var css = "";
		var id = null;
		var found = false;
		//loop through all parents
		while (trg && trg.parentNode){
			if (!found && trg.getAttribute){													//if element with ID mark is not detected yet
				id = trg.getAttribute(this._id);							//check id of current one
				if (id){
					if (trg.getAttribute("userdata"))
						this.callEvent("onLocateData",[id,trg,e]);
					if (!this.callEvent("on"+name,[id,e,trg])) return;		//it will be triggered only for first detected ID, in case of nested elements
					found = true;											//set found flag
				}
			}
			css=trg.className;
			if (css){		//check if pre-defined reaction for element's css name exists
				css = css.split(" ");
				css = css[0]||css[1]; //FIXME:bad solution, workaround css classes which are starting from whitespace
				if (hash[css])
					return  hash[css].call(this,e,id||dhtmlx.html.locate(e, this._id),trg);
			}
			trg=trg.parentNode;
		}		
		return found;	//returns true if item was located and event was triggered
	}
};




/* DHX DEPEND FROM FILE 'config.js'*/


/*
	Behavior:Settings
	
	@export
		customize
		config
*/

/*DHX:Depend template.js*/
/*DHX:Depend dhtmlx.js*/

dhtmlx.Settings={
	_init:function(){
		/* 
			property can be accessed as this.config.some
			in same time for inner call it have sense to use _settings
			because it will be minified in final version
		*/
		this._settings = this.config= {}; 
	},
	define:function(property, value){
		if (typeof property == "object")
			return this._parseSeetingColl(property);
		return this._define(property, value);
	},
	_define:function(property,value){
		dhtmlx.assert_settings.call(this,property,value);
		
		//method with name {prop}_setter will be used as property setter
		//setter is optional
		var setter = this[property+"_setter"];
		return this._settings[property]=setter?setter.call(this,value):value;
	},
	//process configuration object
	_parseSeetingColl:function(coll){
		if (coll){
			for (var a in coll)				//for each setting
				this._define(a,coll[a]);		//set value through config
		}
	},
	//helper for object initialization
	_parseSettings:function(obj,initial){
		//initial - set of default values
		var settings = dhtmlx.extend({},initial);
		//code below will copy all properties over default one
		if (typeof obj == "object" && !obj.tagName)
			dhtmlx.extend(settings,obj);	
		//call config for each setting
		this._parseSeetingColl(settings);
	},
	_mergeSettings:function(config, defaults){
		for (var key in defaults)
			switch(typeof config[key]){
				case "object": 
					config[key] = this._mergeSettings((config[key]||{}), defaults[key]);
					break;
				case "undefined":
					config[key] = defaults[key];
					break;
				default:	//do nothing
					break;
			}
		return config;
	},
	//helper for html container init
	_parseContainer:function(obj,name,fallback){
		/*
			parameter can be a config object, in such case real container will be obj.container
			or it can be html object or ID of html object
		*/
		if (typeof obj == "object" && !obj.tagName) 
			obj=obj.container;
		this._obj = this.$view = dhtmlx.toNode(obj);
		if (!this._obj && fallback)
			this._obj = fallback(obj);
			
		dhtmlx.assert(this._obj, "Incorrect html container");
		
		this._obj.className+=" "+name;
		this._obj.onselectstart=function(){return false;};	//block selection by default
		this._dataobj = this._obj;//separate reference for rendering modules
	},
	//apply template-type
	_set_type:function(name){
		//parameter can be a hash of settings
		if (typeof name == "object")
			return this.type_setter(name);
		
		dhtmlx.assert(this.types, "RenderStack :: Types are not defined");
		dhtmlx.assert(this.types[name],"RenderStack :: Inccorect type name",name);
		//or parameter can be a name of existing template-type	
		this.type=dhtmlx.extend({},this.types[name]);
		this.customize();	//init configs
	},
	customize:function(obj){
		//apply new properties
		if (obj) dhtmlx.extend(this.type,obj);
		
		//init tempaltes for item start and item end
		this.type._item_start = dhtmlx.Template.fromHTML(this.template_item_start(this.type));
		this.type._item_end = this.template_item_end(this.type);
		
		//repaint self
		this.render();
	},
	//config.type - creates new template-type, based on configuration object
	type_setter:function(value){
		this._set_type(typeof value == "object"?dhtmlx.Type.add(this,value):value);
		return value;
	},
	//config.template - creates new template-type with defined template string
	template_setter:function(value){
		return this.type_setter({template:value});
	},
	//config.css - css name for top level container
	css_setter:function(value){
		this._obj.className += " "+value;
		return value;
	}
};



/* DHX DEPEND FROM FILE 'template.js'*/


/*
	Template - handles html templates
*/

/*DHX:Depend dhtmlx.js*/

dhtmlx.Template={
	_cache:{
	},
	empty:function(){	
		return "";	
	},
	setter:function(value){
		return dhtmlx.Template.fromHTML(value);
	},
	obj_setter:function(value){
		var f = dhtmlx.Template.setter(value);
		var obj = this;
		return function(){
			return f.apply(obj, arguments);
		};
	},
	fromHTML:function(str){
		if (typeof str == "function") return str;
		if (this._cache[str])
			return this._cache[str];
			
	//supported idioms
	// {obj} => value
	// {obj.attr} => named attribute or value of sub-tag in case of xml
	// {obj.attr?some:other} conditional output
	// {-obj => sub-template
		str=(str||"").toString();		
		str=str.replace(/[\r\n]+/g,"\\n");
		str=str.replace(/\{obj\.([^}?]+)\?([^:]*):([^}]*)\}/g,"\"+(obj.$1?\"$2\":\"$3\")+\"");
		str=str.replace(/\{common\.([^}\(]*)\}/g,"\"+common.$1+\"");
		str=str.replace(/\{common\.([^\}\(]*)\(\)\}/g,"\"+(common.$1?common.$1(obj):\"\")+\"");
		str=str.replace(/\{obj\.([^}]*)\}/g,"\"+obj.$1+\"");
		str=str.replace(/#([a-z0-9_]+)#/gi,"\"+obj.$1+\"");
		str=str.replace(/\{obj\}/g,"\"+obj+\"");
		str=str.replace(/\{-obj/g,"{obj");
		str=str.replace(/\{-common/g,"{common");
		str="return \""+str+"\";";
		return this._cache[str]= Function("obj","common",str);
	}
};

dhtmlx.Type={
	/*
		adds new template-type
		obj - object to which template will be added
		data - properties of template
	*/
	add:function(obj, data){ 
		//auto switch to prototype, if name of class was provided
		if (!obj.types && obj.prototype.types)
			obj = obj.prototype;
		//if (typeof data == "string")
		//	data = { template:data };
			
		if (dhtmlx.assert_enabled())
			this.assert_event(data);
		
		var name = data.name||"default";
		
		//predefined templates - autoprocessing
		this._template(data);
		this._template(data,"edit");
		this._template(data,"loading");
		
		obj.types[name]=dhtmlx.extend(dhtmlx.extend({},(obj.types[name]||this._default)),data);	
		return name;
	},
	//default template value - basically empty box with 5px margin
	_default:{
		css:"default",
		template:function(){ return ""; },
		template_edit:function(){ return ""; },
		template_loading:function(){ return "..."; },
		width:150,
		height:80,
		margin:5,
		padding:0
	},
	//template creation helper
	_template:function(obj,name){ 
		name = "template"+(name?("_"+name):"");
		var data = obj[name];
		//if template is a string - check is it plain string or reference to external content
		if (data && (typeof data == "string")){
			if (data.indexOf("->")!=-1){
				data = data.split("->");
				switch(data[0]){
					case "html": 	//load from some container on the page
						data = dhtmlx.html.getValue(data[1]).replace(/\"/g,"\\\"");
						break;
					case "http": 	//load from external file
						data = new dhtmlx.ajax().sync().get(data[1],{uid:(new Date()).valueOf()}).responseText;
						break;
					default:
						//do nothing, will use template as is
						break;
				}
			}
			obj[name] = dhtmlx.Template.fromHTML(data);
		}
	}
};


/* DHX DEPEND FROM FILE 'single_render.js'*/


/*
	REnders single item. 
	Can be used for elements without datastore, or with complex custom rendering logic
	
	@export
		render
*/

/*DHX:Depend template.js*/

dhtmlx.SingleRender={
	_init:function(){
	},
	//convert item to the HTML text
	_toHTML:function(obj){
			/*
				this one doesn't support per-item-$template
				it has not sense, because we have only single item per object
			*/
			return this.type._item_start(obj,this.type)+this.type.template(obj,this.type)+this.type._item_end;
	},
	//render self, by templating data object
	render:function(){
		if (!this.callEvent || this.callEvent("onBeforeRender",[this.data])){
			if (this.data)
				this._dataobj.innerHTML = this._toHTML(this.data);
			if (this.callEvent) this.callEvent("onAfterRender",[]);
		}
	}
};


/* DHX DEPEND FROM FILE 'tooltip.js'*/


/*
	UI: Tooltip
	
	@export
		show
		hide
*/

/*DHX:Depend tooltip.css*/
/*DHX:Depend template.js*/
/*DHX:Depend single_render.js*/

dhtmlx.ui.Tooltip=function(container){
	this.name = "Tooltip";
	
	if (dhtmlx.assert_enabled()) this._assert();

	if (typeof container == "string"){
		container = { template:container };
	}
		
	dhtmlx.extend(this, dhtmlx.Settings);
	dhtmlx.extend(this, dhtmlx.SingleRender);
	this._parseSettings(container,{
		type:"default",
		dy:0,
		dx:20
	});
	
	//create  container for future tooltip
	this._dataobj = this._obj = document.createElement("DIV");
	this._obj.className="dhx_tooltip";
	dhtmlx.html.insertBefore(this._obj,document.body.firstChild);
};
dhtmlx.ui.Tooltip.prototype = {
	//show tooptip
	//pos - object, pos.x - left, pox.y - top
	show:function(data,pos){
		if (this._disabled) return;
		//render sefl only if new data was provided
		if (this.data!=data){
			this.data=data;
			this.render(data);
		}
		//show at specified position
		this._obj.style.top = pos.y+this._settings.dy+"px";
		this._obj.style.left = pos.x+this._settings.dx+"px";
		this._obj.style.display="block";
	},
	//hide tooltip
	hide:function(){
		this.data=null; //nulify, to be sure that on next show it will be fresh-rendered
		this._obj.style.display="none";
	},
	disable:function(){
		this._disabled = true;	
	},
	enable:function(){
		this._disabled = false;
	},
	types:{
		"default":dhtmlx.Template.fromHTML("{obj.id}")
	},
	template_item_start:dhtmlx.Template.empty,
	template_item_end:dhtmlx.Template.empty
};



/* DHX DEPEND FROM FILE 'autotooltip.js'*/


/*
	Behavior: AutoTooltip - links tooltip to data driven item
*/

/*DHX:Depend tooltip.js*/

dhtmlx.AutoTooltip = {
	tooltip_setter:function(value){
		var t = new dhtmlx.ui.Tooltip(value);
		this.attachEvent("onMouseMove",function(id,e){	//show tooltip on mousemove
			t.show(this.get(id),dhtmlx.html.pos(e));
		});
		this.attachEvent("onMouseOut",function(id,e){	//hide tooltip on mouseout
			t.hide();
		});
		this.attachEvent("onMouseMoving",function(id,e){	//hide tooltip just after moving start
			t.hide();
		});
		return t;
	}
};


/* DHX DEPEND FROM FILE 'compatibility.js'*/


/*
	Collection of compatibility hacks
*/

/*DHX:Depend dhtmlx.js*/

dhtmlx.compat=function(name, obj){
	//check if name hash present, and applies it when necessary
	if (dhtmlx.compat[name])
		dhtmlx.compat[name](obj);
};


/* DHX DEPEND FROM FILE 'compatibility_layout.js'*/


/*DHX:Depend dhtmlx.js*/
/*DHX:Depend compatibility.js*/

if (!dhtmlx.attaches)
	dhtmlx.attaches = {};
	
dhtmlx.attaches.attachAbstract=function(name, conf){
	var obj = document.createElement("DIV");
	obj.id = "CustomObject_"+dhtmlx.uid();
	obj.style.width = "100%";
	obj.style.height = "100%";
	obj.cmp = "grid";
	document.body.appendChild(obj);
	this.attachObject(obj.id);
	
	conf.container = obj.id;
	
	var that = this.vs[this.av];
	that.grid = new window[name](conf);
	
	that.gridId = obj.id;
	that.gridObj = obj;
	
		
	that.grid.setSizes = function(){
		if (this.resize) this.resize();
		else this.render();
	};
	
	var method_name="_viewRestore";
	return this.vs[this[method_name]()].grid;
};
dhtmlx.attaches.attachDataView = function(conf){
	return this.attachAbstract("dhtmlXDataView",conf);
};
dhtmlx.attaches.attachChart = function(conf){
	return this.attachAbstract("dhtmlXChart",conf);
};

dhtmlx.compat.layout = function(){};





/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXCellObject(idd, css) {
	
	this.cell = document.createElement("DIV");
	this.cell.className = "dhx_cell"+(css||"");
	
	this._idd = idd;
	this._isCell = true;
	
	this.conf = {
		borders: true,
		idx: {},
		css: css||"",
		idx_data: {
			cont: "dhx_cell_cont",
			pr1: "dhx_cell_progress_bar",
			pr2: "dhx_cell_progress_img",
			pr3: "dhx_cell_progress_svg",
			menu: "dhx_cell_menu",
			toolbar: "dhx_cell_toolbar",
			ribbon: "dhx_cell_ribbon",
			sb: "dhx_cell_statusbar",
			cover: "dhx_cell_cover"
		},
		ofs_nodes: { t:{}, b:{} }	// attached dataNodes (menu/toolbar/status), can be true, false;
						// in case of layout - "func" for header
	}
	
	this.dataNodes = {}; // menu/toolbar/status
	
	this.views = {};
	
	// cont
	var p = document.createElement("DIV");
	p.className = "dhx_cell_cont"+this.conf.css;
	this.cell.appendChild(p);
	p = null;
	
	this._updateIdx = function() {
		for (var a in this.conf.idx) {
			this.conf.idx[a] = null;
			delete this.conf.idx[a];
		}
		for (var q=0; q<this.cell.childNodes.length; q++) {
			var css = this.cell.childNodes[q].className;
			for (var a in this.conf.idx_data) {
				var r = new RegExp(this.conf.idx_data[a]);
				if (css.match(r) != null) this.conf.idx[a] = q;
			}
		}
		
		this.callEvent("_onIdxUpdated",[]);
	}
	
	this._adjustAttached = function() {
		// mtb/ribbon
		for (var a in this.dataNodes) {
			if (this.dataNodes[a] != null && typeof(this.dataNodes[a].setSizes) == "function") {
				this.dataNodes[a].setSizes();
			}
		}
		// attached node
		if (this.dataObj != null && typeof(this.dataObj.setSizes) == "function") {
			// check if dataObj is layuot which was attached separately
			if (this.dataType == "layout" && typeof(window.dhtmlXLayoutCell) == "function" && this instanceof window.dhtmlXLayoutCell && this.dataObj._getMainInst() != this.layout._getMainInst()) {
				this.dataObj.setSizes();
				return;
			}
			this.dataObj.setSizes.apply(this.dataObj, arguments);
		}
	}
	
	this._setSize = function(x, y, w, h, parentIdd, noCalcCont, actionType, customProps) {
		
		if (this.conf.size == null) this.conf.size = {};
		if (customProps == null) customProps = {}; // ability to use margin-left instead of left
		
		var styleProps = {left: "x", top: "y", width: "w", height: "h"};
		
		this.conf.size.x = x;
		this.conf.size.y = y;
		this.conf.size.w = Math.max(w,0);
		this.conf.size.h = Math.max(h,0);
		
		for (var a in styleProps) {
			var name = (customProps[a]||a);
			this.cell.style[name] = this.conf.size[styleProps[a]]+"px";
		}
		
		this.callEvent("_onSetSize",[]);
		
		if (noCalcCont !== true) {
			this._adjustCont(parentIdd, actionType);
		} else {
			this._adjustAttached(parentIdd);
		}
		
		this._adjustProgress();
	}
	
	this._adjustCont = function(parentIdd, actionType) {
		
		var t = this.cell.childNodes[this.conf.idx.cont];
		
		// attempt to adjust cell in collapsed layout
		if (typeof(window.dhtmlXLayoutCell) == "function" && this instanceof window.dhtmlXLayoutCell && this.conf.collapsed == true) {
			t.style.left = t.style.top = "0px";
			t.style.width = t.style.height = "200px";
			t = null;
			return;
		}
		
		// header height, menu, toolbar if any
		var ht = 0;
		for (var a in this.conf.ofs_nodes.t) {
			var k = this.conf.ofs_nodes.t[a];
			ht += (k=="func"?this[a]():(k==true?this.cell.childNodes[this.conf.idx[a]].offsetHeight:0));
		}
		
		// bottom offset (height reduce if status attached)
		var hb = 0;
		for (var a in this.conf.ofs_nodes.b) {
			var k = this.conf.ofs_nodes.b[a];
			hb += (k=="func"?this[a]():(k==true?this.cell.childNodes[this.conf.idx[a]].offsetHeight:0));
		}
		
		t.style.left = "0px";
		t.style.top = ht+"px";
		
		if (this.conf.cells_cont == null) {
			this.conf.cells_cont = {};
			t.style.width = this.cell.offsetWidth+"px";
			t.style.height = Math.max(this.cell.offsetHeight-ht-hb,0)+"px";
			this.conf.cells_cont.w = parseInt(t.style.width)-t.offsetWidth;
			this.conf.cells_cont.h = parseInt(t.style.height)-t.offsetHeight;
		}
		
		t.style.left = "0px";
		t.style.top = ht+"px";
		t.style.width = Math.max(this.cell.offsetWidth+this.conf.cells_cont.w,0)+"px";
		t.style.height = Math.max(this.conf.size.h-ht-hb+this.conf.cells_cont.h,0)+"px";
		t = null;
		
		// move out?
		this._adjustAttached(parentIdd); // for layout only 1 arg should be here
		
		// editor adjust cont here, browser check needed ( !!make some tests :)
		if (actionType == "expand" && this.dataType == "editor" && this.dataObj != null) {
			this.dataObj._prepareContent(true);
		}
	}
	
	this._mtbUpdBorder = function() {
		
		var t = ["menu","toolbar","ribbon"];
		for (var q=0; q<t.length; q++) {
			if (this.conf.idx[t[q]] != null) {
				var p = this.cell.childNodes[this.conf.idx[t[q]]];
				var c1 = "dhx_cell_"+t[q]+"_no_borders";
				var c2 = "dhx_cell_"+t[q]+"_def";
				p.className = p.className.replace(new RegExp(this.conf.borders?c1:c2), this.conf.borders?c2:c1);
				p = null;
			}
		}
	}
	
	this._resetSizeState = function() {
		// delete autosize settings, autocalc for cell_cont borders, paddings, useful on skinchange
		this.conf.cells_cont = null;
	}
	
	/* views */
	
	// test with url and getFrame()
	
	// current view
	this.conf.view = "def";
	
	// views loaded at least once
	this.conf.views_loaded = {};
	this.conf.views_loaded[this.conf.view] = true;
	
	// move current data to archive
	this._viewSave = function(name) {
		
		this.views[name] = {
			borders: this.conf.borders,
			ofs_nodes: {t:{},b:{}},
			url_data: this.conf.url_data,
			dataType: this.dataType,
			dataObj: this.dataObj,
			cellCont: [],
			dataNodes: {},
			dataNodesCont: {}
		};
		
		// attached cont
		var cellCont = this.cell.childNodes[this.conf.idx.cont];
		while (cellCont.childNodes.length > 0) {
			this.views[name].cellCont.push(cellCont.firstChild);
			cellCont.removeChild(cellCont.firstChild);
		}
		cellCont = null;
		
		this.dataType = null;
		this.dataObj = null;
		this.conf.url_data = null;
		
		// menu/toolbar/status
		for (var a in this.dataNodes) {
			
			for (var b in this.conf.ofs_nodes) {
				if (typeof(this.conf.ofs_nodes[b][a]) != "undefined") {
					this.views[name].ofs_nodes[b][a] = this.conf.ofs_nodes[b][a];
					this.conf.ofs_nodes[b][a] = null;
					delete this.conf.ofs_nodes[b][a];
				}
			}
			
			this.views[name].dataNodesCont[a] = this.cell.childNodes[this.conf.idx[a]];
			this.cell.removeChild(this.cell.childNodes[this.conf.idx[a]]);
			
			this.views[name].dataNodes[a] = this.dataNodes[a];
			this.dataNodes[a] = null;
			delete this.dataNodes[a];
			
			this._updateIdx();
		}
		
		this.callEvent("_onViewSave", [name]);
		
	}
	
	this._viewRestore = function(name) {
		
		if (this.views[name] == null) return;
		
		// content
		this.dataObj = this.views[name].dataObj;
		this.dataType = this.views[name].dataType;
		this.conf.url_data = this.views[name].url_data;
		for (var q=0; q<this.views[name].cellCont.length; q++) this.cell.childNodes[this.conf.idx.cont].appendChild(this.views[name].cellCont[q]);
		
		// data nodes (menu/toolbar/status)
		for (var a in this.views[name].dataNodes) {
			
			this.dataNodes[a] = this.views[name].dataNodes[a];
			// below is not very universal solution for extending
			if (a == "menu") this.cell.insertBefore(this.views[name].dataNodesCont[a], this.cell.childNodes[this.conf.idx.toolbar||this.conf.idx.cont]);
			if (a == "toolbar") this.cell.insertBefore(this.views[name].dataNodesCont[a], this.cell.childNodes[this.conf.idx.cont]);
			if (a == "ribbon") this.cell.insertBefore(this.views[name].dataNodesCont[a], this.cell.childNodes[this.conf.idx.cont]);
			if (a == "sb") this.cell.appendChild(this.views[name].dataNodesCont[a]);
			
			this._updateIdx();
		}
		
		// ofs_nodes
		for (var a in this.views[name].ofs_nodes) {
			for (var b in this.views[name].ofs_nodes[a]) this.conf.ofs_nodes[a][b] = this.views[name].ofs_nodes[a][b];
		}
		
		if (this.conf.borders != this.views[name].borders) {
			this[this.views[name].borders?"_showBorders":"_hideBorders"](true);
		}
		
		// reload url attache dwith POST
		if (this.dataType == "url" && this.conf.url_data != null && this.conf.url_data.ajax == false && this.conf.url_data.post_data != null) {
			this.reloadURL();
		}
		
		this.callEvent("_onViewRestore", [name]);
		
		this._viewDelete(name);
		
	}
	
	this._viewDelete = function(name) {
		
		if (this.views[name] == null) return;
		
		this.views[name].borders = null;
		
		for (var a in this.views[name].ofs_nodes) {
			for (var b in this.views[name].ofs_nodes[a]) this.views[name].ofs_nodes[a][b] = null;
			this.views[name].ofs_nodes[a] = null;
		}
		
		this.views[name].dataType = null;
		this.views[name].dataObj = null;
		this.views[name].url_data = null;
		
		for (var q=0; q<this.views[name].cellCont.length; q++) this.views[name].cellCont[q] = null;
		this.views[name].cellCont = null;
		
		for (var a in this.views[name].dataNodes) {
			this.views[name].dataNodes[a] = null;
			this.views[name].dataNodesCont[a] = null;
		}
		
		this.views[name].dataNodes = this.views[name].dataNodesCont = null;
		
		this.views[name] = null;
		delete this.views[name];
		
	}
	
	/* views end */
	
	window.dhx4._eventable(this);
	this._updateIdx();
	
	return this;
	
};

// views
dhtmlXCellObject.prototype.showView = function(name) {
	
	if (this.conf.view == name) return false; // alredy visible
	
	// save current view
	this._viewSave(this.conf.view);
	
	// restore requested view if exists
	this._viewRestore(name);
	
	// update cell rendering
	this._updateIdx();
	this._adjustCont();
	
	this.conf.view = name;
	
	var t = (typeof(this.conf.views_loaded[this.conf.view]) == "undefined");
	this.conf.views_loaded[this.conf.view] = true;
	
	return t;
	
};

dhtmlXCellObject.prototype.getViewName = function() {
	return this.conf.view;
};

dhtmlXCellObject.prototype.unloadView = function(name) {
	// hidden view, unload menu/toolbar/status, etc
	
	// unload actve view
	if (name == this.conf.view) {
		
		// set unloading flag to prevent some adjust operations
		var t = this.conf.unloading;
		this.conf.unloading = true;
		
		// remove content
		if (typeof(this.detachMenu) == "function") this.detachMenu();
		if (typeof(this.detachToolbar) == "function") this.detachToolbar();
		if (typeof(this.detachRibbon) == "function") this.detachRibbon();
		this.detachStatusBar();
		this._detachObject(null, true);
		
		// restore unloading flag
		this.conf.unloading = t;
		if (!this.conf.unloading) this._adjustCont(this._idd);
		
		return;
	}
	
	if (this.views[name] == null) return;
	
	var v = this.views[name];
	for (var a in v.dataNodes) {
		if (typeof(v.dataNodes[a].unload) == "function") v.dataNodes[a].unload();
		v.dataNodes[a] = null;
		v.dataNodesCont[a] = null;
	}
	if (v.dataType == "url") {
		if (v.cellCont != null && v.cellCont[0] != "null") {
			this._detachURLEvents(v.cellCont[0]);
		}
	} else if (v.dataObj != null) {
		if (typeof(v.dataObj.unload) == "function") {
			v.dataObj.unload();
		} else if (typeof(v.dataObj.destructor) == "function") {
			v.dataObj.destructor();
		}
		v.dataObj = null;
	}
	v = null;
	
	this._viewDelete(name);
	
	if (typeof(this.conf.views_loaded[name]) != "undefined") {
		delete this.conf.views_loaded[name];
	}
	
};


// id
dhtmlXCellObject.prototype.getId = function() {
	return this._idd;
};

// progress
dhtmlXCellObject.prototype.progressOn = function() {
	
	if (this.conf.progress == true) return;
	
	this.conf.progress = true;
	
	// cover
	var t1 = document.createElement("DIV");
	t1.className = this.conf.idx_data.pr1;
	
	// image/animation
	var t2 = document.createElement("DIV");
	if (this.conf.skin == "material" && (window.dhx4.isFF || window.dhx4.isChrome || window.dhx4.isOpera || window.dhx4.isEdge)) {
		t2.className = this.conf.idx_data.pr3;
		t2.innerHTML = '<svg class="dhx_cell_prsvg" viewBox="25 25 50 50"><circle class="dhx_cell_prcircle" cx="50" cy="50" r="20"/></svg>';
	} else {
		t2.className = this.conf.idx_data.pr2;
	}
	
	if (this.conf.idx.cover != null) {
		this.cell.insertBefore(t2, this.cell.childNodes[this.conf.idx.cover]);
	} else {
		this.cell.appendChild(t2);
	}
	this.cell.insertBefore(t1, t2);
	
	t1 = t2 = null;
	
	this._updateIdx();
	this._adjustProgress();
	
};

dhtmlXCellObject.prototype.progressOff = function() {
	
	if (this.conf.progress != true) return;
	
	for (var a in {pr3:3,pr2:2,pr1:1}) {
		var node = this.cell.childNodes[this.conf.idx[a]];
		if (node != null) node.parentNode.removeChild(node);
		node = null;
	}
	
	this.conf.progress = false;
	
	this._updateIdx();
};

dhtmlXCellObject.prototype._adjustProgress = function() {
	
	if (this.conf.idx.pr1 == null) return;
	
	if (!this.conf.pr) this.conf.pr = {};
	
	var p1 = this.cell.childNodes[this.conf.idx.pr1]; // half-transparent cover
	var p2 = this.cell.childNodes[this.conf.idx.pr2]||this.cell.childNodes[this.conf.idx.pr3]; // image/svg
	
	if (!this.conf.pr.ofs) {
		p2.style.width = p1.offsetWidth + "px";
		p2.style.height = p1.offsetHeight + "px";
		this.conf.pr.ofs = {
			w: p2.offsetWidth-p2.clientWidth,
			h: p2.offsetHeight-p2.clientHeight
		};
	}
	
	p2.style.width = p1.offsetWidth - this.conf.pr.ofs.w + "px";
	p2.style.height = p1.offsetHeight - this.conf.pr.ofs.h + "px";
	
	p1 = p2 = null;
};

// content cover
dhtmlXCellObject.prototype._showCellCover = function() {
	
	if (this.conf.cover == true) return;
	this.conf.cover = true;
	
	var t = document.createElement("DIV");
	t.className = this.conf.idx_data.cover;
	this.cell.appendChild(t);
	t = null;
	
	this._updateIdx();
};

dhtmlXCellObject.prototype._hideCellCover = function() {
	
	if (this.conf.cover != true) return;
	
	this.cell.removeChild(this.cell.childNodes[this.conf.idx.cover]);
	this._updateIdx();
	
	this.conf.cover = false;
	
};

// borders
dhtmlXCellObject.prototype._showBorders = function(noAdjust) {
	
	if (this.conf.borders) return;
	
	this.conf.borders = true;
	
	this.cell.childNodes[this.conf.idx.cont].className = "dhx_cell_cont"+this.conf.css;
	
	this.conf.cells_cont = null;
	this._mtbUpdBorder();
	
	this.callEvent("_onBorderChange",[true]);
	
	if (noAdjust !== true) this._adjustCont(this._idd);
	
};
	
dhtmlXCellObject.prototype._hideBorders = function(noAdjust) {
	
	if (!this.conf.borders) return;
	
	this.conf.borders = false;
	
	this.cell.childNodes[this.conf.idx.cont].className = "dhx_cell_cont"+this.conf.css+" dhx_cell_cont_no_borders";
	this.conf.cells_cont = null;
	this._mtbUpdBorder();
	
	this.callEvent("_onBorderChange",[false]);
	
	if (noAdjust !== true) this._adjustCont(this._idd);
	
};

// basic width/height
dhtmlXCellObject.prototype._getWidth = function() {
	return this.cell.offsetWidth;
};

dhtmlXCellObject.prototype._getHeight = function() {
	return this.cell.offsetHeight;
};


dhtmlXCellObject.prototype.showInnerScroll = function() {
	this.cell.childNodes[this.conf.idx.cont].style.overflow = "auto";
};

/* unload */
dhtmlXCellObject.prototype._unload = function() {
	
	this.conf.unloading = true;
	
	this.callEvent("_onCellUnload",[]);
	
	this.progressOff();
	
	// unload current view (remove attached content)
	this.unloadView(this.conf.view);
	
	this.dataNodes = null;
	
	this.cell.parentNode.removeChild(this.cell);
	this.cell = null;
	
	window.dhx4._eventable(this, "clear");
	
	// views
	for (var a in this.views) this.unloadView(a);
	
	this.conf = null;
	
	// others
	for (var a in this) this[a] = null; // no mercy
	
};


dhtmlXCellObject.prototype.attachObject = function(obj, adjust) {
	
	// adjust - for windows only
	if (window.dhx4.s2b(adjust) && !(typeof(window.dhtmlXWindowsCell) == "function" && this instanceof window.dhtmlXWindowsCell)) {
		adjust = false;
	}
	
	if (typeof(obj) == "string") obj = document.getElementById(obj);
	
	// already attached
	if (obj.parentNode == this.cell.childNodes[this.conf.idx.cont]) {
		obj = null;
		return;
	}
	
	if (adjust) {
		obj.style.display = "";
		var w = obj.offsetWidth;
		var h = obj.offsetHeight;
	}
	
	this._attachObject(obj);
	this.dataType = "obj";
	obj.style.display = "";
	obj = null;
	
	if (adjust) this._adjustByCont(w,h);
	
};

dhtmlXCellObject.prototype.appendObject = function(obj) {
	
	if (typeof(obj) == "string") obj = document.getElementById(obj);
	
	// already attached
	if (obj.parentNode == this.cell.childNodes[this.conf.idx.cont]) {
		obj = null;
		return;
	}
	
	
	if (!this.conf.append_mode) {
		this.cell.childNodes[this.conf.idx.cont].style.overflow = "auto";
		this.conf.append_mode = true;
	}
	
	this._attachObject(obj, null, null, true);
	this.dataType = "obj";
	obj.style.display = "";
	obj = null;
	
};

dhtmlXCellObject.prototype.detachObject = function(remove, moveTo) {
	this._detachObject(null, remove, moveTo);
};

dhtmlXCellObject.prototype.getAttachedStatusBar = function() {
	return this.dataNodes.sb;
};
dhtmlXCellObject.prototype.getAttachedObject = function() {
	if (this.dataType == "obj" || this.dataType == "url" || this.dataType == "url-ajax") {
		return this.cell.childNodes[this.conf.idx.cont].firstChild;
	} else {
		return this.dataObj;
	}
};

dhtmlXCellObject.prototype.attachURL = function(url, useAjax, postData) {
	
	// prepare POST if any, postData should be true or {} otherwise GET
	if (postData == true) postData = {};
	var postReq = (typeof(postData) != "undefined" && postData != false && postData != null);
	
	if (this.conf.url_data == null) this.conf.url_data = {};
	this.conf.url_data.url = url;
	this.conf.url_data.ajax = (useAjax == true);
	this.conf.url_data.post_data = (postData==true?{}:(postData||null)); // true or object
	
	if (this.conf.url_data.xml_doc != null) {
		try {this.conf.url_data.xml_doc.xmlDoc.abort();}catch(e){};
		this.conf.url_data.xml_doc.xmlDoc = null;
		this.conf.url_data.xml_doc = null;
	}
	
	if (useAjax == true) {
		
		var t = this;
		if (postReq) {
			var params = "";
			for (var a in postData) params += "&"+encodeURIComponent(a)+"="+encodeURIComponent(postData[a]);

			this.conf.url_data.xml_doc = dhx4.ajax.post(url, params, function(r){
				if (t.attachHTMLString != null && typeof(r.xmlDoc.responseText) == "string") {
					t.attachHTMLString("<div style='position:relative;width:100%;height:100%;overflow:auto;'>"+r.xmlDoc.responseText+"</div>");
					if (typeof(t._doOnFrameContentLoaded) == "function") t._doOnFrameContentLoaded();
					t.dataType = "url-ajax";
				}
				t = r = null;
			});
		} else {
			this.conf.url_data.xml_doc = dhx4.ajax.get(url, function(r){
				if (t.attachHTMLString != null && typeof(r.xmlDoc.responseText) == "string") {
					t.attachHTMLString("<div style='position:relative;width:100%;height:100%;overflow:auto;'>"+r.xmlDoc.responseText+"</div>");
					if (typeof(t._doOnFrameContentLoaded) == "function") t._doOnFrameContentLoaded();
					t.dataType = "url-ajax";
				}
				t = r = null;
			});
		}
		
	} else {
		if (this.dataType == "url") {
			var fr = this.getFrame();
		} else {
			var fr = document.createElement("IFRAME");
			fr.frameBorder = 0;
			fr.border = 0;
			fr.style.width = "100%";
			fr.style.height = "100%";
			fr.style.position = "relative";
			this._attachObject(fr);
			this.dataType = "url";
			this._attachURLEvents();
		}
		if (postReq) {
			var firstLoad = (typeof(this.conf.url_data.post_ifr) == "undefined");
			this.conf.url_data.post_ifr = true; // load later
			if (firstLoad) this._attachURLEvents();
			fr.src = "about:blank";
		} else {
			fr.src = url+window.dhx4.ajax._dhxr(url);
		}
		fr = null;
	}
	
	fr = null;
};

dhtmlXCellObject.prototype.reloadURL = function() {
	if (!(this.dataType == "url" || this.dataType == "url-ajax")) return;
	if (this.conf.url_data == null) return;
	this.attachURL(this.conf.url_data.url, this.conf.url_data.ajax, this.conf.url_data.post_data);
};

dhtmlXCellObject.prototype.attachHTMLString = function(str) {
	this._attachObject(null, null, str);
	// esec script
	var z = str.match(/<script[^>]*>[^\f]*?<\/script>/g)||[];
	for (var i=0; i<z.length; i++) {
		var s = z[i].replace(/<([\/]{0,1})script[^>]*>/gi,"");
		if (s) {
			if (window.execScript) window.execScript(s); else window.eval(s);
		}
	}
};

dhtmlXCellObject.prototype.attachScheduler = function(day, mode, cont_id, scheduler) {
	
	scheduler = scheduler || window.scheduler;
	
	var ready = false;
	if (cont_id) {
		var obj = document.getElementById(cont_id);
		if (obj) ready = true;
	}
	if (!ready) {
		var tabs = cont_id || '<div class="dhx_cal_tab" name="day_tab" style="right:204px;"></div><div class="dhx_cal_tab" name="week_tab" style="right:140px;"></div><div class="dhx_cal_tab" name="month_tab" style="right:76px;"></div>';
		var obj = document.createElement("DIV");
		obj.id = "dhxSchedObj_"+new Date().getTime();
		obj.style.width = "100%";
		obj.style.height = "100%";
		obj.style.position = "relative";
		obj.style.overflow = "hidden";
		obj.className = "dhx_cal_container";
		obj.innerHTML = '<div class="dhx_cal_navline"><div class="dhx_cal_prev_button">&nbsp;</div><div class="dhx_cal_next_button">&nbsp;</div><div class="dhx_cal_today_button"></div><div class="dhx_cal_date"></div>'+tabs+'</div><div class="dhx_cal_header"></div><div class="dhx_cal_data"></div>';
	}
	
	this._attachObject(obj);
	
	this.dataType = "scheduler";
	this.dataObj = scheduler;
	this.dataObj.setSizes = function(){
		this.update_view();
	}
	
	scheduler.init(obj.id, day, mode);
	
	obj = null;
	
	this.callEvent("_onContentAttach",[]);
	
	return this.dataObj;
};

dhtmlXCellObject.prototype.attachMap = function(opts) {
	
	var obj = document.createElement("DIV");
	obj.style.width = "100%";
	obj.style.height = "100%";
	obj.style.position = "relative";
	obj.style.overflow = "hidden";
	this._attachObject(obj);
	
	if (!opts) opts = {center: new google.maps.LatLng(40.719837,-73.992348), zoom: 11, mapTypeId: google.maps.MapTypeId.ROADMAP};
	
	this.dataType = "maps";
	this.dataObj = new google.maps.Map(obj, opts);
	
	this.dataObj.setSizes = function() {
		google.maps.event.trigger(this, "resize");
	}
	
	obj = null;
	
	this.callEvent("_onContentAttach",[]);
	
	return this.dataObj;
	
};

// status bar
dhtmlXCellObject.prototype._createNode_sb = function(obj, type, htmlString, append, node) {
	// type -> (object) conf={text:string,height:number}
	if (typeof(node) != "undefined") {
		obj = node;
	} else {
		var conf = type||{};
		var text = (typeof(conf.text)=="string" && conf.text.length > 0 ? conf.text : "&nbsp;");
		var h = (typeof(conf.height) == "number" ? conf.height : false);
		var obj = document.createElement("DIV");
		
		obj.className = "dhx_cell_statusbar_def";
		obj.innerHTML = "<div class='"+(conf.paging==true?"dhx_cell_statusbar_paging":"dhx_cell_statusbar_text")+"'>"+text+"</div>";
		
		// height, optional
		if (h != false) obj.firstChild.style.height = obj.firstChild.style.lineHeight = h+"px";
	}
	
	// before progress or last
	if (this.conf.idx.pr1 != null) {
		this.cell.insertBefore(obj, this.cell.childNodes[this.conf.idx.pr1]);
	} else {
		this.cell.appendChild(obj);
	}
	
	this.conf.ofs_nodes.b.sb = true;
	this._updateIdx();
	this._adjustCont(this._idd);
	
	return obj;
};

dhtmlXCellObject.prototype.attachStatusBar = function(conf) { // args-optinal, new in version
	
	if (this.dataNodes.sb) return;  // return this.dataNodes.sb?
	
	if (conf != null && window.dhx4.s2b(conf.paging) == true) conf.height = null; // will set by css
	
	if (this.conf.skin == "dhx_skyblue" && typeof(window.dhtmlXWindowsCell) == "function" && this instanceof window.dhtmlXWindowsCell) {
		 this.cell.childNodes[this.conf.idx.cont].className += " dhx_cell_statusbar_attached";
	}
	this.dataNodes.sb = this._attachObject("sb", conf);
	
	this.dataNodes.sb.setText = function(text) { this.childNodes[0].innerHTML = text; }
	this.dataNodes.sb.getText = function() { return this.childNodes[0].innerHTML; }
	this.dataNodes.sb.onselectstart = function(e) { return false; }
	
	return this.dataNodes.sb;
	
};

dhtmlXCellObject.prototype.detachStatusBar = function() {
	
	if (!this.dataNodes.sb) return;
	
	if (this.conf.skin == "dhx_skyblue"  && typeof(window.dhtmlXWindowsCell)== "function" && this instanceof window.dhtmlXWindowsCell) {
		 this.cell.childNodes[this.conf.idx.cont].className = this.cell.childNodes[this.conf.idx.cont].className.replace(/\s{0,}dhx_cell_statusbar_attached/,"");
	}
	
	this.dataNodes.sb.setText = this.dataNodes.sb.getText = this.dataNodes.sb.onselectstart = null;
	this.dataNodes.sb = null;
	delete this.dataNodes.sb;
	
	this._detachObject("sb");
	
};

dhtmlXCellObject.prototype.showStatusBar = function() {
	this._mtbShowHide("sb", "");
};

dhtmlXCellObject.prototype.hideStatusBar = function() {
	this._mtbShowHide("sb", "none");
};

dhtmlXCellObject.prototype._mtbShowHide = function(name, disp) {
	if (!this.dataNodes[name]) return;
	this.cell.childNodes[this.conf.idx[name]].style.display = disp;
	this._adjustCont();
};


/* private logic */

// !!! fix
dhtmlXCellObject.prototype.getFrame = dhtmlXCellObject.prototype._getFrame = function() { // _getFrame deprecated, use getFrame
	if (this.dataType != "url") return null;
	return this.cell.childNodes[this.conf.idx.cont].firstChild;
};

dhtmlXCellObject.prototype._attachURLEvents = function() {
	
	if (this.dataType != "url") return;
	
	var t = this;
	var cId = this._idd;
	var fr = this.cell.childNodes[this.conf.idx.cont].firstChild;
	
	if (typeof(this._doOnFrameMouseDown) != "function") {
		this._doOnFrameMouseDown = function(e) {
			// console.log("frame mouse down"); // needed for windows to activate window
			t.callEvent("_onContentMouseDown", [cId,e||event]);
		}
	}
	
	if (typeof(window.addEventListener) == "function") {
		fr.onload = function() {
			try { if (typeof(t._doOnFrameMouseDown) == "function") this.contentWindow.document.body.addEventListener("mousedown", t._doOnFrameMouseDown, false); } catch(e) {};
			try { if (typeof(t._doOnFrameContentLoaded) == "function") t._doOnFrameContentLoaded(); } catch(e) {};
		}
	} else {
		// ie8-
		fr.onreadystatechange = function(a) {
			if (this.readyState == "complete") {
				try { if (typeof(t._doOnFrameMouseDown) == "function") this.contentWindow.document.body.attachEvent("onmousedown", t._doOnFrameMouseDown); } catch(e) {};
				try { if (typeof(t._doOnFrameContentLoaded) == "function") t._doOnFrameContentLoaded(); } catch(e) {};
			}
		}
	}
	//fr = null;
};


dhtmlXCellObject.prototype._doOnFrameContentLoaded = function() {
	if (this.conf.url_data.post_ifr == true) {
		var d = this.getFrame().contentWindow.document;
		var f = d.createElement("FORM");
		f.method = "POST";
		f.action = this.conf.url_data.url;
		d.body.appendChild(f);
		var postData = {};
		if (window.dhx4.ajax.cache != true) postData["dhxr"+new Date().getTime()] = "1";
		for (var a in this.conf.url_data.post_data) postData[a] = this.conf.url_data.post_data[a];
		for (var a in postData) {
			var k = d.createElement("INPUT");
			k.type = "hidden";
			k.name = a;
			k.value = postData[a];
			f.appendChild(k);
			k = null;
		}
		this.conf.url_data.post_ifr = false;
		f.submit();
	} else {
		this.callEvent("_onContentLoaded", [this._idd]);
	}
};

dhtmlXCellObject.prototype._detachURLEvents = function(fr) {
	if (fr == null) {
		if (this.dataType != "url") return;
		fr = this.cell.childNodes[this.conf.idx.cont].firstChild;
	}
	if (typeof(window.addEventListener) == "function") {
		fr.onload = null;
		try { fr.contentWindow.document.body.removeEventListener("mousedown", this._doOnFrameMouseDown, false); } catch(e) {/* console.log("error: url detach mousedown event fail"); */};
	} else {
		fr.onreadystatechange = null;
		try { fr.contentWindow.document.body.detachEvent("onmousedown", this._doOnFrameMouseDown); } catch(e) { };
	}
	fr = null;
};




dhtmlXCellObject.prototype._attachObject = function(obj, type, htmlString, append, node) {
	
	if (typeof(obj) == "string" && {menu:1,toolbar:1,ribbon:1,sb:1}[obj] == 1) {
		return this["_createNode_"+obj].apply(this, arguments);
	}
	
	if (append != true) this._detachObject(null, true, null);
	
	if (typeof(htmlString) == "string") {
		this.cell.childNodes[this.conf.idx.cont].innerHTML = htmlString;
	} else {
		this.cell.childNodes[this.conf.idx.cont].appendChild(obj);
	}
	
	obj = null;
};
	
dhtmlXCellObject.prototype._detachObject = function(obj, remove, moveTo) {
	
	this.callEvent("_onBeforeContentDetach",[]);
	
	if (obj == "menu" || obj == "toolbar" || obj == "ribbon" || obj == "sb") {
		
		var p = this.cell.childNodes[this.conf.idx[obj]];
		p.parentNode.removeChild(p);
		p = null;
		
		this.conf.ofs_nodes[obj=="sb"?"b":"t"][obj] = false;
		
		this._updateIdx();
		if (!this.conf.unloading) this._adjustCont(this._idd);
		
		return;
	}
	
	if (remove == true) {
		moveTo = false;
	} else {
		if (typeof(moveTo) == "undefined") {
			moveTo = document.body;
		} else {
			if (typeof(moveTo) == "string") moveTo = document.getElementById(moveTo);
		}
	}
	
	// clear obj
	if (moveTo === false) {
		// cancel ajax-request if unloading
		if (this.conf.unloading == true && String(this.dataType).match(/ajax/) != null) {
			if (this.conf.url_data != null && this.conf.url_data.xml_doc != null) {
				try {this.conf.url_data.xml_doc.xmlDoc.abort();}catch(e){};
				this.conf.url_data.xml_doc.xmlDoc = null;
				this.conf.url_data.xml_doc = null;
			}
		}
		//
		if (this.dataType == "url") {
			this._detachURLEvents();
		} else if (this.dataObj != null) {
			if (typeof(this.dataObj.unload) == "function") {
				this.dataObj.unload();
			} else if (typeof(this.dataObj.destructor) == "function") {
				this.dataObj.destructor(); // at least for grid
			}
		}
	}
	
	// clear cell cont
	var p = this.cell.childNodes[this.conf.idx.cont];
	while (p.childNodes.length > 0) {
		if (moveTo === false) {
			p.removeChild(p.lastChild);
		} else {
			p.firstChild.style.display = "none"; // replace with/add - visibility:hidden?
			moveTo.appendChild(p.firstChild);
		}
	}
	
	if (this.conf.append_mode) {
		p.style.overflow = "";
		this.conf.append_mode = false;
	}
	
	var resetHdrBrd = (this.dataType == "tabbar");
	
	this.dataObj = null;
	this.dataType = null;
	
	moveTo = p = null;
	
	if (this.conf.unloading != true && resetHdrBrd) {
		this.showHeader(true);
		this._showBorders();
	}
	
};

// for dock/undock
dhtmlXCellObject.prototype._attachFromCell = function(cell) {
	
	// clear existing
	this.detachObject(true);
	
	var mode = "layout";
	if (typeof(window.dhtmlXWindowsCell) == "function" && this instanceof window.dhtmlXWindowsCell) {
		mode = "window";
	}
	
	// check opacity:
	// 1) detach from window cell, opacity set to 0.4
	if (typeof(window.dhtmlXWindowsCell) == "function" && cell instanceof window.dhtmlXWindowsCell && cell.wins.w[cell._idd].conf.parked == true) {
		cell.wins._winCellSetOpacity(cell._idd, "open", false);
	}
	// 2) acc-cell collapsed
	if (typeof(window.dhtmlXAccordionCell) == "function" && cell instanceof window.dhtmlXAccordionCell && cell.conf.opened == false) {
		cell._cellSetOpacity("open", false);
	}
	
	// menu, toolbar, status
	for (var a in cell.dataNodes) {
		
		this._attachObject(a, null, null, null, cell.cell.childNodes[cell.conf.idx[a]]);
		this.dataNodes[a] = cell.dataNodes[a];
		
		cell.dataNodes[a] = null;
		cell.conf.ofs_nodes[a=="sb"?"b":"t"][a] = false;
		cell._updateIdx();
		
	}
	
	this._mtbUpdBorder();
	
	if (cell.dataType != null && cell.dataObj != null) {
		this.dataType = cell.dataType;
		this.dataObj = cell.dataObj;
		while (cell.cell.childNodes[cell.conf.idx.cont].childNodes.length > 0) {
			this.cell.childNodes[this.conf.idx.cont].appendChild(cell.cell.childNodes[cell.conf.idx.cont].firstChild);
		}
		cell.dataType = null;
		cell.dataObj = null;
		
		// fixes
		if (this.dataType == "grid") {
			if (mode == "window" && this.conf.skin == "dhx_skyblue") {
				this.dataObj.entBox.style.border = "1px solid #a4bed4";
				this.dataObj._sizeFix = 0;
			} else {
				this.dataObj.entBox.style.border = "0px solid white";
				this.dataObj._sizeFix = 2;
			}
		}
	} else {
		// for attached urls and objects simple move them
		while (cell.cell.childNodes[cell.conf.idx.cont].childNodes.length > 0) {
			this.cell.childNodes[this.conf.idx.cont].appendChild(cell.cell.childNodes[cell.conf.idx.cont].firstChild);
		}
	}
	
	this.conf.view = cell.conf.view;
	cell.conf.view = "def";
	for (var a in cell.views) {
		this.views[a] = cell.views[a];
		cell.views[a] = null;
		delete cell.views[a];
	}
	
	cell._updateIdx();
	cell._adjustCont();
	
	this._updateIdx();
	this._adjustCont();
	
	// save progress state
	if (cell.conf.progress == true) {
		cell.progressOff();
		this.progressOn();
	} else {
		this.progressOff();
	}
	
	// check opacity, set opacity to 0.4
	// 1) attach to window cell, window parked
	if (mode == "window" && this.wins.w[this._idd].conf.parked) {
		this.wins._winCellSetOpacity(this._idd, "close", false);
	}
	
};

/*

 +--------------------------------------------------------+
 |  base                                                  |
 |                                                        |
 |   +-----------------------------------------------+    |
 |   |  header                                       |    |
 |   +-----------------------------------------------+    |
 |                                                        |
 |   +-----------------------------------------------+    |
 |   |  mtb                                          |    |
 |   +-----------------------------------------------+    |
 |                                                        |
 |   +-----------------------------------------------+    |
 |   |  cont                                         |    |
 |   |                                               |    |
 |   |                                               |    |
 |   +-----------------------------------------------+    |
 |                                                        |
 |   +-----------------------------------------------+    |
 |   |  sb                                           |    |
 |   +-----------------------------------------------+    |
 |                                                        |
 |   +-----------------------------------------------+    |
 |   |  footer                                       |    |
 |   +-----------------------------------------------+    |
 |                                                        |
 +--------------------------------------------------------+
 
*/

function dhtmlXCellTop(base, offsets) {
	
	if (arguments.length == 0 || typeof(base) == "undefined") return;
	
	var that = this;
	
	this.dataNodes = {}; // menu/toolbar/ribbon/sb/hdr/ftr
	
	this.conf.ofs = {t:0, b:0, l:0, r:0}; // base outer offset (fullscreen margins)
	this.conf.ofs_nodes = {t:{}, b:{}}; // attached menu/toolbar/sb/hdr/ftr
	this.conf.progress = false;
	
	this.conf.fs_mode = false; // fullscreen mode
	this.conf.fs_tm = null; // fullscreen resize timeout
	this.conf.fs_resize = false; // fullscreen resize
	
	if (base == document.body) {
		
		this.conf.fs_mode = true;
		
		// fullscreen init
		this.base = base;
		
		// custom offset for body
		if (this.base == document.body) {
			var ofsDef = {
				dhx_skyblue: {t: 2, b: 2, l: 2, r: 2},
				dhx_web:     {t: 8, b: 8, l: 8, r: 8},
				dhx_terrace: {t: 9, b: 9, l: 8, r: 8},
				material:    {t: 9, b: 9, l: 8, r: 8}
			};
			this.conf.ofs = (ofsDef[this.conf.skin] != null ? ofsDef[this.conf.skin] : ofsDef.dhx_skyblue);
		}
		
	} else {
		this.base = (typeof(base)=="string"?document.getElementById(base):base);
	}
	
	this.base.className += " "+this.conf.css+"_base_"+this.conf.skin;
	
	this.cont = document.createElement("DIV");
	this.cont.className = this.conf.css+"_cont";
	this.base.appendChild(this.cont);
	
	// conf-offsets override (attachObject usualy)
	if (offsets != null) {
		this.setOffsets(offsets, false);
	} else if (this.base._ofs != null) {
		this.setOffsets(this.base._ofs, false);
		this.base._ofs = null;
		try {delete this.base._ofs;}catch(e){}; // IE6/IE7 fix
	}
	
	this._adjustCont = function() {
		
		var ofsYT = this.conf.ofs.t;
		for (var a in this.conf.ofs_nodes.t) ofsYT += (this.conf.ofs_nodes.t[a]==true ? this.dataNodes[a].offsetHeight:0);
		
		var ofsYB = this.conf.ofs.b;
		for (var a in this.conf.ofs_nodes.b) ofsYB += (this.conf.ofs_nodes.b[a]==true ? this.dataNodes[a].offsetHeight:0);
		
		this.cont.style.left = this.conf.ofs.l + "px";
		this.cont.style.width = this.base.clientWidth - this.conf.ofs.l - this.conf.ofs.r + "px";
		
		this.cont.style.top = ofsYT + "px";
		this.cont.style.height = this.base.clientHeight - ofsYT - ofsYB + "px";
		
	}
	
	this._setBaseSkin = function(skin) {
		this.base.className = this.base.className.replace(new RegExp(this.conf.css+"_base_"+this.conf.skin,"gi"), this.conf.css+"_base_"+skin);
	}
	
	this._initFSResize = function() {
		
		if (this.conf.fs_resize == true) return; // already inited
		
		this._doOnResizeStart = function() {
			window.clearTimeout(that.conf.fs_tm);
			that.conf.fs_tm = window.setTimeout(that._doOnResizeEnd, 200);
		}
		
		this._doOnResizeEnd = function() {
			that.setSizes();
		}
		
		if (typeof(window.addEventListener) == "function") {
			window.addEventListener("resize", this._doOnResizeStart, false);
		} else {
			window.attachEvent("onresize", this._doOnResizeStart);
		}
		
		this.conf.fs_resize = true;
	}
	
	// resize events
	if (this.conf.fs_mode == true) this._initFSResize();
	
	this._unloadTop = function() {
		
		this._mtbUnload();
		this.detachHeader();
		this.detachFooter();
		
		if (this.conf.fs_mode == true) {
			if (typeof(window.addEventListener) == "function") {
				window.removeEventListener("resize", this._doOnResizeStart, false);
			} else {
				window.detachEvent("onresize", this._doOnResizeStart);
			}
		}
		
		this.base.removeChild(this.cont);
		var r = new RegExp("\s{0,}"+this.conf.css+"_base_"+this.conf.skin, "gi");
		this.base.className = this.base.className.replace(r, "");
		this.cont = this.base = null;
		
		that = null;
	}
	
	base = null;
};

// outer offsets
dhtmlXCellTop.prototype.setOffsets = function(data, upd) { // set 'upd' to false to prevent adjusting (useful on init stage)
	var t = false;
	for (var a in data) {
		var k = a.charAt(0);
		if (typeof(this.conf.ofs[k]) != "undefined" && !isNaN(data[a])) {
			this.conf.ofs[k] = parseInt(data[a]);
			t = true;
		}
	}
	if (upd !== false && typeof(this.setSizes) == "function" && t == true) this.setSizes();
};


// top-level menu/toolbar/ribbon/status

// menu
dhtmlXCellTop.prototype.attachMenu = function(conf) {
	
	if (this.dataNodes.menu != null) return;
	
	this.dataNodes.menuObj = document.createElement("DIV");
	this.dataNodes.menuObj.className = "dhxcelltop_menu";
	
	this.base.insertBefore(this.dataNodes.menuObj, this.dataNodes.toolbarObj||this.dataNodes.ribbonObj||this.cont);
	
	if (typeof(conf) != "object" || conf == null) conf = {};
	conf.skin = this.conf.skin;
	conf.parent = this.dataNodes.menuObj;
	
	this.dataNodes.menu = new dhtmlXMenuObject(conf);
	
	this.dataNodes.menuEv = this.attachEvent("_onSetSizes", function(){
		if (this.dataNodes.menuObj.style.display == "none") return;
		if (this.conf.ofs_menu == null) {
			this.dataNodes.menuObj.style.width = this.base.offsetWidth-this.conf.ofs.l-this.conf.ofs.r+"px";
			this.conf.ofs_menu = {w: this.dataNodes.menuObj.offsetWidth-parseInt(this.dataNodes.menuObj.style.width)};
		}
		this.dataNodes.menuObj.style.left = this.conf.ofs.l+"px";
		this.dataNodes.menuObj.style.marginTop = (this.dataNodes.haObj!=null?0:this.conf.ofs.t)+"px";
		this.dataNodes.menuObj.style.width = this.base.offsetWidth-this.conf.ofs.l-this.conf.ofs.r-this.conf.ofs_menu.w+"px";
		
	});
	
	this.conf.ofs_nodes.t.menuObj = true;
	
	this.setSizes();
	
	conf.parnt = null;
	conf = null;
	
	return this.dataNodes.menu;
};

dhtmlXCellTop.prototype.detachMenu = function() {
	
	if (this.dataNodes.menu == null) return;
	
	this.dataNodes.menu.unload();
	this.dataNodes.menu = null;
	
	this.dataNodes.menuObj.parentNode.removeChild(this.dataNodes.menuObj);
	this.dataNodes.menuObj = null;
	
	this.detachEvent(this.dataNodes.menuEv);
	this.dataNodes.menuEv = null;
	
	delete this.dataNodes.menu;
	delete this.dataNodes.menuObj;
	delete this.dataNodes.menuEv;
	
	this.conf.ofs_nodes.t.menuObj = false;
	
	if (!this.conf.unloading) this.setSizes();
};

// toolbar
dhtmlXCellTop.prototype.attachToolbar = function(conf) {
	
	if (!(this.dataNodes.ribbon == null && this.dataNodes.toolbar == null)) return;
	
	this.dataNodes.toolbarObj = document.createElement("DIV");
	this.dataNodes.toolbarObj.className = "dhxcelltop_toolbar";
	this.base.insertBefore(this.dataNodes.toolbarObj, this.cont);
	this.dataNodes.toolbarObj.appendChild(document.createElement("DIV"));
	
	if (typeof(conf) != "object" || conf == null) conf = {};
	conf.skin = this.conf.skin;
	conf.parent = this.dataNodes.toolbarObj.firstChild;
	
	this.dataNodes.toolbar = new dhtmlXToolbarObject(conf);
	
	this.dataNodes.toolbarEv = this.attachEvent("_onSetSizes", function() {
		if (this.dataNodes.toolbarObj.style.display == "none") return;
		this.dataNodes.toolbarObj.style.left = this.conf.ofs.l+"px";
		this.dataNodes.toolbarObj.style.marginTop = (this.dataNodes.haObj!=null||this.dataNodes.menuObj!=null?0:this.conf.ofs.t)+"px";
		this.dataNodes.toolbarObj.style.width = this.base.offsetWidth-this.conf.ofs.l-this.conf.ofs.r+"px";
	});
	
	this.dataNodes.toolbar._masterCell = this;
	this.dataNodes.toolbar.attachEvent("_onIconSizeChange", function(){
		this._masterCell.setSizes();
	});
	
	this.conf.ofs_nodes.t.toolbarObj = true;
	
	this.setSizes();
	
	conf.parnt = null;
	conf = null;
	
	return this.dataNodes.toolbar;
};

dhtmlXCellTop.prototype.detachToolbar = function() {
	
	if (this.dataNodes.toolbar == null) return;
	
	this.dataNodes.toolbar._masterCell = null; // link to this
	this.dataNodes.toolbar.unload();
	this.dataNodes.toolbar = null;
	
	this.dataNodes.toolbarObj.parentNode.removeChild(this.dataNodes.toolbarObj);
	this.dataNodes.toolbarObj = null;
	
	this.detachEvent(this.dataNodes.toolbarEv);
	this.dataNodes.toolbarEv = null;
	
	this.conf.ofs_nodes.t.toolbarObj = false;
	
	delete this.dataNodes.toolbar;
	delete this.dataNodes.toolbarObj;
	delete this.dataNodes.toolbarEv;
	
	if (!this.conf.unloading) this.setSizes();
};

// ribbon
dhtmlXCellTop.prototype.attachRibbon = function(conf) {
	
	if (!(this.dataNodes.ribbon == null && this.dataNodes.toolbar == null)) return;
	
	this.dataNodes.ribbonObj = document.createElement("DIV");
	this.dataNodes.ribbonObj.className = "dhxcelltop_ribbon";
	this.base.insertBefore(this.dataNodes.ribbonObj, this.cont);
	this.dataNodes.ribbonObj.appendChild(document.createElement("DIV"));
	
	if (typeof(conf) != "object" || conf == null) conf = {};
	conf.skin = this.conf.skin;
	conf.parent = this.dataNodes.ribbonObj.firstChild;
	
	this.dataNodes.ribbon = new dhtmlXRibbon(conf);
	
	this.dataNodes.ribbonEv = this.attachEvent("_onSetSizes", function() {
		if (this.dataNodes.ribbonObj.style.display == "none") return;
		this.dataNodes.ribbonObj.style.left = this.conf.ofs.l+"px";
		this.dataNodes.ribbonObj.style.marginTop = (this.dataNodes.haObj!=null||this.dataNodes.menuObj!=null?0:this.conf.ofs.t)+"px";
		this.dataNodes.ribbonObj.style.width = this.base.offsetWidth-this.conf.ofs.l-this.conf.ofs.r+"px";
		this.dataNodes.ribbon.setSizes();
	});
	
	this.conf.ofs_nodes.t.ribbonObj = true;
	
	var t = this;
	this.dataNodes.ribbon.attachEvent("_onHeightChanged", function(){
		t.setSizes();
	});
	
	this.setSizes();
	
	conf.parnt = null;
	conf = null;
	
	return this.dataNodes.ribbon;
};

dhtmlXCellTop.prototype.detachRibbon = function() {
	
	if (this.dataNodes.ribbon == null) return;
	
	this.dataNodes.ribbon.unload();
	this.dataNodes.ribbon = null;
	
	this.dataNodes.ribbonObj.parentNode.removeChild(this.dataNodes.ribbonObj);
	this.dataNodes.ribbonObj = null;
	
	this.detachEvent(this.dataNodes.ribbonEv);
	this.dataNodes.ribbonEv = null;
	
	this.conf.ofs_nodes.t.ribbonObj = false;
	
	delete this.dataNodes.ribbon;
	delete this.dataNodes.ribbonObj;
	delete this.dataNodes.ribbonEv;
	
	if (!this.conf.unloading) this.setSizes();
};


// status
dhtmlXCellTop.prototype.attachStatusBar = function(conf) { // arg-optional, new in version
	
	if (this.dataNodes.sbObj) return;
	
	if (typeof(conf) == "undefined") conf = {};
	
	this.dataNodes.sbObj = document.createElement("DIV");
	this.dataNodes.sbObj.className = "dhxcelltop_statusbar";
	
	if (this.cont.nextSibling != null) {
		this.base.insertBefore(this.dataNodes.sbObj, this.cont.nextSibling);
	} else {
		this.base.appendChild(this.dataNodes.sbObj);
	}
	
	this.dataNodes.sbObj.innerHTML = "<div class='dhxcont_statusbar'>"+(typeof(conf.text)=="string" && conf.text.length > 0 ? conf.text:"&nbsp;")+"</div>";
	if (typeof(conf.height) == "number") this.dataNodes.sbObj.firstChild.style.height = this.dataNodes.sbObj.firstChild.style.lineHeight = conf.height+"px";
	
	this.dataNodes.sbObj.setText = function(text) { this.childNodes[0].innerHTML = text; }
	this.dataNodes.sbObj.getText = function() { return this.childNodes[0].innerHTML; }
	this.dataNodes.sbObj.onselectstart = function(e) { return false; }
	
	
	this.dataNodes.sbEv = this.attachEvent("_onSetSizes", function(){
		if (this.dataNodes.sbObj.style.display == "none") return;
		this.dataNodes.sbObj.style.left = this.conf.ofs.l+"px";
		this.dataNodes.sbObj.style.bottom = (this.dataNodes.faObj != null?this.dataNodes.faObj.offsetHeight:0)+this.conf.ofs.t+"px";
		this.dataNodes.sbObj.style.width = this.base.offsetWidth-this.conf.ofs.l-this.conf.ofs.r+"px";
	});
	
	this.conf.ofs_nodes.b.sbObj = true;
	
	this.setSizes();
	
	return this.dataNodes.sbObj;
	
};

dhtmlXCellTop.prototype.detachStatusBar = function() {
	
	if (!this.dataNodes.sbObj) return;
	
	this.dataNodes.sbObj.setText = this.dataNodes.sbObj.getText = this.dataNodes.sbObj.onselectstart = null;
	this.dataNodes.sbObj.parentNode.removeChild(this.dataNodes.sbObj);
	this.dataNodes.sbObj = null;
	
	this.detachEvent(this.dataNodes.sbEv);
	this.dataNodes.sbEv = null;
	
	this.conf.ofs_nodes.b.sbObj = false;
	
	delete this.dataNodes.sb;
	delete this.dataNodes.sbObj;
	delete this.dataNodes.sbEv;
	
	if (!this.conf.unloading) this.setSizes();
	
};

// show/hide
dhtmlXCellTop.prototype.showMenu = function() {
	this._mtbShowHide("menuObj", "");
};

dhtmlXCellTop.prototype.hideMenu = function() {
	this._mtbShowHide("menuObj", "none");
};

dhtmlXCellTop.prototype.showToolbar = function(){
	this._mtbShowHide("toolbarObj", "");
};

dhtmlXCellTop.prototype.hideToolbar = function(){
	this._mtbShowHide("toolbarObj", "none");
};

dhtmlXCellTop.prototype.showRibbon = function(){
	this._mtbShowHide("ribbonObj", "");
};

dhtmlXCellTop.prototype.hideRibbon = function(){
	this._mtbShowHide("ribbonObj", "none");
};

dhtmlXCellTop.prototype.showStatusBar = function() {
	this._mtbShowHide("sbObj", "");
};

dhtmlXCellTop.prototype.hideStatusBar = function(){
	this._mtbShowHide("sbObj", "none");
};

dhtmlXCellTop.prototype._mtbShowHide = function(name, disp) {
	if (this.dataNodes[name] == null) return;
	this.dataNodes[name].style.display = disp;
	this.setSizes();
};

dhtmlXCellTop.prototype._mtbUnload = function(name, disp) {
	this.detachMenu();
	this.detachToolbar();
	this.detachStatusBar();
	this.detachRibbon();
};

// getters
dhtmlXCellTop.prototype.getAttachedMenu = function() {
	return this.dataNodes.menu;
};
dhtmlXCellTop.prototype.getAttachedToolbar = function() {
	return this.dataNodes.toolbar;
};
dhtmlXCellTop.prototype.getAttachedRibbon = function() {
	return this.dataNodes.ribbon;
};
dhtmlXCellTop.prototype.getAttachedStatusBar = function() {
	return this.dataNodes.sbObj;
};

// top-level progress
dhtmlXCellTop.prototype.progressOn = function() {
	
	if (this.conf.progress) return;
	
	this.conf.progress = true;
	
	var t1 = document.createElement("DIV");
	t1.className = "dhxcelltop_progress";
	this.base.appendChild(t1);
	
	var t2 = document.createElement("DIV");
	if (this.conf.skin == "material" && (window.dhx4.isFF || window.dhx4.isChrome || window.dhx4.isOpera || window.dhx4.isEdge)) {
		t2.className = "dhxcelltop_progress_svg";
		t2.innerHTML = '<svg class="dhx_cell_prsvg" viewBox="25 25 50 50"><circle class="dhx_cell_prcircle" cx="50" cy="50" r="20"/></svg>';
	} else {
		var t2 = document.createElement("DIV");
		t2.className = "dhxcelltop_progress_img";
	}
	this.base.appendChild(t2);
	
	t1 = t2 = null;
	
};

dhtmlXCellTop.prototype.progressOff = function() {
	
	if (!this.conf.progress) return;
	
	var p = {dhxcelltop_progress: true, dhxcelltop_progress_img: true, dhxcelltop_progress_svg: true};
	for (var q=0; q<this.base.childNodes.length; q++) {
		if (typeof(this.base.childNodes[q].className) != "undefined" && p[this.base.childNodes[q].className] == true) {
			p[this.base.childNodes[q].className] = this.base.childNodes[q];
		}
	}
	
	for (var a in p) {
		if (p[a] != true) this.base.removeChild(p[a]);
		p[a] = null;
	}
	
	this.conf.progress = false;
	p = null;
	
};

// fullscreen header-footer

// top margin (2px for skyblue) for fullscreen will always adjusted automatcaly
// bottom margin - can be generated by user-content, write in documentstion
// same for footer

dhtmlXCellTop.prototype.attachHeader = function(obj, height) {

	if (this.dataNodes.haObj != null) return; // already attached
	
	if (typeof(obj) != "object") obj = document.getElementById(obj);
	
	this.dataNodes.haObj = document.createElement("DIV");
	this.dataNodes.haObj.className = "dhxcelltop_hdr";
	this.dataNodes.haObj.style.height = (height||obj.offsetHeight)+"px";
	
	this.base.insertBefore(this.dataNodes.haObj, this.dataNodes.menuObj||this.dataNodes.toolbarObj||this.cont);
	
	this.dataNodes.haObj.appendChild(obj);
	obj.style.visibility = "visible";
	obj = null;
	
	this.dataNodes.haEv = this.attachEvent("_onSetSizes", function(){
		this.dataNodes.haObj.style.left = this.conf.ofs.l+"px";
		this.dataNodes.haObj.style.marginTop = this.conf.ofs.t+"px";
		this.dataNodes.haObj.style.width = this.base.offsetWidth-this.conf.ofs.l-this.conf.ofs.r+"px";
	});
	
	this.conf.ofs_nodes.t.haObj = true;
	
	this.setSizes();
	
};

dhtmlXCellTop.prototype.detachHeader = function() {
	
	if (!this.dataNodes.haObj) return;
	
	while (this.dataNodes.haObj.childNodes.length > 0) {
		this.dataNodes.haObj.lastChild.style.visibility = "hidden";
		document.body.appendChild(this.dataNodes.haObj.lastChild);
	}
	this.dataNodes.haObj.parentNode.removeChild(this.dataNodes.haObj);
	this.dataNodes.haObj = null;
	
	this.detachEvent(this.dataNodes.haEv);
	this.dataNodes.haEv = null;
	
	this.conf.ofs_nodes.t.haObj = false;
	
	delete this.dataNodes.haEv;
	delete this.dataNodes.haObj;
	
	if (!this.conf.unloading) this.setSizes();

};

dhtmlXCellTop.prototype.attachFooter = function(obj, height) {
	
	if (this.dataNodes.faObj != null) return;
	
	if (typeof(obj) != "object") obj = document.getElementById(obj);
	
	this.dataNodes.faObj = document.createElement("DIV");
	this.dataNodes.faObj.className = "dhxcelltop_ftr";
	this.dataNodes.faObj.style.height = (height||obj.offsetHeight)+"px";
	
	var p = (this.dataNodes.sbObj||this.cont);
	if (this.base.lastChild == p) {
		this.base.appendChild(this.dataNodes.faObj);
	} else {
		this.base.insertBefore(this.dataNodes.faObj, p.nextSibling);
	}
	
	this.dataNodes.faEv = this.attachEvent("_onSetSizes", function(){
		this.dataNodes.faObj.style.left = this.conf.ofs.l+"px";
		this.dataNodes.faObj.style.bottom = this.conf.ofs.b+"px";
		this.dataNodes.faObj.style.width = this.base.offsetWidth-this.conf.ofs.l-this.conf.ofs.r+"px";
	});
	
	this.dataNodes.faObj.appendChild(obj);
	obj.style.visibility = "visible";
	p = obj = null;
	
	this.conf.ofs_nodes.b.faObj = true;
	
	this.setSizes();
	
};

dhtmlXCellTop.prototype.detachFooter = function() {
	
	if (!this.dataNodes.faObj) return;
	
	while (this.dataNodes.faObj.childNodes.length > 0) {
		this.dataNodes.faObj.lastChild.style.visibility = "hidden";
		document.body.appendChild(this.dataNodes.faObj.lastChild);
	}
	this.dataNodes.faObj.parentNode.removeChild(this.dataNodes.faObj);
	this.dataNodes.faObj = null;
	
	this.detachEvent(this.dataNodes.faEv);
	this.dataNodes.faEv = null;
	
	this.conf.ofs_nodes.b.faObj = false;
	
	delete this.dataNodes.faEv;
	delete this.dataNodes.faObj;
	
	if (!this.conf.unloading) this.setSizes();
	
};


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXCalendarObject(inps, skin) {
	
	// parse inputs
	this.i = {};
	
	var p = null;
	if (typeof(inps) == "string") {
		var t0 = document.getElementById(inps);
	} else {
		var t0 = inps;
	}
	if (t0 && typeof(t0) == "object" && t0.tagName && String(t0.tagName).toLowerCase() != "input") p = t0;
	t0 = null;
	
	// single param
	if (typeof(inps) != "object" || !inps.length) inps = [inps];
	for (var q=0; q<inps.length; q++) {
		if (typeof(inps[q]) == "string") inps[q] = (document.getElementById(inps[q])||null);
		if (inps[q] != null && inps[q].tagName && String(inps[q].tagName).toLowerCase() == "input") {
			this.i[window.dhx4.newId()] = {input: inps[q]};
		} else {
			if (!(inps[q] instanceof Array) && inps[q] instanceof Object && (inps[q].input != null || inps[q].button != null)) {
				if (inps[q].input != null && typeof(inps[q].input) == "string") inps[q].input = document.getElementById(inps[q].input);
				if (inps[q].button != null && typeof(inps[q].button) == "string") inps[q].button = document.getElementById(inps[q].button);
				this.i[window.dhx4.newId()] = inps[q];
			}
		}
		inps[q] = null;
	}
	
	this.conf = {
		skin: (skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhtmlxcalendar")||"material"),
		zi: window.dhx4.newId(),
		touch: !window.dhx4.isIE,
		time: true,
		today: false,
		ws_first: true // false => start year from 52/53 wekk number (if 1st jan belongs to 1st week)
	}
	
	this.setSkin = function(skin, force) {
		if (this.conf.skin == skin && !force) return;
		this.conf.skin = skin;
		this.base.className = "dhtmlxcalendar_"+this.conf.skin;
		this._ifrSize();
	}
	
	// create base
	this.base = document.createElement("DIV");
	this.base.style.display = "none";
	this.base.appendChild(document.createElement("DIV"));
	
	if (p != null) {
		this._hasParent = true;
		p.appendChild(this.base);
		p = null;
	} else { 
		document.body.appendChild(this.base);
	}
	
	this.setParent = function(p) {
		if (this._hasParent) {
			if (typeof(p) == "object") {
				p.appendChild(this.base);
			} else if (typeof(p) == "string") {
				document.getElementById(p).appendChild(this.base);
			}
		}
	}
	
	this.setSkin(this.conf.skin, true);
	
	this.base.onclick = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault();
		e.cancelBubble = true;
	}
	this.base.onmousedown = function() {
		return false;
	}
	
	if (this.conf.touch) {
		this.base.ontouchstart = this.base.onclick;
	}
	
	this.loadUserLanguage = function(lang) {
		if (!this.langData[lang]) return;
		this.lang = lang;
		this.setWeekStartDay(this.langData[this.lang].weekstart);
		this.setDateFormat(this.langData[this.lang].dateformat||"%Y-%m-%d");
		// month selector
		if (this.msCont) {
			var e = 0;
			for (var q=0; q<this.msCont.childNodes.length; q++) {
				for (var w=0; w<this.msCont.childNodes[q].childNodes.length; w++) {
					this.msCont.childNodes[q].childNodes[w].innerHTML = this.langData[this.lang].monthesSNames[e++];
				}
			}
		}
		// today/clear
		this.contTime.childNodes[0].childNodes[0].childNodes[5].innerHTML = this.langData[this.lang].today;
		this.contTime.childNodes[0].childNodes[0].childNodes[4].innerHTML = this.langData[this.lang].clear;
	}
	
	// build month and year header
	this.contMonth = document.createElement("DIV");
	this.contMonth.className = "dhtmlxcalendar_month_cont";
	this.contMonth.onselectstart = function(e){
		e = e||event;
		e.cancelBubble = true;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		return false;
	}
	this.base.firstChild.appendChild(this.contMonth);
	
	var ul = document.createElement("UL");
	ul.className = "dhtmlxcalendar_line";
	this.contMonth.appendChild(ul);
	
	var li = document.createElement("LI");
	li.className = "dhtmlxcalendar_cell dhtmlxcalendar_month_hdr";
	li.innerHTML = "<div class='dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_left' onmouseover='this.className=\"dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_left_hover\";' onmouseout='this.className=\"dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_left\";'></div>"+
			"<span></span>"+ // hdrformat will here
			"<div class='dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_right' onmouseover='this.className=\"dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_right_hover\";' onmouseout='this.className=\"dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_right\";'></div>";
	ul.appendChild(li);
	
	var that = this;
	
	li.onclick = function(e) {
		
		e = e||event;
		if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
		
		var t = (e.target||e.srcElement);
		// change month by clicking left-right arrows
		if (t.className && t.className.indexOf("dhtmlxcalendar_month_arrow") === 0) {
			that._hideSelector();
			var ind = (t.parentNode.firstChild==t?-1:1);
			var k0 = new Date(that._activeMonth);
			that._drawMonth(new Date(that._activeMonth.getFullYear(), that._activeMonth.getMonth()+ind, 1, 0, 0, 0, 0));
			that._evOnArrowClick([k0, new Date(that._activeMonth)]);
			return;
		}
		// show month selector
		if (t.className && t.className == "dhtmlxcalendar_month_label_month") {
			e.cancelBubble = true;
			that._showSelector("month", Math.round(t.offsetLeft+t.offsetWidth/2), t.offsetTop+t.offsetHeight+2, "selector_month", true);
			return;
		}
		// show year selector
		if (t.className && t.className == "dhtmlxcalendar_month_label_year") {
			e.cancelBubble = true;
			that._showSelector("year", Math.round(t.offsetLeft+t.offsetWidth/2), t.offsetTop+t.offsetHeight+2, "selector_year", true);
			return;
		}
		// hide selector if it visible
		that._hideSelector();
	}
	if (this.conf.touch == true) {
		li.ontouchstart = li.onclick;
	}
	
	// build days names
	this.contDays = document.createElement("DIV");
	this.contDays.className = "dhtmlxcalendar_days_cont";
	this.base.firstChild.appendChild(this.contDays);
	
	this.setWeekStartDay = function(ind) {
		// 1..7 = Mo-Su, also 0 = Su
		if (ind == 0) ind = 7;
		this._wStart = Math.min(Math.max((isNaN(ind)?1:ind),1),7);
		this._drawDaysOfWeek();
	}
	
	this._drawDaysOfWeek = function() {
		if (this.contDays.childNodes.length == 0) {
			var ul = document.createElement("UL");
			ul.className = "dhtmlxcalendar_line";
			this.contDays.appendChild(ul);
		} else {
			var ul = this.contDays.firstChild;
		}
		
		var w = this._wStart;
		var k = this.langData[this.lang].daysSNames;
		k.push(String(this.langData[this.lang].daysSNames[0]).valueOf());
		
		for (var q=0; q<8; q++) {
			if (ul.childNodes[q] == null) {
				var li = document.createElement("LI");
				ul.appendChild(li);
			} else {
				var li = ul.childNodes[q];
			}
			if (q == 0) {
				li.className = "dhtmlxcalendar_cell_wn";
				li.innerHTML = "<div class='dhtmlxcalendar_label'>"+(this.langData[this.lang].weekname||"w")+"</div>";
			} else {
				li.className = "dhtmlxcalendar_cell"+(w>=6?" dhtmlxcalendar_day_weekday_cell":"")+(q==1?"_first":"");
				li.innerHTML = k[w];
				if (++w > 7) w = 1;
			}
		}
		if (this._activeMonth != null) this._drawMonth(this._activeMonth);
	}
	
	this._wStart = this.langData[this.lang].weekstart;
	this.setWeekStartDay(this._wStart);
	
	// dates container
	this.contDates = document.createElement("DIV");
	this.contDates.className = "dhtmlxcalendar_dates_cont";
	this.base.firstChild.appendChild(this.contDates);
	
	this.contDates.onclick = function(e){
		
		e = e||event;
		if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
		
		var t = (e.target||e.srcElement);
		
		if (t.parentNode != null && t.parentNode._date != null) t = t.parentNode;
		if (t._date != null && !t._css_dis) {
			
			var t1 = that._activeDate.getHours();
			var t2 = that._activeDate.getMinutes();
			var d0 = t._date;
			
			// cjeck if allow to modify input
			if (that.checkEvent("onBeforeChange")) {
				if (!that.callEvent("onBeforeChange",[new Date(t._date.getFullYear(),t._date.getMonth(),t._date.getDate(),t1,t2)])) return;
			}
			
			if (that._activeDateCell != null) {
				that._activeDateCell._css_date = false;
				that._updateCellStyle(that._activeDateCell._q, that._activeDateCell._w);
			}
			
			// update month if day from prev/next month clicked
			var refreshView = (that._activeDate.getFullYear()+"_"+that._activeDate.getMonth() != d0.getFullYear()+"_"+d0.getMonth());
			
			that._nullDate = false;
			that._activeDate = new Date(d0.getFullYear(),d0.getMonth(),d0.getDate(),t1,t2);
			
			that._activeDateCell = t;
			that._activeDateCell._css_date = true;
			that._activeDateCell._css_hover = false;
			that._updateCellStyle(that._activeDateCell._q, that._activeDateCell._w);
			
			if (refreshView) that._drawMonth(that._activeDate);
			
			// update date in input if any
			that._updateInp();
			
			// hide
			if (!that._hasParent) {
				if (e.type == "touchstart") {
					window.setTimeout(function(){that._hide();},400);
				} else {
					that._hide();
				}
			}
			//
			that._evOnClick([new Date(that._activeDate.getTime())]);
			
		}
	}
	
	if (this.conf.touch == true) {
		this.contDates.ontouchstart = this.contDates.onclick;
	}
	
	this.contDates.onmouseover = function(e) {
		e = e||event;
		var t = (e.target||e.srcElement);
		if (t.parentNode != null && t.parentNode._date != null) t = t.parentNode;
		if (t._date != null) { // && t != that._activeDateCell) { // skip hover for selected date
			if (that._lastHover == t || t._css_hover) return;
			t._css_hover = true;
			that._updateCellStyle(t._q, t._w);
			that._lastHover = t;
			that._evOnMouseOver([new Date(t._date.getFullYear(),t._date.getMonth(),t._date.getDate(),0,0,0,0),e]);
			t = null;
		}
	}
	this.contDates.onmouseout = function(e) {
		that._clearDayHover(e||event);
	}
	
	this._lastHover = null;
	this._clearDayHover = function(ev) {
		if (!this._lastHover) return;
		this._lastHover._css_hover = false;
		this._updateCellStyle(this._lastHover._q, this._lastHover._w);
		if (ev != null) that._evOnMouseOut([new Date(this._lastHover._date.getFullYear(),this._lastHover._date.getMonth(),this._lastHover._date.getDate(),0,0,0,0),ev]);
		this._lastHover = null;
	}
	
	// build cells
	for (var q=0; q<6; q++) {
		var ul = document.createElement("UL");
		ul.className = "dhtmlxcalendar_line";
		this.contDates.appendChild(ul);
		for (var w=0; w<=7; w++) {
			var li = document.createElement("LI");
			if (w == 0) {
				// week number
				li.className = "dhtmlxcalendar_cell_wn";
			} else {
				li.className = "dhtmlxcalendar_cell";
			}
			ul.appendChild(li);
		}
	}
	
	
	// timepicker
	this.contTime = document.createElement("DIV");
	this.contTime.className = "dhtmlxcalendar_time_cont";
	this.contTime.style.display = "none";
	this.base.firstChild.appendChild(this.contTime);
	
	this.showTime = function() {
		if (this.conf.time != true) {
			this.conf.time = true;
			this._adjustTimeCont();
		}
	}
	
	this.hideTime = function() {
		if (this.conf.time == true) {
			this.conf.time = false;
			this._adjustTimeCont();
		}
	}
	
	this.showToday = function() {
		if (this.conf.today != true) {
			this.conf.today = true;
			this._adjustTimeCont();
		}
	}
	
	this.hideToday = function() {
		if (this.conf.today == true) {
			this.conf.today = false;
			this._adjustTimeCont();
		}
	}
	
	this._adjustTimeCont = function() {
		var css = "";
		if (this.conf.time == true) css += "_time";
		if (this.conf.today == true) css += "_today";
		if (css == "") {
			this.contTime.style.display = "none";
		} else {
			this.contTime.className = "dhtmlxcalendar_time_cont dhtmlxcalendar_mode"+css;
			this.contTime.style.display = "";
		}
		this._ifrSize();
	}
	
	this._adjustTimeCont();
	
	var ul = document.createElement("UL");
	ul.className = "dhtmlxcalendar_line";
	this.contTime.appendChild(ul);
	
	var li = document.createElement("LI");
	li.className = "dhtmlxcalendar_cell dhtmlxcalendar_time_hdr";
	li.innerHTML = "<div class='dhtmlxcalendar_time_img'></div>"+
			"<span class='dhtmlxcalendar_label_hours'></span><span class='dhtmlxcalendar_label_colon'>:</span><span class='dhtmlxcalendar_label_minutes'></span>"+
			"<span class='dhtmlxcalendar_label_clear'>"+this.langData[this.lang].clear+"</span><span class='dhtmlxcalendar_label_today'>"+this.langData[this.lang].today+"</span>"; // added in 4.6
	ul.appendChild(li);
	
	li.onclick = function(e) {
		e = e||event;
		if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
		
		var t = (e.target||e.srcElement);
		if (t.tagName != null && t.tagName.toLowerCase() == "span" && t._par == true && t.parentNode != null) {
			t = t.parentNode;
		}
		// show hours selector
		if (t.className && t.className == "dhtmlxcalendar_label_hours") {
			e.cancelBubble = true;
			var h = that.contMonth.offsetHeight+that.contDays.offsetHeight+that.contDates.offsetHeight+t.offsetTop;
			that._showSelector("hours", Math.round(t.offsetLeft+t.offsetWidth/2), h-2, "selector_hours", true);
			return;
		}
		// show minutes selector
		if (t.className && t.className == "dhtmlxcalendar_label_minutes") {
			e.cancelBubble = true;
			if (that._minutesInterval == 1) {
				var d = that.getFormatedDate("%i");
				t.innerHTML = "<span class='dhtmlxcalendar_selected_date'>"+d.charAt(0)+"</span>"+d.charAt(1);
				t.firstChild._par = true;
				that._selectorMode = 1; // select hour
			}
			var h = that.contMonth.offsetHeight+that.contDays.offsetHeight+that.contDates.offsetHeight+t.offsetTop;
			that._showSelector("minutes", Math.round(t.offsetLeft+t.offsetWidth/2), h-2, "selector_minutes",true);
			return;
		}
		// hide selector if it visible
		that._hideSelector();
		// today/clear buttons, added in 4.6
		if (t.className && t.className == "dhtmlxcalendar_label_today") {
			var d = new Date();
			d = new Date(d.getFullYear(), d.getMonth(), d.getDate(), that._activeDate.getHours(), that._activeDate.getMinutes(), that._activeDate.getSeconds(), that._activeDate.getMilliseconds());
			that.setDate(d);
			that._updateInp();
			that.callEvent("onButtonClick", [d]);
		}
		if (t.className && t.className == "dhtmlxcalendar_label_clear") {
			that._nullDate = true;
			that._drawMonth(new Date());
			that._updateInp();
			that.callEvent("onButtonClick", [null]);
		}
	}
	if (this.conf.touch == true) {
		li.ontouchstart = li.onclick;
	}
	
	this._activeMonth = null;
	
	this._activeDate = new Date();
	this._activeDateCell = null;
	
	this.setDate = function(d) {
		window.dhx4.temp_calendar = {tz:null};
		this._nullDate = (typeof(d) == "undefined" || d === "" || !d);
		
		if (!(d instanceof Date)) {
			d = this._strToDate(String(d||""));
			if (d == "Invalid Date") d = new Date(); else this.conf.tz = window.dhx4.temp_calendar.tz;
			window.dhx4.temp_calendar = null;
		}
		if (this.conf.tz == null) this.conf.tz = window.dhx4.date2str(d,"%P");
		
		var time = d.getTime();
		
		// out of range
		if (this._isOutOfRange(time)) return;
		
		this._activeDate = new Date(time);
		this._drawMonth(this._nullDate?new Date():this._activeDate);
		this._updateVisibleHours();
		this._updateVisibleMinutes();
	}
	
	this.getDate = function(formated) {
		if (this._nullDate) return null;
		var t = new Date(this._activeDate.getTime());
		if (formated) {
			window.dhx4.temp_calendar = {tz:this.conf.tz};
			var d = this._dateToStr(t);
			window.dhx4.temp_calendar = null;
			return d;
		}
		return t;
	}
	
	this._drawMonth = function(d) {
		
		if (!(d instanceof Date)) return;
		if (isNaN(d.getFullYear())) d = new Date(this._activeMonth.getFullYear(), this._activeMonth.getMonth(), 1, 0, 0, 0, 0);
		
		this._activeMonth = new Date(d.getFullYear(), d.getMonth(), 1, 0, 0, 0, 0);
		
		this._activeDateCell = null;
		
		var first = new Date(this._activeMonth.getTime());
		var d0 = first.getDay();
		
		var e0 = d0-this._wStart;
		if (e0 < 0) e0 = e0+7;
		first.setDate(first.getDate()-e0);
		
		var mx = d.getMonth();
		var dx = new Date(this._activeDate.getFullYear(), this._activeDate.getMonth(), this._activeDate.getDate(), 0, 0, 0, 0).getTime();
		var i = 0;
		for (var q=0; q<6; q++) {
			var ws = this._wStart;
			for (var w=0; w<=7; w++) {
				if (w == 0) {
					var wn = this.getWeekNumber(new Date(first.getFullYear(), first.getMonth(), first.getDate()+i, 0, 0, 0, 0));
					// if active month set to jan and 1st jan belong to 1st week - display 1st week instead of 52/53
					if (wn >= 52 && this.conf.ws_first == true && this._activeMonth.getMonth() == 0) {
						var wn2 = this.getWeekNumber(new Date(first.getFullYear(), first.getMonth(), first.getDate()+i+7, 0, 0, 0, 0));
						if (wn2 < wn && wn2 > 1) wn = 1;
					}
					this.contDates.childNodes[q].childNodes[w].innerHTML = "<div class='dhtmlxcalendar_label'>"+wn+"</div>";
				} else {
					
					var d2 = new Date(first.getFullYear(), first.getMonth(), first.getDate()+i, 0, 0, 0, 0);
					if (d2.getHours() != 0) {
						var h = (d2.getHours()>12 ? 24-d2.getHours() : d2.getHours()); // yesturday/tomorrow while daylight saving
						d2.setTime(d2.getTime() + 60*60*1000*h);
					}
					
					var day = d2.getDay();
					var time = d2.getTime();
					
					var label_css = "dhtmlxcalendar_label";
					if (this._tipData[time] != null) {
						if (this._tipData[time].usePopup && typeof(window.dhtmlXPopup) == "function") {
							this.contDates.childNodes[q].childNodes[w].removeAttribute("title");
							this._initTooltipPopup();
						} else {
							this.contDates.childNodes[q].childNodes[w].setAttribute("title", this._tipData[time].text);
						}
						if (this._tipData[time].showIcon) label_css += " dhtmlxcalendar_label_title";
					} else {
						this.contDates.childNodes[q].childNodes[w].removeAttribute("title");
						
					}
					
					this.contDates.childNodes[q].childNodes[w].innerHTML = "<div class='"+label_css+"'>"+d2.getDate()+"</div>";
					
					this.contDates.childNodes[q].childNodes[w]._date = new Date(time);
					this.contDates.childNodes[q].childNodes[w]._q = q;
					this.contDates.childNodes[q].childNodes[w]._w = w;
					this.contDates.childNodes[q].childNodes[w]._css_month = (d2.getMonth()==mx);
					this.contDates.childNodes[q].childNodes[w]._css_date = (!this._nullDate&&time==dx);
					this.contDates.childNodes[q].childNodes[w]._css_weekend = (ws>=6);
					this.contDates.childNodes[q].childNodes[w]._css_dis = this._isOutOfRange(time);
					this.contDates.childNodes[q].childNodes[w]._css_holiday = (this._holidays[time] == true);
					
					this._updateCellStyle(q, w);
					
					if (time==dx) this._activeDateCell = this.contDates.childNodes[q].childNodes[w];
					
					if (++ws > 7) ws = 1;
					i++;
				}
				
			}
		}
		
		this.contMonth.firstChild.firstChild.childNodes[1].innerHTML = this._buildMonthHdr(d);
		
	}
	
	this._updateCellStyle = function(q, w) {
		
		var r = this.contDates.childNodes[q].childNodes[w];
		
		var s = "dhtmlxcalendar_cell dhtmlxcalendar_cell";
		
		// this/another month
		s += (r._css_month ? "_month" : "");
		
		// selected date
		s += (r._css_date ? "_date" : "");
		
		// is weekend
		s += (r._css_weekend ? "_weekend" : "");
		
		// is holiday
		s += (r._css_holiday ? "_holiday" : "");
		
		// is cell disabled
		s += (r._css_dis ? "_dis" : "");
		
		// is cell hover (only if not disabled)
		s += (r._css_hover && !r._css_dis ? "_hover" : "");
		
		r.className = s;
		r = null;
		
	}
	
	/* global selector obj */
	
	this._minutesInterval = 5; // default
	
	this._initSelector = function(type,css) {
		
		if (!this._selCover) {
			this._selCover = document.createElement("DIV");
			this._selCover.className = "dhtmlxcalendar_selector_cover";
			this.base.firstChild.appendChild(this._selCover);
		}

		if (!this._sel) {
			
			this._sel = document.createElement("DIV");
			this._sel.className = "dhtmlxcalendar_selector_obj";
			this.base.firstChild.appendChild(this._sel);
			
			this._sel.appendChild(document.createElement("TABLE"));
			this._sel.firstChild.className = "dhtmlxcalendar_selector_table";
			this._sel.firstChild.cellSpacing = 0;
			this._sel.firstChild.cellPadding = 0;
			this._sel.firstChild.border = 0;
			this._sel.firstChild.appendChild(document.createElement("TBODY"));
			this._sel.firstChild.firstChild.appendChild(document.createElement("TR"));
			
			this._sel.firstChild.firstChild.firstChild.appendChild(document.createElement("TD"));
			this._sel.firstChild.firstChild.firstChild.appendChild(document.createElement("TD"));
			this._sel.firstChild.firstChild.firstChild.appendChild(document.createElement("TD"));
			
			this._sel.firstChild.firstChild.firstChild.childNodes[0].className = "dhtmlxcalendar_selector_cell_left";
			this._sel.firstChild.firstChild.firstChild.childNodes[1].className = "dhtmlxcalendar_selector_cell_middle";
			this._sel.firstChild.firstChild.firstChild.childNodes[2].className = "dhtmlxcalendar_selector_cell_right";
			this._sel.firstChild.firstChild.firstChild.childNodes[0].innerHTML = "&nbsp;";
			this._sel.firstChild.firstChild.firstChild.childNodes[2].innerHTML = "&nbsp;";
			
			this._sel.firstChild.firstChild.firstChild.childNodes[0].onmouseover = function(){
				this.className = "dhtmlxcalendar_selector_cell_left dhtmlxcalendar_selector_cell_left_hover";
			}
			this._sel.firstChild.firstChild.firstChild.childNodes[0].onmouseout = function(){
				this.className = "dhtmlxcalendar_selector_cell_left";
			}
			
			this._sel.firstChild.firstChild.firstChild.childNodes[2].onmouseover = function(){
				this.className = "dhtmlxcalendar_selector_cell_right dhtmlxcalendar_selector_cell_right_hover";
			}
			this._sel.firstChild.firstChild.firstChild.childNodes[2].onmouseout = function(){
				this.className = "dhtmlxcalendar_selector_cell_right";
			}
			
			this._sel.onmouseover = function(e) {
				e = e||event;
				var t = (e.target||e.srcElement);
				if (t._cell === true) {
					if (that._selHover != t) that._clearSelHover();
					if (String(t.className).match(/^\s{0,}dhtmlxcalendar_selector_cell\s{0,}$/gi) !=null) {
						t.className += " dhtmlxcalendar_selector_cell_hover";
						that._selHover = t;
					}
				}
			}
			
			this._sel.onmouseout = function() {
				that._clearSelHover();
			}
			
			this._sel.firstChild.firstChild.firstChild.childNodes[0].onclick = function(e){
				e = e||event;
				if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
				e.cancelBubble = true;
				that._scrollYears(-1);
			}
			
			this._sel.firstChild.firstChild.firstChild.childNodes[2].onclick = function(e){
				e = e||event;
				if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
				e.cancelBubble = true;
				that._scrollYears(1);
			}
			
			if (this.conf.touch == true) {
				this._sel.firstChild.firstChild.firstChild.childNodes[0].ontouchstart = this._sel.firstChild.firstChild.firstChild.childNodes[0].onclick;
				this._sel.firstChild.firstChild.firstChild.childNodes[2].ontouchstart = this._sel.firstChild.firstChild.firstChild.childNodes[2].onclick;
			}
			
			this._sel._ta = {};
			
			this._selHover = null;
			
			this._sel.appendChild(document.createElement("DIV"));
			this._sel.lastChild.className = "dhtmlxcalendar_selector_obj_arrow";
		}
		
		// check if already inited
		if (this._sel._ta[type] == true) return;
		
		// init month
		if (type == "month") {
			
			this._msCells = {};
			
			this.msCont = document.createElement("DIV");
			this.msCont.className = "dhtmlxcalendar_area_"+css;
			this._sel.firstChild.firstChild.firstChild.childNodes[1].appendChild(this.msCont);
			
			var i = 0;
			for (var q=0; q<4; q++) {
				var ul = document.createElement("UL");
				ul.className = "dhtmlxcalendar_selector_line";
				this.msCont.appendChild(ul);
				for (var w=0; w<3; w++) {
					var li = document.createElement("LI");
					li.innerHTML = this.langData[this.lang].monthesSNames[i];
					li.className = "dhtmlxcalendar_selector_cell";
					ul.appendChild(li);
					li._month = i;
					li._cell = true;
					this._msCells[i++] = li;
				}
			}
			
			this.msCont.onclick = function(e) {
				e = e||event;
				if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
				e.cancelBubble = true;
				var t = (e.target||e.srcElement);
				if (t._month != null) {
					that._hideSelector();
					that._updateActiveMonth();
					that._drawMonth(new Date(that._activeMonth.getFullYear(), t._month, 1, 0, 0, 0, 0));
					that._doOnSelectorChange();
				}
			}
			if (this.conf.touch == true) {
				this.msCont.ontouchstart = this.msCont.onclick;
			}
		}
		
		// init year
		if (type == "year") {
			
			this._ysCells = {};
			
			this.ysCont = document.createElement("DIV");
			this.ysCont.className = "dhtmlxcalendar_area_"+css;
			this._sel.firstChild.firstChild.firstChild.childNodes[1].appendChild(this.ysCont);
			
			for (var q=0; q<4; q++) {
				var ul = document.createElement("UL");
				ul.className = "dhtmlxcalendar_selector_line";
				this.ysCont.appendChild(ul);
				for (var w=0; w<3; w++) {
					var li = document.createElement("LI");
					li.className = "dhtmlxcalendar_selector_cell";
					li._cell = true;
					ul.appendChild(li);
				}
			}
			
			this.ysCont.onclick = function(e) {
				e = e||event;
				if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
				e.cancelBubble = true;
				var t = (e.target||e.srcElement);
				if (t._year != null) {
					that._hideSelector();
					that._drawMonth(new Date(t._year, that._activeMonth.getMonth(), 1, 0, 0, 0, 0));
					that._doOnSelectorChange();
				}
			}
			if (this.conf.touch == true) {
				this.ysCont.ontouchstart = this.ysCont.onclick;
			}
			
		}
		
		// init hours
		if (type == "hours") {
			
			this._hsCells = {};
			
			this.hsCont = document.createElement("DIV");
			this.hsCont.className = "dhtmlxcalendar_area_"+css;
			this._sel.firstChild.firstChild.firstChild.childNodes[1].appendChild(this.hsCont);
			
			var i = 0;
			for (var q=0; q<4; q++) {
				var ul = document.createElement("UL");
				ul.className = "dhtmlxcalendar_selector_line";
				this.hsCont.appendChild(ul);
				for (var w=0; w<6; w++) {
					var li = document.createElement("LI");
					li.innerHTML = this._fixLength(i,2);
					li.className = "dhtmlxcalendar_selector_cell";
					ul.appendChild(li);
					li._hours = i;
					li._cell = true;
					this._hsCells[i++] = li;
				}
			}
			
			this.hsCont.onclick = function(e) {
				e = e||event;
				if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
				e.cancelBubble = true;
				var t = (e.target||e.srcElement);
				if (t._hours != null) {
					that._hideSelector();
					that._activeDate.setHours(t._hours);
					that._updateActiveHours();
					that._updateVisibleHours();
					that._doOnSelectorChange();
					//
					that.callEvent("onTimeChange",[new Date(that._activeDate.getTime())]);
				}
			}
			if (this.conf.touch == true) {
				this.hsCont.ontouchstart = this.hsCont.onclick;
			}
		}
		
		// init minutes
		if (type == "minutes") {
			
			// _minutesInterval = 5, def
			
			var q1 = 4;
			var w1 = 3;
			var len = 2; // leading zero
			
			if (this._minutesInterval == 1) {
				if (this._selectorMode == 1) {
					q1 = 2;
					w1 = 3;
					len = 1;
				} else {
					q1 = 2;
					w1 = 5;
					len = 1;
					css += "5";
				}
			}
			if (this._minutesInterval == 10) q1 = 2;
			if (this._minutesInterval == 15) {
				q1 = 1;
				w1 = 4;
				css += "4";
			}
			
			this._rsCells = {};
			
			this.rsCont = document.createElement("DIV");
			this.rsCont.className = "dhtmlxcalendar_area_"+css;
			this._sel.firstChild.firstChild.firstChild.childNodes[1].appendChild(this.rsCont);
			
			var i = 0;
			for (var q=0; q<q1; q++) {
				var ul = document.createElement("UL");
				ul.className = "dhtmlxcalendar_selector_line";
				this.rsCont.appendChild(ul);
				for (var w=0; w<w1; w++) {
					var li = document.createElement("LI");
					li.innerHTML = (len>1?this._fixLength(i,len):i);
					li.className = "dhtmlxcalendar_selector_cell";
					ul.appendChild(li);
					li._minutes = i;
					li._cell = true;
					this._rsCells[i] = li;
					i += this._minutesInterval;
				}
			}
			
			this.rsCont.onclick = function(e) {
				e = e||event;
				if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
				e.cancelBubble = true;
				var t = (e.target||e.srcElement);
				if (t._minutes != null) {
					if (that._minutesInterval == 1) {
						
						var m = that.getFormatedDate("%i");
						if (that._selectorMode == 1) {
							m = t._minutes.toString()+m.charAt(1);
						} else {
							m = m.charAt(0)+t._minutes.toString();
						}
						that._activeDate.setMinutes(Number(m));
						//
						that.callEvent("onTimeChange",[new Date(that._activeDate.getTime())]);
						
						that._hideSelector(); // will unload
						
						if (that._selectorMode == 1) {
							// show 2nd
							
							that._updateVisibleMinutes(true);
							that._selectorMode = 2;
							that._showSelector("minutes", that._sel._x, that._sel._y, "selector_minutes", true);
							that._updateActiveMinutes();
							return;
						} else {
							that._selectorMode = 1;
						}
					} else {
						that._hideSelector();
						that._activeDate.setMinutes(t._minutes);
						that._updateActiveMinutes();
						//
						that.callEvent("onTimeChange",[new Date(that._activeDate.getTime())]);
					}
					that._updateVisibleMinutes();
					that._doOnSelectorChange();
				}
			}
			if (this.conf.touch == true) {
				this.rsCont.ontouchstart = this.rsCont.onclick;
			}
		}
		
		// mark that selector of current type is inited
		this._sel._ta[type] = true;
	}
	
	this._showSelector = function(type, x, y, css, autoHide) {
		
		if (autoHide === true && this._sel != null && this._isSelectorVisible() && type == this._sel._t) {
			this._hideSelector();
			return;
		}
		
		if (this.conf.skin == "dhx_terrace") {
			x += 12; // ul's margin
		}
		
		if (!this._sel || !this._sel._ta[type]) this._initSelector(type,css);
		
		// minutes was visible, selector jumps to other type, remove red line
		if (type != this._sel._t && this._sel._t == "minutes" && this._minutesInterval == 1) {
			this.contTime.firstChild.firstChild.childNodes[3].innerHTML = this.getFormatedDate("%i");
		}
		
		this._sel._x = x;
		this._sel._y = y;
		
		// show selector cover
		this._sel.style.visibility = "hidden";
		this._sel.style.display = "";
		
		this._selCover.style.width = this.base.offsetWidth-2+"px";
		this._selCover.style.top = this.contMonth.offsetHeight+"px";
		this._selCover.style.height = this.contDates.offsetHeight+this.contDays.offsetHeight-1+"px";
		
		this._selCover.style.display = "";
		
		// show selector
		this._sel._t = type;
		this._sel.className = "dhtmlxcalendar_selector_obj dhtmlxcalendar_"+css+(type=="hours"&&this.conf.today==true?"2":"");
		
		// left/right table arrows
		this._sel.childNodes[0].firstChild.firstChild.childNodes[0].style.display = this._sel.childNodes[0].firstChild.firstChild.childNodes[2].style.display = (type=="year"?"":"none");
		
		// coords
		var x0 = Math.max(0, x-Math.round(this._sel.offsetWidth/2));
		if (x0+this._sel.offsetWidth > this._sel.parentNode.offsetWidth) {
			x0 = this._sel.parentNode.offsetWidth - this._sel.offsetWidth;
		}
		
		this._sel.style.left = x0+"px";
		
		if (type == "hours" || type == "minutes") {
			this._sel.style.top = y-this._sel.offsetHeight+"px";
		} else {
			this._sel.style.top = y+"px";
		}
		
		// arrow width
		this._sel.childNodes[1].style.width = this._sel.childNodes[0].offsetWidth+"px";
		
		// final apply
		this._sel.style.visibility = "visible";
		
		// callbacks
		this._doOnSelectorShow(type);
	}
	
	this._doOnSelectorShow = function(type) {
		if (type == "month") this._updateActiveMonth();
		if (type == "year") this._updateYearsList(this._activeMonth);
		if (type == "hours") this._updateActiveHours();
		if (type == "minutes") this._updateActiveMinutes();
	}
	
	this._hideSelector = function(selMode) {
		if (!this._sel) return;
		this._sel.style.display = "none";
		this._sel.style.visible = "hidden";
		this._selCover.style.display = "none";
		//
		if (this._sel._t == "minutes" && this._minutesInterval == 1) {
			this.contTime.firstChild.firstChild.childNodes[3].innerHTML = this.getFormatedDate("%i");
			this._unloadSelector("minutes");
		}
	}
	
	this._isSelectorVisible = function() {
		if (!this._sel) return false;
		return (this._sel.style.display != "none");
	}
	
	this._doOnSelectorChange = function(state) {
		this.callEvent("onChange",[new Date(this._activeMonth.getFullYear(), this._activeMonth.getMonth(), this._activeDate.getDate(), this._activeDate.getHours(), this._activeDate.getMinutes(), this._activeDate.getSeconds()),state===true]);
	}
	
	this._clearSelHover = function() {
		if (!this._selHover) return;
		this._selHover.className = String(this._selHover.className.replace(/dhtmlxcalendar_selector_cell_hover/gi,""));
		this._selHover = null;
	}
	
	this._unloadSelector = function(type) {
		if (!this._sel) return;
		if (!this._sel._ta[type]) return;
		
		// month selector
		if (type == "month") {
			
			this.msCont.onclick = this.msCont.ontouchstart = null;
			this._msActive = null;
			
			// li
			for (var a in this._msCells) {
				this._msCells[a]._cell = null;
				this._msCells[a]._month = null;
				this._msCells[a].parentNode.removeChild(this._msCells[a]);
				this._msCells[a] = null;
			}
			this._msCells = null;
			
			// ul
			while (this.msCont.childNodes.length > 0) this.msCont.removeChild(this.msCont.lastChild);
			
			// div
			this.msCont.parentNode.removeChild(this.msCont);
			this.msCont = null;
			
		}
		
		// years selector
		if (type == "year") {
			
			this.ysCont.onclick = this.ysCont.ontouchstart = null;
			
			// li
			for (var a in this._ysCells) {
				this._ysCells[a]._cell = null;
				this._ysCells[a]._year = null;
				this._ysCells[a].parentNode.removeChild(this._ysCells[a]);
				this._ysCells[a] = null;
			}
			this._ysCells = null;
			
			// ul
			while (this.ysCont.childNodes.length > 0) this.ysCont.removeChild(this.ysCont.lastChild);
			
			// div
			this.ysCont.parentNode.removeChild(this.ysCont);
			this.ysCont = null;
			
		}
		
		// hours selector
		if (type == "hours") {
			
			this.hsCont.onclick = this.hsCont.ontouchstart = null;
			this._hsActive = null;
			
			// li
			for (var a in this._hsCells) {
				this._hsCells[a]._cell = null;
				this._hsCells[a]._hours = null;
				this._hsCells[a].parentNode.removeChild(this._hsCells[a]);
				this._hsCells[a] = null;
			}
			this._hsCells = null;
			
			// ul
			while (this.hsCont.childNodes.length > 0) this.hsCont.removeChild(this.hsCont.lastChild);
			
			// div
			this.hsCont.parentNode.removeChild(this.hsCont);
			this.hsCont = null;
			
		}
		
		// minutes selector
		if (type == "minutes") {
			
			this.rsCont.onclick = this.rsCont.ontouchstart = null;
			this._rsActive = null;
			
			// li
			for (var a in this._rsCells) {
				this._rsCells[a]._cell = null;
				this._rsCells[a]._minutes = null;
				this._rsCells[a].parentNode.removeChild(this._rsCells[a]);
				this._rsCells[a] = null;
			}
			this._rsCells = null;
			
			// ul
			while (this.rsCont.childNodes.length > 0) this.rsCont.removeChild(this.rsCont.lastChild);
			
			// div
			this.rsCont.parentNode.removeChild(this.rsCont);
			this.rsCont = null;
			
		}
		
		
		this._sel._ta[type] = null;
	}
	
	this.setMinutesInterval = function(d) {
		if (!(d == 1 || d == 5 || d == 10 || d == 15)) return;
		this._minutesInterval = d;
		this._unloadSelector("minutes");
	}
	
	
	/* month selector */
	
	this._updateActiveMonth = function() {
		if (typeof(this._msActive) != "undefined" && typeof(this._msCells[this._msActive]) != "undefined") this._msCells[this._msActive].className = "dhtmlxcalendar_selector_cell";
		this._msActive = this._activeMonth.getMonth();
		this._msCells[this._msActive].className = "dhtmlxcalendar_selector_cell dhtmlxcalendar_selector_cell_active";
	}
	
	/* year selector */
	
	this._updateActiveYear = function() {
		var i = this._activeMonth.getFullYear();
		if (this._ysCells[i]) this._ysCells[i].className = "dhtmlxcalendar_selector_cell dhtmlxcalendar_selector_cell_active";
	}
	
	this._updateYearsList = function(d) {
		for (var a in this._ysCells) {
			this._ysCells[a] = null;
			delete this._ysCells[a];
		}
		//
		var i = 12*Math.floor(d.getFullYear()/12);
		for (var q=0; q<4; q++) {
			for (var w=0; w<3; w++) {
				this.ysCont.childNodes[q].childNodes[w].innerHTML = i;
				this.ysCont.childNodes[q].childNodes[w]._year = i;
				this.ysCont.childNodes[q].childNodes[w].className = "dhtmlxcalendar_selector_cell";
				this._ysCells[i++] = this.ysCont.childNodes[q].childNodes[w];
			}
		}
		this._updateActiveYear();
	}
	
	this._scrollYears = function(i) {
		var y = (i<0?this.ysCont.firstChild.firstChild._year:this.ysCont.lastChild.lastChild._year)+i;
		var d = new Date(y, this._activeMonth.getMonth(), 1, 0, 0, 0, 0);
		this._updateYearsList(d);
	}
	
	/* hours selector */
	
	// update hours in selector
	this._updateActiveHours = function() {
		if (typeof(this._hsActive) != "undefined" && typeof(this._hsCells[this._hsActive]) != "undefined") this._hsCells[this._hsActive].className = "dhtmlxcalendar_selector_cell";
		this._hsActive = this._activeDate.getHours();
		this._hsCells[this._hsActive].className = "dhtmlxcalendar_selector_cell dhtmlxcalendar_selector_cell_active";
	}
	
	// update hours in calendar
	this._updateVisibleHours = function() {
		this.contTime.firstChild.firstChild.childNodes[1].innerHTML = this._fixLength(this._activeDate.getHours(),2);
	}
	
	/* minutes selector */
	
	// update minutes in selector
	this._updateActiveMinutes = function() {
		if (this._rsActive != null && typeof(this._rsActive) != "undefined" && typeof(this._rsCells[this._rsActive]) != "undefined") this._rsCells[this._rsActive].className = "dhtmlxcalendar_selector_cell";
		if (this._minutesInterval == 1) {
			this._rsActive = (this.getFormatedDate("%i").toString()).charAt(this._selectorMode==1?0:1);
		} else {
			this._rsActive = this._activeDate.getMinutes();
		}
		if (typeof(this._rsCells[this._rsActive]) != "undefined") this._rsCells[this._rsActive].className = "dhtmlxcalendar_selector_cell dhtmlxcalendar_selector_cell_active";
	}
	
	// update minutes in calendar
	this._updateVisibleMinutes = function(h) {
		var t = this._fixLength(this._activeDate.getMinutes(),2).toString();
		if (h == true) t = t.charAt(0)+"<span class='dhtmlxcalendar_selected_date'>"+t.charAt(1)+"</span>";
		this.contTime.firstChild.firstChild.childNodes[3].innerHTML = t;
		if (h == true) this.contTime.firstChild.firstChild.childNodes[3].lastChild._par = true;
	}
	
	/* some common functionality */
	
	this._fixLength = function(t, r) {
		while (String(t).length < r) t = "0"+String(t);
		return t;
	}
	
	this._dateFormat = "";
	this._dateFormatRE = null;
	
	this.setDateFormat = function(format) {
		
		// check value in inputs
		// for 1st call on init strTodate not defined
		var upd = {};
		if (this._strToDate != null) {
			for (var a in this.i) {
				if (this.i[a].input != null && this.i[a].input.value.length > 0) {
					var d = this._strToDate(this.i[a].input.value, this._dateFormat||this.langData[this.lang].dateformat||"%Y-%m-%d");
					if (d instanceof Date) upd[a] = d;
				}
			}
		}
		
		this._dateFormat = format;
		var k = String(this._dateFormat).replace(/%[a-zA-Z]+/g,function(t){
			var t2 = t.replace(/%/,"");
			switch (t2) {
				case "n": case "h": case "j": case "g": case "G": return "\\d{1,2}";
				case "m": case "d": case "H": case "i": case "s": case "y": return "\\d{2}";
				case "Y": return "\\d{4}";
				case "M": return "("+that.langData[that.lang].monthesSNames.join("|").toLowerCase()+"){1,}";
				case "F": return "("+that.langData[that.lang].monthesFNames.join("|").toLowerCase()+"){1,}";
				case "D": return "[a-z]{2}";
				case "a": case "A": return "AM|PM";
				case "u": return "\\d{1,6}";
				case "P": return "[\\+\\-]\\d{1,2}\\:\\d{1,2}";
			}
			return t;
		});
		
		this._dateFormatRE = new RegExp(k,"i");
		
		// update dates in inputs
		for (var a in upd) {
			this.i[a].input.value = this._dateToStr(upd[a]);
		}
		upd = null;
	}
	
	this.setDateFormat(this.langData[this.lang].dateformat||"%Y-%m-%d");
	
	this._updateDateStr = function(str) {
		// check if valid str
		if (!this._dateFormatRE || !str.match(this._dateFormatRE)) return;
		
		// input was not updated
		if (str == this.getFormatedDate()) return;
		
		var r = this._strToDate(str);
		if (!(r instanceof Date)) return;
		
		// cjeck if allow to modify input
		if (this.checkEvent("onBeforeChange")) {
			if (!this.callEvent("onBeforeChange",[new Date(r.getFullYear(),r.getMonth(),r.getDate(),r.getHours(),r.getMinutes(),r.getSeconds())])) {
				// revert value
				this._updateInp();
				return;
			}
		}
		
		this._nullDate = false;
		this._activeDate = r;
		this._drawMonth(this._nullDate?new Date():this._activeDate);
		
		this._updateVisibleMinutes();
		this._updateVisibleHours();
		
		if (this._sel && this._isSelectorVisible()) this._doOnSelectorShow(this._sel._t);
		this._doOnSelectorChange(true);
		
	}
	
	this.showMonth = function(d) {
		if (typeof(d) == "string") d = this._strToDate(d);
		if (!(d instanceof Date)) return;
		this._drawMonth(d);
	}
	
	this.setFormatedDate = function(format, str, a, return_only) {
		var date = this._strToDate(str, format);
		if (return_only) return date;
		this.setDate(date);
	}

	this.getFormatedDate = function(format, date){
		if (!(date && date instanceof Date)){
			if (this._nullDate) return ""; 
			date = new Date(this._activeDate);
		}
		return this._dateToStr(date, format);
	}
	
	/* week numbers */
	this.getWeekNumber = function(dateX) {
		
		if (typeof(dateX) == "string") dateX = this._strToDate(dateX);
		if (!(dateX instanceof Date)) return "Invalid Date";
		
		if (typeof(this._ftDay) == "undefined") this._ftDay = 4;
		
		var ws = this._wStart; // 1..7 = Mo-Su
		var we = ws+7;
		
		var ft = 4; // first thursday
		
		
		var x1_date = new Date(dateX.getFullYear(), 0, 1, 0, 0, 0, 0);// day-of-week, jan first
		var x1 = x1_date.getDay();
		if (x1 == 0) x1 = 7;
		
		// offset
		if (ft < ws) {
			ft += 7;
			x1 += 7;
		}
		
		// detect date of 1st week
		
		var i = 0; // week offset
		if (x1 >= ws && x1 <= ft) {
			// x1 belong 1st week
		} else {
			// x1 belong 2nd week
			i = 1;
		}
		var k = x1-ws;
		var w1 = new Date(dateX.getFullYear(), 0, 1-k+i*7, 0, 0, 0, 0);// 1st week start date
		
		// console.log("1st week of "+x.getFullYear()+" year starts from "+this.getFormatedDate("%M %d, %Y",w1));
		
		var d7 = 604800000; // 7 days in ms, 60*60*24*7*1000
		var x2 = new Date(dateX.getFullYear(), dateX.getMonth(), dateX.getDate()+1, 0, 0, 0, 0); // 2nd day to get interval
		
		var wn = Math.ceil((x2.getTime()-w1.getTime())/d7);
		
		// if 1st jan coincide with 52/53'd week of prev year, get week number of 1st day of current week
		if (wn == 0) {
			var curDate = new Date(dateX.getFullYear(), dateX.getMonth(), dateX.getDate(), 0, 0, 0, 0);
			var firstDay = curDate.getDay()-this._wStart;
			if (firstDay < 0) firstDay = firstDay+7;
			curDate.setDate(curDate.getDate()-firstDay);
			wn = this.getWeekNumber(curDate);
		}
		
		return wn;
		
	}
	
	this.showWeekNumbers = function() {
		this.base.firstChild.className = "dhtmlxcalendar_wn";
	}
	
	this.hideWeekNumbers = function() {
		this.base.firstChild.className = "";
	}
	
	/* show/hide calendar */
	
	// public show/hide
	
	this.show = function(id) {
		// if id not set - try show in container
		if (!id && this._hasParent) {
			this._show();
			return;
		}
		
		// show by real input id, added in 5.0
		if (typeof(id) == "string") {
			var i = document.getElementById(id);
			if (i != null && typeof(i._dhtmlxcalendar_uid) != "undefined" && this.i[i._dhtmlxcalendar_uid] != null) {
				this._show(i._dhtmlxcalendar_uid);
				return;
			}
		}
		
		// if input id not specified show near first found
		// if nothing found - do not show
		if (typeof(id) == "object" && typeof(id._dhtmlxcalendar_uid) != "undefined" && this.i[id._dhtmlxcalendar_uid] == id) {
			this._show(id._dhtmlxcalendar_uid);
			return;
		}
		if (typeof(id) == "undefined") { for (var a in this.i) if (!id) id = a; }
		if (!id) return;
		this._show(id);
	}
	
	this.hide = function() {
		if (this._isVisible()) this._hide();
	}
	
	this.isVisible = function() {
		return this._isVisible();
	}
	
	
	// private show/hide
	this._activeInp = null;
	
	this.pos = "bottom";
	this.setPosition = function(x, y) {
		this._px = null;
		this._py = null;
		if (x == "right" || x == "bottom") {
			this.pos = x;
		} else {
			this.pos = "int";
			if (typeof(x) != "undefined" && !isNaN(x)) {
				this.base.style.left = x+"px";
				this._px = x;
			}
			if (typeof(y) != "undefined" && !isNaN(y)) {
				this.base.style.top = y+"px";
				this._py = y;
			}
			this._ifrSize();
		}
	}
	
	this._show = function(inpId, autoHide) {
		if (autoHide === true && this._activeInp == inpId && this._isVisible()) {
			this._hide();
			return;
		}
		this.base.style.visibility = "hidden";
		this.base.style.display = "";
		if (!inpId) {
			if (this._px != null && this._py != null) {
				this.base.style.left = this._px+"px";
				this.base.style.top = this._py+"px";
			} else {
				this.base.style.left = "0px";
				this.base.style.top = "0px";
			}
		} else {
			if (this.base.className.indexOf("dhtmlxcalendar_in_input") == -1) this.base.className += " dhtmlxcalendar_in_input";
			var i = (this.i[inpId].input||this.i[inpId].button);
			var dim = window.dhx4.screenDim();
			var inp = {top: window.dhx4.absTop(i), left: window.dhx4.absLeft(i)};
			if (this.pos == "right") {
				this.base.style.left = inp.left+i.offsetWidth+"px";
				this.base.style.top = Math.min(inp.top, dim.bottom-this.base.offsetHeight)+"px";
			} else if (this.pos == "bottom") {
				var y0 = inp.top+i.offsetHeight+1;
				if (y0+this.base.offsetHeight > dim.bottom) {
					var ny0 = inp.top-this.base.offsetHeight;
					if (ny0 >= -20) y0 = ny0;
				}
				// checi overflow from right side
				var x = inp.left;
				if (x + this.base.offsetWidth > dim.right) x = Math.max(0, inp.left+i.offsetWidth-this.base.offsetWidth);
				//
				this.base.style.left = x+"px";
				this.base.style.top = y0+"px";
			} else {
				this.base.style.left = (this._px||0)+"px";
				this.base.style.top = (this._py||0)+"px";
			}
			this._activeInp = inpId;
			i = null;
		}
		this._hideSelector();
		this.base.style.visibility = "visible";
		this.base.style.zIndex = window.dhx4.zim.reserve(this.conf.zi);
		this._ifrSize();
		if (this._ifr) this._ifr.style.display = "";
		this.callEvent("onShow",[]);
	}
	
	this._hide = function() {
		if (this._lastHover != null) this._clearDayHover();
		this._hideSelector();
		this.base.style.display = "none";
		window.dhx4.zim.clear(this.conf.zi);
		if (this.base.className.indexOf("dhtmlxcalendar_in_input") >= 0) this.base.className = this.base.className.replace(/\s{0,}dhtmlxcalendar_in_input/gi, "");
		this._activeInp = null;
		if (this._ifr) this._ifr.style.display = "none";
		this.callEvent("onHide",[]);
	}
	
	this._isVisible = function() {
		return (this.base.style.display!="none");
	}
	
	this._rangeActive = false;
	this._rangeFrom = null;
	this._rangeTo = null;
	this._rangeSet = {};
	
	this.setInsensitiveDays = function(d) {
		
		// !works in append mode
		var t = this._extractDates(d);
		for (var q=0; q<t.length; q++) this._rangeSet[new Date(t[q].getFullYear(),t[q].getMonth(),t[q].getDate(),0,0,0,0).getTime()] = true;
		
		this._drawMonth(this._activeMonth);
		
	}
	
	this.clearInsensitiveDays = function() {
		this._clearRangeSet();
		this._drawMonth(this._activeMonth);
	}
	
	this._holidays = {};
	this.setHolidays = function(r) {
		if (r == null) {
			this._clearHolidays();
		} else if (r != null) {
			var t = this._extractDates(r);
			for (var q=0; q<t.length; q++) this._holidays[new Date(t[q].getFullYear(),t[q].getMonth(),t[q].getDate(),0,0,0,0).getTime()] = true;
		}
		this._drawMonth(this._activeMonth);
	}
	
	this._extractDates = function(r) {
		// r = array of dates or comma-separated string list
		// return array with dates
		if (typeof(r) == "string" || r instanceof Date) r = [r];
		var t = [];
		for (var q=0; q<r.length; q++) {
			if (typeof(r[q]) == "string") {
				var e = r[q].split(",");
				for (var w=0; w<e.length; w++) t.push(this._strToDate(e[w]));
			} else if (r[q] instanceof Date) {
				t.push(r[q]);
			}
		}
		return t;
	}
	
	this._clearRange = function() {
		this._rangeActive = false;
		this._rangeType = null;
		this._rangeFrom = null;
		this._rangeTo = null;
	}
	
	this._clearRangeSet = function() {
		for (var a in this._rangeSet) {
			this._rangeSet[a] = null;
			delete this._rangeSet[a];
		}
	}
	
	this._clearHolidays = function() {
		for (var a in this._holidays) {
			this._holidays[a] = null;
			delete this._holidays[a];
		}
	}
	
	this._isOutOfRange = function(time) {
		
		if (this._rangeSet[time] == true) return true;
		
		if (this._rangeActive) {
			
			if (this._rangeType == "in" && (time<this._rangeFrom || time>this._rangeTo)) return true;
			if (this._rangeType == "out" && (time>=this._rangeFrom && time<=this._rangeTo)) return true;
			if (this._rangeType == "from" && time<this._rangeFrom)return true;
			if (this._rangeType == "to" && time>this._rangeTo) return true;
		}
		
		var t0 = new Date(time);
		
		if (this._rangeWeek) {
			if (this._rangeWeekData[t0.getDay()] === true) return true;
		}
		
		if (this._rangeMonth) {
			if (this._rangeMonthData[t0.getDate()] === true) return true;
		}
		
		if (this._rangeYear) {
			if (this._rangeYearData[t0.getMonth()+"_"+t0.getDate()] === true) return true;
		}
		
		return false;
		
	}
	
	this.clearSensitiveRange = function() {
		this._clearRange();
		this._drawMonth(this._activeMonth);
	}
	
	this.setSensitiveRange = function(from, to, ins) {
		
		var f = false;
		
		// set range
		if (from != null && to != null) {
			
			if (!(from instanceof Date)) from = this._strToDate(from);
			if (!(to instanceof Date)) to = this._strToDate(to);
			
			if (from.getTime() > to.getTime()) return;
			
			this._rangeFrom = new Date(from.getFullYear(),from.getMonth(),from.getDate(),0,0,0,0).getTime();
			this._rangeTo = new Date(to.getFullYear(),to.getMonth(),to.getDate(),0,0,0,0).getTime();
			this._rangeActive = true;
			this._rangeType = "in";
			
			f = true;
		}
		
		// set range "from date"
		if (!f && from != null && to == null) {
			
			if (!(from instanceof Date)) from = this._strToDate(from);
			this._rangeFrom = new Date(from.getFullYear(),from.getMonth(),from.getDate(),0,0,0,0).getTime();
			this._rangeTo = null;
			
			if (ins === true) this._rangeFrom++;
			
			this._rangeActive = true;
			this._rangeType = "from";
			
			f = true;
			
		}
		
		// set range "to date"
		if (!f && from == null && to != null) {
			
			if (!(to instanceof Date)) to = this._strToDate(to);
			this._rangeFrom = null;
			this._rangeTo = new Date(to.getFullYear(),to.getMonth(),to.getDate(),0,0,0,0).getTime();
			
			if (ins === true) this._rangeTo--;
			
			this._rangeActive = true;
			this._rangeType = "to";
			
			f = true;
			
		}
		
		if (f) this._drawMonth(this._activeMonth);
	}
	
	this.setInsensitiveRange = function(from, to) {
		
		if (from != null && to != null) {
			
			if (!(from instanceof Date)) from = this._strToDate(from);
			if (!(to instanceof Date)) to = this._strToDate(to);
			
			if (from.getTime() > to.getTime()) return;
			
			this._rangeFrom = new Date(from.getFullYear(),from.getMonth(),from.getDate(),0,0,0,0).getTime();
			this._rangeTo = new Date(to.getFullYear(),to.getMonth(),to.getDate(),0,0,0,0).getTime();
			this._rangeActive = true;
			this._rangeType = "out";
			
			this._drawMonth(this._activeMonth);
			return;
		}
		
		if (from != null && to == null) {
			this.setSensitiveRange(null, from, true);
			return;
		}
		
		if (from == null && to != null) {
			this.setSensitiveRange(to, null, true);
			return;
		}
		
	}
	
	//
	this.disableDays = function(mode, d) {
		
		if (mode == "week") {
			
			// !! works in replace mode
			
			if (typeof(d) != "object" && typeof(d.length) == "undefined") d = [d];
			
			if (!this._rangeWeekData) this._rangeWeekData = {};
			for (var a in this._rangeWeekData) {
				this._rangeWeekData[a] = false;
				delete this._rangeWeekData[a];
			}
			
			for (var q=0; q<d.length; q++) {
				this._rangeWeekData[d[q]] = true;
				if (d[q] == 7) this._rangeWeekData[0] = true;
			}
			this._rangeWeek = true;
		}
		
		if (mode == "month") {
			
			// !! works in replace mode
			
			if (typeof(d) != "object" && typeof(d.length) == "undefined") d = [d];
			
			if (!this._rangeMonthData) this._rangeMonthData = {};
			for (var a in this._rangeMonthData) {
				this._rangeMonthData[a] = false;
				delete this._rangeMonthData[a];
			}
			for (var q=0; q<d.length; q++) this._rangeMonthData[d[q]] = true;
			
			this._rangeMonth = true;
		}
		
		if (mode == "year") {
			
			// !! works in replace mode
			
			var t = this._extractDates(d);
			
			if (!this._rangeYearData) this._rangeYearData = {};
			for (var a in this._rangeYearData) {
				this._rangeYearData[a] = false;
				delete this._rangeYearData[a];
			}
			for (var q=0; q<t.length; q++) this._rangeYearData[t[q].getMonth()+"_"+t[q].getDate()] = true;
			
			this._rangeYear = true;
		}
		
		this._drawMonth(this._activeMonth);
	}
	
	this.enableDays = function(mode) {
		
		if (mode == "week") {
			this._rangeWeek = false;
		}
		
		if (mode == "month") {
			this._rangeMonth = false;
		}
		
		if (mode == "year") {
			this._rangeYear = false;
		}
		
		this._drawMonth(this._activeMonth);
	}
	
	
	/* tooltips */
	
	this._tipData = {};
	this._tipTM = null;
	this._tipTMTime = 400;
	this._tipEvs = false;
	this._tipPopup = null;
	this._tipCellDate = null;
	this._tipCellDim = null;
	
	this.setTooltip = function(dateX, text, showIcon, usePopup) {
		
		var t = this._extractDates(dateX);
		for (var q=0; q<t.length; q++) {
			var k = new Date(t[q].getFullYear(),t[q].getMonth(),t[q].getDate(),0,0,0,0).getTime();
			this._tipData[k] = { text: text, showIcon: showIcon, usePopup: usePopup };
		}
		this._drawMonth(this._activeMonth);
	}
	
	this.clearTooltip = function(dateX) {
		
		var t = this._extractDates(dateX);
		for (var q=0; q<t.length; q++) {
			var k = new Date(t[q].getFullYear(),t[q].getMonth(),t[q].getDate(),0,0,0,0).getTime();
			this._tipData[k] = null;
			delete this._tipData[k];
		}
		this._drawMonth(this._activeMonth);
	}
	
	this._initTooltipPopup = function() {
		
		if (this._tipEvs) return;
		
		this.attachEvent("onMouseOver", function(d){
			var k = new Date(d.getFullYear(),d.getMonth(),d.getDate(),0,0,0,0).getTime();
			if (this._tipData[k] != null) {
				if (this._tipTM) window.clearTimeout(this._tipTM);
				this._tipCellDate = d;
				this._tipCellDim = this.getCellDimension(d);
				this._tipText = this._tipData[k].text;
				this._tipTM = window.setTimeout(this._showTooltipPopup,this._tipTMTime);
			}
		});
		
		this.attachEvent("onMouseOut", this._hideTooltipPopup);
		
		this._tipEvs = true;
	}
	this._showTooltipPopup = function(text,x,y,w,h) {
		if (!that._tipPopup) that._tipPopup = new dhtmlXPopup({mode:"top"});
		that._tipPopup.attachHTML(that._tipText);
		that._tipPopup.show(that._tipCellDim.x, that._tipCellDim.y, that._tipCellDim.w, that._tipCellDim.h);
		that.callEvent("onPopupShow",[that._tipCellDate]);
	}
	
	this._hideTooltipPopup = function() {
		if (this._tipTM) window.clearTimeout(this._tipTM);
		if (this._tipPopup != null && this._tipPopup.isVisible()) {
			this._tipPopup.hide();
			this.callEvent("onPopupHide",[this._tipCellDate]);
		}
	}
	
	this.getPopup = function() {
		return this._tipPopup;
	}
	
	this.getCellDimension = function(dateX) {
		
		if (typeof(dateX) == "string") dateX = this._strToDate(dateX);
		if (!(dateX instanceof Date)) return null;
		
		var t = new Date(dateX.getFullYear(),dateX.getMonth(),dateX.getDate(),0,0,0,0).getTime();
		
		var k = null;
		
		for (var q=0; q<this.contDates.childNodes.length; q++) {
			for (var w=0; w<this.contDates.childNodes[q].childNodes.length; w++) {
				var p = this.contDates.childNodes[q].childNodes[w];
				if (p._date != null && p._date.getTime() == t) k = { x: window.dhx4.absLeft(p), y: window.dhx4.absTop(p), w: p.offsetWidth, h: p.offsetHeight };
				p = null;
			}
		}
		
		return k;
	}
	
	/* other */
	this._updateFromInput = function(t) {
		if (this._nullInInput && ((t.value).replace(/\s/g,"")).length == 0) {
			if (this.checkEvent("onBeforeChange")) {
				if (!this.callEvent("onBeforeChange",[null])) {
					// revert value
					this._updateInp();
					return;
				}
			}
			this.setDate(null);
		} else {
			this._updateDateStr(t.value);
		}
		t = null;
	}
	
	// global events
	this._doOnClick = function(e) {
		e = e||event;
		var t = (e.target||e.srcElement);
		// completely close alien calendar (both selector and container) inly if any assigned input clicked
		// otherwise hide selector and container separately
		if (t._dhtmlxcalendar_uid && t._dhtmlxcalendar_uid != that._activeInp && that._isVisible() && that._activeInp) {
			that._hide();
			return;
		}
		if (!t._dhtmlxcalendar_uid || !that.i[t._dhtmlxcalendar_uid]) { // !that.i[t._dhtmlxcalendar_uid] means alien input, for several calendar instances
			if (that._isSelectorVisible()) that._hideSelector(); else if (!that._hasParent && that._isVisible()) that._hide();
		}
	}
	
	this._doOnKeyDown = function(e) {
		e = e||event;
		if (e.keyCode == 27 || e.keyCode == 13) {
			if (that._isSelectorVisible()) that._hideSelector(); else if (that._isVisible() && !that._hasParent) that._hide();
		}
	}
	
	// inputs events
	this._doOnInpClick = function(e) {
		e = e||event;
		if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
		var t = (e.target||e.srcElement);
		if (!t._dhtmlxcalendar_uid) return;
		if (!that._listenerEnabled) {
			that._updateFromInput(t);
		}
		that._show(t._dhtmlxcalendar_uid, true);
	}
	
	this._doOnInpKeyUp = function(e) {
		e = e||event;
		var t = (e.target||e.srcElement);
		if (e.keyCode == 13 || !t._dhtmlxcalendar_uid) return;
		// otherwise try to update calendar's date
		if (!that._listenerEnabled) that._updateFromInput(t);
	}
	
	this._doOnBtnClick = function(e) {
		e = e||event;
		if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
		var t = (e.target||e.srcElement);
		if (!t._dhtmlxcalendar_uid) return;
		if (that.i[t._dhtmlxcalendar_uid].input != null) that._updateFromInput(that.i[t._dhtmlxcalendar_uid].input);
		that._show(t._dhtmlxcalendar_uid, true);
	}
	
	this._doOnUnload = function() {
		if (that && that.unload) that.unload();
	}
	
	if (typeof(window.addEventListener) == "function") {
		document.body.addEventListener("click", that._doOnClick, false);
		window.addEventListener("keydown", that._doOnKeyDown, false);
		window.addEventListener("unload", that._doOnUnload, false);
		if (this.conf.touch == true) document.body.addEventListener("touchstart", that._doOnClick, false);
	} else {
		document.body.attachEvent("onclick", that._doOnClick);
		document.body.attachEvent("onkeydown", that._doOnKeyDown);
		window.attachEvent("onunload", that._doOnUnload);
	}
	
	this.attachObj = function(obj) {
		var a = window.dhx4.newId();
		if (typeof(obj) == "string") {
			// id
			this.i[a] = {input:document.getElementById(obj)};
		} else if (typeof(obj.tagName) != "undefined") {
			// input dom obj
			this.i[a] = {input:obj};
		} else if (typeof(obj) == "object" && (obj.input != null || obj.button != null)) {
			// object
			this.i[a] = {};
			if (obj.input != null) this.i[a].input = (typeof(obj.input)=="string"?document.getElementById(obj.input):obj.input);
			if (obj.button != null) this.i[a].button = (typeof(obj.button)=="string"?document.getElementById(obj.button):obj.button);
		}
		this._attachEventsToObject(a);
		return a;
	}
	
	this.detachObj = function(obj) {
		var a = null;
		if (this.i[obj] != null) {
			// direct id
			a = obj;
		} else if (typeof(obj) == "string") {
			// id
			obj = document.getElementById(obj);
			a = obj._dhtmlxcalendar_uid;
		} else if (typeof(obj.tagName) != "undefined") {
			// input dom element
			a = obj._dhtmlxcalendar_uid;
		} else if (typeof(obj) == "object" && (obj.input != null || obj.button != null)) {
			if (a == null && obj.input != null) a = (typeof(obj.input)=="string"?document.getElementById(obj.input):obj.input)._dhtmlxcalendar_uid;
			if (a == null && obj.button != null) a = (typeof(obj.button)=="string"?document.getElementById(obj.button):obj.button)._dhtmlxcalendar_uid;
		}
		if (a != null && this.i[a] != null) {
			this._detachEventsFromObject(a);
			for (var b in this.i[b]) {
				this.i[a][b]._dhtmlxcalendar_uid = null;
				this.i[a][b] = null;
				delete this.i[a][b];
			}
			this.i[a] = null;
			delete this.i[a];
			return true;
		}
		return false;
	}
	
	this._attachEventsToObject = function(a) {
		if (this.i[a].button != null) {
			this.i[a].button._dhtmlxcalendar_uid = a;
			if (typeof(window.addEventListener) == "function") {
				this.i[a].button.addEventListener("click", that._doOnBtnClick, false);
				if (this.conf.touch == true) this.i[a].button.addEventListener("touchstart", that._doOnBtnClick, false);
			} else {
				this.i[a].button.attachEvent("onclick", that._doOnBtnClick);
			}
		} else if (this.i[a].input != null) {
			this.i[a].input._dhtmlxcalendar_uid = a;
			if (typeof(window.addEventListener) == "function") {
				this.i[a].input.addEventListener("click", that._doOnInpClick, false);
				this.i[a].input.addEventListener("keyup", that._doOnInpKeyUp, false);
				if (this.conf.touch == true) this.i[a].input.addEventListener("touchstart", that._doOnInpClick, false);
			} else {
				this.i[a].input.attachEvent("onclick", that._doOnInpClick);
				this.i[a].input.attachEvent("onkeyup", that._doOnInpKeyUp);
			}
		}
	}
	
	this._detachEventsFromObject = function(a) {
		if (this.i[a].button != null) {
			if (typeof(window.addEventListener) == "function") {
				this.i[a].button.removeEventListener("click", that._doOnBtnClick, false);
				if (this.conf.touch == true) this.i[a].button.removeEventListener("touchstart", that._doOnBtnClick, false);
				
			} else {
				this.i[a].button.detachEvent("onclick", that._doOnBtnClick);
			}
		} else if (this.i[a].input != null) {
			if (typeof(window.addEventListener) == "function") {
				this.i[a].input.removeEventListener("click", that._doOnInpClick, false);
				this.i[a].input.removeEventListener("keyup", that._doOnInpKeyUp, false);
				if (this.conf.touch == true) this.i[a].input.removeEventListener("touchstart", that._doOnInpClick, false);
			} else {
				this.i[a].input.detachEvent("onclick", that._doOnInpClick);
				this.i[a].input.detachEvent("onkeyup", that._doOnInpKeyUp);
			}
		}
	}
	this._updateInp = function() {
		if (this.i != null && this._activeInp != null && this.i[this._activeInp] != null && this.i[this._activeInp].input != null) {
			this.i[this._activeInp].input.value = this.getFormatedDate();
		}
	}
	
	// listener
	this.enableListener = function(t) {
		if (!t) return;
		if (typeof(window.addEventListener) == "function") {
			t.addEventListener("focus", that._listenerEvFocus, false);
			t.addEventListener("blur", that._listenerEvBlur, false);
		} else {
			t.attachEvent("onfocus", that._listenerEvFocus);
			t.attachEvent("onblur", that._listenerEvBlur);
		}
		t = null;
	}
	
	this.disableListener = function(t) {
		if (!t) return;
		t._f0 = false;
		if (this._tmListener) window.clearTimeout(this._tmListener);
		if (typeof(window.addEventListener) == "function") {
			t.removeEventListener("focus", that._listenerEvFocus, false);
			t.removeEventListener("blur", that._listenerEvBlur, false);
		} else {
			t.detachEvent("onfocus", that._listenerEvFocus);
			t.detachEvent("onblur", that._listenerEvBlur);
		}
		t = null;
	}
	
	this._startListener = function(t) {
		if (this._tmListener) window.clearTimeout(this._tmListener);
		if (typeof(t._v1) == "undefined") t._v1 = t.value;
		if (t._v1 != t.value) {
			this._updateFromInput(t);
			t._v1 = t.value;
		}
		if (t._f0) this._tmListener = window.setTimeout(function(){that._startListener(t);},100);
	}
	
	this._listenerEvFocus = function(e) {
		e = e||event;
		var t = e.target||e.srcElement;
		t._f0 = true;
		that._startListener(t)
		t = null;
	}
	this._listenerEvBlur = function(e) {
		e = e||event;
		var t = e.target||e.srcElement;
		t._f0 = false;
		t = null;
	}
	
	
	//
	for (var a in this.i) this._attachEventsToObject(a);
	
	// events
	window.dhx4._eventable(this);
	
	// event wrappers
	this._evOnArrowClick = function(args) {
		return this.callEvent("onArrowClick", args);
	}
	this._evOnClick = function(args) {
		return this.callEvent("onClick", args);
	}
	this._evOnMouseOut = function(args) {
		return this.callEvent("onMouseOut", args);
	}
	this._evOnMouseOver = function(args) {
		return this.callEvent("onMouseOver", args);
	}
	
	
	
	/* unload */
	
	this.unload = function() {
		
		this._activeDate = null;
		this._activeDateCell = null;
		this._activeInp = null;
		this._activeMonth = null;
		this._dateFormat = null;
		this._dateFormatRE = null;
		this._lastHover = null;
		
		if (this._tmListener) window.clearTimeout(this._tmListener);
		this._tmListener = null;
		
		/* main events */
		
		if (typeof(window.addEventListener) == "function") {
			document.body.removeEventListener("click", that._doOnClick, false);
			window.removeEventListener("keydown", that._doOnKeyDown, false);
			window.removeEventListener("unload", that._doOnUnload, false);
			if (this.conf.touch == true) document.body.removeEventListener("touchstart", that._doOnClick, false);
		} else {
			document.body.detachEvent("onclick", that._doOnClick);
			document.body.detachEvent("onkeydown", that._doOnKeyDown);
			window.detachEvent("onunload", that._doOnKeyDown);
		}
		
		this._doOnClick = null;
		this._doOnKeyDown = null;
		this._doOnUnload = null;
		
		/* assigned inputs */
		
		for (var a in this.i) {
			// marker
			this.i[a]._dhtmlxcalendar_uid = null;
			
			// events
			this._detachEventsFromObject(a);
			this.disableListener(this.i[a].input);
			
			this.i[a] = null;
			delete this.i[a];
			
		}
		
		this.i = null;
		
		this._doOnInpClick = null;
		this._doOnInpKeyUp = null;
		
		/* clear events */
		window.dhx4._eventable(this, "clear");
		
		/* months */
		
		this.contMonth.onselectstart = null;
		
		// li
		this.contMonth.firstChild.firstChild.onclick = null;
		this.contMonth.firstChild.firstChild.ontouchstart = null;
		
		// arrows
		this.contMonth.firstChild.firstChild.firstChild.onmouseover = null;
		this.contMonth.firstChild.firstChild.firstChild.onmouseout = null;
		this.contMonth.firstChild.firstChild.lastChild.onmouseover = null;
		this.contMonth.firstChild.firstChild.lastChild.onmouseout = null;
		
		while (this.contMonth.firstChild.firstChild.childNodes.length > 0) this.contMonth.firstChild.firstChild.removeChild(this.contMonth.firstChild.firstChild.lastChild);
		
		// li
		this.contMonth.firstChild.removeChild(this.contMonth.firstChild.firstChild);
		
		// ul
		this.contMonth.removeChild(this.contMonth.firstChild);
		
		// div
		this.contMonth.parentNode.removeChild(this.contMonth);
		this.contMonth = null;
		
		/* days */
		
		// li
		while (this.contDays.firstChild.childNodes.length > 0) this.contDays.firstChild.removeChild(this.contDays.firstChild.lastChild);
		
		// ul
		this.contDays.removeChild(this.contDays.firstChild);
		
		// div
		this.contDays.parentNode.removeChild(this.contDays);
		this.contDays = null;
		
		/* dates */
		
		this.contDates.onclick = null;
		this.contDates.ontouchstart = null;
		this.contDates.onmouseover = null;
		this.contDates.onmouseout = null;
		
		while (this.contDates.childNodes.length > 0) {
			while (this.contDates.lastChild.childNodes.length > 0) {
				// li
				this.contDates.lastChild.lastChild._css_date = null;
				this.contDates.lastChild.lastChild._css_month = null;
				this.contDates.lastChild.lastChild._css_weekend = null;
				this.contDates.lastChild.lastChild._css_hover = null;
				this.contDates.lastChild.lastChild._date = null;
				this.contDates.lastChild.lastChild._q = null;
				this.contDates.lastChild.lastChild._w = null;
				this.contDates.lastChild.removeChild(this.contDates.lastChild.lastChild);
			}
			// ul
			this.contDates.removeChild(this.contDates.lastChild);
		}
		
		// div
		this.contDates.parentNode.removeChild(this.contDates);
		this.contDates = null;
		
		/* time */
		
		this.contTime.firstChild.firstChild.onclick = null;
		this.contTime.firstChild.firstChild.ontouchstart = null;
		
		// labels
		while (this.contTime.firstChild.firstChild.childNodes.length > 0) this.contTime.firstChild.firstChild.removeChild(this.contTime.firstChild.firstChild.lastChild);
		
		// li
		this.contTime.firstChild.removeChild(this.contTime.firstChild.firstChild);
		
		// ul
		this.contTime.removeChild(this.contTime.firstChild);
		
		// div
		this.contTime.parentNode.removeChild(this.contTime);
		this.contTime = null;
		
		
		this._lastHover = null;
		
		/* selector */
		
		this._unloadSelector("month");
		this._unloadSelector("year");
		this._unloadSelector("hours");
		this._unloadSelector("minutes");
		
		// selector cover
		if (this._selCover) {
			this._selCover.parentNode.removeChild(this._selCover);
			this._selCover = null;
		}
		
		// selector object
		if (this._sel) {
			
			for (var a in this._sel._ta) this._sel._ta[a] = null;
			this._sel._ta = null;
			this._sel._t = null;
			
			this._sel.onmouseover = null;
			this._sel.onmouseout = null;
			
			// td
			while (this._sel.firstChild.firstChild.firstChild.childNodes.length > 0) {
				this._sel.firstChild.firstChild.firstChild.lastChild.onclick = null;
				this._sel.firstChild.firstChild.firstChild.lastChild.onmouseover = null;
				this._sel.firstChild.firstChild.firstChild.lastChild.onmouseout = null;
				this._sel.firstChild.firstChild.firstChild.removeChild(this._sel.firstChild.firstChild.firstChild.lastChild);
			}
			
			// tr
			this._sel.firstChild.firstChild.removeChild(this._sel.firstChild.firstChild.firstChild);
			
			// tbody
			this._sel.firstChild.removeChild(this._sel.firstChild.firstChild);
			
			// table and arrow div
			while (this._sel.childNodes.length > 0) this._sel.removeChild(this._sel.lastChild);
			
			// object
			this._sel.parentNode.removeChild(this._sel);
			this._sel = null;
		}
		
		
		/* base */
		
		this.base.onclick = null;
		this.base.onmousedown = null;
		this.base.ontouchstart = null;
		this.base.onmouseout = null;
		this.base.parentNode.removeChild(this.base);
		this.base = null;
		
		/* methods */
		
		this._clearDayHover = null;
		this._clearSelHover = null;
		this._doOnSelectorChange = null;
		this._doOnSelectorShow = null;
		this._drawMonth = null;
		this._fixLength = null;
		this._ifrSize = null;
		this._hide = null;
		this._hideSelector = null;
		this._initSelector = null;
		this._isSelectorVisible = null;
		this._isVisible = null;
		this._scrollYears = null;
		this._show = null;
		this._showSelector = null;
		this._strToDate = null;
		this._updateActiveHours = null;
		this._updateActiveMinutes = null;
		this._updateActiveMonth = null;
		this._updateActiveYear = null;
		this._updateCellStyle = null;
		this._updateDateStr = null;
		this._updateVisibleHours = null;
		this._updateVisibleMinutes = null;
		this._updateYearsList = null;
		this.enableIframe = null;
		this.hide = null;
		this.hideTime = null;
		this.setDate = null;
		this.setDateFormat = null;
		this.setYearsRange = null;
		this.show = null;
		this.showTime = null;
		this.unload = null;
		
		/* popup */
		if (this._tipPopup != null) {
			this._tipPopup.unload();
			this._tipPopup = null;
		}
		
		for (var a in this) delete this[a];
		
		a = that = null;
		
	}
	
	
	// set init date
	this.setDate(this._activeDate);
	
	return this;
};

dhtmlXCalendarObject.prototype.lang = "en";
dhtmlXCalendarObject.prototype.langData = {
	"en": {
		dateformat: "%Y-%m-%d",
		hdrformat: "%F %Y",
		monthesFNames: ["January","February","March","April","May","June","July","August","September","October","November","December"],
		monthesSNames: ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],
		daysFNames: ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],
		daysSNames: ["Su","Mo","Tu","We","Th","Fr","Sa"],
		weekstart: 1,
		weekname: "w",
		today: "Today",
		clear: "Clear"
	}
};

dhtmlXCalendarObject.prototype._buildMonthHdr = function(val) {
	var that = this;
	var z = function(t) {
		return (String(t).length==1?"0"+String(t):t);
	}
	var w = function(type, str) {
		return "<span class='dhtmlxcalendar_month_label_"+type+"'>"+str+"</span>";
	}
	var format = String(this.langData[this.lang].hdrformat||("%F %Y")).replace(/%[a-z]/gi, function(t){
		switch (t) {
			case "%m": return w("month", z(val.getMonth()+1));
			case "%n": return w("month", val.getMonth()+1);
			case "%M": return w("month", that.langData[that.lang].monthesSNames[val.getMonth()]);
			case "%F": return w("month", that.langData[that.lang].monthesFNames[val.getMonth()]);
			case "%y": return w("year", z(val.getYear()%100));
			case "%Y": return w("year", val.getFullYear());
			case "%%": return "%";
			default: return t;
		}
	});
	that = z = w = null;
	return format;
};

dhtmlXCalendarObject.prototype.enableIframe = function(mode) {
	if (mode == true) {
		if (!this._ifr) {
			this._ifr = document.createElement("IFRAME");
			this._ifr.frameBorder = 0;
			this._ifr.border = 0;
			this._ifr.setAttribute("src","javascript:false;");
			this._ifr.className = "dhtmlxcalendar_ifr";
			this._ifr.onload = function(){
				this.onload = null;
				this.contentWindow.document.open("text/html", "replace");
				this.contentWindow.document.write("<html><head><style>html,body{width:100%;height:100%;overflow:hidden;margin:0px;}</style></head><body</body></html>");
			}
			this.base.parentNode.insertBefore(this._ifr, this.base);
			this._ifrSize();
		}
	} else {
		if (this._ifr) {
			this._ifr.parentNode.removeChild(this._ifr);
			this._ifr = null;
		}
	}
};

dhtmlXCalendarObject.prototype._ifrSize = function() {
	if (this._ifr) {
		this._ifr.style.left = this.base.style.left;
		this._ifr.style.top = this.base.style.top;
		this._ifr.style.width = this.base.offsetWidth+"px";
		this._ifr.style.height = this.base.offsetHeight+"px";
	}
};

dhtmlxCalendarObject = dhtmlXCalendarObject;

dhtmlXCalendarObject.prototype._dateStrings = function() {
	var k = this.langData[this.lang];
	return {monthFullName: k.monthesFNames, monthShortName: k.monthesSNames, dayFullName: k.daysFNames, dayShortName: k.daysSNames};
};
dhtmlXCalendarObject.prototype._strToDate = function(val, format) {
	return window.dhx4.str2date(val, format||this._dateFormat, this._dateStrings());
};
dhtmlXCalendarObject.prototype._dateToStr = function(val, format) {
	return window.dhx4.date2str(val, format||this._dateFormat, this._dateStrings());
};


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

window.dhtmlxDblCalendarObject = window.dhtmlXDoubleCalendarObject = window.dhtmlXDoubleCalendar = function(parentId) {
	
	var that = this;
	
	this.leftCalendar = new dhtmlXCalendarObject(parentId);
	this.leftCalendar.hideTime();
	this.rightCalendar = new dhtmlXCalendarObject(parentId);
	this.rightCalendar.hideTime();
	
	this.leftCalendar.attachEvent("onClick", function(d){
		that._updateRange("rightCalendar", d, null);
		that._evOnClick(["left", d]);
	});
	
	this.rightCalendar.attachEvent("onClick", function(d){
		that._updateRange("leftCalendar", null, d);
		that._evOnClick(["right", d]);
	});
	
	this.leftCalendar.attachEvent("onBeforeChange", function(d){
		return that._evOnBeforeChange(["left",d]);
	});
	
	this.rightCalendar.attachEvent("onBeforeChange", function(d){
		return that._evOnBeforeChange(["right",d]);
	});
	
	this.show = function() {
		this.leftCalendar.show();
		this.rightCalendar.base.style.marginLeft=this.leftCalendar.base.offsetWidth-1+"px";
		this.rightCalendar.show();
	}
	
	this.hide = function() {
		this.leftCalendar.hide();
		this.rightCalendar.hide();
	}
	
	this.setDateFormat = function(t) {
		this.leftCalendar.setDateFormat(t);
		this.rightCalendar.setDateFormat(t);
	}
	
	this.setDates = function(d0, d1) {
		if (d0 != null) this.leftCalendar.setDate(d0);
		if (d1 != null) this.rightCalendar.setDate(d1);
		this._updateRange();
	}
	
	this._updateRange = function(obj, from, to) {
		if (arguments.length == 3) {
			(obj=="leftCalendar"?this.leftCalendar:this.rightCalendar).setSensitiveRange(from, to);
		} else {
			this.leftCalendar.setSensitiveRange(null, this.rightCalendar.getDate());
			this.rightCalendar.setSensitiveRange(this.leftCalendar.getDate(), null);
		}
	}
	
	this.getFormatedDate = function() {
		return this.leftCalendar.getFormatedDate.apply(this.leftCalendar, arguments);
	}
	
	this.unload = function() {
		
		window.dhx4._eventable(this, "clear");
		
		this.leftCalendar.unload();
		this.rightCalendar.unload();
		this.leftCalendar = this.rightCalendar = null;
		
		this._updateRange = null;
		this._evOnClick = null;
		this._evOnBeforeChange = null;
		this.show = null;
		this.hide = null;
		this.setDateFormat = null;
		this.setDates = null;
		this.getFormatedDate = null;
		this.unload = null;
		
		that = null;
	}
	
	this._evOnClick = function(args) {
		return this.callEvent("onClick", args);
	}
	this._evOnBeforeChange = function(args) {
		return this.callEvent("onBeforeChange", args);
	}
	
	window.dhx4._eventable(this);
	
	return this;
}


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXCombo(parentId, formName, width, optionType, tabIndex) {
	
	// console.info("allow html in options?");
	// console.info("add placeholder?");
	// console.info("iframe for IE6");
	
	var that = this;
	var apiObj = null;
	var skin = null;
	if (typeof(parentId) == "object" && !parentId.tagName) {
		apiObj = parentId;
		parentId = apiObj.parent;
		width = apiObj.width;
		formName = apiObj.name;
		optionType = apiObj.mode;
		skin = apiObj.skin;
	}
	
	this.cont = (typeof(parentId)=="string"?document.getElementById(parentId):parentId);
	
	this.conf = {
		skin: null,
		form_name: formName||"dhxcombo",
		combo_width: (parseInt(width)||this.cont.offsetWidth||120)-(dhx4.isFF||dhx4.isIE||dhx4.isChrome||dhx4.isOpera?2:0),
		combo_image: false,
		combo_focus: false,
		opts_type: (typeof(optionType)=="string" && typeof(this.modes[optionType]) !="undefined" ? optionType : "option"),
		opts_count: 8, // count of visible items
		opts_count_min: 3, // min count of visible items (when near screen edge)
		opts_width: null,
		item_h: null,
		list_zi_id: window.dhx4.newId(), // "dhxcombo_list_"+window.dhx4.newId(), // z-index id
		allow_free_text: true,
		allow_empty_value: true, // allow empty value in combo (when free_text not allowed)
		free_text_empty: false, // when free text not allowed and incorrect value entered restore last selected value or reset to empty
		enabled: true,
		btn_left: ((window.dhx4.isIE6||window.dhx4.isIE7||window.dhx4.isIE8) && typeof(window.addEventListener) == "undefined" ? 1:0), // 1 for IE8-
		// search in r/o mode
		ro_mode: false,
		ro_text: "",
		ro_tm: null,
		ro_tm_time: 750,
		// images
		img_path: "",
		img_def: "",
		img_def_dis: true, // if set to true - img_def used for disabled
		// templates
		template: {
			header: true,    // render header in multicolumn mode, added in 4.5.1
			input:  "#text#",// template for top-input
			option: "#text#" // template for option text
		},
		// filtering
		f_func: null,
		f_mode: false, // "start", "between"
		f_url: false,
		f_cache: false,
		f_cache_data: {},
		f_dyn: false,
		f_dyn_end: false, // check if last response have opts
		f_mask: "", // last loaded mask from server
		f_ac: true, // autocomplete if f_mode:"start" filtering mode
		f_ac_text: "",
		f_server_tm: null,
		f_server_last: "",
		f_loading: false,
		// scroll tm
		s_tm: null,
		s_time: 200,
		s_mode: "select", // type of subload request calling, 'select' last item or 'scroll' to last item
		// hover-selected
		last_hover: null,
		last_selected: null,
		last_match: null,
		last_text: "",
		last_value: "",
		tm_hover: null,
		tm_confirm_blur: null,
		// nav settings
		clear_click: false,
		clear_blur: false,
		clear_bsp: false,
		clear_key: false,
		// skin params
		i_ofs: 23, // top-image offset
		sp: {
			dhx_skyblue: {list_ofs: 1, hdr_ofs: 1, scr_ofs: 1},
			dhx_web: {list_ofs: 0, hdr_ofs: 1, scr_ofs: 0},
			dhx_terrace: {list_ofs: 1, hdr_ofs: 1, scr_ofs: 1},
			material: {list_ofs: 0, hdr_ofs: 1, scr_ofs: 1}
		},
		// autowidth for columns mode
		col_w: null
	};
	
	this.conf.combo_image = (this.modes[this.conf.opts_type].image==true);
	
	this.t = {}; // options will here
	
	this.base = document.createElement("DIV");
	//this.base.className = "dhxcombo_"+this.conf.skin;
	
	this.base.style.width = this.conf.combo_width+"px";
	this.base.innerHTML = "<input type='text' class='dhxcombo_input' style='width:"+(this.conf.combo_width-(this.conf.i_ofs+1)-(this.conf.combo_image?this.conf.i_ofs:0))+"px;"+(this.conf.combo_image?"margin-left:"+this.conf.i_ofs+"px;":"")+"' autocomplete='off'>"+
				"<input type='hidden' value=''>"+ // value
				"<input type='hidden' value='false'>"+ // new_value
				"<div class='dhxcombo_select_button'><div class='dhxcombo_select_img'></div></div>"+
				(this.conf.combo_image?"<div class='dhxcombo_top_image'>"+this.modes[this.conf.opts_type].getTopImage(null, this.conf.enabled)+"</div>":"");
	this.cont.appendChild(this.base);
	
	this.list = document.createElement("DIV");
	this.list._listId = window.dhx4.newId(); // used when combo attached to popup
	this.list.style.display = "none";
	document.body.insertBefore(this.list, document.body.firstChild);
	
	// auto-subload logic
	this._doOnListScroll = function() {
		if (that.conf.s_tm != null) window.clearTimeout(that.conf.s_tm);
		that.conf.s_tm = window.setTimeout(that._doOnListScrollAction, that.conf.s_time);
	}
	this._doOnListScrollAction = function() {
		that.conf.s_tm = null;
		if (that.conf.s_mode == "scroll" && that.list.scrollHeight - that.list.scrollTop - 10 < that.list.clientHeight) {
			that._subloadRequest();
		}
	}
	if (typeof(window.addEventListener) == "function") {
		this.list.addEventListener("scroll", this._doOnListScroll, false);
	} else {
		this.list.attachEvent("onscroll", this._doOnListScroll);
	}
	
	// apply skin
	this.setSkin(skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxcombo")||"material");
	
	this._updateTopImage = function(id) {
		
		if (!this.conf.combo_image) return;
		
		if (id != null) {
			this.base.lastChild.innerHTML = this.t[id].obj.getTopImage(this.t[id].item, this.conf.enabled);
		} else {
			this.base.lastChild.innerHTML = this.modes[this.conf.opts_type].getTopImage(null, this.conf.enabled);
		}
		 
	}
	
	/* filtering */
	
	this._filterOpts = function(hiddenMode) {
		
		if (this.conf.f_server_tm) window.clearTimeout(this.conf.f_server_tm);
		
		var k = String(this.base.firstChild.value).replace(new RegExp(this._fixRE(this.conf.f_ac_text)+"$","i"),"");
		
		
		if (this.conf.f_server_last == k.toLowerCase()) {
			this._checkForMatch();
			return;
		}
		
		// check if user-filter specified
		if (this.conf.f_url != null && this.checkEvent("onDynXLS")) {
			this.conf.f_server_last = k.toLowerCase();
			this.callEvent("onDynXLS", [k]);
			return;
		}
		
		if (this.conf.f_url != null) {
			// server
			if (k.length == 0) {
				this.conf.f_server_last = k.toLowerCase();
				this.clearAll();
				return;
			}
			// check cache
			if (this.conf.f_cache == true && this.conf.f_cache_data[k] != null) {
				// load from cache
				this.clearAll();
				this.conf.f_server_last = k.toLowerCase();
				for (var q=0; q<this.conf.f_cache_data[k].data.length; q++) {
					this.load(this.conf.f_cache_data[k].data[q]);
				}
				if (this.conf.f_dyn) {
					this.conf.f_dyn_end = this.conf.f_cache_data[k].dyn_end;
					this.conf.f_mask = this.conf.f_cache_data[k].mask;
				}
				if (hiddenMode !== true) {
					this._showList(true);
					this._checkForMatch();
				}
			} else {
				this.conf.f_server_tm = window.setTimeout(function(){
					that.conf.f_server_last = k.toLowerCase();
					that.conf.f_mask = k;
					var params = "mask="+encodeURIComponent(k);
					if (that.conf.f_dyn) {
						params += "&pos=0";
						that.conf.f_dyn_end = false;
					}
					var callBack = function(r) {
						// cache
						if (that.conf.f_cache) {
							if (!that.conf.f_cache_data[k]) that.conf.f_cache_data[k] = {data:[],dyn_end:false,mask:k};
							that.conf.f_cache_data[k].data.push(r.xmlDoc.responseXML);
						}
						// load opts
						that.clearAll();
						that.load(r.xmlDoc.responseXML);
						
						var v = (that.base.offsetWidth > 0 && that.base.offsetHeight > 0);
						if (v == true && that.conf.enabled == true && that.conf.combo_focus == true && hiddenMode !== true) {
							// autocomplete if any
							if (that.conf.f_ac && that.conf.f_mode == "start" && that.conf.clear_bsp == false && that.list.firstChild != null) {
								// autocomplete
								var sid = that.list.firstChild._optId;
								var text = String(that.t[sid].obj.getText(that.list.firstChild, true));
								if (k == that.base.firstChild.value && String(text).toLowerCase().indexOf(String(k).toLowerCase()) === 0) {
									that.base.firstChild.value = text;
									that.conf.f_ac_text = text.substr(k.length);
									that._selectRange(k.length, text.length);
								}
							}
							that._showList(true);
							that._checkForMatch();
						}
						callBack = null;
					}
					if (window.dhx4.ajax.method == "post") {
						window.dhx4.ajax.post(that.conf.f_url, params, callBack);
					} else if (window.dhx4.ajax.method == "get") {
						window.dhx4.ajax.get(that.conf.f_url+(String(that.conf.f_url).indexOf("?")>=0?"&":"?")+params, callBack);
					}
				},200);
			}
		} else {
			// client
			this.conf.f_server_last = k.toLowerCase();
			
			var r = (k.length==0?true:new RegExp((this.conf.f_mode=="start"?"^":"")+this._fixRE(k),"i"));
			
			var acText = null;
			
			for (var a in this.t) {
				var t = false;
				if (r !== true) {
					if (this.conf.f_func != null) {
						var option = this._getOption(this.t[a].item._optId, q);
						t = (this.conf.f_func.apply(window, [k, option]) == true);
					} else {
						var text = this.t[a].obj.getText(this.t[a].item, true);
						t = (r.test(text) == true);
					}
				}
				if (r === true || t == true) {
					this.t[a].item.style.display = "";
					if (acText == null && k.length > 0) acText = String(this.t[a].obj.getText(this.t[a].item, true));
				} else {
					this.t[a].item.style.display = "none";
				}
			}
			
			if (this.conf.f_ac && this.conf.f_mode == "start" && this.conf.clear_bsp == false && acText != null) {
				this.conf.f_ac_text = acText.replace(new RegExp("^"+k,"i"),"");
				this.base.firstChild.value = acText;
				this._selectRange(this.conf.f_server_last.length, this.base.firstChild.value.length);
			}
			
			// if any text selected and backspace pressed - clear highlight
			// usefull for "between" mode
			if (this.conf.f_mode == "between" && this.conf.clear_bsp == true) {
				this._checkForMatch(true);
			}
			
			if (hiddenMode !== true) {
				this._showList(true);
				this._checkForMatch();
			}
		}
	}
	
	this._searchRO = function(s) {
		if (this.conf.ro_tm) window.clearTimeout(this.conf.ro_tm);
		this.conf.ro_text += s;
		this._showList();
		for (var q=0; q<this.list.childNodes.length; q++) {
			var sid = this.list.childNodes[q]._optId;
			var text = String(this.t[sid].obj.getText(this.list.childNodes[q], true)).toLowerCase();
			if (text.indexOf(this.conf.ro_text) === 0) {
				this._setSelected(sid, true, true);
				this._confirmSelect("script", false);
				break;
			}
		}
		this.conf.ro_tm = window.setTimeout(function(){that.conf.ro_text="";}, this.conf.ro_tm_time);
	}
	
	this._fixRE = function(t) {
		return String(t).replace(/[\\\^\$\*\+\?\.\(\)\|\{\}\[\]]/gi, "\\$&");
	}
	
	// data loading
	this._initObj = function(data) {
		if (typeof(data.template) != "undefined") this.setTemplate(data.template);
		if (data.add != true && this.conf.f_loading != true) this.clearAll(false);
		this.addOption(data.options);
	}
	
	this._xmlToObj = function(data, selectToObj, selectedIndex) {
		
		/*
		xml format:
		<complete add="true">
			<template>
				<input>...</input>
				<option>...</option>
				<header>false</header> <!-- do not render header for multi-column mode, in 4.5.1 -->
				<columns>
					<column width="..." css="option css optional">
						<header>text in header</header>
						<option>template for text in option cell</option>
					</column>
				</columns>
			</template>
			<option value="xx" selected="1" img_src="icon_url" checked="1" css="some text">option text</option>
		</complete>
		
		img_src - also add the 4th parameter to combobox constructor - "image"
		checked - checkbox state, for combo with "checkbox" type, 0 by default
		*/
		
		var t = {add:false,options:[]};
		
		var root = (selectToObj==true?data:data.getElementsByTagName("complete"));
		
		if (root.length > 0) {
			if (window.dhx4.s2b(root[0].getAttribute("add")) == true) t.add = true;
			var nodes = root[0].childNodes;
			for (var q=0; q<nodes.length; q++) {
				if (typeof(nodes[q].tagName) != "undefined") {
					
					// template
					if (String(nodes[q].tagName).toLowerCase() == "template") {
						
						var template = {};
						
						for (var w=0; w<nodes[q].childNodes.length; w++) {
							
							var n = nodes[q].childNodes[w];
							
							if (n.tagName != null) {
								
								// default values
								var k = n.tagName;
								if (typeof(this.conf.template[k]) != "undefined") {
									template[k] = window.dhx4._xmlNodeValue(n);
								}
								
								// columns if any
								if (k == "columns") {
									for (var e=0; e<n.childNodes.length; e++) {
										
										var col = n.childNodes[e];
										
										if (col.tagName != null && col.tagName == "column") {
											
											var colData = {};
											
											// attrs
											// <column width="xx" css="xx" header="xx" option="xx"/>
											for (var a in {width:1, css:1, header:1, option:1}) {
												if (col.getAttribute(a) != null) colData[a] = col.getAttribute(a);
											}
											
											// extra header and option if any
											// <column><option><header>..</header><option>..</option></column>
											for (var a in {header:1, option:1}) {
												var h = col.getElementsByTagName(a);
												if (h[0] != null && h[0].firstChild != null) colData[a] = window.dhx4._xmlNodeValue(h[0]);
											}
											
											if (template.columns == null) template.columns = [];
											template.columns.push(colData);
											
										}
										
										col = null;
										
									}
									
								}
							}
							n = null;
						}
						this.setTemplate(template);
					}
					// option
					if (String(nodes[q].tagName).toLowerCase() == "option") {
						var optSelected = false;
						if (selectToObj == true) {
							optSelected = (t.options.length==selectedIndex);
						} else {
							optSelected = window.dhx4.s2b(nodes[q].getAttribute("selected"));
						}
						var opt = {
							value: nodes[q].getAttribute("value"),
							text: window.dhx4._xmlNodeValue(nodes[q]),
							selected: optSelected,
							checked: window.dhx4.s2b(nodes[q].getAttribute("checked"))
						};
						// images
						for (var a in {img:1,img_dis:1,img_src:1,img_src_dis:1,css:1}) {
							if (nodes[q].getAttribute(a) != null) opt[a] = nodes[q].getAttribute(a);
						}
						// text
						for (var w=0; w<nodes[q].childNodes.length; w++) {
							if (nodes[q].childNodes[w].tagName != null && String(nodes[q].childNodes[w].tagName).toLowerCase() == "text") {
								opt.text = {};
								var n = nodes[q].childNodes[w];
								for (var e=0; e<n.childNodes.length; e++) {
									if (n.childNodes[e].tagName != null) {
										opt.text[n.childNodes[e].tagName] = window.dhx4._xmlNodeValue(n.childNodes[e]);
									}
								}
							}
						}
						t.options.push(opt);
					}
				}
			}
			root = nodes = null;
		}
		return t;
	}
	
	window.dhx4._enableDataLoading(this, "_initObj", "_xmlToObj", "complete", {data:true});
	window.dhx4._eventable(this);
	
	
	this._getNearItem = function(item, dir) {
		// return nearest next/prev visible item or null
		var sid = null;
		while (item != null) {
			item = item[dir<0?"previousSibling":"nextSibling"];
			if (sid == null && item != null && item.style.display == "" && item._optId != null) {
				sid = item;
				item = null;
			}
		}
		return sid;
	}
	
	this.setName(this.conf.form_name);
	
	// list hightlight/select
	this._doOnListMouseMove = function(e) {
		e = e||event;
		var t = e.target||e.srcElement;
		while (t != null && t != this) {
			if (typeof(t._optId) != "undefined") {
				if (that.conf.tm_hover) window.clearTimeout(that.conf.tm_hover);
				that._setSelected(t._optId, false, false, true);
			}
			t = t.parentNode;
		}
		t = null;
	}
	
	this._doOnListMouseDown = function(e) {
		e = e||event;
		e.cancelBubble = true;
		that.conf.clear_click = true;
		window.setTimeout(function(){that.base.firstChild.focus();},1);
	}
	
	this._doOnListMouseUp = function(e) {
		// select new item
		e = e||event;
		if (e.button != that.conf.btn_left) return;
		var t = e.target||e.srcElement;
		while (t != null && t != this) {
			if (typeof(t._optId) != "undefined") {
				var r = true;
				if (typeof(that.t[t._optId].obj.optionClick) == "function" && that.t[t._optId].obj.optionClick(t, e, that) !== true) r = false;
				if (r) {
					that._setSelected(t._optId, null, true);
					that._confirmSelect("click");
				}
			}
			t = t.parentNode;
		}
		t = null;
	}
	
	this._doOnListMouseOut = function(e) {
		// when cursor out of item - clear hover or highlight selected
		if (that.conf.tm_hover) window.clearTimeout(that.conf.tm_hover);
		that.conf.tm_hover = window.setTimeout(function(){
			// select last selected
			var sId = that.conf.last_match||that.conf.last_selected;
			if (that.conf.last_match == null && that.t[sId] != null) {
				// but if no match found, check if entered text is same as in option
				if (that.base.firstChild.value != that.t[sId].obj.getText(that.t[sId].item, true)) sId = null;
			}
			that._setSelected(sId, null, true, true);
		},1);
	}
	
	this._doOnBaseMouseDown = function(e) {
		
		if (!that.conf.enabled) return;
		
		that.conf.clear_click = true;
		
		e = e||event;
		if (e.button != that.conf.btn_left) return;
		
		var t = e.target||e.srcElement;
		if (t != this.firstChild) {
			// focus input if list opened by clicking on arrow
			window.setTimeout(function(){that.base.firstChild.focus();},1);
			
			// top-image click?
			var p = t;
			while (p != this && p != null) {
				if (p == this.lastChild) {
					if (typeof(that.modes[that.conf.opts_type].topImageClick) == "function") {
						var t_id = (that.conf.last_hover||that.conf.last_selected);
						var t_item = (t_id != null?that.t[t_id].item:null);
						if (that.modes[that.conf.opts_type].topImageClick(t_item, that) !== true) {
							t_id = t_item = null;
							return;
						}
					}
					p = null;
				} else {
					p = p.parentNode;
				}
			}
			
		}
		
		if (that._isListVisible()) {
			that._hideList();
		} else {
			if (t != this.firstChild) that.conf.clear_blur = true;
			that._showList();
			that._setSelected(that.conf.last_selected, true, true);
		}
		t = null;
	}
	
	// body click -> hide list if any
	this._doOnBodyMouseDown = function() {
		if (that.conf.clear_click) {
			that.conf.clear_click = false;
			return;
		}
		that._confirmSelect("blur");
	}
	
	// input focus/blur
	this._doOnInputFocus = function() {
		that.conf.clear_blur = false;
		// if forus back to input - cancel confirm (occured when user clicked on arrow while list opened)
		if (that.conf.tm_confirm_blur) window.clearTimeout(that.conf.tm_confirm_blur);
		// ev
		if (that.conf.combo_focus == false) {
			that.conf.combo_focus = true;
			if (that.conf.skin == "material" && that.base.className.match(/dhxcombo_actv/) == null) {
				that.base.className += " dhxcombo_actv";
			}
			that.callEvent("onFocus",[]);
		}
	}
	this._doOnInputBlur = function() {
		if (that.conf.clear_blur == true) {
			that.conf.clear_blur = false;
			return;
		}
		// start confirm tm
		if (that.conf.tm_confirm_blur) window.clearTimeout(that.conf.tm_confirm_blur);
		that.conf.tm_confirm_blur = window.setTimeout(function(){
			if (that.conf.clear_click == false) {
				// if (that._isListVisible()) that._hideList();
				that._confirmSelect("blur");
				that.conf.combo_focus = false;
				if (that.conf.skin == "material" && that.base.className.match(/dhxcombo_actv/) != null) {
					that.base.className = that.base.className.replace(/\s*dhxcombo_actv/gi, "");
				}
				that.callEvent("onBlur",[]);
			}
		},20);
	}
	
	// input events, typing/filtering
	this._doOnInputKeyUp = function(e) {
		
		e = e||event;
		
		if (that.conf.f_mode != false) {
			that.conf.clear_bsp = (e.keyCode==8||e.keyCode==46); // backspace(8) and delete(46)
			that._filterOpts();
			return;
		} else {
			that._checkForMatch();
		}
	}
	
	this._doOnInputKeyDown = function(e) {
		
		e = e||event;
		
		// console.log("onkeypress ", e.keyCode, " ", e.charCode)
		
		// up (38) /down (40)
		if ((e.keyCode == 38 || e.keyCode == 40) && !e.ctrlKey && !e.shiftKey && !e.altKey) {
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			e.cancelBubble = true;
			that._keyOnUpDown(e.keyCode==38?-1:1);
		}
		
		// F2
		if (e.keyCode == 113) {
			if (!that._isListVisible()) {
				that._showList();
				if (that.base.firstChild.value == that.conf.last_text) {
					that._setSelected(that.conf.last_selected, true, true);
					that.base.firstChild.value = that.conf.last_text;
					that.conf.f_server_last = that.base.firstChild.value.toLowerCase();
				} else {
					that.conf.f_server_last = that.base.firstChild.value.toLowerCase();
					if (that.conf.f_mode == false) that._checkForMatch();
				}
			} else {
				
			}
		}
		
		// esc
		if (e.keyCode == 27) {
			// cancel operation, restore last value
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			e.cancelBubble = true;
			that._cancelSelect();
		}
		
		// enter
		if (e.keyCode == 13) {
			if (e.preventDefault) e.preventDefault(); // if combo attached to form
			that._confirmSelect("kbd");
		}
		
		// selection in r/o mode
		if (that.conf.ro_mode == true && ((e.keyCode >= 48 && e.keyCode <= 57) || (e.keyCode >= 65 && e.keyCode <= 90))) {
			that._searchRO(String.fromCharCode(e.keyCode).toLowerCase());
			e.cancelBubble = true;
		}
		
		that.conf.clear_key = true;
		that.callEvent("onKeyPressed",[e.keyCode||e.charCode]);
	}
	
	this._doOnInputKeyPress = function(e) {
		if (that.conf.clear_key) {
			that.conf.clear_key = false;
			return;
		}
		e = e||event;
		that.callEvent("onKeyPressed",[e.keyCode||e.charCode]);
	}
	
	this._keyOnUpDown = function(dir) {
		
		// select(just hover) next/prev item in a list
		
		var item = null;
		if (this.conf.last_hover) {
			item = this.t[this.conf.last_hover].item;
		} else if (this.conf.last_selected) {
			item = this.t[this.conf.last_selected].item;
		}
		
		if (!item && this._getListVisibleCount() == 0) return;
		if (item != null && item.style.display != "") item = null;
		
		this._showList();
		
		if (item != null) {
			// check if item highlighted
			if (this.t[item._optId].obj.isSelected(item)) item = this._getNearItem(item, dir);
		} else {
			item = this.list.firstChild;
			if (item.style.display != "") item = this._getNearItem(item, 1);
		}
		
		if (item == null) return; // first/last
		
		this._setSelected(item._optId, true, true);
		
		if (this.conf.f_mode == false) {
			this.base.firstChild.value = this.t[item._optId].obj.getText(item, true);
		} else {
			var text = String(this.t[item._optId].obj.getText(item, true));
			if (this.conf.f_mode == "start" && this.conf.f_ac == true) {
				if (text.toLowerCase().indexOf(this.conf.f_server_last) === 0) {
					// try to find match and select part of text
					this.conf.f_ac_text = text.substring(this.conf.f_server_last.length, text.length);
					this.base.firstChild.value = text;
					this._selectRange(this.conf.f_server_last.length, this.base.firstChild.value.length);
				} else {
					// insert all text and select
					this.base.firstChild.value = text;
					this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
					this._selectRange(0, this.base.firstChild.value.length);
				}
			} else {
				// just insert text into main input
				this.base.firstChild.value = text;
				this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
			}
		}
		
		//
		item = null;
	}
	
	this.conf.evs_nodes = [
		{node: document.body, evs: {mousedown: "_doOnBodyMouseDown"}},
		{node: this.base, evs: {mousedown: "_doOnBaseMouseDown"}},
		{node: this.base.firstChild, evs: {keyup: "_doOnInputKeyUp", keydown: "_doOnInputKeyDown", keypress: "_doOnInputKeyPress", focus: "_doOnInputFocus", blur: "_doOnInputBlur"}},
		{node: this.list, evs: {mousemove: "_doOnListMouseMove", mousedown: "_doOnListMouseDown", mouseup: "_doOnListMouseUp", mouseout: "_doOnListMouseOut"}}
	];
	for (var q=0; q<this.conf.evs_nodes.length; q++) {
		for (var a in this.conf.evs_nodes[q].evs) {
			if (typeof(window.addEventListener) == "function") {
				this.conf.evs_nodes[q].node.addEventListener(a, this[this.conf.evs_nodes[q].evs[a]], false);
			} else {
				this.conf.evs_nodes[q].node.attachEvent("on"+a, this[this.conf.evs_nodes[q].evs[a]]);
			}
		}
	}
	
	
	this.unload = function() {
		
		// remove options
		this.clearAll();
		this.t = null;
		
		// detach dom events
		for (var q=0; q<this.conf.evs_nodes.length; q++) {
			for (var a in this.conf.evs_nodes[q].evs) {
				if (typeof(window.addEventListener) == "function") {
					this.conf.evs_nodes[q].node.removeEventListener(a, this[this.conf.evs_nodes[q].evs[a]], false);
				} else {
					this.conf.evs_nodes[q].node.detachEvent("on"+a, this[this.conf.evs_nodes[q].evs[a]]);
				}
				this.conf.evs_nodes[q].evs[a] = null;
				delete this.conf.evs_nodes[q].evs[a];
			}
			this.conf.evs_nodes[q].node = null;
			this.conf.evs_nodes[q].evs = null;
			delete this.conf.evs_nodes[q].node;
			delete this.conf.evs_nodes[q].evs;
			this.conf.evs_nodes[q] = null;
		}
		
		window.dhx4._eventable(this, "clear");
		window.dhx4._enableDataLoading(this, null, null, null, "clear");
		
		this._mcDetachHeader();
		
		// depr
		this.DOMelem_input = this.DOMelem_button = this.DOMlist = this.DOMelem = this.DOMParent = null;
		
		for (var a in this.conf) {
			this.conf[a] = null;
			delete this.conf[a];
		}
		this.conf = null;
		
		if (typeof(window.addEventListener) == "function") {
			this.list.removeEventListener("scroll", this._doOnListScroll, false);
		} else {
			this.list.detachEvent("onscroll", this._doOnListScroll);
		}
		
		this.base.parentNode.removeChild(this.base);
		this.list.parentNode.removeChild(this.list);
		this.base = this.list = this.cont = null;
		
		this.modes = null;
		
		for (var a in this) {
			if (typeof(this[a]) == "function") this[a] = null;
		}
		
		that = null;
		
	};
	
	// DEPRECATED props
	this.DOMelem_input = this.base.firstChild; // 3.6 compat, use getInput()
	this.DOMelem_button = this.base.childNodes[this.base.childNodes.length-(this.conf.combo_image?2:1)]; // 3.6 compat, use getButton()
	this.DOMlist = this.list; // 3.6 compat, use getList()
	this.DOMelem = this.base; // 3.6 compat, use getBase()
	this.DOMParent = parentId; // 3.0 compat, use getParent()
	parentId = null;
	
	// check for object api init details
	if (apiObj != null) {
		// filter
		if (apiObj.filter != null) {
			if (typeof(apiObj.filter) == "string") {
				this.enableFilteringMode(true, apiObj.filter, window.dhx4.s2b(apiObj.filter_cache), window.dhx4.s2b(apiObj.filter_sub_load));
			} else {
				this.enableFilteringMode(true);
			}
		}
		// imgs
		if (apiObj.image_path != null) this.setImagePath(apiObj.image_path);
		if (apiObj.default_image != null || apiObj.default_image_dis != null) this.setDefaultImage(apiObj.default_image, apiObj.default_image_dis);
		// opts
		if (apiObj.items || apiObj.options) this.addOption(apiObj.items||apiObj.options);
		if (apiObj.xml || apiObj.json) this.load(apiObj.xml||apiObj.json);
		// misc
		if (typeof(apiObj.readonly) != "undefined") this.readonly(apiObj.readonly);
		//
		apiObj = null;
	}
	
	return this;
	
};

function dhtmlXComboFromSelect(selectId) {
	
	// <select mode="checkbox">
	
	if (typeof(selectId) == "string") selectId = document.getElementById(selectId);
	
	// collect params
	var comboWidth = selectId.offsetWidth;
	var formName = selectId.getAttribute("name")||null;
	
	// add node
	var comboNode = document.createElement("SPAN");
	selectId.parentNode.insertBefore(comboNode, selectId);
	
	// combo mode
	var comboMode = selectId.getAttribute("mode")||selectId.getAttribute("opt_type")||"option";
	
	// init combo
	var combo = new dhtmlXCombo(comboNode, formName, comboWidth, comboMode);
	comboNode = null;
	
	var imagePath = selectId.getAttribute("imagePath");
	if (imagePath) combo.setImagePath(imagePath);
	
	var defImg = selectId.getAttribute("defaultImage");
	var defImgDis = selectId.getAttribute("defaultImageDis");
	if (window.dhx4.s2b(defImgDis) == true) defImgDis = true;
	if (defImg != null || defImgDis != null) combo.setDefaultImage(defImg, defImgDis);
	
	// options
	var opts = combo._xmlToObj([selectId], true, selectId.selectedIndex);
	if (opts.options.length > 0) combo.addOption(opts.options);
	opts = null;
	
	// remove select
	selectId.parentNode.removeChild(selectId);
	selectId = null;
	
	return combo;
};

/* common funcs */
dhtmlXCombo.prototype.setName = function(name) { // change name for form
	this.conf.form_name = name;
	this.base.childNodes[1].name = name;
	this.base.childNodes[2].name = name.replace(/(\[.*)?$/, "_new_value$1");
};

dhtmlXCombo.prototype.readonly = function(mode) { // enable/disable readonly mode
	if (window.dhx4.s2b(mode)) {
		this.base.firstChild.setAttribute("readOnly", "true");
		this.conf.ro_mode = true;
	} else {
		this.base.firstChild.removeAttribute("readOnly");
		this.conf.ro_mode = false;
	}
};

dhtmlXCombo.prototype.setPlaceholder = function(text) { // new in 4.0, limited support
	if (typeof(text) == "undefined" || text == null) text = "";
	this.base.firstChild.setAttribute("placeholder", String(text));
};

dhtmlXCombo.prototype.setTemplate = function(tpl) {
	for (var a in tpl) {
		if (typeof(this.conf.template[a]) != "undefined") {
			if (a == "header") {
				this.conf.template[a] = window.dhx4.s2b(tpl[a]);
			} else {
				this.conf.template[a] = String(tpl[a]);
			}
		}
	};
	
	// columns
	if (tpl.columns != null) {
		this._mcMakeTemplate(tpl.columns);
	} else {
		this._mcDetachHeader();
	}
	
	// template changed, update combo text and update rendered options
	for (var a in this.t) {
		this.t[a].obj.setText(this.t[a].item, this.t[a].item._conf.text);
	};
	this._confirmSelect();
};

dhtmlXCombo.prototype.setSkin = function(skin) {
	if (skin == this.conf.skin) return;
	this.conf.skin = skin;
	this.base.className = "dhxcombo_"+this.conf.skin+(this.conf.enabled?"":" dhxcombo_disabled");
	this.list.className = "dhxcombolist_"+this.conf.skin+(this.hdr!=null?" dhxcombolist_multicolumn":"");
	if (this.hdr != null) this.hdr.className = "dhxcombolist_"+this.conf.skin+" dhxcombolist_hdr";
	this.conf.i_ofs = (skin == "material"?26:23);
	this._adjustBase();
};

dhtmlXCombo.prototype.getInput = function() { // returns input, new in 4.0
	return this.base.firstChild;
};
dhtmlXCombo.prototype.getButton = function() { // returns button, new in 4.0
	return this.base.childNodes[this.base.childNodes.length-(this.conf.combo_image?2:1)];
};
dhtmlXCombo.prototype.getList = function() { // do we need it?
	return this.list;
};
dhtmlXCombo.prototype.getBase = function() { // do we need it?
	return this.base;
};

dhtmlXCombo.prototype.getParent = function() { // do we need it?
	return this.DOMParent;
};

dhtmlXCombo.prototype.forEachOption = function(handler) { // iterator, new in 4.0
	for (var q=0; q<this.list.childNodes.length; q++) {
		handler.apply(window, [this._getOption(this.list.childNodes[q]._optId, q)]);
	}
};

dhtmlXCombo.prototype.setFocus = function() {
	if (this.conf.enabled) this.base.firstChild.focus();
};
dhtmlXCombo.prototype.setFontSize = function(sizeInp, sizeList) {
	// "11px" or" "0.9em"
	if (sizeInp != null) this.base.firstChild.style.fontSize = sizeInp;
	if (sizeList != null) this.list.style.fontSize = sizeList;
};

/* options */
dhtmlXCombo.prototype.getOption = function(value) { // option by value
	var id = null;
	var index = null;
	for (var q=0; q<this.list.childNodes.length; q++) {
		if (id == null) {
			var a = this.list.childNodes[q]._optId;
			if (this.t[a].obj.getValue(this.t[a].item) == value) { id = a; index = q; }
		}
	}
	return (id==null?null:this._getOption(id, index));
};

dhtmlXCombo.prototype.getOptionByIndex = function(index) { // option by index
	if (index < 0) return null;
	if (this.list.childNodes[index] == null) return null;
	return this._getOption(this.list.childNodes[index]._optId, index);
};

dhtmlXCombo.prototype.getOptionByLabel = function(text) { // rename to getOptionByText ?
	// option by label
	var id = null;
	var index = null;
	for (var q=0; q<this.list.childNodes.length; q++) {
		if (id == null) {
			var a = this.list.childNodes[q]._optId;
			if (this.t[a].obj.getText(this.t[a].item, true) == text) { id = a; index = q; }
		}
	}
	return (id==null?null:this._getOption(id, index));
};

dhtmlXCombo.prototype.getSelectedIndex = function() { // gets index of selected option
	return this._getOptionProp(this.conf.last_selected, "index", -1);
};

dhtmlXCombo.prototype.getSelectedText = function() { // gets text of selected option
	return this._getOptionProp(this.conf.last_selected, "text", "");
};

dhtmlXCombo.prototype.getSelectedValue = function() { // gets value of selected item
	return this._getOptionProp(this.conf.temp_selected||this.conf.last_selected, "value", null);
};

dhtmlXCombo.prototype.getActualValue = function() { // gets value which will be sent with form
	return this.base.childNodes[1].value;
};
dhtmlXCombo.prototype.getComboText = function() { // gets current text in combobox
	return this.base.childNodes[0].value;
};

dhtmlXCombo.prototype.getIndexByValue = function(value) { // returns index of item by value
	var t = this.getOption(value);
	return (t!=null?t.index:-1);
};

dhtmlXCombo.prototype.setComboText = function(text) {
	// sets text in combobox, reset selected option
	if (this.conf.allow_free_text != true) return;
	
	this.unSelectOption();
	this.conf.last_text = this.base.firstChild.value = text;
	this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
	
};

dhtmlXCombo.prototype.setComboValue = function(value) {
	// sets text in combobox, only text
	var t = this.getOption(value);
	if (t != null) {
		this.selectOption(t.index);
	} else {
		this.conf.last_value = value;
		this.base.childNodes[1].value = this.conf.last_value;
		this.base.childNodes[2].value = "true";
	}
};

dhtmlXCombo.prototype.selectOption = function(index, filter, conf) { // selects option
	if (index < 0 || index >= this.list.childNodes.length) return;
	var id = this.list.childNodes[index]._optId;
	this._setSelected(id, this._isListVisible(), true);
	this._confirmSelect("script");
};

dhtmlXCombo.prototype.unSelectOption = function() { // unselects option
	
	if (this.conf.last_hover != null) {
		this.t[this.conf.last_hover].obj.setSelected(this.t[this.conf.last_hover].item, false);
		this.conf.last_hover = null;
	}
	
	this.base.firstChild.value = "";
	
	if (this.conf.f_mode != false) {
		this._filterOpts(true);
	}
	this._hideList();
	this._updateTopImage(null);
	
	this._confirmSelect("script");
	
};

dhtmlXCombo.prototype.confirmValue = function() {
	this._confirmSelect("script");
};

/* enable/disable */
dhtmlXCombo.prototype.enable = function(mode) {
	
	mode = (typeof(mode)=="undefined"?true:window.dhx4.s2b(mode));
	if (this.conf.enabled == mode) return;
	
	this.conf.enabled = mode;
	
	if (mode) {
		this.base.className = "dhxcombo_"+this.conf.skin;
		this.base.firstChild.removeAttribute("disabled");
	} else {
		this._hideList();
		this.base.className = "dhxcombo_"+this.conf.skin+" dhxcombo_disabled";
		this.base.firstChild.setAttribute("disabled","true");
	}
	
	// update disabled image if any
	this._updateTopImage(this.conf.last_selected);
};

dhtmlXCombo.prototype.disable = function(mode) {
	mode = (typeof(mode)=="undefined"?true:window.dhx4.s2b(mode));
	this.enable(!mode);
};

dhtmlXCombo.prototype.isEnabled = function() {
	return (this.conf.enabled==true);
};

/* visibility */
dhtmlXCombo.prototype.show = function(mode) {
	if (typeof(mode) == "undefined") mode = true; else mode = window.dhx4.s2b(mode);
	this.base.style.display = (mode==true?"":"none");
};

dhtmlXCombo.prototype.hide = function(mode) {
	if (typeof(mode) == "undefined") mode = true;
	this.show(!mode);
};

dhtmlXCombo.prototype.isVisible = function() {
	return (this.base.style.display=="");
};


/* filtering */
dhtmlXCombo.prototype.setFilterHandler = function(f) {
	if (typeof(f) == "function") {
		this.conf.f_func = f;
		this.conf.f_mode = true;
		this.conf.f_dyn = this.conf.f_cache = this.conf.f_url = null;
	} else if (typeof(f) == "string" && typeof(window[f]) == "function") {
		this.conf.f_func = window[f];
		this.conf.f_mode = true;
		this.conf.f_dyn = this.conf.f_cache = this.conf.f_url = null;
	} else {
		this.conf.f_func = null;
	}
};
dhtmlXCombo.prototype.enableFilteringMode = function(mode, url, cache, dyn) {
	if (mode == true || mode == "between") {
		this.conf.f_mode = (mode==true?"start":"between");
		if (url != null) {
			this.conf.f_url = url;
			this.conf.f_cache = window.dhx4.s2b(cache);
			this.conf.f_dyn = window.dhx4.s2b(dyn);
		} else {
			this.conf.f_url = null;
			this.conf.f_cache = false;
			this.conf.f_dyn = false;
		}
	} else {
		this.conf.f_mode = false;
		this.conf.f_url = null;
		this.conf.f_cache = false;
		this.conf.f_dyn = false;
	}
};

dhtmlXCombo.prototype.filter = function(handler, showList) { // new in 4.0
	for (var q=0; q<this.list.childNodes.length; q++) {
		var k = handler.apply(window, [this._getOption(this.list.childNodes[q]._optId,q)]);
		this.list.childNodes[q].style.display = (k===true?"":"none");
	}
	if (typeof(showList) == "undefined" || showList == true) {
		this._showList(true);
	}
};

dhtmlXCombo.prototype.sort = function(mode) { // new in 4.0
	var r = [];
	for (var q=0; q<this.list.childNodes.length; q++) {
		var id = this.list.childNodes[q]._optId;
		r.push([id, this._getOption(id, q)]);
	}
	// sort
	if (mode == "asc" || mode == "desc") {
		k = true;
		r.sort(function(a,b){
			a = a[1].text_option.toLowerCase();
			b = b[1].text_option.toLowerCase();
			var r = (mode=="asc"?1:-1);
			return (a>b?r:-1*r);
		});
	} else if (typeof(mode) == "function" || typeof(window[mode]) == "function") {
		if (typeof(window[mode]) == "function") mode = window[mode];
		r.sort(function(a,b){
			return mode.apply(window, [a[1],b[1]]);
		});
	}
	// reorder
	while (this.list.childNodes.length > 0) this.list.removeChild(this.list.lastChild);
	for (var q=0; q<r.length; q++) this.list.appendChild(this.t[r[q][0]].item);
};

dhtmlXCombo.prototype.enableAutocomplete = function(mode) { // autocomplete for f_mode:start, enabled by default
	if (typeof(mode) == "undefined") mode = true; else mode = window.dhx4.s2b(mode);
	this.conf.f_ac = mode;
};
dhtmlXCombo.prototype.disableAutocomplete = function(mode) {
	if (typeof(mode) == "undefined") mode = true; else mode = window.dhx4.s2b(mode);
	this.enableAutocomplete(!mode);
};

dhtmlXCombo.prototype.allowFreeText = function(mode, resetToEmpty) { // new in 4.0
	this.conf.allow_free_text = (typeof(mode)=="undefined"?true:window.dhx4.s2b(mode));
	this.conf.free_text_empty = (typeof(resetToEmpty)=="undefined"?false:window.dhx4.s2b(resetToEmpty)); // 4.5.1
};

dhtmlXCombo.prototype._checkForMatch = function(forceClear) {
	// check if text matched to any opt_text for opt_hover while user entered text
	var k = window.dhx4.trim(this.base.firstChild.value).toLowerCase();
	var id = null;
	var item = this.list.firstChild;
	while (item != null) {
		if (item.style.display == "" && item._optId != null) {
			var text = window.dhx4.trim(this.t[item._optId].obj.getText(item, true)).toLowerCase();
			if (k == text) {
				id = item._optId;
				item = null;
			}
		}
		if (item != null) item = item.nextSibling;
	}
	// match found, hover item
	if (this.conf.last_match == null) {
		if (id != null) {
			// 1st match
			this._setSelected(id, true, true);
			this.conf.last_match = id;
		} else {
			// nothing found
			// clear current selection if any
			if (this.conf.f_mode != "between" || forceClear == true) {
				this._setSelected(null, true, true);
				this.conf.last_match = null;
			}
		}
	} else {
		if (id != null) {
			// another match, check if same or new
			if (id != this.conf.last_match) {
				this._setSelected(id, true, true);
				this.conf.last_match = id;
			}
		} else {
			// nothing found clear last match if hovered and selection not changed
			this._setSelected(null, true, true);
			this.conf.last_match = null;
		}
	}
	
};

dhtmlXCombo.prototype._selectRange = function(from, to) {
	if (this.conf.combo_focus == true) window.dhx4.selectTextRange(this.base.firstChild, from, to);
};

/* show/hide select list */
dhtmlXCombo.prototype.openSelect = function() { // opens list of options
	if (!this._isListVisible()) this._showList();
};

dhtmlXCombo.prototype.closeAll = function() {
	this._hideList();
};

dhtmlXCombo.prototype._showList = function(autoHide) {
	
	if (this._getListVisibleCount() == 0) {
		if (autoHide && this._isListVisible()) this._hideList();
		return;
	}
	
	if (this._isListVisible()) {
		this._checkListHeight();
		return;
	}
	
	this.list.style.zIndex = window.dhx4.zim.reserve(this.conf.list_zi_id); // get new z-index
	if (this.hdr != null && this.conf.template.header == true) this.hdr.style.zIndex = Number(this.list.style.zIndex)+1;
	
	this.list.style.visibility = "hidden";
	this.list.style.display = "";
	if (this.hdr != null && this.conf.template.header == true) {
		this.hdr.style.visibility = this.list.style.visibility;
		this.hdr.style.display = this.list.style.display;
	}
	
	// position
	var h0 = (this.hdr != null && this.conf.template.header == true ? this.hdr.offsetHeight : 0);
	
	this.list.style.width = Math.max(this.conf.opts_width||this.conf.col_w||0, this.conf.combo_width)+"px";
	this.list.style.top = window.dhx4.absTop(this.base)+h0+this.base.offsetHeight-1+"px";
	this.list.style.left = window.dhx4.absLeft(this.base)+"px";
	
	if (this.hdr != null && this.conf.template.header == true) {
		this.hdr.style.width = this.list.style.width;
		this.hdr.style.left = this.list.style.left;
		this.hdr.style.top = parseInt(this.list.style.top)-h0+"px";
	}
	
	// height
	this._checkListHeight();
	
	// check bottom overlay
	this.list.style.visibility = "visible";
	if (this.hdr != null && this.conf.template.header == true) this.hdr.style.visibility = "visible";
	
	this.callEvent("onOpen",[]);
	
};

dhtmlXCombo.prototype._hideList = function() {
	
	if (!this._isListVisible()) return;
	
	window.dhx4.zim.clear(this.conf.list_zi_id); // clear z-index
	this.list.style.display = "none";
	if (this.hdr != null && this.conf.template.header == true) this.hdr.style.display = "none";
	
	this.conf.clear_click = false;
	
	this.callEvent("onClose",[]);
	
};

dhtmlXCombo.prototype._isListVisible = function() {
	return (this.list.style.display=="");
};

dhtmlXCombo.prototype._getListVisibleCount = function() {
	var k = 0;
	for (var q=0; q<this.list.childNodes.length; q++) k += (this.list.childNodes[q].style.display==""?1:0);
	return k;
};

dhtmlXCombo.prototype._checkListHeight = function() {
	
	if (!this._isListVisible()) return;
	
	if (this.conf.item_h == null) {
		var item = this.list.firstChild;
		while (item != null) {
			if (item.style.display == "") {
				this.conf.item_h = item.offsetHeight + (this.hdr != null ? -1 : 0); // multicol rows have -1px margin
				item = null;
			} else {
				item = item.nextSibling;
			}
		}
		item = null;
	}
	
	var s = window.dhx4.screenDim();
	var by = window.dhx4.absTop(this.base);
	var bh = this.base.offsetHeight;
	var hh = (this.hdr!=null&&this.conf.template.header==true?this.hdr.offsetHeight:0); // header_height
	
	var onTop = Math.max(0, Math.floor((by+hh-s.top)/this.conf.item_h));
	var onBottom = Math.max(0, Math.floor((s.bottom-(by+bh+hh))/this.conf.item_h));
	
	var itemsCount = this._getListVisibleCount();
	
	// top/bottom detect
	if (onBottom < Math.min(this.conf.opts_count_min, itemsCount) && onTop > onBottom) onBottom = null;
	
	var itemsToShow = Math.min((onBottom==null?onTop:onBottom), this.conf.opts_count, itemsCount);
	var h = (itemsToShow<itemsCount?(itemsToShow*this.conf.item_h)+"px":"");
	
	var ofs = this.conf.sp[this.conf.skin][this.hdr!=null&&this.conf.template.header==true?"hdr_ofs":"list_ofs"];
	
	this.list.style.height = h;
	this.list.style.top = (onBottom==null?by-this.list.offsetHeight+ofs:by+bh+hh-ofs)+"px";
	if (this.hdr != null && this.conf.template.header == true) this.hdr.style.top = (onBottom==null?by-hh-this.list.offsetHeight+ofs:by+bh-ofs)+"px";
	
};

dhtmlXCombo.prototype._scrollToItem = function(id) {
	
	var y1 = this.t[id].item.offsetTop;
	var y2 = y1+this.t[id].item.offsetHeight;
	var a1 = this.list.scrollTop;
	var a2 = a1+this.list.clientHeight;
	
	if (y1 < a1) {
		// on top
		this.list.scrollTop = y1+(this.hdr!=null&&this.conf.template.header==true?1:0);
	} else if (y2 > a2) {
		// on bottom
		this.list.scrollTop = y2-this.list.clientHeight+(this.hdr!=null&&this.conf.template.header==true?-this.conf.sp[this.conf.skin].scr_ofs:0);
	}
	
};

/* in-list selection/highlighting */
dhtmlXCombo.prototype._setSelected = function(id, scrollToItem, updateImg, mouseMove) {
	
	this.conf.temp_selected = null;
	
	if (updateImg) this._updateTopImage(id);
	
	if (id != null && this.conf.last_hover == id) {
		if (scrollToItem) this._scrollToItem(id);
		return;
	}
	
	if (this.conf.last_hover != null) {
		this.t[this.conf.last_hover].obj.setSelected(this.t[this.conf.last_hover].item, false);
		this.conf.last_hover = null;
		if (id == null) this.callEvent("onSelectionChange", []);
	}
	
	if (id != null) {
		
		this.t[id].obj.setSelected(this.t[id].item, true);
		this.conf.last_hover = id;
		
		if (mouseMove != true) {
			this.conf.temp_selected = id;
			this.callEvent("onSelectionChange", []);
		}
		
		// last item selected, try subload
		if (this.conf.s_mode == "select" && this.t[id].item == this.t[id].item.parentNode.lastChild) this._subloadRequest();
		
		if (scrollToItem) this._scrollToItem(id);
		
	}
	
};

// auto-subload
dhtmlXCombo.prototype._subloadRequest = function() {
	
	if (this.conf.f_url != null && this.conf.f_dyn == true && this.conf.f_dyn_end == false) {
		
		var params = "mask="+encodeURIComponent(this.conf.f_mask)+"&pos="+this.list.childNodes.length;
		var t = this;
		var callBack = function(r){
			
			// cache
			if (t.conf.f_cache) t.conf.f_cache_data[t.conf.f_mask].data.push(r.xmlDoc.responseXML);
			var k = t.list.childNodes.length;
			
			// skip clear opts w/o add='true'
			t.conf.f_loading = true;
			t.load(r.xmlDoc.responseXML);
			t.conf.f_loading = false;
			
			// if no more opts left on server, stop dyn requests
			if (k == t.list.childNodes.length) {
				t.conf.f_dyn_end = true;
				if (t.conf.f_cache) t.conf.f_cache_data[t.conf.f_mask].dyn_end = true;
			}
			callBack = t = null;
		}
		if (window.dhx4.ajax.method == "post") {
			window.dhx4.ajax.post(this.conf.f_url, params, callBack);
		} else if (window.dhx4.ajax.method == "get") {
			window.dhx4.ajax.get(this.conf.f_url+(String(this.conf.f_url).indexOf("?")>=0?"&":"?")+params, callBack);
		}
	}
};

/* add / remove options */
dhtmlXCombo.prototype.addOption = function(value, text, css, img, selected) {
	
	// selected added in 4.0
	
	/*
	
	single option, 4 params
	z.addOption(value, text, css, img_src);
	value, text, css (css string attached to the option, optional), img_src (path to the option icon image, just for "image" combo type)
	
	several options, array of array (in this case you can't use 4th parameter img_src - improve?)
	z.addOption([["a","option A", "color:red;"],[],[],...]);
	
	several options, as an array of objects (you can use 4 parameters)
	z.addOption([{value: "a", text: "option A", img_src: "../images/blue.gif", css:"color:red;"},{},{}...]);
	
	*/
	
	var toSelect = null;
	
	if (!(value instanceof Array)) {
		// single option
		var id = this._renderOption({value:value, text:text, css:css, img:img});
		if (toSelect == null && window.dhx4.s2b(selected) == true) toSelect = id;
		
	} else {
		// array with opts
		for (var q=0; q<value.length; q++) {
			if (typeof(value[q]) == "undefined") continue;
			if (value[q] instanceof Array) {
				id = this._renderOption({value:value[q][0], text:value[q][1], css:value[q][2], img:value[q][3]});
				if (toSelect == null && window.dhx4.s2b(value[q][4]) == true) toSelect = id;
			} else {
				var id = this._renderOption(value[q]);
				if (toSelect == null && window.dhx4.s2b(value[q].selected) == true) toSelect = id;
			}
		}
	}
	
	if (toSelect != null) {
		this._setSelected(toSelect, this._isListVisible(), true);
		this._confirmSelect("onInit");
	}
};

dhtmlXCombo.prototype.updateOption = function(oldValue, newValue, newText, newCss) {
	var id = this._getOptionId(oldValue);
	if (id == null) return;
	this.t[id].obj.update(this.t[id].item, {value: newValue, text: newText, css: newCss});
	if (this.conf.last_selected == id) {
		this.conf.last_text = this.base.firstChild.value = this.t[id].obj.getText(this.t[id].item, true);
		this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
	}
};

dhtmlXCombo.prototype.deleteOption = function(value) { // deletes option by value
	
	for (var a in this.t) {
		var v = this.t[a].obj.getValue(this.t[a].item);
		if (v == value) this._removeOption(a);
	}
	
	if (this._isListVisible()) this._showList(true); // resize if any or hide if no more items left
	
};

dhtmlXCombo.prototype.clearAll = function(hideList) { // remove all options
	
	hideList = (typeof(hideList)=="undefined"?true:window.dhx4.s2b(hideList));
	for (var a in this.t) this._removeOption(a);
	
	// props
	if (this.conf.tm_hover) window.clearTimeout(this.conf.tm_hover);
	this.conf.last_hover = null;
	this.conf.last_selected = null;
	
	this.list.scrollTop = 0;
	if (hideList == true) this._hideList();
	
};

dhtmlXCombo.prototype._renderOption = function(data) {
	
	var id = window.dhx4.newId();
	var item = document.createElement("DIV");
	
	item._optId = id;
	item._tpl = this.conf.template;
	
	// wrapper for img_src/img_src_dis
	if (typeof(data.img) == "undefined" && typeof(data.img_src) != "undefined") {
		data.img = data.img_src;
		delete data.img_src;
	}
	if (typeof(data.img_dis) == "undefined" && typeof(data.img_src_dis) != "undefined") {
		data.img_dis = data.img_src_dis;
		delete data.img_src_dis;
	}
	
	data.img_path = this.conf.img_path;
	data.img_def = this.conf.img_def;
	data.img_def_dis = this.conf.img_def_dis;
	
	this.list.appendChild(item);
	
	var v = (this._isListVisible() && window.dhx4.isFF == true);
	if (v == true) {
		var k = this.list.scrollTop;
		this.list.scrollTop -= 1;
	}
	
	// if multicolumn
	if (this.hdr != null) data.multicol = true;
	
	this.t[item._optId] = {
		obj: this.modes[this.conf.opts_type].render(item, data),
		item: item,
		conf: {
			type: this.conf.opts_type
		}
	};
	item = null;
	
	if (v == true) this.list.scrollTop += 1;
	
	return id;
};

dhtmlXCombo.prototype._removeOption = function(id) {
	this.t[id].obj.destruct(this.t[id].item);
	this.t[id].obj = null;
	this.t[id].item.parentNode.removeChild(this.t[id].item);
	this.t[id].item = null;
	this.t[id].conf = null;
	this.t[id] = null;
	delete this.t[id];
	
	if (this.conf.last_hover == id) this.conf.last_hover = null;
	if (this.conf.last_selected == id) {
		this.conf.last_selected = null;
		this._confirmSelect("onDelete");
	}
};

dhtmlXCombo.prototype._confirmSelect = function(mode, hideList) {
	
	var wasChanged = false;
	if (typeof(hideList) == "undefined") hideList = true;
	
	if (this.conf.f_server_tm) window.clearTimeout(this.conf.f_server_tm);
	
	// confirm selection
	// if any item hovered - select, if not - just apply entered value
	if (this.conf.last_hover != null) {
		// select value
		wasChanged = wasChanged||(this.conf.last_value != this._getOptionValue(this.conf.last_hover));
		this.conf.last_match = this.conf.last_selected = this.conf.last_hover;
		this.conf.last_value = this._getOptionValue(this.conf.last_selected);
		this.conf.last_text = this.base.firstChild.value = this.t[this.conf.last_selected].obj.getText(this.t[this.conf.last_selected].item, true);
		this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
		// inputs
		this.base.childNodes[1].value = this.conf.last_value;
		this.base.childNodes[2].value = "false";
	} else {
		// just a text,
		// check if free text allowed
		if (this.conf.allow_free_text || (this.base.firstChild.value == "" && this.conf.allow_empty_value)) {
			wasChanged = wasChanged||(this.conf.last_text != this.base.firstChild.value);
			this.conf.last_match = this.conf.last_value = this.conf.last_selected = null;
			this.conf.last_text = this.base.firstChild.value;
			this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
			// inputs
			this.base.childNodes[1].value = this.conf.last_text;
			this.base.childNodes[2].value = "true";
		} else {
			this._cancelSelect(true);
			this._updateTopImage(this.conf.last_selected);
			return;
		}
	}
	
	if (this.conf.f_ac && this.conf.f_mode == "start") {
		this.conf.f_ac_text = "";
		if (mode != "blur") {
			this._selectRange(this.base.firstChild.value.length, this.base.firstChild.value.length);
		}
	}
	
	if (hideList) this._hideList();
	
	if (wasChanged == true && mode != "onInit" && mode != "onDelete") {
		this.callEvent("onSelectionChange", []);
		this.callEvent("onChange", [this.conf.last_value, this.conf.last_text]);
	}
	
};

dhtmlXCombo.prototype._cancelSelect = function(freeTextReset) {
	
	this._hideList();
	
	if (freeTextReset == true && this.conf.allow_free_text == false && this.conf.free_text_empty == true) {
		this.conf.f_server_last = this.conf.last_match = this.conf.last_value = this.conf.last_selected = null;
		this.base.childNodes[1].value = this.conf.last_text = this.base.firstChild.value = "";
		this.base.childNodes[2].value = "false";
	} else {
		this.base.firstChild.value = this.conf.last_text;
	}
	
	// restore filters if any
	if (this.conf.f_mode != false) {
		this._filterOpts(true);
	}
	
};


/* option object operations */
dhtmlXCombo.prototype._getOption = function(id, index) {
	
	if (!this.t[id]) return null;
	
	// autodetect index if any
	if (typeof(index) == "undefined") index = -1;
	if (index < 0) {
		for (var q=0; q<this.list.childNodes.length; q++) {
			if (index < 0 && this.list.childNodes[q]._optId == id) index = q;
		}
	}
	
	// comon data
	var t = {
		value: this.t[id].obj.getValue(this.t[id].item),
		text: this.t[id].obj.getText(this.t[id].item),
		text_input: this.t[id].obj.getText(this.t[id].item, true),
		text_option: this.t[id].obj.getText(this.t[id].item, null, true),
		css: this.t[id].obj.getCss(this.t[id].item),
		selected: (id==this.conf.last_selected),
		index: index
	};
	
	// extra data if any, for example "checked" for checkbox
	if (typeof(this.t[id].obj.getExtraData) == "function") {
		var k = this.t[id].obj.getExtraData(this.t[id].item);
		for (var a in k) { if (typeof(t[a]) == "undefined") t[a] = k[a]; }
	}
	
	return t;
};

dhtmlXCombo.prototype._getOptionProp = function(id, prop, def) { // get any property of any option
	if (id != null) {
		var t = this._getOption(id);
		if (t != null) return t[prop];
	}
	return def;
};
dhtmlXCombo.prototype._getOptionId = function(value) {
	var id = null;
	for (var q=0; q<this.list.childNodes.length; q++) {
		if (id == null) {
			var p = this.list.childNodes[q]._optId;
			if (value == this.t[p].obj.getValue(this.t[p].item)) id = p;
		}
	}
	return id;
};
dhtmlXCombo.prototype._getOptionValue = function(id) {
	return this._getOptionProp(id, "value", null);
};


dhtmlXCombo.prototype.setSize = function(width) { // changes control size
	this.conf.combo_width = parseInt(width)-(dhx4.isFF||dhx4.isIE||dhx4.isChrome||dhx4.isOpera?2:0);
	this.base.style.width = Math.max(0, this.conf.combo_width)+"px";
	this._adjustBase();
};

dhtmlXCombo.prototype._adjustBase = function() {
	this.base.firstChild.style.width = Math.max(0, (this.conf.combo_width-(this.conf.i_ofs+1)-(this.conf.combo_image?this.conf.i_ofs:0)))+"px";
	this.base.firstChild.style.marginLeft = (this.conf.combo_image?this.conf.i_ofs+"px":"0px");
};

dhtmlXCombo.prototype.setOptionWidth = function(w) { // sets width of combo list
	this.conf.opts_width = (parseInt(w)||null);
};

dhtmlXCombo.prototype.setOptionIndex = function(value, index) { // added in 4.1
	
	if (isNaN(index) || index < 0) return;
	
	var p = this.getOption(value);
	if (p == null) return;
	
	if (index == p.index) return;
	
	var t = this.list.childNodes[p.index];
	t.parentNode.removeChild(t);
	
	if (this.list.childNodes[index] != null) {
		this.list.insertBefore(t, this.list.childNodes[index]);
	} else {
		this.list.appendChild(t);
	}
	t = null;
	
};

dhtmlXCombo.prototype.getOptionsCount = function() { // added in 4.1
	return this.list.childNodes.length;
};

// multicolumn feature
dhtmlXCombo.prototype._mcMakeTemplate = function(cols) {
	
	var h = "";
	var t = "";
	
	this.conf.col_w = 0;
	
	for (var q=0; q<cols.length; q++) {
		
		var w = Number(parseInt(cols[q].width)||50);
		var css = (cols[q].css||"");
		var cssIE = (q == 0 && window.dhx4.isIE6 == true ? "_first":"");
		
		t += "<div class='dhxcombo_cell"+cssIE+" "+css+"' style='width:"+w+"px;'><div class='dhxcombo_cell_text'>"+(cols[q].option||"&nbsp;")+"</div></div>";
		h += "<div class='dhxcombo_hdrcell"+cssIE+" "+css+"' style='width:"+w+"px;'><div class='dhxcombo_hdrcell_text'>"+(cols[q].header||"&nbsp;")+"</div></div>";
		//
		this.conf.col_w += w+1;
	}
	
	var w = 500;
	var k = document.createElement("DIV");
	k.style.position = "absolute";
	k.style.top = "10px";
	k.style.left = -w*2+"px";
	k.style.width = w+"px";
	k.style.height = "50px";
	k.style.overflowY = "scroll";
	k.innerHTML = "<div>&nbsp;</div>";
	document.body.appendChild(k);
	
	this.conf.col_w += w-k.firstChild.offsetWidth+10;
	
	k.parentNode.removeChild(k);
	k = null;
	
	this.conf.template.option = t;
	this._mcAttachHeader(h);
	
	this.list.className += " dhxcombolist_multicolumn";
};

dhtmlXCombo.prototype._mcAttachHeader = function(text) {
	
	if (this.hdr == null) {
		
		this.hdr = document.createElement("DIV");
		this.hdr.className = "dhxcombolist_"+this.conf.skin+" dhxcombolist_hdr";
		this.hdr.style.display = "none";
		
		this.list.parentNode.insertBefore(this.hdr, this.list);
		
		if (typeof(window.addEventListener) == "function") {
			this.hdr.addEventListener("mousedown", this._doOnListMouseDown, false);
		} else {
			this.hdr.attachEvent("onmousedown", this._doOnListMouseDown);
		}
		
		// remove top-image from input
		if (this.conf.opts_type == "checkbox" && this.conf.combo_image == true) {
			this.conf.combo_image = false;
			if (this.base.lastChild.className.match(/dhxcombo_top_image/) != null) this.base.removeChild(this.base.lastChild);
			this._adjustBase();
		}
	}
	
	this.hdr.innerHTML = "<div class='dhxcombo_hdrtext'>"+text+"</div>";
	
};

dhtmlXCombo.prototype._mcDetachHeader = function() {
	
	if (this.hdr != null) {
		
		if (typeof(window.addEventListener) == "function") {
			this.hdr.removeEventListener("mousedown", this._doOnListMouseDown, false);
		} else {
			this.hdr.detachEvent("onmousedown", this._doOnListMouseDown);
		}
		
		this.hdr.parentNode.removeChild(this.hdr);
		this.hdr = null;
	}
	
	this.conf.col_w = null;
	this.conf.item_h = null;
	
};


/****************************************************************************************************************************************************************************************************************/

/* options */
dhtmlXCombo.prototype.modes = {}; // option types

dhtmlXCombo.prototype.doWithItem = function(index, method, param1, param2) { // wrapper to perform opts operations from combo
	
	// get option inner id
	var id = (index >= 0 && index < this.list.childNodes.length ? this.list.childNodes[index]._optId : null);
	if (id == null) return null; // opt no found
	if (typeof(this.t[id].obj[method]) != "function") return null; // function not found
	
	// generate params
	var params = [this.t[id].item];
	for (var q=2; q<arguments.length; q++) params.push(arguments[q]);
	
	// call method
	return this.t[id].obj[method].apply(this.t[id].obj, params);
	
};

function dhtmlXComboExtend(to, from) {
	for (var a in dhtmlXCombo.prototype.modes[from]) {
		if (typeof(dhtmlXCombo.prototype.modes[to][a]) == "undefined") {
			dhtmlXCombo.prototype.modes[to][a] = dhtmlXCombo.prototype.modes[from][a];
		}
	};
};
/****************************************************************************************************************************************************************************************************************/

dhtmlXCombo.prototype.modes.option = {
	
	image: false, // top-level image prev-to input
	html: false,
	option_css: "dhxcombo_option_text",
	
	render: function(item, data) {
		
		item._conf = {value: data.value, css: ""};
		
		item.className = "dhxcombo_option";
		item.innerHTML = "<div class='"+this.option_css+"'>&nbsp;</div>";
		
		if (data.css != null) {
			item.lastChild.style.cssText = data.css;
			item._conf.css = data.css;
		}
		
		this.setText(item, data.text);
		
		return this;
	},
	
	destruct: function(item) {
		item._conf = null;
	},
	
	update: function(item, data) {
		item._conf.value = data.value;
		item._conf.css = data.css;
		item.lastChild.style.cssText = data.css;
		this.setText(item, data.text);
	},
	
	setText: function(item, text, skip) {
		item._conf.text = text;
		var t = (typeof(text) == "object" ? window.dhx4.template(item._tpl.option, this.replaceHtml(item._conf.text, skip), true) : window.dhx4.trim(this.replaceHtml(item._conf.text, skip)||""));
		item.lastChild.innerHTML = (t.length==0?"&nbsp;":t);
	},
	
	getText: function(item, asStringInput, asStringOption) {
		if (window.dhx4.s2b(asStringInput) && typeof(item._conf.text) == "object") return window.dhx4.template(item._tpl.input, item._conf.text, true);
		if (window.dhx4.s2b(asStringOption) && typeof(item._conf.text) == "object") return window.dhx4.template(item._tpl.option, item._conf.text, true);
		return item._conf.text;
	},
	
	getValue: function(item) {
		return item._conf.value;
	},
	
	getCss: function(item) {
		return item._conf.css;
	},
	
	setSelected: function(item, state) {
		item.className = "dhxcombo_option"+(state?" dhxcombo_option_selected":"");
	},
	
	isSelected: function(item) {
		return String(item.className).indexOf("dhxcombo_option_selected") >= 0;
	},
	
	getExtraData: function(item) {
		// optional function,
		// adds extra data to option object returned by getOption()
		return {type: "option"};
	},
	
	replaceHtml: function(text, skip) {
		if (this.html == true) return text;
		if (typeof(skip) == "undefined" || skip == null) skip = {};
		if (typeof(text) == "object") {
			var t = {};
			for (var a in text) {
				t[a] = (skip[a]==true?text[a]:this.replaceHtml(text[a]));
			}
		} else {
			var t = (text||"").replace(/[\<\>\&\s]/g, function(t){
				switch (t) {
					case "<": return "&lt;";
					case ">": return "&gt;";
					case "&": return "&amp;";
					case " ": return "&nbsp;";
				}
				return t;
			});
		}
		return t;
	}
	
};

/****************************************************************************************************************************************************************************************************************/

dhtmlXCombo.prototype.modes.checkbox = {
	
	image: true, // disable in code if multicolumn
	html: false,
	image_css: "dhxcombo_checkbox dhxcombo_chbx_#state#",
	option_css: "dhxcombo_option_text dhxcombo_option_text_chbx",
	
	render: function(item, data) {
		
		if (this.image_css_regexp == null) this.image_css_regexp = new RegExp(this.image_css.replace("#state#","\\d*"));
		
		item._conf = {value: data.value, css: "", checked: window.dhx4.s2b(data.checked)};
		
		item.className = "dhxcombo_option";
		
		var skip = {}; // skip html replace
		
		if (data.multicol == true) {
			data.text.checkbox = "<div class='"+String(this.image_css).replace("#state#",(item._conf.checked?"1":"0"))+"'></div>&nbsp;";
			skip.checkbox = true;
			item.innerHTML = "<div class='"+dhtmlXCombo.prototype.modes.option.option_css+"'></div>";
		} else {
			item.innerHTML = "<div class='"+String(this.image_css).replace("#state#",(item._conf.checked?"1":"0"))+"'></div>"+
					"<div class='"+this.option_css+"'>&nbsp;</div>";
		}
		
		if (data.css != null) {
			item.lastChild.style.cssText += data.css;
			item._conf.css = data.css;
		}
		
		this.setText(item, data.text, skip);
		
		return this;
	},
	
	setChecked: function(item, state) {
		item._conf.checked = window.dhx4.s2b(state);
		var css = String(this.image_css).replace("#state#",(item._conf.checked?"1":"0"));
		this._changeChbxCss(item.childNodes, css);
	},
	
	_changeChbxCss: function(nodes, css) {
		for (var q=0; q<nodes.length; q++) {
			if (nodes[q].tagName != null && nodes[q].className != null && nodes[q].className.match(this.image_css_regexp) != null) {
				nodes[q].className = css;
			} else if (nodes[q].childNodes.length > 0) {
				this._changeChbxCss(nodes[q].childNodes, css);
			}
		}
	},
	
	isChecked: function(item) {
		return (item._conf.checked==true);
	},
	
	getExtraData: function(item) {
		return {type: "checkbox", checked: item._conf.checked};
	},
	
	optionClick: function(item, ev, combo) {
		// called when option clicked, return true allows selection+confirm, return false - not
		var r = true;
		var t = (ev.target||ev.srcElement);
		while (r == true && t != null && t != item && t.className != null) {
			if (t.className.match(this.image_css_regexp) != null) {
				var args = [item._conf.value, !item._conf.checked];
				if (combo.callEvent("onBeforeCheck", args) === true) {
					this.setChecked(item, !this.isChecked(item));
					combo.callEvent("onCheck", args);
				};
				r = false;
				args = null;
			} else {
				t = t.parentNode;
			}
		}
		t = combo = item = null;
		return r;
	},
	
	getTopImage: function(item, enabled) {
		// returns html for top image
		// if item not specified - default image
		// enabled specify if combo enabled
		return "";
	},
	
	topImageClick: function(item, combo) {
		// called when user clicked on top-image,
		// return true/false to allow defailt action (open/close list) ot not
		// for checkbox - perform default action
		return true;
	}
	
};

dhtmlXComboExtend("checkbox", "option");

dhtmlXCombo.prototype.setChecked = function(index, mode) {
	this.doWithItem(index, "setChecked", mode);
};

dhtmlXCombo.prototype.getChecked = function(index) {
	// return checked values
	var t = [];
	for (var q=0; q<this.list.childNodes.length; q++) {
		if (this.isChecked(q)) t.push(this._getOptionProp(this.list.childNodes[q]._optId, "value", ""));
	}
	return t;
};

dhtmlXCombo.prototype.isChecked = function(index) {
	return this.doWithItem(index, "isChecked");
};

/****************************************************************************************************************************************************************************************************************/

dhtmlXCombo.prototype.modes.image = {
	
	image: true,
	html: false,
	image_css: "dhxcombo_image",
	option_css: "dhxcombo_option_text dhxcombo_option_text_image",
	
	render: function(item, data) {
		
		item._conf = {value: data.value, css: ""};
		
		item.className = "dhxcombo_option";
		item.innerHTML = "<div class='"+this.image_css+"'></div>"+
				"<div class='"+this.option_css+"'>&nbsp;</div>";
		
		if (data.css != null) {
			item.lastChild.style.cssText += data.css;
			item._conf.css = data.css;
		}
		
		this.setText(item, data.text);
		this.setImage(item, data.img, data.img_dis, data.img_path, data.img_def, data.img_def_dis);
		
		return this;
	},
	
	update: function(item, data) {
		item._conf.value = data.value;
		item._conf.css = data.css;
		item.lastChild.style.cssText = data.css;
		this.setText(item, data.text);
		this.setImage(item, data.img, data.img_dis, data.img_path, data.img_def, data.img_def_dis);
	},
	
	setImage: function(item, img, img_dis, path, def, def_dis) {
		
		// image
		if (img != null && img.length > 0) {
			img = path+img;
		} else if (def != null && def.length > 0) {
			img = path+def;
		} else {
			img = null;
		}
		
		// image
		if (img_dis != null && img_dis.length > 0) {
			img_dis = path+img_dis;
		} else if (def_dis != null && def_dis.length > 0) {
			img_dis = path+def_dis;
		} else if (def_dis == true) {
			img_dis = img;
		} else {
			img_dis = null;
		}
		
		item._conf.img = img;
		item._conf.img_dis = img_dis;
		
		item.firstChild.style.backgroundImage = (img!=null?"url("+img+")":"none");
	},
	
	getExtraData: function(item) {
		return {type: "image"};
	},
	
	getTopImage: function(item, enabled) {
		// returns html for top image
		// if item not specified - default image
		var a = (enabled?"img":"img_dis");
		if (item != null && item._conf[a] != null) return "<div class='"+this.image_css+"' style='background-image:url("+item._conf[a]+");'></div>";
		return "";
	}
	
};

dhtmlXComboExtend("image", "option");

dhtmlXCombo.prototype.setDefaultImage = function(img, imgDis) {
	// sets default image
	// set imgDis to tru to use the same image as for enabled combo, default
	if (img != null) this.conf.img_def = img;
	if (imgDis != null) this.conf.img_def_dis = imgDis;
};
dhtmlXCombo.prototype.setImagePath = function(path) {
	this.conf.img_path = path;
};


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXColorPicker(base) {
	
	if (!(this instanceof window.dhtmlXColorPicker)) {
		return new dhtmlXColorPicker(base);
	}
	
	dhx4._eventable(this);
	
	var that = this, base_type = undefined,
	temp_node = null, i,l, temp_conf;
	
	this._nodes = [];
	
	this.activeNode = null;
	this._inputListenerId = null;
	this.base = null;
	this._globalNode = null;
	this.memory = null;
	this.skin = null;
	
	this.conf = {
		cp_id: dhx4.newId(),
		x: 0,
		y: 0,
		c: 0,
		indent: 2,
		position: "right", // right or bottom
		customColors: false,
		selectedColor: null,
		hide: false,
		hideOnSelect: false,
		lang: "en",
		closeable: true // autohide when button cancel clicked, can be used for custom-parent init
	};
	
	this.value = {
		red: -1,
		blue: -1,
		green: -1,
		hue: -1,
		sat: -1,
		lum: -1
	};
	
	this._initMoveSelection = function(e) {
		e = e || event;
		if (typeof(window.addEventListener) == "function") {
			that._controllerNodes.colorArea.addEventListener("mousemove", that._setMoveSelection, false);
			document.body.addEventListener("mouseup", that._cleanMoveSelection, false);
		} else {
			that._controllerNodes.colorArea.attachEvent("onmousemove", that._setMoveSelection);
			document.body.attachEvent("onmouseup", that._cleanMoveSelection);
		}
		
		that._setMoveSelection(e,that._controllerNodes.colorArea);
		return false;
	};
	
	this._cleanMoveSelection = function() {
		if (typeof(window.removeEventListener) == "function") {
			that._controllerNodes.colorArea.removeEventListener("mousemove", that._setMoveSelection, false);
			document.body.removeEventListener("mouseup", that._cleanMoveSelection, false);
		} else {
			that._controllerNodes.colorArea.detachEvent("onmousemove", that._setMoveSelection);
			document.body.detachEvent("onmouseup", that._cleanMoveSelection);
		}
		
		return false;
	};
	
	this._setMoveSelection = function(e) {
		e = e || event;
		var coord = that._getOffsetPosition(e, that._controllerNodes.colorArea);
		if (that._controllerNodes.fr_cover) {
			setTimeout(function() {
					that._setColorAreaXY(coord.x, coord.y);
					that._setColorByXYC();
			},0);
		} else {
			that._setColorAreaXY(coord.x, coord.y);
			that._setColorByXYC();
		}
		return false;
	};
	
	this._initMoveContrast = function(e) {
		e = e || event;
		if (typeof(window.addEventListener) == "function") {
			document.body.addEventListener("mousemove", that._setMoveContrast, false);
			document.body.addEventListener("mouseup", that._cleanMoveContrast, false);
		} else {
			document.body.attachEvent("onmousemove", that._setMoveContrast);
			document.body.attachEvent("onmouseup", that._cleanMoveContrast);
		}
		
		that._setMoveContrast(e,that._controllerNodes.contrastArea);
	};
	
	this._cleanMoveContrast = function() {
		if (typeof(window.removeEventListener) == "function") {
			document.body.removeEventListener("mousemove", that._setMoveContrast, false);
			document.body.removeEventListener("mouseup", that._cleanMoveContrast, false);
		} else {
			document.body.detachEvent("onmousemove", that._setMoveContrast);
			document.body.detachEvent("onmouseup", that._cleanMoveContrast);
		}
	};
	
	this._setMoveContrast = function(e) {
		e = e || event;
		
		var coord = that._getOffsetPosition(e, that._controllerNodes.contrastArea);
		that._setContrastY(coord.y);
		that._setColorByXYC(true);
	};
	
	this._doOnSelectColor = function() {
		var hex = that.colorAIP.rgb2hex({
				r: that.value.red,
				g: that.value.green,
				b: that.value.blue
		});
		
		if (that.activeNode != null) {
			if (that.activeNode.valueCont) {
				that.activeNode.valueCont.value = hex;
			}
			if (that.activeNode.valueColor) {
				that.activeNode.valueColor.style.backgroundColor = hex;
			}
		}
		
		if (that.base._dhx_remove || that.conf.hideOnSelect) {
			that.hide();
		}
		
		that.callEvent("onSelect",[hex,((that.activeNode)? that.activeNode.node: null)]);
	};
	
	this._doOnCancel = function() {
		// if cp isn't closeable - allow event to be fired anyway
		if (that.callEvent("onCancel",[((that.activeNode)? that.activeNode.node: null)]) == true && that.conf.closeable == true) {
			that.hide();
		}
	};
	
	this._doOnFocusByInput = function() {
		var target = (this != window)? this : event.srcElement;
		var object = (that.activeNode && that.activeNode.valueCont && that.activeNode.valueCont == target) ? that.activeNode : that._getNodeByValueCont(target);
		
		that.activeNode = object;
		if (object && object == that.activeNode) {
			that._initListenerInput();
		}
	};
	
	this._doOnBlurByInput = function() {
		var target = (this != window)? this : event.srcElement;
		var object = (that.activeNode && that.activeNode.valueCont && that.activeNode.valueCont == target) ? that.activeNode : that._getNodeByValueCont(target);
		if (object && object == that.activeNode) {
			that._removeListenerInput();
		}
	};
	
	this._doOnClickByNode = function(e) {
		e = e || event;
		var target = (this != window)? this : event.srcElement;
		that.activeNode = (that.activeNode.node != target)
		? that._getNodeByElement(target)
		: that.activeNode;
		if (!that.isVisible()) {
			that.show();
		}
	};
	
	this.saveColor = function() {
		that.memory.setValue(that.value);
	};
	
	this._onSelectMemoryEl = function(contr) {
		var key;
		that._refreshCoordinatesByHSL(contr.value.hue, contr.value.sat, contr.value.lum);
		
		for (key in contr.value) {
			that.value[key] = contr.value[key];
		}
		
		that._refreshContrast();
		that._refreshInputValues();
		that._refreshColorValue();
	};
	
	this._doOnClickByBody = function(e) {
		e = e || event;
		var is_close = true, target =e.target || e.srcElement;
		
		if (that._isBaseNode(target)) {
			is_close = false;
		}
		
		if (is_close && that.activeNode && (that.activeNode.node == target || that.activeNode.valueCont == target)) {
			is_close = false;
		}
		
		if (is_close) {
			that.hide();
		}
	};
	
	this._doOnChangeHSL = function() {
		var hue = parseInt(that._controllerNodes.hue.value),
		sat = parseInt(that._controllerNodes.sat.value),
		lum = parseInt(that._controllerNodes.lum.value),
		rgb;
		
		if (isNaN(hue) || hue > 359 || hue < 0) {
			that._controllerNodes.hue.value = that.value.hue;
		} else {
			that.value.hue = hue;
		}
		
		if (isNaN(sat) || sat > 100 || sat < 0) {
			that._controllerNodes.sat.value = that.value.sat;
		} else {
			that.value.sat = sat;
		}
		
		
		if (isNaN(lum) || lum > 100 || lum < 0) {
			that._controllerNodes.lum.value = that.value.lum;
		} else {
			that.value.lum = lum;
		}
		
		rgb = that.colorAIP.hsl2rgb(that.value.hue, that.value.sat/100, that.value.lum/100);
		that.value.red = Math.round(255*rgb.r);
		that.value.green = Math.round(255*rgb.g);
		that.value.blue = Math.round(255*rgb.b);
		
		that._refreshCoordinatesByHSL(that.value.hue,that.value.sat,that.value.lum);
		that._refreshContrast();
		that._refreshInputValues();
		that._refreshColorValue();
	};
	
	this._doOnChangeRGB = function() {
		var red = parseInt(that._controllerNodes.red.value),
		green = parseInt(that._controllerNodes.green.value),
		blue = parseInt(that._controllerNodes.blue.value),
		hsl;
		
		if (isNaN(red) || red > 255 || red < 0) {
			that._controllerNodes.red.value = that.value.red;
		} else {
			that.value.red = red;
		}
		
		if (isNaN(green) || green > 255 || green < 0) {
			that._controllerNodes.green.value = that.value.green;
		} else {
			that.value.green = green;
		}
		
		if (isNaN(blue) || blue > 255 || blue < 0) {
			that._controllerNodes.blue.value = that.value.blue;
		} else {
			that.value.blue = blue;
		}
		
		hsl = that.colorAIP.rgb2hsl(that.value.red/255, that.value.green/255, that.value.blue/255);
		that.value.hue = Math.round(hsl.h);
		that.value.sat = Math.round(hsl.s*100);
		that.value.lum = Math.round(hsl.l*100);
		
		that._refreshCoordinatesByHSL(that.value.hue,that.value.sat,that.value.lum);
		that._refreshContrast();
		that._refreshInputValues();
		that._refreshColorValue();
	};
	
	this._doOnChangeHSV = function() {
		that._controllerNodes.hsv.value = that.setColor(that._controllerNodes.hsv.value);
	};
	
	this._checkType = function (base) {
		var tempType;
		if (base instanceof Array) {
			tempType = that._checkType(base[0]);
			switch (tempType) {
			case "string":
				return "array_string";
				break;
			case "input":
			case "textarea":
				return "array_input";
				break;
			case "object":
				return "array_object";
				break;
				default:
				return undefined;
			}
			
		} else if (base == undefined) {
			return null;
			
		} else if (typeof(base) == "string") {
			return "string";
			
		} else if (base.tagName && base.tagName.toLowerCase() == "input") {
			return "input";
			
		} else if (base.tagName && base.tagName.toLowerCase() == "textarea") {
			return "textarea";
			
		} else if (base.tagName) {
			return "container";
			
		} else if (typeof(base) == "object") {
			return "object";
			
		} else return undefined;
	};
	
	this._initByObject = function (conf) {
		if (conf.parent && conf.parent.tagName) {
			that.base = conf.parent;
		} else if (typeof(conf.parent) == "string") {
			that.base = document.getElementById(conf.parent);
		} else {
			that.base = document.createElement("div");
			that.base._dhx_remove = true;
		}
		
		if (conf.color) {
			that.conf.selectedColor = conf.color;
		}
		if (typeof(conf.closeable) != "undefined") {
			this.conf.closeable = dhx4.s2b(conf.closeable);
		}
		if (conf.custom_colors) {
			this._tempInitCC = function() {
				var i, l;
				this.initMemoryColors();
				this.conf.customColors = true;
				
				if (conf.custom_colors instanceof Array) {
					l = conf.custom_colors.length;
					for (i=0; i<l; i++) {
						this.setCustomColors(conf.custom_colors[i]);
					}
				}
				
				if (this.base.parentNode) {
					this.showMemory();
				}
				delete this._tempInitCC;
			};
		}
		
		if (conf.hide) {
			that.conf.hide = true;
		}
		
		if (conf.input) {
			that._addNode(conf.input, conf.target_color, conf.target_value);
		}
		
		var skin = conf.skin || window.dhx4.skin || (typeof(dhtmlx) != "undefined"? dhtmlx.skin : null) || window.dhx4.skinDetect("dhxcolorpicker") || "material";
		that.setSkin(skin);
		
		// deprecated
		if (conf.colors) {
			that.initMemoryColors();
			that.conf.customColors = true;
		}
		
		if (conf.link) {
			that._addNode(conf.link);
		}
	};
	
	this.unload = function() {
		var i,l,key;
		if (this.isVisible()) {
			this.hide();
		}
		this.destructMemory();
		
		l = this._nodes.length;
		for (i=0; i<l; i++) {
			this._detachEventsFromNode(this._nodes[i]);
			for (key in this._nodes[i]) {
				this._nodes[i][key] = null;
			}
			delete this._nodes[i];
		}
		this._nodes = null;
		
		if (!this.base._dhx_remove) {
			this.base.className = this.base.className.replace(/\s?dhtmlxcp_\S*/, "");
		} else {
			delete this.base._dhx_remove;
		}
		
		if (typeof(window.addEventListener) == "function") {
			this._controllerNodes.colorArea.removeEventListener("mousedown", this._initMoveSelection, false);
			this._controllerNodes.colorArea.removeEventListener("dblclick", this._doOnSelectColor, false);
			this._controllerNodes.contrastArea.removeEventListener("mousedown", this._initMoveContrast, false);
			
			this._controllerNodes.button_save.removeEventListener("click", this._doOnSelectColor, false);
			this._controllerNodes.button_cancel.removeEventListener("click", this._doOnCancel, false);
			
			this._controllerNodes.hue.removeEventListener("change", this._doOnChangeHSL, false);
			this._controllerNodes.sat.removeEventListener("change", this._doOnChangeHSL, false);
			this._controllerNodes.lum.removeEventListener("change", this._doOnChangeHSL, false);
			
			this._controllerNodes.red.removeEventListener("change", this._doOnChangeRGB, false);
			this._controllerNodes.green.removeEventListener("change", this._doOnChangeRGB, false);
			this._controllerNodes.blue.removeEventListener("change", this._doOnChangeRGB, false);
			
			this._controllerNodes.hsv.removeEventListener("change", this._doOnChangeHSV, false);
			
		} else {
			this._controllerNodes.colorArea.detachEvent("onmousedown", this._initMoveSelection);
			this._controllerNodes.colorArea.detachEvent("ondblclick", this._doOnSelectColor);
			this._controllerNodes.contrastArea.detachEvent("onmousedown", this._initMoveContrast);
			
			this._controllerNodes.button_save.detachEvent("onclick", this._doOnSelectColor);
			this._controllerNodes.button_cancel.detachEvent("onclick", this._doOnCancel);
			
			this._controllerNodes.hue.detachEvent("onchange", this._doOnChangeHSL);
			this._controllerNodes.sat.detachEvent("onchange", this._doOnChangeHSL);
			this._controllerNodes.lum.detachEvent("onchange", this._doOnChangeHSL);
			
			this._controllerNodes.red.detachEvent("onchange", this._doOnChangeRGB);
			this._controllerNodes.green.detachEvent("onchange", this._doOnChangeRGB);
			this._controllerNodes.blue.detachEvent("onchange", this._doOnChangeRGB);
			
			this._controllerNodes.hsv.detachEvent("onchange", this._doOnChangeHSV);
		}
		
		if (this._controllerNodes.fr_cover) {
			if (this._controllerNodes.fr_cover.parentNode) {
				this._controllerNodes.fr_cover.parentNode.removeChild(this._controllerNodes.fr_cover);
			}
			delete this._controllerNodes.fr_cover;
		}
		
		dhx4.zim.clear(this.conf.cp_id);
		dhx4._eventable(this, "clear");
		
		for (key in this) {
			this[key] = null;
		}
		
		that = null, temp_node = null, temp_conf = null;
	};
	
	base_type = this._checkType(base);
	switch (base_type) {
		case "object":
			that._initByObject(base);
			break;
			
		case "input":
		case "textarea":
			that._initByObject({});
			this._addNode(base);
			break;
			
		case "string":
			temp_node = document.getElementById(base);
			return new dhtmlXColorPicker(temp_node);
			break;
			
		case "container":
			that._initByObject({
				parent: base
			});
			break;
			
		case null:
			that._initByObject({});
			break;
			
		case "array_string":
		case "array_input":
			that._initByObject({});
			l = base.length;
			for (i=0; i<l; i++) this._addNode(base[i]);
			break;
			
		case "array_object":
			that._initByObject({});
			l = base.length;
			for (i=0; i<l; i++) {
				temp_conf = this._addNode(base[i].input, base[i].target_color, base[i].target_value).conf;
				temp_conf.customColors = (base[i].custom_colors != undefined)? dhx4.s2b(base[i].custom_colors): temp_conf.customColors;
				temp_conf.selectedColor = (base[i].color != undefined)? base[i].color: temp_conf.selectedColor;
			}
			break;
	}
	
	this.base.innerHTML = "<div class='dhxcp_g_area'>"+
					"<div class='dhxcp_sub_area'>"+
						"<div class='dhxcp_g_color_area'>"+
							"<div class='dhxcp_color_selector'>"+
								"<div class='dhxcp_v_line'></div>"+
								"<div class='dhxcp_h_line'></div>"+
							"</div>"+
							"<div class='dhxcp_contrast_area'>"+
								"<div class='dhxcp_h_line'></div>"+
							"</div>"+
						"</div>"+
						//+
						"<div class='dhxcp_g_input_area'>"+
							"<div class='dhxcp_value_cont'>"+
								"<div class='dhxcp_value_color'></div>"+
								"<input type='text' class='dhxcp_value'/>"+
							"</div>"+
							"<table class='dhxcp_inputs_cont' cellpadding='0' cellspacing='0' border='0'>"+
								"<tr>"+
									"<td class='dhxcp_label_hsl'>"+this.i18n[this.conf.lang].labelHue+"</td>"+
									"<td class='dhxcp_input_hsl'><input type='text' class='dhxcp_input_hsl'/></td>"+
									"<td class='dhxcp_label_rgb'>"+this.i18n[this.conf.lang].labelRed+"</td>"+
									"<td class='dhxcp_input_rgb'><input type='text' class='dhxcp_input_rgb'/></td>"+
								"</tr>"+
								"<tr>"+
									"<td class='dhxcp_label_hsl'>"+this.i18n[this.conf.lang].labelSat+"</td>"+
									"<td class='dhxcp_input_hsl'><input type='text' class='dhxcp_input_hsl'/></td>"+
									"<td class='dhxcp_label_rgb'>"+this.i18n[this.conf.lang].labelGreen+"</td>"+
									"<td class='dhxcp_input_rgb'><input type='text' class='dhxcp_input_rgb'/></td>"+
								"</tr>"+
								"<tr>"+
									"<td class='dhxcp_label_hsl'>"+this.i18n[this.conf.lang].labelLum+"</td>"+
									"<td class='dhxcp_input_hsl'><input type='text' class='dhxcp_input_hsl'/></td>"+
									"<td class='dhxcp_label_rgb'>"+this.i18n[this.conf.lang].labelBlue+"</td>"+
									"<td class='dhxcp_input_rgb'><input type='text' class='dhxcp_input_rgb'/></td>"+
								"</tr>"+
							"</table>"+
						"</div>"+
						"<div class='dhxcp_g_memory_area'></div>"+
						"<div class='dhxcp_buttons_area'>"+
							"<button class='dhx_button_save'>"+this.i18n[this.conf.lang].btnSelect+"</button>"+
							"<button class='dhx_button_cancel'>"+this.i18n[this.conf.lang].btnCancel+"</button>"+
						"</div>"+
					"</div>"
				"</div>";
	
	this._globalNode = this.base.firstChild;
	
	this._controllerNodes = {
		colorArea: this._globalNode.firstChild.firstChild.firstChild,
		v_line   : this._globalNode.firstChild.firstChild.firstChild.childNodes[0],
		h_line   : this._globalNode.firstChild.firstChild.firstChild.childNodes[1],
		
		contrastArea : this._globalNode.firstChild.firstChild.childNodes[1],
		contrast_line: this._globalNode.firstChild.firstChild.childNodes[1].firstChild,
		
		color: this._globalNode.firstChild.childNodes[1].childNodes[0].firstChild,
		hsv  : this._globalNode.firstChild.childNodes[1].childNodes[0].childNodes[1],
		
		hue: this._globalNode.firstChild.childNodes[1].childNodes[1].firstChild.childNodes[0].childNodes[1].firstChild,
		sat: this._globalNode.firstChild.childNodes[1].childNodes[1].firstChild.childNodes[1].childNodes[1].firstChild,
		lum: this._globalNode.firstChild.childNodes[1].childNodes[1].firstChild.childNodes[2].childNodes[1].firstChild,
		
		red  : this._globalNode.firstChild.childNodes[1].childNodes[1].firstChild.childNodes[0].childNodes[3].firstChild,
		green: this._globalNode.firstChild.childNodes[1].childNodes[1].firstChild.childNodes[1].childNodes[3].firstChild,
		blue : this._globalNode.firstChild.childNodes[1].childNodes[1].firstChild.childNodes[2].childNodes[3].firstChild,
		
		memory_block: this._globalNode.firstChild.childNodes[2],
		
		button_save  : this._globalNode.firstChild.childNodes[3].firstChild,
		button_cancel: this._globalNode.firstChild.childNodes[3].childNodes[1]
	};
	
	this._labelNodes = {
		labelHue   : this._globalNode.firstChild.childNodes[1].childNodes[1].firstChild.childNodes[0].firstChild,
		labelSat   : this._globalNode.firstChild.childNodes[1].childNodes[1].firstChild.childNodes[1].firstChild,
		labelLum   : this._globalNode.firstChild.childNodes[1].childNodes[1].firstChild.childNodes[2].firstChild,
		labelRed   : this._globalNode.firstChild.childNodes[1].childNodes[1].firstChild.childNodes[0].childNodes[2],
		labelGreen : this._globalNode.firstChild.childNodes[1].childNodes[1].firstChild.childNodes[1].childNodes[2],
		labelBlue  : this._globalNode.firstChild.childNodes[1].childNodes[1].firstChild.childNodes[2].childNodes[2],
		btnAddColor: null,
		btnSelect  : this._globalNode.firstChild.childNodes[3].firstChild,
		btnCancel  : this._globalNode.firstChild.childNodes[3].childNodes[1]
	};
	
	if (typeof(this._tempInitCC) == "function") {
		this._tempInitCC();
	};
	
	if (typeof(window.addEventListener) == "function") {
		this._controllerNodes.colorArea.addEventListener("mousedown", this._initMoveSelection, false);
		this._controllerNodes.colorArea.addEventListener("dblclick", this._doOnSelectColor, false);
		this._controllerNodes.contrastArea.addEventListener("mousedown", this._initMoveContrast, false);
		
		this._controllerNodes.button_save.addEventListener("click", this._doOnSelectColor, false);
		this._controllerNodes.button_cancel.addEventListener("click", this._doOnCancel, false);
		
		this._controllerNodes.hue.addEventListener("change", this._doOnChangeHSL, false);
		this._controllerNodes.sat.addEventListener("change", this._doOnChangeHSL, false);
		this._controllerNodes.lum.addEventListener("change", this._doOnChangeHSL, false);
		
		this._controllerNodes.red.addEventListener("change", this._doOnChangeRGB, false);
		this._controllerNodes.green.addEventListener("change", this._doOnChangeRGB, false);
		this._controllerNodes.blue.addEventListener("change", this._doOnChangeRGB, false);
		
		this._controllerNodes.hsv.addEventListener("change", this._doOnChangeHSV, false);
	} else {
		this._controllerNodes.colorArea.attachEvent("onmousedown", this._initMoveSelection);
		this._controllerNodes.colorArea.attachEvent("ondblclick", this._doOnSelectColor);
		this._controllerNodes.contrastArea.attachEvent("onmousedown", this._initMoveContrast);
		
		this._controllerNodes.button_save.attachEvent("onclick", this._doOnSelectColor);
		this._controllerNodes.button_cancel.attachEvent("onclick", this._doOnCancel);
		
		this._controllerNodes.hue.attachEvent("onchange", this._doOnChangeHSL);
		this._controllerNodes.sat.attachEvent("onchange", this._doOnChangeHSL);
		this._controllerNodes.lum.attachEvent("onchange", this._doOnChangeHSL);
		
		this._controllerNodes.red.attachEvent("onchange", this._doOnChangeRGB);
		this._controllerNodes.green.attachEvent("onchange", this._doOnChangeRGB);
		this._controllerNodes.blue.attachEvent("onchange", this._doOnChangeRGB);
		
		this._controllerNodes.hsv.attachEvent("onchange", this._doOnChangeHSV);
	}
	
	this.setColor(this.conf.selectedColor||"#ffffff");
	
	if (this._nodes.length) {
		for (var i=0; i<this._nodes.length; i++) {
			this._attachEventsToNode(this._nodes[i]);
		}
	}
	
	if (this.conf.hide) {
		this.hide();
	}
	
	if (typeof(this._cpInitFRM) == "function") {
		this._cpInitFRM();
	}
}

dhtmlXColorPicker.prototype.linkTo = function(colorValue, element, value) {
	if (arguments.length == 1) {
		element = value = colorValue;
	}
	
	var object;
	colorValue = colorValue || null;
	value = value || null;
	
	if (typeof(element) == "string") {
		element = document.getElementById(element);
	}
	
	object = this._addNode(element,colorValue,value);
	if (object) {
		this._attachEventsToNode(object);
	}
	
	return object;
};

dhtmlXColorPicker.prototype._isBaseNode = function(node) {
	if (node == this.base) {
		return true;
	}
	
	if (node.parentElement == document.body) {
		return false;
	} else if (!node.parentElement) {
		return false;
	} else {
		return this._isBaseNode(node.parentElement);
	}
};

dhtmlXColorPicker.prototype._hasInput = function(node) {
	var i,l, answer = false;
	l = this._nodes.length;
	for (i=0; i<l; i++) {
		if (this._nodes[i].valueCont == node) {
			answer = true;
			break;
		}
	}
	
	return answer;
};

dhtmlXColorPicker.prototype._findNodesByArray = function(data) {
	var i, l, temp, answer = [];
	l = data.length;
	for (i = 0; i<l; i++) {
		if (typeof(data[i]) == "string") {
			temp = document.getElementById(data[i]);
		} else {
			temp = data[i];
		}
		
		if (temp) {
			this._addNode(temp);
		}
	}
};

dhtmlXColorPicker.prototype._addNode = function(node, valueColor, value) {
	var _node, _newCont, _valueColor, object;
	if (typeof(node) == "string") {
		_node = document.getElementById(node);
	} else {
		_node = node;
	}
	
	if (typeof(valueColor) == "string") {
		valueColor = document.getElementById(valueColor);
	}
	
	if (typeof(value) == "string") {
		value = document.getElementById(value);
	}
	
	if (!_node) return null;
	
	if (dhx4.s2b(_node.getAttribute("colorbox"))) {
		_newCont = document.createElement('div');
		_newCont.style.width=_node.offsetWidth+"px";
		_newCont.style.height=_node.offsetHeight+"px";
		_node.style.width=_node.offsetWidth-(_node.offsetHeight+8)+"px";
		_node.parentNode.insertBefore(_newCont,_node);
		_newCont.style.position="relative";
		_valueColor=document.createElement("div");
		_newCont.appendChild(_node);
		_newCont.appendChild(_valueColor);
		_valueColor.className="dhxcp_colorBox";
		_node.className+=" dhxcp_colorInput";
		_valueColor.style.width=_valueColor.style.height= _node.offsetHeight+"px";
	}
	
	object = {
		node: _node,
		valueColor: (valueColor != undefined)? valueColor : _valueColor || _node,
		valueCont: (value != undefined)? value : _node,
		conf: {
			customColors: (_node.getAttribute("customcolors") != null) ? dhx4.s2b(_node.getAttribute("customcolors")) : null,
			selectedColor: _node.getAttribute("selectedcolor")
		}
	};
	
	this._nodes.push(object);
	
	if (!this.activeNode) {
		this.activeNode = object;
	}
	
	return object;
};

dhtmlXColorPicker.prototype.getNode = function(base) {
	var element = null, node = null;
	
	if (typeof(base) == "string") {
		element = document.getElementById(base);
	} else {
		element = base;
	}
	
	if (element.tagName != undefined) {
		node = this._getNodeByElement(element);
	}
	
	return node;
};

dhtmlXColorPicker.prototype._getNodeByElement = function(element) {
	var answer = null,i,l;
	l = this._nodes.length;
	for (i=0; i<l; i++) {
		if (this._nodes[i].node == element) {
			answer = this._nodes[i];
		}
	}
	
	return answer;
};

dhtmlXColorPicker.prototype._getNodeByValueCont = function(element) {
	var answer = null,i,l;
	l = this._nodes.length;
	for (i=0; i<l; i++) {
		if (this._nodes[i].valueCont &&  this._nodes[i].valueCont == element) {
			answer = this._nodes[i];
		}
	}
	
	return answer;
};

dhtmlXColorPicker.prototype.initMemoryColors = function() {
	
	var that = this;
	
	this._controllerNodes.memory_block.innerHTML = "<div class='dhxcp_memory_button_cont'>"+
								"<button class='dhxcp_save_to_memory'>"+
									"<div class='dhxcp_label_bm'>"+this.i18n[this.conf.lang].btnAddColor+"</div>"+
								"</button>"+
							"</div>"+
							"<div class='dhxcp_memory_els_cont'>"+
								"<a class='dhxcp_memory_el'></a>"+
								"<a class='dhxcp_memory_el'></a>"+
								"<a class='dhxcp_memory_el'></a>"+
								"<a class='dhxcp_memory_el'></a>"+
								"<a class='dhxcp_memory_el'></a>"+
								"<a class='dhxcp_memory_el'></a>"+
								"<a class='dhxcp_memory_el'></a>"+
								"<a class='dhxcp_memory_el'></a>"+
							"</div>";
	
	this.memory = new this.Memory(this._controllerNodes.memory_block.childNodes[1]);
	this.memory.onSelect = this._onSelectMemoryEl;
	this.memory.onSave = function(value) {
		var color = that.colorAIP.rgb2hex({r: value.red, g: value.green, b: value.blue});
		that.callEvent("onSaveColor", [color]);
	};
	
	var button = this._controllerNodes.memory_block.childNodes[0].firstChild;
	this._labelNodes.btnAddColor = this._controllerNodes.memory_block.childNodes[0].firstChild.firstChild;
	if (typeof(window.addEventListener) == "function") {
		button.addEventListener("click", this.saveColor, false);
	} else {
		button.attachEvent("onclick", this.saveColor);
	}
};

dhtmlXColorPicker.prototype._refreshCoordinatesByHSL = function(h,s,l) {
	var x,y1,y2;
	x = Math.round((this.configColorArea.maxX - this.configColorArea.minX)*h/359)+this.configColorArea.minX;
	y1 = Math.round((this.configColorArea.maxY - this.configColorArea.minY)*(100-l)/100) + this.configColorArea.minY;
	y2 = Math.round((this.configColorArea.maxY - this.configColorArea.minY)*(100-s)/100) + this.configColorArea.minY;
	
	this._setColorAreaXY(x,y1);
	this._setContrastY(y2);
};

dhtmlXColorPicker.prototype._parseColor = function(value) {
	if (value instanceof Array) {
		var rgb = {
			r: parseInt(value[0]),
			g: parseInt(value[1]),
			b: parseInt(value[2])
		};
	} else if (typeof(value) == "string") {
		value = value.replace(/\s/g,"");
		if (/^rgb\((\d{1,3})\,(\d{1,3})\,(\d{1,3})\)$/i.test(value)) {
			var temp = value.match(/^rgb\((\d{1,3})\,(\d{1,3})\,(\d{1,3})\)$/i);
			var rgb = {
				r: parseInt(temp[1]),
				g: parseInt(temp[2]),
				b: parseInt(temp[3])
			};
		} else {
			var rgb = this.colorAIP.hex2rgb(value);
		}
	}
	return rgb;
};

dhtmlXColorPicker.prototype.setColor = function(value) {
	
	var old_value = this.colorAIP.rgb2hex({ r:this.value.red, g:this.value.green, b:this.value.blue});
	var rgb = this._parseColor(value);
	
	var is_check = (rgb instanceof Object);
	is_check = is_check && (0 <= rgb.r && rgb.r <= 255);
	is_check = is_check && (0 <= rgb.g && rgb.g <= 255);
	is_check = is_check && (0 <= rgb.b && rgb.b <= 255);
	
	if (!is_check) {
		return old_value;
	}
	
	var new_value = this.colorAIP.rgb2hex({ r:rgb.r, g:rgb.g, b:rgb.b });
	
	if (new_value == old_value) {
		return old_value;
	}
	
	this.value.red = rgb.r;
	this.value.green = rgb.g;
	this.value.blue = rgb.b;
	
	var hsl = this.colorAIP.rgb2hsl(rgb.r/255,rgb.g/255,rgb.b/255);
	this.value.hue = Math.round(hsl.h);
	this.value.sat = Math.round(hsl.s*100);
	this.value.lum = Math.round(hsl.l*100);
	
	this._refreshCoordinatesByHSL(this.value.hue, this.value.sat, this.value.lum);
	this._refreshContrast();
	this._refreshInputValues();
	this._refreshColorValue();
	
	return new_value;
};

dhtmlXColorPicker.prototype.getSelectedColor = function() {
	return [
		this.colorAIP.rgb2hex({ r:this.value.red, g:this.value.green, b:this.value.blue }),
		[this.value.red, this.value.green, this.value.blue],
		[this.value.hue, this.value.sat, this.value.lum]
	];
};

dhtmlXColorPicker.prototype._attachEventsToNode = function(object) {
	if (typeof(window.addEventListener) == "function") {
		object.node.addEventListener("click", this._doOnClickByNode, false);
	} else {
		object.node.attachEvent("onclick", this._doOnClickByNode);
	}
	
	if (object.valueCont && object.valueCont.tagName.toLowerCase() == "input") {
		if (typeof(window.addEventListener) == "function") {
			object.valueCont.addEventListener("focus", this._doOnFocusByInput, false);
			object.valueCont.addEventListener("blur", this._doOnBlurByInput, false);
		} else {
			object.valueCont.attachEvent("onfocus", this._doOnFocusByInput);
			object.valueCont.attachEvent("onblur", this._doOnBlurByInput);
		}
	}
};

dhtmlXColorPicker.prototype._detachEventsFromNode = function(object) {
	if (typeof(window.addEventListener) == "function") {
		object.node.removeEventListener("click", this._doOnClickByNode, false);
	} else {
		object.node.detachEvent("onclick", this._doOnClickByNode);
	}
	
	if (object.valueCont && object.valueCont.tagName.toLowerCase() == "input") {
		if (typeof(window.addEventListener) == "function") {
			object.valueCont.removeEventListener("focus", this._doOnFocusByInput, false);
			object.valueCont.removeEventListener("blur", this._doOnBlurByInput, false);
		} else {
			object.valueCont.detachEvent("onfocus", this._doOnFocusByInput);
			object.valueCont.detachEvent("onblur", this._doOnBlurByInput);
		}
	}
};

dhtmlXColorPicker.prototype.show = function(node) {
	var is_show_memory = false;
	
	if (node != undefined) {
		this.activeNode = this.getNode(node) || this.activeNode;
	}
	
	if (this.activeNode && this.activeNode.valueCont && this.activeNode.valueCont.value) {
		this.setColor(this.activeNode.valueCont.value);
	}
	
	if (this.activeNode) {
		is_show_memory = (this.activeNode.conf.customColors!=null?this.activeNode.conf.customColors:this.conf.customColors);
		this.setColor(this.activeNode.conf.selectedColor);
	} else {
		is_show_memory = this.conf.customColors;
	}
	
	if (is_show_memory) {
		this.showMemory();
	} else {
		this.hideMemory();
	}
	
	if (this.base._dhx_remove) {
		this.base.firstChild.style.zIndex = dhx4.zim.reserve(this.conf.cp_id);
		
		this.base.style.visibility = "hidden";
		if (document.body.firstChild) {
			document.body.insertBefore(this.base, document.body.firstChild);
		} else {
			document.body.appendChild(this.base);
		}
		
		this._refreshPosition();
		this.base.style.visibility = "visible";
		
		if (typeof(window.addEventListener) == "function") {
			document.body.addEventListener("mousedown", this._doOnClickByBody, false);
		} else {
			document.body.attachEvent("onmousedown", this._doOnClickByBody);
		}
		
	} else {
		this.base.appendChild(this._globalNode);
	}
	
	if (this._controllerNodes.fr_cover) {
		this.base.insertBefore(this._controllerNodes.fr_cover, this._globalNode);
	}
	
	this.callEvent("onShow",[((this.activeNode)? this.activeNode.node: null) ]);
};

dhtmlXColorPicker.prototype.setPosition = function(x,y) {
	var pos = null;
	var cx = parseInt(x);
	var cy = parseInt(y);
	if (isNaN(cx)) pos = ({right:"right",bottom:"bottom"}[x.toLowerCase()]?x:null);
	
	if (this.base._dhx_remove) {
		if (pos == null) {
			
		} else {
			this.conf.position = pos;
			this._refreshPosition(pos);
		}
		
	} else {
		if (isNaN(cx) || isNaN(cy)) {
			
		} else {
			this._globalNode.style.left = cx + "px";
			this._globalNode.style.top = cy + "px";
			
			if (this._controllerNodes.fr_cover) {
				this._controllerNodes.fr_cover.style.left = this._globalNode.style.left;
				this._controllerNodes.fr_cover.style.top = this._globalNode.style.top;
			}
		}
	}
};

dhtmlXColorPicker.prototype._initListenerInput = function() {
	var that = this;
	this._inputListenerId = this._inputListenerId || setInterval(function() {
			that._refreshValueByInput();
	},70);
};

dhtmlXColorPicker.prototype._removeListenerInput = function() {
	if (this._inputListenerId) {
		clearInterval(this._inputListenerId);
		this._inputListenerId = null;
	}
};

dhtmlXColorPicker.prototype._refreshValueByInput = function() {
	var value = this.activeNode.valueCont.value,
	oldValue = this.getSelectedColor()[0];
	
	if (this._inputListenerId) {
		if (/^#[\da-f]{6}$/i.test(value) && value != oldValue) {
			this.setColor(value);
			this.callEvent("onSelect",[value, this.activeNode.node]);
		}
	}
};

dhtmlXColorPicker.prototype._refreshPosition = function(position) {
	if (this.activeNode == null) return;
	
	var topInp = dhx4.absTop(this.activeNode.node);
	var leftInp = dhx4.absLeft(this.activeNode.node);
	var sizeWindow = dhx4.screenDim();
	var widthCP = this._globalNode.offsetWidth;
	var heigthCP = this._globalNode.offsetHeight;
	var top = 0;
	
	position = position || this.conf.position;
	
	switch (position) {
		case "bottom":
			var top = topInp+this.activeNode.node.offsetHeight+this.conf.indent;
			var left = leftInp;
			
			// no space on right
			if (left+widthCP > sizeWindow.left+sizeWindow.right) {
				left = leftInp+this.activeNode.node.offsetWidth-widthCP;
			}
			//no space on left
			if (left < sizeWindow.left) {
				left = leftInp;
			}
			
			// no space at bottom
			if (top+heigthCP > sizeWindow.top+sizeWindow.bottom) {
				top = topInp-heigthCP-this.conf.indent;
			}
			
			// on top also no more space (browser's height too small?)
			if (top - sizeWindow.top < 0) {
				top = sizeWindow.top + this.conf.indent;
			}
			
			this._globalNode.style.top = top+"px";
			this._globalNode.style.left = left+"px";
			
			
			break;
		default:
			var left = leftInp+this.activeNode.node.offsetWidth+this.conf.indent;
			top = topInp;
			
			if (position == "right") {
				// no space on right, open to left
				if (left+widthCP > sizeWindow.left+sizeWindow.right) {
					left = leftInp-widthCP-this.conf.indent;
				}
				// no space on left, open to right
				if (left < sizeWindow.left) {
					left = leftInp+this.activeNode.node.offsetWidth+this.conf.indent;
				}
			}
			
			if (sizeWindow.bottom - (top + heigthCP) <= 0) {
				top = topInp+this.activeNode.node.offsetHeight-heigthCP;
			}
			
			if (top - sizeWindow.top < 0) {
				top = sizeWindow.top + this.conf.indent;
			}
			this._globalNode.style.left = left+"px";
			this._globalNode.style.top = top+"px";
	}
	
	if (this._controllerNodes.fr_cover) {
		this._controllerNodes.fr_cover.style.left = this._globalNode.style.left;
		this._controllerNodes.fr_cover.style.top = this._globalNode.style.top;
	}
};

dhtmlXColorPicker.prototype.isVisible = function() {
	var answer = false;
	if (this.base._dhx_remove) {
		answer = this.base.parentNode == document.body;
	} else {
		answer = this._globalNode.parentNode == this.base;
	}
	
	return answer;
};

dhtmlXColorPicker.prototype.hide = function() {
	if (this.base._dhx_remove) {
		if (this.base.parentNode) {
			this.base.parentNode.removeChild(this.base);
			dhx4.zim.clear(this.conf.cp_id);
			if (typeof(window.addEventListener) == "function") {
				document.body.removeEventListener("mousedown", this._doOnClickByBody, false);
			} else {
				document.body.detachEvent("onmousedown", this._doOnClickByBody);
			}
		}
	} else {
		if (this.isVisible() == false) return;
		this.base.removeChild(this._globalNode);
	}
	
	if (this._controllerNodes.fr_cover && this._controllerNodes.fr_cover.parentNode) {
		this._controllerNodes.fr_cover.parentNode.removeChild(this._controllerNodes.fr_cover);
	}
	
	if (this.callEvent != undefined) {
		this.callEvent("onHide",[((this.activeNode)? this.activeNode.node: null) ]);
	}
};

dhtmlXColorPicker.prototype.configColorArea = {
	minX: 1,
	maxX: 209,
	minY: 1,
	maxY: 119
};

dhtmlXColorPicker.prototype._skinCollection = {
	dhx_skyblue: true,
	dhx_web: true,
	dhx_terrace: true,
	material: true
};

dhtmlXColorPicker.prototype.i18n = {
	en: {
		labelHue   : "Hue",
		labelSat   : "Sat",
		labelLum   : "Lum",
		labelRed   : "Red",
		labelGreen : "Green",
		labelBlue  : "Blue",
		btnAddColor: "Save the color",
		btnSelect  : "Select",
		btnCancel  : "Cancel"
	}
};

dhtmlXColorPicker.prototype.loadUserLanguage = function(ln) {
	// deprecated
	if (typeof(this._mergeLangModules) == "function") { 
		this._mergeLangModules();
	}
	//
	
	this.conf.lang = ln;
	this._refreshLanguage();
};

dhtmlXColorPicker.prototype._refreshLanguage = function() {
	var key, hash= this.i18n[this.conf.lang];
	for (key in hash) {
		if (this._labelNodes[key]) {
			this._labelNodes[key].innerHTML = hash[key];
		}
	}
};

dhtmlXColorPicker.prototype._setColorAreaXY = function(x,y) {
	var config = this.configColorArea;
	
	x = parseInt(x);
	if (config.minX > x) {
		this.conf.x = config.minX;
	} else if (x > config.maxX) {
		this.conf.x = config.maxX;
	} else if (!isNaN(x)) {
		this.conf.x = x;
	}
	
	y = parseInt(y);
	if (config.minY > y) {
		this.conf.y = config.minY;
	} else if (y > config.maxY) {
		this.conf.y = config.maxY;
	} else if (!isNaN(y)) {
		this.conf.y = y;
	}
	
	this._refreshLines();
};

dhtmlXColorPicker.prototype._setColorByXYC = function(notRefreshC) {
	notRefreshC = notRefreshC || false;
	
	this.value.hue = Math.round((359*(this.conf.x - this.configColorArea.minX)) / (this.configColorArea.maxX - this.configColorArea.minX));
	this.value.lum = Math.round(100 - (100*(this.conf.y - this.configColorArea.minY)) / (this.configColorArea.maxY - this.configColorArea.minY));
	this.value.sat = Math.round(100 - (100*(this.conf.c - this.configColorArea.minY)) / (this.configColorArea.maxY - this.configColorArea.minY));
	
	var rgb = this.colorAIP.hsl2rgb(this.value.hue, this.value.sat/100, this.value.lum/100);
	
	this.value.red = Math.round(255*rgb.r);
	this.value.green = Math.round(255*rgb.g);
	this.value.blue = Math.round(255*rgb.b);
	
	if (!notRefreshC) {
		this._refreshContrast();
	} 
	
	this._refreshInputValues();
	this._refreshColorValue();
};

dhtmlXColorPicker.prototype._setContrastY = function(y) {
	var config = this.configColorArea;
	
	y = parseInt(y);
	if (!isNaN(y)) {
		this.conf.c = Math.min(Math.max(config.minY, y), config.maxY);
	}
	
	this._refreshContrastLine();
};

dhtmlXColorPicker.prototype._refreshInputValues = function() {
	this._controllerNodes.hue.value = this.value.hue;
	this._controllerNodes.sat.value = this.value.sat;
	this._controllerNodes.lum.value = this.value.lum;
	
	this._controllerNodes.red.value = this.value.red;
	this._controllerNodes.green.value = this.value.green;
	this._controllerNodes.blue.value = this.value.blue;
};

dhtmlXColorPicker.prototype._refreshColorValue = function() {
	this._controllerNodes.color.style.backgroundColor = "rgb("+[this.value.red, this.value.green, this.value.blue].join(", ")+")";
	
	var hex = this.colorAIP.rgb2hex({
		r: this.value.red,
		g: this.value.green,
		b: this.value.blue
	});
	
	this._controllerNodes.hsv.value = hex;
	this.callEvent("onChange",[hex]);
};

dhtmlXColorPicker.prototype._refreshContrast = function() {
	var rgb_top = this.colorAIP.hsl2rgb(this.value.hue, 0, this.value.lum/100);
	var rgb_bot = this.colorAIP.hsl2rgb(this.value.hue, 1, this.value.lum/100);
	
	var ieV = this._checkIeVersion();
	if (ieV && ieV<=9) {
		var ie_gradient = this._controllerNodes.contrastArea.firstChild;
		if (ie_gradient == this._controllerNodes.contrast_line) {
			ie_gradient = document.createElement("div");
			ie_gradient.className += "dhxcp_ie_gradient";
			this._controllerNodes.contrastArea.appendChild(ie_gradient);
			this._controllerNodes.contrastArea.appendChild(this._controllerNodes.contrast_line);
		}
		var hex_bot = this.colorAIP.rgb2hex({r: Math.round(255*rgb_top.r) ,g: Math.round(255*rgb_top.g) ,b: Math.round(255*rgb_top.b)});
		var hex_top = this.colorAIP.rgb2hex({r: Math.round(255*rgb_bot.r) ,g: Math.round(255*rgb_bot.g) ,b: Math.round(255*rgb_bot.b)});
		ie_gradient.style.filter = "progid:DXImageTransform.Microsoft.gradient(startColorstr='"+hex_top+"', endColorstr='"+hex_bot+"', GradientType=0)";
	} else {
		rgb_top = [Math.round(255*rgb_top.r), Math.round(255*rgb_top.g), Math.round(255*rgb_top.b)];
		rgb_bot = [Math.round(255*rgb_bot.r), Math.round(255*rgb_bot.g), Math.round(255*rgb_bot.b)];
		var bg_img = "linear-gradient(rgb("+rgb_bot.join(",")+"), rgb("+rgb_top.join(",")+"))";
		if (window.dhx4.isKHTML == true && navigator.userAgent.match(/Windows/gi) != null) bg_img = "-webkit-"+bg_img; // for win/safari 5.1.7
		this._controllerNodes.contrastArea.style.backgroundImage = bg_img;
	}
};

dhtmlXColorPicker.prototype._refreshLines = function() {
	this._controllerNodes.v_line.style.left = this.conf.x+"px";
	this._controllerNodes.h_line.style.top = this.conf.y+"px";
};

dhtmlXColorPicker.prototype._refreshContrastLine = function() {
	this._controllerNodes.contrast_line.style.top = this.conf.c+"px";
};

dhtmlXColorPicker.prototype._getOffsetPosition = function(e, node) {
	var answer = {
		x: NaN,
		y: NaN
	}, target = e.target || e.srcElement;
	if (target == node) {
		answer.x = (e.offsetX != undefined)? e.offsetX: e.layerX;
		answer.y = (e.offsetY != undefined)? e.offsetY: e.layerY;
	} else if (target == this._controllerNodes.v_line) {
		answer.y = (e.offsetY != undefined)? e.offsetY: e.layerY;
	} else {
		answer.x = (e.offsetX != undefined)? e.offsetX: e.layerX;
	}
	
	return answer;
};

dhtmlXColorPicker.prototype.colorAIP = {
	hex2rgb: function(str) {
		var data = str.match(/^(#)([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i);
		if (data != null) {
			return {
				r: parseInt("0x"+data[2]),
				g: parseInt("0x"+data[3]),
				b: parseInt("0x"+data[4])
			};
		} else {
			return null;
		}
	},
	// data {r:.., g:.., b:..}
	rgb2hex: function(data) {
		var r = parseInt(data.r), g = parseInt(data.g), b = parseInt(data.b);
		r = r||0, g = g||0, b = b||0;
		return "#"+((r)? ((r<16)? "0"+r.toString(16):r.toString(16)): "00") +((g)? ((g<16)? "0"+g.toString(16):g.toString(16)): "00") +((b)? ((b<16)? "0"+b.toString(16):b.toString(16)): "00");
	},
	
	// {float} r [0..1], g [0..1], b [0..1], returns {object} hsl
	rgb2hsl: function(r,g,b) {
		var H, S, L;
		var max = Math.max(r,g,b), min = Math.min(r,g,b);
		
		//** L **
		L = 0.5*(max + min);
		
		//** H **
		if (max == min) H = 0;
		else if (max == r) {
			H = 60*(g - b)/(max-min);
			if (g < b) H += 360;
		} else if (max == g) H = 60*(b - r)/(max - min) + 120;
		else H = 60*(r-g)/(max - min) + 240;
		
		//** S **
		if (L == 0 || max == min) S = 0;
		else if (L <= 0.5) S = 0.5*(max - min)/L;
		else S = 0.5*(max - min)/(1 - L);
		
		return {
			h: H,
			s: S,
			l: L
		};
	},
	
	// {int} H [0..359], {float} S [0..1], L [0..1] returns {object} rgb [0..1]
	hsl2rgb: function(H,S,L) {
		var Q,P,_H;
		var T = [], RGB = [];
		
		// ** Q **
		if (L <= 0.5) Q = L*(1+S);
		else Q = L + S - (L*S);
		
		//** P **
		P = 2*L - Q;
		
		//** H ***
		_H = H/360;
		
		T.push(_H + 1/3);
		T.push(_H);
		T.push(_H - 1/3);
		
		for (var i = 0; i<3; i++) {
			if (T[i]<0) T[i] += 1;
			else if (T[i]>1) T[i] -= 1;
			
			if (T[i] < 1/6) RGB.push(P + (Q - P)*6*T[i]);
			else if (T[i] < 0.5) RGB.push(Q);
			else if (T[i] < 2/3) RGB.push(P + (Q - P)*(2/3 - T[i])*6);
			else RGB.push(P);
		}
		
		return {
			r: RGB[0],
			g: RGB[1],
			b: RGB[2]
		};
	}
};

dhtmlXColorPicker.prototype._checkIeVersion = function() {
	var answer;
	var str  = navigator.userAgent.match(/(MSIE)\s(\d\.\d)/i);
	answer = (str && str[2])? parseInt(str[2]): null;
	return answer;
};

dhtmlXColorPicker.prototype.setCustomColors = function() {
	if (this.memory == null) {
		this.initMemoryColors();
		this.conf.customColors = true;
	}
	
	var i, l, value,colors,
	q,w;
	l = arguments.length;
	for (i=0; i<l; i++) {
		if (arguments[i] instanceof Array) {
			value = this._rgb2value(arguments[i][0],arguments[i][1],arguments[i][2]);
			this.memory.setValue(value,null,false);
			continue;
			
		} else if (typeof(arguments[i]) == "string") {
			colors = arguments[i].match(/^rgb\((\d{1,3})\,(\d{1,3})\,(\d{1,3})\)$/i);
			if (colors instanceof Array) {
				value = this._rgb2value(colors[1],colors[2],colors[3]);
				this.memory.setValue(value,null,false);
				continue;
			}
			
			colors = arguments[i].match(/(#[\da-f]{6})/ig);
			if (colors instanceof Array) {
				w = colors.length;
				for (q=0; q<w; q++) {
					value = this._hex2value(colors[q]);
					this.memory.setValue(value,null,false);
				}
			} 
			
		}
	}
};

dhtmlXColorPicker.prototype.getCustomColors = function() {
	var k = [];
	if (this.memory != null && this.conf.customColors == true) {
		for (var q=0; q<this.memory.controllers.length; q++) {
			var v = this.memory.controllers[q].value;
			k.push(this.colorAIP.rgb2hex({r: v.red, g: v.green, b: v.blue}));
		}
	}
	return k;
};

dhtmlXColorPicker.prototype._rgb2value = function(r,g,b) {
	var hsl = this.colorAIP.rgb2hsl(r/255,g/255,b/255);
	
	return {
		red: r,
		green: g,
		blue: b,
		hue: Math.round(hsl.h),
		sat: Math.round(hsl.s*100),
		lum: Math.round(hsl.l*100)
	};
};

dhtmlXColorPicker.prototype._hex2value = function(str) {
	var rgb, hsl;
	rgb = this.colorAIP.hex2rgb(str);
	hsl = this.colorAIP.rgb2hsl(rgb.r/255,rgb.g/255,rgb.b/255);
	
	return {
		red: rgb.r,
		green: rgb.g,
		blue: rgb.b,
		hue: Math.round(hsl.h),
		sat: Math.round(hsl.s*100),
		lum: Math.round(hsl.l*100)
	};
};

dhtmlXColorPicker.prototype.showMemory = function() {
	if (this.memory == null) {
		this.initMemoryColors();
	}
	
	if (!this._globalNode.className.match(/dhxcp_add_memory/)) {
		this._globalNode.className += " dhxcp_add_memory";
	}
	
	this.conf.customColors = true;
};

dhtmlXColorPicker.prototype.hideMemory = function() {
	if (this.memory != null) {
		this._globalNode.className = this._globalNode.className.replace(/\sdhxcp_add_memory/, "");
	}
	
	this.conf.customColors = false;
};

dhtmlXColorPicker.prototype.setSkin = function (skin) {
	
	if (this._skinCollection[skin] != true) return;
	
	var r = "dhtmlxcp_"+(this.skin||"dummy");
	this.base.className = this.base.className.replace(new RegExp(r), "");
	this.base.className += " dhtmlxcp_"+skin;
	this.skin = skin;
	
	if (this.skin == "material") {
		var t = {labelHue: "H", labelSat: "S", labelLum: "L", labelRed: "R", labelGreen: "G", labelBlue: "B"};
		for (var a in t) this.i18n.en[a] = t[a];
	}
	
	if (this.base.className.match(/dhxcp_shadow/) == null && !(dhx4.isIE6 || dhx4.isIE7 || dhx4.isIE8)) {
		this.base.className += " dhxcp_shadow";
	}
};

dhtmlXColorPicker.prototype.hideOnSelect = function(value) {
	value = dhx4.s2b(value);
	this.conf.hideOnSelect = value;
};

dhtmlXColorPicker.prototype._indexOf = function(arr, el) {
	var i,l,answer = -1;
	l = arr.length;
	for (i=l; i>=0; i--) {
		if (arr[i] == el) {
			answer = i;
			break;
		}
	}
	
	return answer;
};

dhtmlXColorPicker.prototype.destructMemory = function() {
	if (this.memory == null) {
		return;
	} 
	this.hideMemory();
	
	var button = this._controllerNodes.memory_block.childNodes[0].firstChild;
	this._labelNodes.btnAddColor =  null;
	if (typeof(window.addEventListener) == "function") {
		button.removeEventListener("click", this.saveColor, false);
	} else {
		button.detachEvent("onclick", this.saveColor);
	}
	
	this.memory.remove();
	
	this._controllerNodes.memory_block.innerHTML = "";
	this.memory = null;
};

dhtmlXColorPicker.prototype.Memory = function(base) {
	var  that = this, selected = null,
	dfValue = {
		red: 255,
		blue: 255,
		green: 255,
		hue: 0,
		sat: 0,
		lum: 100
	};
	
	this.select = function() {
		var target  = (this != window)? this: event.srcElement;
		var contr = contr || target.dhxpc_memory;
		
		if (selected != null) {
			that.unSelect();
		}
		selected = contr;
		contr.domElement.className += " dhxcp_memory_el_select";
		
		if (typeof(that.onSelect) == "function") {
			that.onSelect(contr);
		}
	};
	
	this.onSelect = null;
	this.onSave = null;
	
	this._createMemoryController = function (el) {
		var data = {
			domElement: el,
			value: dhx4._copyObj(dfValue)
		};
		
		el.dhxpc_memory = data;
		
		if (typeof(window.addEventListener) == "function") {
			el.addEventListener("click", that.select, false);
		} else {
			el.attachEvent("onclick", that.select);
		}
		
		return data;
	};
	
	this._findMemoryControllers = function (base) {
		var divs = base.getElementsByTagName("a"),i,l,
		answer = [];
		l = divs.length;
		for (i=0; i<l; i++) {
			answer.push(this._createMemoryController(divs[i]));
		}
		
		return answer;
	};
	
	this.controllers = this._findMemoryControllers(base);
	
	this.unSelect = function() {
		if (selected) selected.domElement.className = selected.domElement.className.replace(/\s.*$/i, "");
		selected = null;
	};
	
	this.setActiveNext = function() {
		var ind = null, l;
		if (selected == null) {
			selected = this.controllers[0];
		} else {
			ind = this.getIndex(selected);
			l = this.controllers.length;
			this.unSelect();
			selected = (ind+1 < l)?  this.controllers[ind+1]:this.controllers[0];
		}
		selected.domElement.className += " dhxcp_memory_el_next";
		return selected;
	};
	
	this.setValue = function(value, contr, callEvent) {
		selected = contr || selected;
		if (selected == null) {
			selected = this.controllers[0];
		}
		
		selected.value.red = value.red;
		selected.value.blue = value.blue;
		selected.value.green = value.green;
		selected.value.hue = value.hue;
		selected.value.sat = value.sat;
		selected.value.lum = value.lum;
		
		selected.domElement.style.backgroundColor = "rgb("+[value.red, value.green, value.blue].join(", ")+")";
		
		this.setActiveNext();
		
		if ((callEvent != false) && (typeof(this.onSave) == "function")) this.onSave(value);
	};
	
	this.clean = function() {
		var l = this.controllers.length,
		item;
		for (var i=0; i<l; i++) {
			item = this.controllers[i];
			item.value = dhx4._copyObj(dfValue);
			item.domElement.style.backgroundColor = "rgb("+[dfValue.red, dfValue.green, dfValue.blue].join(", ")+")";
		}
		this.unSelect();
		selected = this.controllers[0];
	};
	
	this.getIndex = function(selected) {
		var i,l,answer = -1;
		
		l = this.controllers.length;
		for (i=0; i<l; i++) {
			if (this.controllers[i] == selected) {
				answer = i;
				break;
			}
		}
		
		return answer;
	};
	
	this.remove = function() {
		var i,l;
		l = this.controllers.length;
		for (i=0; i<l; i++) {
			if (typeof(window.addEventListener) == "function") {
				this.controllers[i].domElement.removeEventListener("click", this.select, false);
			} else {
				this.controllers[i].domElement.detachEvent("onclick", this.select);
			}
			
			delete this.controllers[i].domElement.dhxpc_memory;
		}
		delete this.onSelect;
		delete this.controllers;
		delete this.onSave;
	};
};

if (window.dhx4.isIE6) {
	dhtmlXColorPicker.prototype._cpInitFRM = function() {
		var f;
		if (!this._controllerNodes.fr_cover) {
			f = document.createElement("IFRAME");
			f.className = "dhxcp_frm";
			f.border = 0;
			f.frameBorder = 0;
			this._controllerNodes.fr_cover = f;
		}
		
		if (!this.base._dhx_remove) {
			this.base.insertBefore(f, this._globalNode);
		}
	};
};

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXSlider(data) {
	
	var that = this;
	
	this.conf = {
		size: null,
		skin: null,
		vertical: false,
		min: 0,
		max: 99,
		value: 0,
		step: 1,
		decimals: 0,
		margin: 2,
		border: 1,
		inverse: false,
		disabled: false,
		tooltip: false,
		visible: true,
		linkTo: null,
		range: false,	// new in 4.3, range-mode
		bg: null,	// new in 4.3, render bg-div inside track, false for single, true for range
		bg_mode: "left"	// new in 4.3, left or right, if range-mode - between runners
	};
	
	this._attachedNode = {};
	this._movingInitialValues = null;
	
	this.base = null;
	
	if (arguments.length > 1) { // init by arguments
		return new dhtmlXSlider(this._renderArgumets(arguments));
	}else if (typeof(data) == "string" || (typeof(data) == "object" && data.tagName)) { // init by node
		return new dhtmlXSlider({parent: data});
	}
	
	if (typeof(data.parent) == "string") {
		this.base = document.getElementById(data.parent);
	} else {
		this.base = data.parent;
	}
	
	this._mergeConfig(this._readAttFormNode(this.base));
	this._mergeConfig(data);
	
	if (this.conf.bg == null) {
		this.conf.bg = (this.conf.range==true);
	}
	
	// fix value/linkto for range-mode
	if (this.conf.range == true) {
		if (!(this.conf.value instanceof Array)) this.conf.value = [this.conf.value];
		if (this.conf.value.length < 2) this.conf.value.push(this.conf.value[0]);
		if (!(this.conf.linkTo instanceof Array)) this.conf.linkTo = [this.conf.linkTo];
	}
	
	this._detectDecimals();
	
	if (this.conf.size == null || typeof(this.conf.size) == "undefined") {
		if (this.conf.vertical) {
			this.conf.size = this.base.offsetHeight;
		} else {
			this.conf.size = this.base.offsetWidth;
		}
	}
	
	var skin = this.conf.skin || window.dhx4.skin || (typeof(dhtmlx) != "undefined"? dhtmlx.skin : null) || window.dhx4.skinDetect("dhxslider") || "material";
	
	this.setSkin(skin);
	
	this.base.innerHTML = "<div class='dhxsl_container'>"+
					"<div class='dhxsl_track'>"+
						(this.conf.bg==true?"<div class='dhxsl_track_bg'></div>":"")+
					"</div>"+
					"<div class='dhxsl_runner'></div>"+
					(this.conf.range==true?"<div class='dhxsl_runner'></div>":"")+
				"</div>";
	
	this._nodes = {
		cont: this.base.firstChild,
		track: this.base.firstChild.firstChild,
		runner: this.base.firstChild.childNodes[1],
		runner2: this.base.firstChild.childNodes[2] // for range-mode
	};
	
	this._nodes.cont.onmousedown = 
	this._nodes.track.onmousedown = 
	this._nodes.cont.onselectstart = 
	this._nodes.track.onselectstart = function(e) {
		e = e || event;
		if (typeof(e.preventDefault) == "function") {
			e.preventDefault();
		} else {
			e.returnValue = false;
		}
		return false;
	};
	
	this._r_actv = null; // active runner
	
	if (this.conf.range == true) {
		this.conf.value = this._normalizeRange(this.conf.value, this.conf.min, this.conf.max);
	} else {
		this.conf.value = this._normalize(this.conf.value, this.conf.min, this.conf.max);
	}
	
	this._setOrient(this.conf.vertical);
	this.setSize(this.conf.size);
	
	// events start
	this._initMover = function(e, index) {
		
		if (that.conf.disabled) return;
		
		e = e || event;
		if (typeof(e.preventDefault) == "function") e.preventDefault();
		
		if (index != null) {
			that._r_actv = that._nodes[index==0?"runner":"runner2"];
		} else {
			that._r_actv = e.target||e.srcElement;
			if (that._r_actv.className.indexOf("dhxsl_runner") == -1) that._r_actv = that._nodes.runner;
		}
		
		that._r_actv.className = "dhxsl_runner dhxsl_runner_actv";
		
		that._movingInitialValues = {};
		if (that.conf.range == true) {
			that._movingInitialValues.index = (that._r_actv==that._nodes.runner?0:1);
			that._movingInitialValues.value = that.conf.value[that._movingInitialValues.index];
		} else {
			that._movingInitialValues.value = that.conf.value;
		}
		that._movingInitialValues.coord = that._getTouchCoord(e);
		
		if (that.conf.disabled == false) {
			if (typeof(window.addEventListener) == "function") {
				window.addEventListener("mousemove", that._move, false);
				window.addEventListener("mouseup", that._cleanMove, false);
				window.addEventListener("touchmove", that._move, false);
				window.addEventListener("touchend", that._cleanMove, false);
			} else {
				document.body.attachEvent("onmousemove", that._move);
				document.body.attachEvent("onmouseup", that._cleanMove);
			}
		}
		that.callEvent("onMouseDown",[that._r_actv==that._nodes.runner?0:1]);
		return false;
	};
	
	this._move = function(e) {
		
		if (that.conf.disabled) return;
		
		e = e || event;
		if (typeof(e.preventDefault) == "function") e.preventDefault();
		
		var runner = (that.conf.vertical) ? that._r_actv.offsetHeight : that._r_actv.offsetWidth;
		var range = that.conf.max - that.conf.min;
		var n_cord = that._getTouchCoord(e);
		var new_value = that._movingInitialValues.value + (n_cord - that._movingInitialValues.coord)*range/(that.conf.size - runner)*(that.conf.inverse?-1:1);
		
		if (that.conf.range == true) {
			var v = [that.conf.value[0], that.conf.value[1]];
			// limits
			if (that._movingInitialValues.index == 0) {
				v[0] = Math.min(v[1], new_value);
			} else if (that._movingInitialValues.index == 1) {
				v[1] = Math.max(v[0], new_value);
			}
			that.setValue(v, true);
		} else {
			that.setValue(new_value, true);
		}
	};
	
	this._cleanMove = function(e) {
		if (typeof(window.addEventListener) == "function") {
			window.removeEventListener("mousemove", that._move, false);
			window.removeEventListener("mouseup", that._cleanMove, false);
			window.removeEventListener("touchmove", that._move, false);
			window.removeEventListener("touchend", that._cleanMove, false);
		} else {
			document.body.detachEvent("onmousemove", that._move);
			document.body.detachEvent("onmouseup", that._cleanMove);
		}
		that._movingInitialValues = null;
		that._r_actv.className = that._r_actv.className.replace(/\s{0,}dhxsl_runner_actv/gi,"");
		that.callEvent("onSlideEnd", [that.conf.value]);
		that.callEvent("onMouseUp", [that._r_actv==that._nodes.runner?0:1]);
		that._r_actv = null;
	};
	
	this._doOnSetValue = function(e) {
		
		if (that.conf.disabled) return;
		
		if (that._movingInitialValues != null) return false;
		
		e = e || event;
		if (typeof(e.preventDefault) == "function") e.preventDefault();
		
		var ofs = 0;
		var t = e.target||e.srcElement;
		if (t.className.match(/dhxsl_track_bg/) != null) ofs = parseInt(t.style[that.conf.vertical?"top":"left"]);
		
		if (e.type.match(/touch/) != null) {
			var n_coord = that._getTouchCoord(e) + ofs;
		} else {
			var n_coord = (that.conf.vertical ? (e.offsetY || e.layerY) : (e.offsetX || e.layerX)) + ofs;
		}
		var runner = (that.conf.vertical ? that._nodes.runner.offsetHeight : that._nodes.runner.offsetWidth) + ofs;
		var range = that.conf.max - that.conf.min;
		
		var index = null;
		var new_value = null;
		
		if (that.conf.inverse == true) {
			new_value = that.conf.max-(n_coord*range/(that.conf.size));
		} else {
			new_value = (n_coord*range/(that.conf.size) + that.conf.min);
		}
		
		if (that.conf.range == true) {
			index = (Math.abs(that.conf.value[0]-new_value) <= Math.abs(that.conf.value[1]-new_value) ? 0 : 1); // select nearest runner
			new_value = [index==0?new_value:that.conf.value[0], index==1?new_value:that.conf.value[1]];
		}
		
		that.conf.init_index = index;
		that.setValue(new_value, true);
		that.conf.init_index = null;
		
		if (that._movingInitialValues == null) that._initMover(e, index);
		
		return false;
	};
	
	this._doOnChangeInput = function(e) {
		e = e || event;
		var target = e.target || e.srcElement;
		that.setValue(target.value);
	};
	
	this._doOnKeyDown = function(e) {
		e = e || event;
		var target = e.target || e.srcElement;
		if (e.keyCode == 13) that.setValue(target.value);
	};
	
	// events end
	
	this._attachEvents(this._nodes);
	
	this.unload = function() {
		
		dhx4._eventable(this, "clear");
		
		this._detachNode();
		this._detachEvents(this._nodes);
		
		this.base.removeChild(this._nodes.cont);
		
		this._nodes.cont.onmousedown = 
		this._nodes.track.onmousedown = 
		this._nodes.cont.onselectstart = 
		this._nodes.track.onselectstart = null;
		
		delete this._nodes.cont;
		delete this._nodes.track;
		delete this._nodes.max;
		delete this._nodes.min;
		delete this._nodes.runner;
		if (this._nodes.runner2) delete this._nodes.runner2;
		
		if (/\s?dhtmlxslider_\S*/.test(this.base.className)) {
			this.base.className = this.base.className.replace(/\s?dhtmlxslider_\S*/, "");
		}
		
		for (var key in this) this[key] = null;
		
		that = null;
	};
	
	dhx4._eventable(this);
	
	if (this.conf.disabled) {
		this.disable();
	}
	
	if (this.conf.tooltip) {
		this.enableTooltip();
	}
	
	if (!this.conf.visible) {
		this.hide();
	}
	
	if (this.conf.linkTo) {
		this.linkTo(this.conf.linkTo);
	}
	
	return this;
	
};

dhtmlXSlider.prototype._setOrient = function(vertical) {
	vertical = vertical || false;
	
	if (/\s?dhxsl_cont_hr/i.test(this._nodes.cont.className)) {
		this._nodes.cont.className = this._nodes.cont.className.replace(/\s?dhxsl_cont_hr/i, "");
	}
	
	if (/\s?dhxsl_cont_vr/i.test(this._nodes.cont.className)) {
		this._nodes.cont.className = this._nodes.cont.className.replace(/\s?dhxsl_cont_vr/i, "");
	}
	
	if (vertical) {
		this._nodes.cont.className += " dhxsl_cont_vr";
	} else {
		this._nodes.cont.className += " dhxsl_cont_hr";
	}
};

dhtmlXSlider.prototype._getTouchCoord = function(e) {
	var type = (e.type.match(/mouse/) != null ? "client":"page") + (this.conf.vertical == true ? "Y":"X");
	var coord = (typeof(e[type]) != "undefined" && e[type] != 0 ? e[type] : (e.touches != null && e.touches[0] != null ? e.touches[0][type]||0:0));
	return coord;
};

dhtmlXSlider.prototype._attachEvents = function(nodes) {
	if (typeof(window.addEventListener) == "function") {
		nodes.runner.addEventListener("mousedown", this._initMover, false);
		nodes.runner.addEventListener("touchstart", this._initMover, false);
		nodes.cont.addEventListener("mousedown", this._doOnSetValue, false);
		nodes.cont.addEventListener("touchstart", this._doOnSetValue, false);
		if (nodes.runner2) {
			nodes.runner2.addEventListener("mousedown", this._initMover, false);
			nodes.runner2.addEventListener("touchstart", this._initMover, false);
		}
	} else {
		nodes.runner.attachEvent("onmousedown", this._initMover);
		nodes.cont.attachEvent("onmousedown", this._doOnSetValue);
		if (nodes.runner2) {
			nodes.runner2.attachEvent("onmousedown", this._initMover);
		}
	}
};

dhtmlXSlider.prototype._detachEvents = function(nodes) {
	if (typeof(window.addEventListener) == "function") {
		nodes.runner.removeEventListener("mousedown", this._initMover, false);
		nodes.runner.removeEventListener("touchstart", this._initMover, false);
		nodes.cont.removeEventListener("mousedown", this._doOnSetValue, false);
		nodes.cont.removeEventListener("touchstart", this._doOnSetValue, false);
		if (nodes.runner2) {
			nodes.runner2.removeEventListener("mousedown", this._initMover, false);
			nodes.runner2.removeEventListener("touchstart", this._initMover, false);
		}
	} else {
		nodes.runner.detachEvent("onmousedown", this._initMover);
		nodes.cont.detachEvent("onmousedown", this._doOnSetValue);
		if (nodes.runner2) {
			nodes.runner2.detachEvent("onmousedown", this._initMover);
		}
	}
};

dhtmlXSlider.prototype._mergeConfig = function(data) {
	for (var key in data) {
		switch (key.toLowerCase()) {
			case "min":
			case "max":
			case "size":
			case "step":
			case "value":
			case "inverse":
				this.conf[key] = data[key];
				break;
			case "tooltip":
			case "visible":
			case "vertical":
			case "disabled":
			case "range":
			case "bg":
				this.conf[key] = dhx4.s2b(data[key]);
				break;
			case "bg_mode":
				this.conf[key] = ({"left":"left","right":"right"}[data[key]])||"left";
				break;
			case "parent":
				continue;
				break;
			case "skin":
				this.conf[key] = (this._skinCollection[data[key]] == true ? data[key] : null); // reset not supported 3.6 skins to default
				break;
			default:
				this.conf[key] = data[key];
		}
	}
};

dhtmlXSlider.prototype._readAttFormNode = function(node) {
	var atts = node.attributes, l = atts.length, i, answer = {}, att;
	
	for (i=0; i<l; i++) {
		att = atts[i];
		switch (att.name.toLowerCase()) {
			case "size":
			case "min":
			case "max":
			case "value":
			case "step":
				answer[att.name] = Number(att.value);
				break;
			case "skin":
				answer[att.name] = att.value;
				break;
			case "vertical":
			case "disabled":
			case "visible":
			case "range":
			case "bg":
				answer[att.name] = dhx4.s2b(att.value);
				break;
			case "linkto":
				answer[att.name] = att.value;
				break;
			case "tooltip":
				answer[att.name] = dhx4.s2b(att.value);
				break;
			case "bg_mode":
				answer[att.name] = ({"left":"left","right":"right"}[att.value])||"left";
				break;
		}
	}
	
	return answer;
};

dhtmlXSlider.prototype._renderArgumets = function(arg) {
	var answer = {}, i,l;
	l = arg.length;
	
	for (i=0; i<l; i++) {
		switch (i) {
			case 0:
				answer.parent = arg[i];
				break;
			case 1:
				answer.size = arg[i];
				break;
			case 2:
				answer.skin = arg[i];
				break;
			case 3:
				answer.vertical = arg[i];
				break;
			case 4:
				answer.min = arg[i];
				break;
			case 5:
				answer.max = arg[i];
				break;
			case 6:
				answer.value = arg[i];
				break;
			case 7:
				answer.step = arg[i];
				break;
		}
	}
	
	return answer;
};

dhtmlXSlider.prototype._skinCollection = {
	dhx_skyblue: true,
	dhx_web: true,
	dhx_terrace: true,
	material: true
};

dhtmlXSlider.prototype._indexOf = function(arr, el) {
	var i,l,answer = -1;
	l = arr.length;
	for (i=l; i>=0; i--) {
		if (arr[i] == el) {
			answer = i;
			break;
		}
	}
	
	return answer;
};

dhtmlXSlider.prototype._refreshRunner = function(index) {
	
	var k = (this.conf.vertical == true ? {x: "top", y: "left", ofs_w: "offsetHeight", ofs_h: "offsetWidth"} : {x: "left", y: "top", ofs_w: "offsetWidth", ofs_h: "offsetHeight"});
	
	var cmax = this._nodes.cont[k.ofs_w] - this._nodes.runner[k.ofs_w];
	
	var r1 = this._nodes.runner;
	var r2 = this._nodes.runner2;
	
	// single or left
	if (index == null || index == 0) {
		var cp = this._getCoord(cmax, (this.conf.value instanceof Array?this.conf.value[0]:this.conf.value));
		r1.style[k.x] = cp + this.conf.border + "px";
		r1.style[k.y] = Math.round((this._nodes.cont[k.ofs_h] - r1[k.ofs_h])/2) + "px";
	}
	
	// right
	if (this.conf.range == true && (index == null || index == 1)) {
		var cp = this._getCoord(cmax, this.conf.value[1]);
		r2.style[k.x] = cp + this.conf.border + "px";
		r2.style[k.y] = Math.round((this._nodes.cont[k.ofs_h] - r1[k.ofs_h])/2) + "px";
	}
	
	// check z-index
	if (this.conf.range == true) {
		if (r1.style[k.x] == r2.style[k.x] && this.conf.value[1] == this.conf.max) {
			if (r1.style.zIndex != 2) r1.style.zIndex = 2;
		} else {
			if (r1.style.zIndex == 2) r1.style.zIndex = 1;
		}
	}
	
	r1 = r2 = null;
	
	this._refreshBG();
};

dhtmlXSlider.prototype._setValueByCoord = function(data) {
	var cx = dhx4.absLeft(this._nodes.cont),
	cy = dhx4.absTop(this._nodes.cont),
	value, k;
	
	if (this.conf.vertical) {
		k = (data.y - cy - this._nodes.runner.offsetHeight/2)/(this._nodes.cont.offsetHeight - this._nodes.runner.offsetHeight);
	} else {
		k = (data.x - cx - this._nodes.runner.offsetWidth/2)/(this._nodes.cont.offsetWidth - this._nodes.runner.offsetWidth);
	}
	
	value = (this.conf.max-this.conf.min)*k+this.conf.min;
	
	this.setValue(value, true);
};

dhtmlXSlider.prototype._getCoord = function(max, value) {
	var v = (this.conf.inverse?this._inverseValue(value):value);
	var k = (v-this.conf.min)/(this.conf.max - this.conf.min);
	return Math.round(max*k);
};

dhtmlXSlider.prototype._normalize = function(value, min, max) {
	value = Number(value); // for decimals
	value = Math.round(value/this.conf.step)*this.conf.step;
	var ten = Math.pow(10, this.conf.decimals);
	value = Math.round(value*ten)/ten;
	value = Math.max(min, Math.min(max, value));
	return value;
};

dhtmlXSlider.prototype._normalizeRange = function(value, min, max) {
	if (value[1] < value[0]) value[1] = value[0];
	value[0] = this._normalize(value[0], min, Math.min(max, value[1]));
	value[1] = this._normalize(value[1], Math.max(min, value[0]), max);
	return value;
};

dhtmlXSlider.prototype._refreshBG = function() {
	
	if (this.conf.bg != true) return;
	
	var p = this._nodes.track.firstChild;
	var r = this._nodes.runner;
	var r2 = r.nextSibling;
	
	var k = (this.conf.vertical == true ? {x: "top", w: "height", ofs: "offsetHeight"} : {x: "left", w: "width", ofs: "offsetWidth"});
	
	if (this.conf.range == true) {
		p.style[k.x] = Math.floor(parseInt(r.style[k.x])+r[k.ofs]/2)+"px";
		p.style[k.w] = Math.max(Math.floor(parseInt(r2.style[k.x])+r2[k.ofs]/2)-parseInt(p.style[k.x]), 0)+"px";
	} else {
		var mode = (this.conf.inverse == true? {"left":"right", "right":"left"}[this.conf.bg_mode] : this.conf.bg_mode);
		p.style[k.x] = (mode == "left" ? "0" : Math.floor(parseInt(r.style[k.x])+r[k.ofs]/2)) + "px";
		p.style[k.w] = (mode == "left" ? Math.floor(parseInt(r.style[k.x])+r[k.ofs]/2) : this._nodes.track[k.ofs]-parseInt(p.style[k.x])) + "px";
	}
	
	p = r = r2 = null;
	
};

dhtmlXSlider.prototype._attachNode = function(node, index) {
	
	this._detachNode(index);
	
	var tagName = node.tagName.toLowerCase();
	if (!tagName) return;
	
	// node._dhxsl_mode = mode;
	this._attachedNode["node_"+index] = node;
	
	switch (tagName) {
		case "input":
		case "select":
			if (typeof(window.addEventListener) == "function") {
				node.addEventListener("change", this._doOnChangeInput, false);
				node.addEventListener("keydown", this._doOnKeyDown, false);
			} else {
				node.attachEvent("onchange", this._doOnChangeInput);
				node.attachEvent("onkeydown", this._doOnKeyDown);
			}
			
			this._attachedNode.setValue = function(value, decimals, index) {
				var v = (value instanceof Array?value[index||0]:value);
				this["node_"+(index||0)].value = dhtmlXSlider.prototype._atatchedNodeFixDec(v, decimals);
			};
			break;
		default:
			this._attachedNode.setValue = function(value, decimals, index) {
				var v = (value instanceof Array?value[index||0]:value);
				this["node_"+(index||0)].innerHTML = dhtmlXSlider.prototype._atatchedNodeFixDec(v, decimals);
			};
	}
	
	this._attachedNode.setValue(this.conf.value, this.conf.decimals, index);
};

dhtmlXSlider.prototype._detachNode = function(index) {
	
	var node = this._attachedNode["node_"+index];
	
	if (!node) return;
	
	var tagName = node.tagName;
	
	switch (tagName) {
		case "input":
		case "select":
			if (typeof(window.addEventListener) == "function") {
				node.removeEventListener("change", this._doOnChangeInput, false);
				node.removeEventListener("keydown", this._doOnChangeInput, false);
			} else {
				node.detachEvent("change", this._doOnChangeInput);
				node.detachEvent("keydown", this._doOnChangeInput);
			}
			break;
	}
	
	delete this._attachedNode["node_"+index];
	delete this._attachedNode.setValue;
	node = null;
};

dhtmlXSlider.prototype._atatchedNodeFixDec = function(value, decimals) {
	value = String(value);
	if (decimals > 0) {
		var k = value.match(/\.\d{1,}$/);
		if (k != null) decimals = Math.max(decimals-k[0].length+1);
		value += (value.indexOf(".")<0?".":"");
		for (var q=0; q<decimals; q++) value += "0";
	}
	return value;
};

dhtmlXSlider.prototype._detectDecimals = function() {
	var k = this.conf.step.toString().match(/\.(\d*)$/);
	this.conf.decimals = (k!=null?k[1].length:0);
};

dhtmlXSlider.prototype.setSize = function(size) {
	if (!isNaN(size)) {
		if (this.conf.vertical) {
			if (this._nodes.cont.style.width) delete this._nodes.cont.style.width;
			this._nodes.cont.style.height = size-this.conf.margin + "px";
		} else {
			if (this._nodes.cont.style.height) delete this._nodes.cont.style.height;
			this._nodes.cont.style.width = size-this.conf.margin + "px";
		}
		this._refreshRunner();
	}
};

dhtmlXSlider.prototype.setSkin = function (skin) {
	skin = skin.toLowerCase();
	
	var classes, _int = -1, skinName, className="dhtmlxslider";
	
	classes = this.base.className.match(/\S\w+/ig);
	
	if (classes instanceof  Array) {    
		for (skinName in this._skinCollection) {
			if (_int == -1) {
				_int = this._indexOf(classes, className + "_" + skinName);
			} else {           
				break;
			}
		}
		
		_int = (_int == -1) ? classes.length : _int;
	} else {
		classes = [];
		_int = 0;
	}
	
	
	
	classes[_int] = className + "_" + skin;
	
	this.base.className = classes.join(" ");
	this.conf.skin = skin;
	
	if (this._nodes) this._refreshRunner();
};

dhtmlXSlider.prototype.setValue = function(value, callEvent) {
	
	callEvent = callEvent || false;
	
	var index = null;
	var refresh = false;
	
	if (this.conf.range == true) {
		if (this._r_actv != null) index = (this._r_actv==this._nodes.runner?0:1);
		value = this._normalizeRange(value, this.conf.min, this.conf.max);
		refresh = (this.conf.value[0] != value[0] || this.conf.value[1] != value[1]);
	} else {
		value = this._normalize(value, this.conf.min, this.conf.max);
		refresh = (this.conf.value != value);
	}
	
	if (refresh = true) {
		
		this.conf.value = value;
		this._refreshRunner(index);
		
		this._refreshTooltip();
		
		if (callEvent) {
			var args = [value, this];
			if (this.conf.range == true) {
				if (this._r_actv != null) {
					args.push(this._r_actv==this._nodes.runner?0:1);
				} else if (this.conf.init_index != null) {
					args.push(this.conf.init_index.valueOf());
				}
			}
			this.callEvent("onChange", args);
		}
	}
	
	if (typeof(this._attachedNode.setValue) == "function") {
		if (index == null) index = this.conf.init_index;
		this._attachedNode.setValue(this.conf.value, this.conf.decimals, index);
	}
};

dhtmlXSlider.prototype.getValue = function() {
	if (this.conf.range == true) {
		return [this.conf.value[0].valueOf(),this.conf.value[1].valueOf()];
	} else {
		return this.conf.value.valueOf();
	}
};

dhtmlXSlider.prototype._inverseValue = function(value) {
	return this.conf.max+this.conf.min-value;
};

dhtmlXSlider.prototype.disable = function(mode) {
	mode = (mode == false) ? false : true; // deprecated
	var reg = null;
	if (mode) {
		for (var nm in this._nodes) {
			if (nm == "cont") continue;
			var a = (nm == "runner2"?"runner":nm);
			if (this._nodes[nm] != null) {
				reg = new RegExp("\\s?dhxsl_"+a+"_dis","i");
				if (!reg.test(this._nodes[nm].className)) this._nodes[nm].className += " dhxsl_"+a+"_dis";
			}
		}
		
		this.conf.disabled = true;
	} else {
		this.enable();
	}
};

dhtmlXSlider.prototype.enable = function() {
	var reg;
	for (var nm in this._nodes) {
		if (nm == "cont") continue;
		var a = (nm == "runner2"?"runner":nm);
		if (this._nodes[nm] != null) {
			reg = new RegExp("\\s?dhxsl_"+a+"_dis","i");
			if (reg.test(this._nodes[nm].className)) this._nodes[nm].className = this._nodes[nm].className.replace(reg,"");
		}
	}
	
	this.conf.disabled = false;
};

dhtmlXSlider.prototype.isEnabled = function() {
	return !this.conf.disabled;
};

dhtmlXSlider.prototype.disableTooltip = function() {
	this._nodes.cont.removeAttribute("title");
	this.conf.tooltip = false;
};

dhtmlXSlider.prototype.enableTooltip = function(mode) {
	if (typeof(mode) == "undefined") mode = true; else mode = dhx4.s2b(mode);
	if (mode) {
		this.conf.tooltip = true;
		this._refreshTooltip();
	} else {
		this.disableTooltip();
	}
};

dhtmlXSlider.prototype.setMax = function(value) {
	if (!isNaN(value) && this.conf.min < value) {
		this.conf.max = value;
		this.setValue(this.conf.value);
	}
};

dhtmlXSlider.prototype.getMax = function() {
	return this.conf.max;
};

dhtmlXSlider.prototype.setMin = function(value) {
	if (!isNaN(value) && this.conf.max > value) {
		this.conf.min = value;
		this.setValue(this.conf.value);
	}
};

dhtmlXSlider.prototype.getMin = function() {
	return this.conf.min;
};

dhtmlXSlider.prototype.setStep = function(value) {
	var maxValue = this.conf.max - this.conf.min;
	if (!isNaN(value) && value < maxValue) {
		this.conf.step = value;
		this._detectDecimals();
		this.setValue(this.conf.value);
	}
};

dhtmlXSlider.prototype.getStep = function() {
	return this.conf.step;
};

dhtmlXSlider.prototype.show = function() {
	if (/\s?dhxsl_hidden/i.test(this._nodes.cont.className)) {
		this._nodes.cont.className = this._nodes.cont.className.replace(/\s?dhxsl_hidden/i, "");
	}
	
	this.conf.visible = true;
};

dhtmlXSlider.prototype.hide = function() {
	if (!/\s?dhxsl_hidden/i.test(this._nodes.cont.className)) {
		this._nodes.cont.className += " dhxsl_hidden";
	}
	
	this.conf.visible = false;
};

dhtmlXSlider.prototype.isVisible = function() {
	return this.conf.visible;
};

dhtmlXSlider.prototype.linkTo = function(node) {
	if (!(node instanceof Array)) node = [node];
	for (var q=0; q<node.length && q<2; q++) {
		if (node[q] != null) {
			if (typeof(node[q]) == "string") node[q] = document.getElementById(node[q]);
			this._attachNode(node[q], q);
		}
	}
};

dhtmlXSlider.prototype._refreshTooltip = function() {
	if (this.conf.tooltip == true) {
		if (this.conf.value instanceof Array) {
			this._nodes.cont.title = this.conf.value.join(", ");
		} else {
			this._nodes.cont.title = this.conf.value;
		}
	}
};

dhtmlXSlider.prototype.getRunnerIndex = function() {
	if (this._r_actv == null) return -1;
	return (this._r_actv==this._nodes.runner?0:1);
};

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXPopup(conf) {
	
	var that = this;
	
	this.conf = conf||{};
	conf = null;
	
	this.mode = (this.conf.mode||"bottom"); // popup position related to caller element
	this.conf.zi = window.dhx4.newId();
	
	// enable/disable native context menu, enabled by default
	this.conf.context = (this.conf.context==null?true:window.dhx4.s2b(this.conf.context));
	
	// enable/disable full-fix for content in IE6 (depending on content fix mey be not required), disabled by default
	this.conf.IE6_display_fix = (this.conf.IE6_display_fix==null?false:window.dhx4.s2b(this.conf.IE6_display_fix));
	
	// click/touch conf
	this.conf.last_p_click = this.conf.last_body_click = null;
	
	this.p = document.createElement("DIV");
	this.p.style.display = "none";
	this.p.innerHTML = "<div class='dhx_popup_area"+(window.dhx4.isIE?" dhx_popup_area_ie":"")+"'>"+
					"<table cellspacing='0' cellpadding='0' border='0' class='dhx_popup_table'><tbody></tbody></table>"+
				"</div>"+
				"<div class='dhx_popup_arrow dhx_popup_arrow_"+this.mode+"'></div>";
	
	document.body.appendChild(this.p);
	
	this.p.oncontextmenu = function(e) {
		if (that.conf.context == false) {
			e = e||event;
			e.returnValue = false;
			return false;
		}
	}
	
	this.skinParams = {
		dhx_terrace: {
			t0: 19, // minimal top offset for polygon, i.e. space between polygon top and arrow top
			t1: 9,  // if no more space at top, and "t0 allowed" - move top polygon position a bit to bottom, t1 = offset for empty space at top
			t2: 19, // same as t0, for width
			t3: 9   // same as t1, for width
		},
		dhx_skyblue: {t0: 12, t1: 9, t2: 12, t3: 9},
		dhx_web: {t0: 12, t1: 9, t2: 12, t3: 9},
		material: {t0: 19, t1: 9, t2: 19, t3: 9}
	};
	
	this.p.ontouchstart = this.p.onclick = function(e) {
		e = e||event;
		
		// skip click if touch
		var r = (that.conf.last_p_click != null && that.conf.last_p_click != e.type);
		that.conf.last_p_click = e.type;
		if (r == true) return;
		
		that._clearClick = true;
		if (that._nodeObj != null) {
			that.callEvent("onContentClick",[]);
			return true;
		}
		var t = (e.target||e.srcElement);
		var id = null;
		while (t != that.p && t != null) {
			if (typeof(t._idd) != "undefined" && !t._isSeparator) {
				id = t._idd;
				t = null;
			} else {
				t = t.parentNode;
			}
		}
		t = null;
		if (id != null) {
			that.callEvent("onClick",[id]);
			if (that != null && that.isVisible != null && that.isVisible() && that.callEvent("onBeforeHide",["select",e,id]) === true) {
				e.cancelBubble = true;
				that.hide();
			}
		}
	}
	
	this.separator = "DHXSEP_"+window.dhx4.newId();
	
	this.tpl = [];
	this._setTemplate = function(t) {
		this.tpl = t.split(",");
	}
	
	this.show = function(id) { // 4 coords for custom object, x, y, width, height
		
		var p = null;
		
		if (arguments.length == 1) {
			
			// if id not specified show on first
			
			if (!id) {
				id = this.conf.id[0];
			} else {
				if (!this._idExists(id)) return;
			}
			if (this.conf.toolbar) {
				p = this.conf.toolbar._getItemDim(id);
			}
			if (this.conf.ribbon) {
				p = this.conf.ribbon._getItemDim(id);
			}
			if (this.conf.form) {
				p = this.conf.form._getItemDim(id);
			}
			
		} else if (arguments.length == 4) {
			
			this._clearClick = true;
			
			// show for custom object, 4 coords
			p = {
				left:   arguments[0],
				top:    arguments[1],
				width:  arguments[2],
				height: arguments[3]
			}
			
			id = null;
		}
		
		if (!p) return;
		
		this.p.style.visibility = "hidden";
		this.p.style.display = "";
		
		this._setPos(p);
		
		this.p.style.zIndex = window.dhx4.zim.reserve(this.conf.zi);
		this.p.style.visibility = "visible";
		
		this._lastId = id;
		
		this.callEvent("onShow",[id]);
		
		
	}
	
	this._setPos = function(p, state) {
		
		var x = p.left;
		var y = p.top;
		var w = p.width;
		var h = p.height;
		
		this._posData = {
			left: x,
			top: y,
			width: w,
			height: h
		};
		
		var d = window.dhx4.screenDim();
		
		var mode = state||this.mode;
		if (typeof(state) == "undefined") state = false;
		
		// avail space form each side, negative value = no-space
		var availSpace = {
			top: (y-this.p.offsetHeight)-d.top,
			bottom: d.bottom-(y+h+this.p.offsetHeight),
			left: x-this.p.offsetWidth-d.left,
			right: d.right-(x+w+this.p.offsetWidth)
		};
		
		if (!state && availSpace[mode] < 0) {
			var k = this._getAvailPos(mode, availSpace);
			if (k !== false) {
				this._setPos(p, k);
				return;
			}
			
		}
		
		if (mode == "top" || mode == "bottom") {
			
			var t0 = this.skinParams[this.conf.skin].t2;
			var t1 = this.skinParams[this.conf.skin].t3;
			
			var pw2 = Math.round(this.p.offsetWidth/2); // 1/2 polygon width
			var aw2 = Math.round(this.p.lastChild.offsetWidth/2); // 1/2 arrow width
			
			// define max left and right position of input including rendering [d.left..d.right] area
			if (x < d.left) { var x1 = Math.min(x+w, d.left); w = x+w-x1; x = x1; } // left
			if (x+w > d.right) w = d.right-x; // right
			
			// arrow position
			var ta = Math.round(x+w/2);
			
			// polygon top
			var left = ta - pw2;
			var maxLeft = ta - t0 - aw2;
			var maxLeftRight = ta+aw2+t0-this.p.offsetWidth;
			
			
			if (left < d.left-t1) { // left
				left = Math.min(d.left-t1, maxLeft);
			} else if (left+this.p.offsetWidth > d.right+t1) { // right
				left = Math.max(maxLeftRight, d.right+t1-this.p.offsetWidth); // -scrollWidth here?
			}
			
			// draw polygon
			this.p.style.left = left+"px";
			this.p.style.top = (mode=="top"?y-this.p.offsetHeight:y+h)+"px";
			
			// fix arrow offset (it inside polygon)
			ta = ta-left-aw2;
			
			// draw arrow
			this.p.lastChild.className = "dhx_popup_arrow dhx_popup_arrow_"+mode;
			this.p.lastChild.style.top = (mode=="top"?this.p.offsetHeight-this.p.lastChild.offsetHeight:0)+"px";
			this.p.lastChild.style.left = ta+"px";
			
			
		}
		
		
		if (mode == "left" || mode == "right") {
			
			var t0 = this.skinParams[this.conf.skin].t0;
			var t1 = this.skinParams[this.conf.skin].t1;
			
			var ph2 = Math.round(this.p.offsetHeight/2); // 1/2 polygon height
			var ah2 = Math.round(this.p.lastChild.offsetHeight/2); // 1/2 arrow height
			
			// define max top and bottom position of input including rendering [d.top..d.bottom] area
			if (y < d.top) { var y1 = Math.min(y+h, d.top); h = y+h-y1; y = y1; } // top
			if (y+h > d.bottom) h = d.bottom-y; // bottom
			
			// arrow position
			var ta = Math.round(y+h/2);
			
			// polygon top
			var top = ta - ph2;
			var maxTop = ta - t0 - ah2;
			var maxTopBottom = ta+ah2+t0-this.p.offsetHeight;
			
			
			if (top < d.top-t1) { // top
				top = Math.min(d.top-t1, maxTop);
			} else if (top+this.p.offsetHeight > d.bottom+t1) { // bottom
				top = Math.max(maxTopBottom, d.bottom+t1-this.p.offsetHeight);
			}
			
			// draw polygon
			this.p.style.left = (mode=="left"?x-this.p.offsetWidth:x+w)+"px";
			this.p.style.top = top+"px";
			
			// fix arrow offset (it inside polygon)
			ta = ta-top-ah2;
			
			// draw arrow
			this.p.lastChild.className = "dhx_popup_arrow dhx_popup_arrow_"+mode;
			this.p.lastChild.style.left = (mode=="left"?this.p.offsetWidth-this.p.lastChild.offsetWidth:0)+"px";
			this.p.lastChild.style.top = ta+"px";
			
		}
		
		if (this._IEDisp && this._nodeId != null) {
			var t = document.getElementById(this._nodeId);
			if (this.conf.IE6_display_fix == true) t.style.visibility = "hidden";
			window.setTimeout(function(){
				t.style.visibility = "visible";
				t = null;
			},1);
		}
	}
	
	this._getAvailPos = function(mode, data) {
		
		var seq = {
			top: ["bottom","right","left"],
			bottom: ["top","right","left"],
			left: ["right", "bottom", "top"],
			right: ["left", "bottom", "top"]
		};
		
		var dir = null;
		
		// check "next" with avail space
		for (var q=0; q<seq[mode].length; q++) {
			if (dir == null && data[seq[mode][q]] > 0) dir = seq[mode][q];
		}
		
		// define which side have more space
		if (dir == null) {
			dir = "bottom";
			for (var a in data) if (data[a] > data[dir]) dir = a;
		}
		
		if (dir == mode) return false;
		
		return dir;
		
	}
	
	this._repaint = function() {
		if (this.isVisible()) this._setPos(this._posData);
	}
	
	this.clear = function() {
		
		if (this._nodeObj) {
			if (window.dhx4.isIE && typeof(window.dhtmlXLayoutObject) == "function" && this._nodeObj instanceof window.dhtmlXLayoutObject) {
				this.p.onmousedown = null;
			}
			if (this._nodeObj.unload) {
				this._nodeObj.unload();
			} else if (this._nodeObj.destruct) {
				this._nodeObj.destruct();
			}
			this._nodeObj = this._nodeId = null;
			// events if any
			if (this._nodeObjEv != null) {
				for (var q=0; q<this._nodeObjEv.length; q++) this.detachEvent(this._nodeObjEv[q]);
				this._nodeObjEv = null;
			}
		}
		
		if (this._IEHoverInited) this._IEHoverClear();
		
		var r = this.p.firstChild.firstChild.firstChild; // table->tbody
		while (r.childNodes.length > 0) r.removeChild(r.lastChild);
		
		r = null;
		
		this.itemData = {};
	}
	
	this.hide = function() {
		if (this.p.style.display != "none") {
			this.p.style.display = "none";
			window.dhx4.zim.clear(this.conf.zi);
			var id = this._lastId;
			this._lastId = null;
			this.callEvent("onHide",[id]);
			// reset click/tuoch events types
			this.conf.last_p_click = this.conf.last_body_click = null;
		}
	}
	
	this.isVisible = function() {
		return (this.p.style.display == "");
	}
	
	this.itemData = {};
	
	this.getItemData = function(id) {
		if (!id) return this.itemData;
		if (this.itemData[id]) return this.itemData[id];
		return {};
	}
	
	this.setSkin = function(skin) {
		this.conf.skin = skin;
		this.p.className = "dhx_popup_"+this.conf.skin;
		if (this._nodeObj != null && typeof(this._nodeObj.setSkin) == "function") this._nodeObj.setSkin(this.conf.skin);
		this._repaint();
	}
	
	this.attachList = function(template, data) {
		
		this._setTemplate(template);
		
		this.clear();
		var r = this.p.firstChild.firstChild.firstChild; // table->tbody
		
		for (var q=0; q<data.length; q++) {
			
			var tr = document.createElement("TR");
			if (data[q] != this.separator) {
				if (typeof(data[q].id) == "undefined" || data[q].id == null) {
					tr._idd = window.dhx4.newId();
					while (this.itemData[tr._idd] != null) tr._idd = window.dhx4.newId();
				} else {
					tr._idd = data[q].id;
				}
				this.itemData[tr._idd] = data[q];
			}
			r.appendChild(tr);
			
			if (data[q] == this.separator) {
				tr.className = "dhx_popup_sep";
				tr._isSeparator = true;
				var td = document.createElement("TD");
				td.className = "dhx_popup_sep";
				td.colSpan = this.tpl.length;
				td.innerHTML = "<div class='dhx_popup_sep'>&nbsp;</div>";
				tr.appendChild(td);
				td = null;
			} else {
				for (var w=0; w<this.tpl.length; w++) {
					var css = "dhx_popup_td";
					if (this._IEFirstLast && (this.tpl.length==1||w==0||w==this.tpl.length-1)) {
						if (this.tpl.length==1) css += " dhx_popup_td_single"; else css += (w==0?" dhx_popup_td_first":" dhx_popup_td_last");
					}
					var td = document.createElement("TD");
					td.className = css;
					td.innerHTML = data[q][this.tpl[w]]||"&nbsp;";
					tr.appendChild(td);
					td = null;
				}
				// IE6 hover functionality
				if (this._IEHover) {
					tr._IEHover = true;
					if (!this._IEHoverInited) this._IEHoverInit();
				}
			}
			tr = null;
		}
		r = null;
		
		this._repaint();
		
	}
	
	this._attachNode = function(mode, data) {
		
		this.clear();
		
		this._nodeId = "dhxpopup_node_"+window.dhx4.newId();
		
		var r = this.p.firstChild.firstChild.firstChild; // table->tbody
		
		var tr = document.createElement("TR");
		tr.className = "dhxnode";
		r.appendChild(tr);
		
		var td = document.createElement("TD");
		td.className = "dhx_popup_td";
		td.innerHTML = "<div id='"+this._nodeId+"' style='position:relative;'></div>";
		
		if (data.width) td.firstChild.style.width = data.width+"px";
		if (data.height) td.firstChild.style.height = data.height+"px";
		
		tr.appendChild(td);
		
		td = tr = r = null;
		
		if (typeof(this["_attach_init_"+mode]) == "function") {
			this["_attach_init_"+mode](data);
			this._enableIEVFix();
		}
		
		this._repaint();
		
		return this._nodeObj;
		
	}
	
	this.unload = function() {
		
		if (typeof(window.addEventListener) == "function") {
			window.removeEventListener("touchstart", this._doOnClick, false);
			window.removeEventListener("click", this._doOnClick, false);
			window.removeEventListener("keyup", this._doOnKeyUp, false);
			window.removeEventListener("unload", this._doOnUnload, false);
		} else {
			document.body.detachEvent("onclick", this._doOnClick, false);
			document.body.detachEvent("onkeyup", this._doOnKeyUp, false);
			document.body.detachEvent("onunload", this._doOnUnload, false);
		}
		window.dhx4.detachEvent(this.conf.ev_grid_click);
		this.clear();
		
		if (this.conf.toolbarEvent != null && this.conf.toolbar != null) {
			if (this.conf.toolbar.detachEvent != null) {
				// make sure toolbar wasn't unloaded
				this.conf.toolbar.detachEvent(this.conf.toolbarEvent);
			} else {
				this.conf.toolbar._getItemDim = null;
			}
		}
		
		if (this.conf.ribbonEvent != null && this.conf.ribbon != null) {
			if (this.conf.ribbon.detachEvent != null) {
				this.conf.ribbon.detachEvent(this.conf.ribbonEvent);
			} else {
				this.conf.ribbon._getItemDim = null;
			}
		}
		
		if (this.conf.slider != null) {
			for (var q=0; q<this.conf.slider_events.length; q++) {
				this.conf.slider.detachEvent(this.conf.slider_events[q]);
			}
			this.conf.slider_events = null;
			this._sliderShow = this._sliderHide = null;
			this.conf.slider = null;
		}
		
		window.dhx4._eventable(this, "clear");
		
		this.p.onclick = this.p.ontouchstart = this.p.oncontextmenu = null;
		this.p.parentNode.removeChild(this.p);
		this.p = null;
		
		for (var a in this.conf) this.conf[a] = null;
		for (var a in this) this[a] = null;
		
		that = null;
		
	}
	
	window.dhx4._eventable(this);
	
	this._doOnClick = function(e) {
		e = e||event;
		
		// skip click if touch
		var r = (that.conf.last_body_click != null && that.conf.last_body_click != e.type);
		that.conf.last_body_click = e.type;
		if (r == true) return;
		
		if (that._clearClick == true) {
			that._clearClick = false;
			return;
		}
		
		if (that.conf.form != null) {
			var id;
			var t = (e.target||e.srcElement);
			if ((t.tagName||"").toLowerCase() == "option") t = t.parentNode;
			if (t.className != null && t.className.search("dhxform") >= 0) {
				if (t.parentNode != null && t.parentNode.parentNode != null && t.parentNode.parentNode._idd != null) {
					id = t.parentNode.parentNode._idd;
					if (t.parentNode.parentNode._type == "ra") id = [t.parentNode.parentNode._group, t.parentNode.parentNode._value];
				}
			} else {
				// check if button, editor or combo
				var k = true;
				var f = false;
				while (k && !f) {
					var p = (t.className||"").toLowerCase();
					if (p.length > 0) f = (p == "dhxform_btn" || p.search(/dhxeditor_inside/gi) >= 0 || p == "dhxcombo_input" || p.search(/dhxcombolist/gi) >=0);
					t = t.parentNode;
					k = (t != null);
				}
				if (f) return;
			}
			t = null;
			if (id != null && that._idExists(id)) return;
		}
		// if popup has attached form - skin closing if list clicked (it attached to body)
		if (typeof(window.dhtmlXForm) == "function" && that._nodeObj instanceof window.dhtmlXForm) {
			var combos = {};
			var p = 0;
			var form = that._nodeObj;
			form.forEachItem(function(id){
				if (form.getItemType(id) == "combo") {
					combos[form.getCombo(id).list._listId] = true;
					p++;
				}
			});
			form = null;
			//
			if (p > 0) {
				var t = (e.target||e.srcElement);
				var k = true;
				var f = false;
				while (k == true && f != true) {
					var p = (t.className||"").toLowerCase();
					if (p.length > 0 && p.search(/^dhxcombolist/gi) >=0 && t._listId != null && combos[t._listId] == true) {
						f = true;
						t = null;
					} else {
						t = t.parentNode;
						k = (t != null);
					}
				}
				if (f == true) {
					// clicked combo belong to attached form, cancel popup hiding
					return;
				}
			}
		}
		if (that.isVisible() && that.callEvent("onBeforeHide",["click",e]) === true) {
			that.hide();
		}
	}
	this._doOnKeyUp = function(e) {
		e = e||event;
		if (e.keyCode == 27) {
			if (that.isVisible() && that.callEvent("onBeforeHide",["esc",e]) === true) {
				that.hide();
			}
		}
	}
	this._doOnUnload = function() {
		that.unload();
	}
	
	if (typeof(window.addEventListener) == "function") {
		window.addEventListener("touchstart", this._doOnClick, false);
		window.addEventListener("click", this._doOnClick, false);
		window.addEventListener("keyup", this._doOnKeyUp, false);
		window.addEventListener("unload", this._doOnUnload, false);
	} else {
		document.body.attachEvent("onclick", this._doOnClick, false);
		document.body.attachEvent("onkeyup", this._doOnKeyUp, false);
		document.body.attachEvent("onunload", this._doOnUnload, false);
	}
	
	// grid canceling some events, but trigger inner event
	this.conf.ev_grid_click = window.dhx4.attachEvent("_onGridClick", function(ev, grid){
		if (that._nodeObj != null && (that._nodeObj == grid || that._findGrid(that._nodeObj, grid) == true)) {
			// clicked grid is inside popup, attached directly or to any nested control
			// do not hide popup by this click
		} else {
			// grid is outside of popup
			that._clearClick = false;
			that._doOnClick(ev);
		}
		grid = null;
	});
	
	this._findGrid = function(obj, grid) {
		var gridFound = false;
		if (typeof(window.dhtmlXTabBar) == "function" && obj instanceof window.dhtmlXTabBar) {
			obj.forEachTab(function(tab){
				var nested = tab.getAttachedObject();
				if (gridFound == false && nested != null) {
					gridFound = gridFound||(nested==grid)||this._findGrid(nested);
					nested = null;
				}
			});
		}
		// check if attached to form's container
		if (typeof(window.dhtmlXForm) == "function" && obj instanceof window.dhtmlXForm) {
			obj.forEachItem(function(id){
				if (gridFound != true && obj.getItemType(id) == "container" && grid.entBox == obj.getContainer(id)) {
					gridFound = true;
				}
			});
		}
		obj = null;
		return gridFound;
	};
	
	this._idExists = function(id) {
		var r = false;
		for (var q=0; q<this.conf.id.length; q++) {
			if (this.conf.id[q] instanceof Array) { // radiobutton
				r = r||(this.conf.id[q][0]==id[0]&&this.conf.id[q][1]==id[1]);
			} else {
				r = r||this.conf.id[q]==id;
			}
		}
		return r;
	}
	
	// IE6/Quircks Display fix
	this._IEDisp = (window.dhx4.isIE6 || document.compatMode != "CSS1Compat");
	
	// IE6 hover functionality
	this._IEHover = (window.dhx4.isIE6 == true);
	if (this._IEHover) {
		this._IEHoverInit = function() {
			this.p.onmouseover = function() {
				var t = event.srcElement;
				while (t != this && t._IEHover != true) t = t.parentNode;
				if (t._IEHover) {
					if (that._IEHoverTM) window.clearTimeout(that._IEHoverTM);
					if (that._lastIEHover == t) return;
					that._IEHoverRender(t);
					t = null;
				}
			}
			this.p.onmouseout = function() {
				if (that._IEHoverTM) window.clearTimeout(that._IEHoverTM);
				that._IEHoverTM = window.setTimeout(function(){that._IEHoverRender(null);},1);
			}
			this._IEHoverRender = function(t) {
				if (this._lastIEHover != null) {
					if (this._lastIEHover.className.search(/tr_hover/gi) >= 0) {
						this._lastIEHover.className = this._lastIEHover.className.replace(/\s{0,}tr_hover/gi, "");
						this._lastIEHover = null;
					}
				}
				if (t != null && t.className.search(/tr_hover/gi) < 0) {
					t.className += " tr_hover";
					that._lastIEHover = t;
				}
			}
			this._IEHoverInited = true;
		}
		this._IEHoverClear =  function() {
			this.p.onmouseover = null;
			this.p.onmouseout = null;
			this._IEHoverInited = false;
		}
	}
	
	// IE6/7/8 first/last-child
	this._IEFirstLast = (window.dhx4.isIE6 || window.dhx4.isIE7 || window.dhx4.isIE8);
	
	// IE6 visibility fix
	this._enableIEVFix = function() {
		if (window.dhx4.isIE6 || window.dhx4.isIE7) {
			var e1 = this.attachEvent("onHide", function(){
				document.getElementById(this._nodeId).style.visibility = "hidden";
			});
			var e2 = this.attachEvent("onShow", function(){
				document.getElementById(this._nodeId).style.visibility = "visible";
			});
			if (this._nodeObjEv == null) this._nodeObjEv = [];
			this._nodeObjEv.push(e1,e2);
		}
	}
	
	// auto-init, toolbar mode
	if (typeof(window.dhtmlXToolbarObject) == "function" && this.conf.toolbar != null && this.conf.toolbar instanceof window.dhtmlXToolbarObject && this.conf.id != null) {
		
		if (!(this.conf.id instanceof Array)) this.conf.id = [this.conf.id];
		
		this.skinParent = this.conf.toolbar.conf.skin;
		
		this._doOnToolbarClick = function(id) {
			for (var q=0; q<that.conf.id.length; q++) {
				if (id == that.conf.id[q]) {
					if (id != that._lastId) {
						that.show(id);
						that._clearClick = true;
					}
				}
			}
		}
		
		// extension for toolbar, return pos/dim for specified button
		if (typeof(dhtmlXToolbarObject.prototype._getItemDim) == "undefined") {
			
			dhtmlXToolbarObject.prototype._getItemDim = function(id) {
				var t = this.objPull[this.idPrefix+id];
				var p = {
					left: window.dhx4.absLeft(t.obj),
					top: window.dhx4.absTop(t.obj),
					width: t.obj.offsetWidth+(t.arw?t.arw.offsetWidth:0),
					height: t.obj.offsetHeight
				};
				t = null;
				return p;
			}
			
		}
		
		this.conf.toolbarEvent = this.conf.toolbar.attachEvent("onClick", this._doOnToolbarClick);
		
	}
	
	// auto-init, ribbon mode
	if (typeof(window.dhtmlXRibbon) == "function" && this.conf.ribbon != null && this.conf.ribbon instanceof window.dhtmlXRibbon && this.conf.id != null) {
		
		if (!(this.conf.id instanceof Array)) this.conf.id = [this.conf.id];
		
		this.skinParent = this.conf.ribbon.conf.skin;
		
		this._doOnRibbonClick = function(id) {
			for (var q=0; q<that.conf.id.length; q++) {
				if (id == that.conf.id[q]) {
					if (id != that._lastId) {
						that.show(id);
						that._clearClick = true;
					}
				}
			}
		}
		
		// extension for toolbar, return pos/dim for specified button
		if (typeof(dhtmlXRibbon.prototype._getItemDim) == "undefined") {
			
			dhtmlXRibbon.prototype._getItemDim = function(id) {
				var t = this._items[id].base;
				var p = {
					left: window.dhx4.absLeft(t),
					top: window.dhx4.absTop(t),
					width: t.offsetWidth,
					height: t.offsetHeight
				};
				t = null;
				return p;
			}
			
		}
		
		this.conf.ribbonEvent = this.conf.ribbon.attachEvent("_showPopup", this._doOnRibbonClick);
		
	}
	
	// auto-init, form mode
	if (typeof(window.dhtmlXForm) == "function" && this.conf.form != null && this.conf.form instanceof window.dhtmlXForm && this.conf.id != null) {
		
		if (!(this.conf.id instanceof Array)) this.conf.id = [this.conf.id];
		
		if (!this.conf.mode) this.mode = "right"; // default mode for form
		this.skinParent = this.conf.form.skin;
		
		if (typeof(dhtmlXForm.prototype._getItemDim) == "undefined") {
			
			dhtmlXForm.prototype._getItemDim = function(name, value) {
				return this.doWithItem(name, "_getDim");
			};
			
			for (var a in dhtmlXForm.prototype.items) {
				
				dhtmlXForm.prototype.items[a]._getDim = function(item) {
					
					var t = item;
					
					if ({ta:true, pw:true, se:true, tp:true, fl:true, calendar:true, colorpicker:1, editor:true, container:true}[item._type]) {
						t = item.childNodes[item._ll?1:0].childNodes[0];
					}
					if ({ch:true, ra:true, btn2state:true}[item._type]) {
						t = item.childNodes[item._ll?1:0].childNodes[1];
					}
					if ({bt:true, lb:true, fs:true}[item._type]) {
						t = item.firstChild;
					}
					if ({combo:true}[item._type]) {
						t = item._combo.DOMParent.firstChild;
					}
					if ({image:true}[item._type]) {
						t = item.childNodes[item._ll?1:0].lastChild;
					}
					if ({bl:true}[item._type]) {
						t = item.firstChild.firstChild.firstChild; // nested form's base
					}
					
					var p = {
						left: window.dhx4.absLeft(t),
						top: window.dhx4.absTop(t),
						width: t.offsetWidth,
						height: t.offsetHeight
					};
					
					t = null;
					return p;
					
				};
				
			}
			
		}
		
	}
	
	// auto-init, slider mode
	if (typeof(window.dhtmlXSlider) == "function" && this.conf.slider != null && this.conf.slider instanceof window.dhtmlXSlider) {
		
		if (!this.conf.mode) this.mode = "top"; // default mode for slider
		
		this.conf.slider_tm = null;
		
		this._sliderShow = function() {
			if (that.conf.slider_tm) window.clearTimeout(that.conf.slider_tm);
			var t = that.conf.slider._r_actv;
			if (t != null) {
				var p = {
					left: window.dhx4.absLeft(t),
					top: window.dhx4.absTop(t),
					width: t.offsetWidth,
					height: t.offsetHeight
				};
				that.show(p.left, p.top, p.width, p.height);
				t = null;
			}
		}
		
		this._sliderHide = function() {
			that.conf.slider_tm = window.setTimeout(function(){
				that.hide();
			}, 200);
		}
		
		this.conf.slider_events = [
			this.conf.slider.attachEvent("onMouseDown", this._sliderShow),
			this.conf.slider.attachEvent("onMouseUp", this._sliderHide),
			this.conf.slider.attachEvent("onChange", this._sliderShow)
		];
		
	}
	
	
	// define skin
	this.setSkin(this.skinParent||this.conf.skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhx_popup")||"material");
	
	return this;
	
};

// object
dhtmlXPopup.prototype.attachObject = function(obj) {
	return this._attachNode("object", {obj: obj});
};
dhtmlXPopup.prototype._attach_init_object = function(data) {
	this._nodeObj = (typeof(data.obj)=="string"?document.getElementById(data.obj):data.obj);
	data.obj = null;
	document.getElementById(this._nodeId).appendChild(this._nodeObj);
	this._nodeObj.style.display = "";
	this._nodeObj.style.visibility = "visible";
};

// html
dhtmlXPopup.prototype.attachHTML = function(html) {
	return this._attachNode("html", {html: html});
};
dhtmlXPopup.prototype._attach_init_html = function(data) {
	document.getElementById(this._nodeId).innerHTML = data.html;
	this._nodeObj = {text: data.html};
};

// form
dhtmlXPopup.prototype.attachForm = function(struct, width) {
	return this._attachNode("form", {struct: struct, width: width});
};
dhtmlXPopup.prototype._attach_init_form = function(data) {
	var that = this;
	this._nodeObj = new dhtmlXForm(this._nodeId, data.struct);
	this._nodeObj.setSkin(this.conf.skin);
	this._nodeObj.attachEvent("_onBeforeEditorAccess", function(){
		// prevent popup autohide, editor will trigger body/click
		that._clearClick = true;
	});
	// fix editors which were inited in hidden popup
	if (this.conf.editorEv != null && this.checkEvent(this.conf.editorEv) == false) {
		this.conf.editorEv = null;
	}
	// attach event for first popup show
	if (dhtmlXForm.prototype.items.editor != null && this.conf.editorEv == null) {
		this.conf.editorEv = this.attachEvent("onShow", function(){
			var editors = dhtmlXForm.prototype.items.editor.editor;
			for (var a in editors) {
				var base = editors[a].base;
				var fixSize = false;
				while (base != null) {
					if (base == this.p) {
						fixSize = true;
						base = null;
					} else {
						base = base.parentNode;
					}
				}
				base = null;
				if (fixSize == true) {
					editors[a].cell.conf.cells_cont = null;
					editors[a].setSizes();
				}
			}
			editors = null;
			this.detachEvent(this.conf.editorEv);
			this.conf.editorEv = null;
		});
		if (this._nodeObjEv == null) this._nodeObjEv = [];
		this._nodeObjEv.push(this.conf.editorEv);
	}
};

// calendar
dhtmlXPopup.prototype.attachCalendar = function(conf) {
	return this._attachNode("calendar", conf||{});
};
dhtmlXPopup.prototype._attach_init_calendar = function(data) {
	if (data["double"] == true) {
		this._nodeObj = new dhtmlXDoubleCalendarObject(this._nodeId);
		this._nodeObj.leftCalendar.setSkin(this.conf.skin);
		this._nodeObj.rightCalendar.setSkin(this.conf.skin);
	} else {
		this._nodeObj = new dhtmlXCalendarObject(this._nodeId);
		this._nodeObj.setSkin(this.conf.skin);
	}
	this._nodeObj.show();
};

// grid
dhtmlXPopup.prototype.attachGrid = function(width, height) {
	return this._attachNode("grid", {width: width||400, height: height||200});
};
dhtmlXPopup.prototype._attach_init_grid = function() {
	this._nodeObj = new dhtmlXGridObject(this._nodeId);
	this._nodeObj.setSkin(this.conf.skin);
};

// tree
dhtmlXPopup.prototype.attachTree = function(width, height, rootId) {
	return this._attachNode("tree", {width: width||400, height: height||200, rootId: rootId||0});
};
dhtmlXPopup.prototype._attach_init_tree = function(data) {
	this._nodeObj = new dhtmlXTreeObject(this._nodeId, "100%", "100%", (data.rootId))
};

// layout
dhtmlXPopup.prototype.attachLayout = function(width, height, pattern) {
	return this._attachNode("layout", {width: width||400, height: height||200, pattern: pattern||"3L"});
};
dhtmlXPopup.prototype._attach_init_layout = function(data) {
	this._nodeObj = new dhtmlXLayoutObject(this._nodeId, data.pattern, this.conf.skin)
};

// accordion
dhtmlXPopup.prototype.attachAccordion = function(width, height, conf) {
	return this._attachNode("accordion", {width: width||400, height: height||200, conf:conf||{}});
};
dhtmlXPopup.prototype._attach_init_accordion = function(conf) {
	conf.conf.parent = this._nodeId;
	conf.conf.skin = this.conf.skin;
	this._nodeObj = new dhtmlXAccordion(conf.conf);
};

// tabbar
dhtmlXPopup.prototype.attachTabbar = function(width, height, conf) {
	if (typeof(conf) == "string") {
		conf = {mode:conf}; // 3.6 compat
	} else if (typeof(conf) != "object" || conf == null) {
		conf = {};
	}
	return this._attachNode("tabbar", {width: width||400, height: height||200, conf:conf});
};
dhtmlXPopup.prototype._attach_init_tabbar = function(conf) {
	conf.conf.parent = this._nodeId;
	conf.conf.skin = this.conf.skin;
	this._nodeObj = new dhtmlXTabBar(conf.conf);
};

// sidebar
dhtmlXPopup.prototype.attachSidebar = function(width, height, conf) {
	if (conf == null) conf = {};
	return this._attachNode("sidebar", {width: width||400, height: height||200, conf:conf});
};
dhtmlXPopup.prototype._attach_init_sidebar = function(conf) {
	conf.conf.parent = this._nodeId;
	conf.conf.skin = this.conf.skin;
	this._nodeObj = new dhtmlXSideBar(conf.conf);
};

// editor
dhtmlXPopup.prototype.attachEditor = function(width, height, conf) {
	return this._attachNode("editor", {width: width||400, height: height||200, conf: conf||{}});
};
dhtmlXPopup.prototype._attach_init_editor = function(data) {
	document.getElementById(this._nodeId).className = "dhxeditor_"+this.conf.skin;
	data.conf.parent = this._nodeId;
	if (data.conf.skin == null) data.conf.skin = this.conf.skin;
	this._nodeObj = new dhtmlXEditor(data.conf);
	var evId = this.attachEvent("onShow", function(){
		if (this._nodeObj instanceof window.dhtmlXEditor) this._nodeObj.setSizes();
	});
	if (this._nodeObjEv == null) this._nodeObjEv = [];
	this._nodeObjEv.push(evId);
};

// color picker
dhtmlXPopup.prototype.attachColorPicker = function(conf) {
	if (typeof(conf) != "object" || conf == null) conf = {};
	return this._attachNode("colorpicker", {conf:conf});
};
dhtmlXPopup.prototype._attach_init_colorpicker = function(conf) {
	conf.conf.skin = this.conf.skin;
	conf.conf.parent = this._nodeId;
	this._nodeObj = new dhtmlXColorPicker(conf.conf);
};

// carousel
dhtmlXPopup.prototype.attachCarousel = function(width, height, conf) {
	if (conf == null) conf = {};
	return this._attachNode("carousel", {width: width||400, height: height||300, conf:conf});
};
dhtmlXPopup.prototype._attach_init_carousel = function(conf) {
	conf.conf.parent = this._nodeId;
	conf.conf.skin = this.conf.skin;
	this._nodeObj = new dhtmlXCarousel(conf.conf);
};

// treeview
dhtmlXPopup.prototype.attachTreeView = function(width, height, conf) {
	if (conf == null) conf = {};
	return this._attachNode("treeview", {width: width||400, height: height||300, conf: conf});
};
dhtmlXPopup.prototype._attach_init_treeview = function(conf) {
	conf.conf.parent = this._nodeId;
	conf.conf.skin = this.conf.skin;
	this._nodeObj = new dhtmlXTreeView(conf.conf);
	//
	this._nodeObj.base.className += " dhxtreeview_with_border";
	//
	var evId = this.attachEvent("onShow", function(){
		if (this._nodeObj instanceof window.dhtmlXTreeView) this._nodeObj.setSizes();
	});
	if (this._nodeObjEv == null) this._nodeObjEv = [];
	this._nodeObjEv.push(evId);
};

// other functionality
dhtmlXPopup.prototype.setDimension = function(w, h) {
	if (this._nodeId == null || (w == null && h == null)) return;
	var node = document.getElementById(this._nodeId);
	if (w != null) node.style.width = w+"px";
	if (h != null) node.style.height = h+"px";
	this._repaint();
	if (this._nodeObj != null && typeof(this._nodeObj.setSizes) == "function") this._nodeObj.setSizes();
	node = null;
};

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXMenuObject(base, skin) {
	
	var that = this;
	
	// iframe
	this.conf = {
		skin: (skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxmenu")||"material"),
		mode: "web",
		align: "left",
		is_touched: false,
		selected: -1,
		last_click: -1,
		fixed_pos: false, // should be used for frameset in IE
		rtl: false,
		icons_path: "",
		icons_css: false, // use css for icons or direct img links, added in 5.0
		arrow_ff_fix: (navigator.userAgent.indexOf("MSIE") >= 0 && document.compatMode=="BackCompat"), // border fixer for FF for arrows polygons
		live_id: window.dhx4.newId(),
		tags: {
			root: "menu",
			item: "item",
			text_ext: "itemtext",
			userdata: "userdata",
			tooltip: "tooltip",
			hotkey: "hotkey",
			href: "href"
		},
		autoload: {},
		hide_tm: {},
		// shows sublevel polygons from toplevel items with delay
		top_mode: true,
		top_tmtime: 200,
		// visible area
		v_enabled: false,
		v: {x1: null, x2: null, y1: null, y2: null},
		// open direction
		dir_toplv: "bottom",
		dir_sublv: "right",
		// overflow
		auto_overflow: false,
		overflow_limit: 0,
		of_utm: null, // scroll up - tm
		of_utime: 20, // scroll up - time
		of_ustep: 3, // scroll up - step
		of_dtm: null,
		of_dtime: 20,
		of_dstep: 3,
		of_ah: {dhx_skyblue: 24, dhx_web: 25, dhx_terrace: 27, material: 25}, // arrow height+oplygon top/bottom padding
		of_ih: {dhx_skyblue: 24, dhx_web: 24, dhx_terrace: 24, material: 30}, // item height
		// hide
		tm_sec: 400,
		tm_handler: null,
		// dyn load
		dload: false,
		dload_url: "",
		dload_icon: false, // show loading icon
		dload_params: {action: "loadMenu"}, // extra params
		dload_pid: "parentId", // parentId param name
		// skinbased offsets
		tl_botmarg: 1, // top level bottom margin
		tl_rmarg: 0, // right margin
		tl_ofsleft: 1, // offset left
		// context menu
		context: false,
		ctx_zoneid: false,
		ctx_autoshow: true, // default open action
		ctx_autohide: true, // default close action
		ctx_hideall: true, // true will hide all opened contextual menu polygons on mouseout, false - all except topleft
		ctx_zones: {},
		ctx_baseid: null, // add baseId as context zone
		// selected subitems
		selected_sub: [],
		opened_poly: []
	}
	
	if (typeof(base) == "object" && base != null && typeof(base.tagName) == "undefined") {
		
		// object-api init
		if (base.icons_path != null || base.icon_path != null) this.conf.icons_path = (base.icons_path||base.icon_path);
		if (base.skin != null) this.conf.skin = base.skin;
		if (base.visible_area) {
			this.conf.v_enabled = true;
			this.conf.v = {
				x1: base.visible_area.x1,
				x2: base.visible_area.x2,
				y1: base.visible_area.y1,
				y2: base.visible_area.y2
			};
		}
			
		for (var a in {json:1,xml:1,items:1,top_text:1,align:1,open_mode:1,overflow:1,dynamic:1,dynamic_icon:1,context:1,onload:1,onclick:1,oncheckboxclick:1,onradioclick:1,iconset:1}) {
			if (base[a] != null) this.conf.autoload[a] = base[a];
		}
		
		base = base.parent;
	}
	
	if (base == null) {
		this.base = document.body;
	} else {
		var baseObj = (typeof(base)=="string"?document.getElementById(base):base);
		if (baseObj != null) {
			this.base = baseObj;
			if (!this.base.id) this.base.id = "menuBaseId_"+new Date().getTime();
			this.base.className += " dhtmlxMenu_"+this.conf.skin+"_Middle dir_left";
			this.base._autoSkinUpdate = true;
			 // preserv default oncontextmenu for future restorin in case of context menu
			if (this.base.oncontextmenu) this.base._oldContextMenuHandler = this.base.oncontextmenu;
			//
			this.conf.ctx_baseid = this.base.id;
			this.base.onselectstart = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
			this.base.oncontextmenu = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		} else {
			this.base = document.body;
		}
	}
	
	this.idPrefix = "";
	this.topId = "dhxWebMenuTopId";
	
	this.idPull = {};
	this.itemPull = {};
	this.userData = {};
	this.radio = {};
	//
	this.setSkin = function(skin) {
		var oldSkin = this.conf.skin;
		this.conf.skin = skin;
		switch (this.conf.skin){
			case "dhx_skyblue":
			case "dhx_web":
				this.conf.tl_botmarg = 2;
				this.conf.tl_rmarg = 1;
				this.conf.tl_ofsleft = 1;
				break;
			case "dhx_terrace":
			case "material":
				this.conf.tl_botmarg = 0;
				this.conf.tl_rmarg = 0;
				this.conf.tl_ofsleft = 0;
				break;
		}
		if (this.base._autoSkinUpdate) {
			this.base.className = this.base.className.replace("dhtmlxMenu_"+oldSkin+"_Middle", "")+" dhtmlxMenu_"+this.conf.skin+"_Middle";
		}
		
		for (var a in this.idPull) {
			this.idPull[a].className = String(this.idPull[a].className).replace(oldSkin, this.conf.skin);
			
		}
	}
	this.setSkin(this.conf.skin);
	//
	
	this._addSubItemToSelected = function(item, polygon) {
		var t = true;
		for (var q=0; q<this.conf.selected_sub.length; q++) { if ((this.conf.selected_sub[q][0] == item) && (this.conf.selected_sub[q][1] == polygon)) { t = false; } }
		if (t == true) { this.conf.selected_sub.push(new Array(item, polygon)); }
		return t;
	}
	this._removeSubItemFromSelected = function(item, polygon) {
		var m = new Array();
		var t = false;
		for (var q=0; q<this.conf.selected_sub.length; q++) { if ((this.conf.selected_sub[q][0] == item) && (this.conf.selected_sub[q][1] == polygon)) { t = true; } else { m[m.length] = this.conf.selected_sub[q]; } }
		if (t == true) { this.conf.selected_sub = m; }
		return t;
	}
	this._getSubItemToDeselectByPolygon = function(polygon) {
		var m = new Array();
		for (var q=0; q<this.conf.selected_sub.length; q++) {
			if (this.conf.selected_sub[q][1] == polygon) {
				m[m.length] = this.conf.selected_sub[q][0];
				m = m.concat(this._getSubItemToDeselectByPolygon(this.conf.selected_sub[q][0]));
				var t = true;
				for (var w=0; w<this.conf.opened_poly.length; w++) { if (this.conf.opened_poly[w] == this.conf.selected_sub[q][0]) { t = false; } }
				if (t == true) { this.conf.opened_poly[this.conf.opened_poly.length] = this.conf.selected_sub[q][0]; }
				this.conf.selected_sub[q][0] = -1;
				this.conf.selected_sub[q][1] = -1;
			}
		}
		return m;
	}
	
	this._hidePolygon = function(id) {
		if (this.idPull["polygon_" + id] != null) {
			// clear z-index
			if (this.idPull["polygon_"+id]._zId != null) {
				window.dhx4.zim.clear(this.idPull["polygon_"+id]._zId);
			}
			//
			if (typeof(this._menuEffect) != "undefined" && this._menuEffect !== false) {
				this._hidePolygonEffect("polygon_"+id);
			} else {
				// already hidden
				if (this.idPull["polygon_"+id].style.display == "none") return;
				//
				this.idPull["polygon_"+id].style.display = "none";
				if (this.idPull["arrowup_"+id] != null) this.idPull["arrowup_"+id].style.display = "none";
				if (this.idPull["arrowdown_"+id] != null) this.idPull["arrowdown_"+id].style.display = "none";
				this._updateItemComplexState(id, true, false);
				// hide ie6 cover
				if (window.dhx4.isIE6 && this.idPull["polygon_"+id+"_ie6cover"] != null) this.idPull["polygon_"+id+"_ie6cover"].style.display = "none";
			}
			// call event
			id = String(id).replace(this.idPrefix, "");
			if (id == this.topId) id = null;
			this.callEvent("onHide", [id]);
			
			// corners
			if (id != null && this.conf.skin == "dhx_terrace" && this.itemPull[this.idPrefix+id].parent == this.idPrefix+this.topId) {
				this._improveTerraceButton(this.idPrefix+id, true);
			}
			
		}
	}
	
	this._showPolygon = function(id, openType) {
		
		var itemCount = this._countVisiblePolygonItems(id);
		if (itemCount == 0) return;
		var pId = "polygon_"+id;
		if ((this.idPull[pId] != null) && (this.idPull[id] != null)) {
			
			if (this.conf.top_mode && this.conf.mode == "web" && !this.conf.context) {
				if (!this.idPull[id]._mouseOver && openType == this.conf.dir_toplv) return;
			}
			
			// detect visible area
			if (!this.conf.fixed_pos) this._autoDetectVisibleArea();
			
			// show arrows
			var arrUpH = 0;
			var arrDownH = 0;
			//
			var arrowUp = null;
			var arrowDown = null;
			
			// show polygon
			if (this.idPull[pId]._zId == null) {
				this.idPull[pId]._zId = window.dhx4.newId();
			}
			this.idPull[pId]._zInd = window.dhx4.zim.reserve(this.idPull[pId]._zId);
			
			this.idPull[pId].style.visibility = "hidden";
			this.idPull[pId].style.left = "0px";
			this.idPull[pId].style.top = "0px";
			this.idPull[pId].style.display = "";
			this.idPull[pId].style.zIndex = this.idPull[pId]._zInd;
			
			//
			if (this.conf.auto_overflow) {
				if (this.idPull[pId].childNodes[1].childNodes[0].offsetHeight > this.conf.v.y2-this.conf.v.y1) {
					var t0 = Math.max(Math.floor((this.conf.v.y2-this.conf.v.y1-this.conf.of_ah[this.conf.skin]*2)/this.conf.of_ih[this.conf.skin]),1); // (y2-y1-arrow_height*2)/item_height
					this.conf.overflow_limit = t0;
				} else {
					this.conf.overflow_limit = 0;
					
					if (this.idPull["arrowup_"+id] != null) this._removeUpArrow(String(id).replace(this.idPrefix,""));
					if (this.idPull["arrowdown_"+id] != null) this._removeDownArrow(String(id).replace(this.idPrefix,""));
				}
			}
			
			if (this.conf.overflow_limit > 0 && this.conf.overflow_limit < itemCount)  {
				
				// add overflow arrows if they not exists
				if (this.idPull["arrowup_"+id] == null) this._addUpArrow(String(id).replace(this.idPrefix,""));
				if (this.idPull["arrowdown_"+id] == null) this._addDownArrow(String(id).replace(this.idPrefix,""));
				
				// configure up arrow
				arrowUp = this.idPull["arrowup_"+id];
				arrowUp.style.display = "none";
				//arrUpH = arrowUp.offsetHeight;
				
				// configure bottom arrow
				arrowDown = this.idPull["arrowdown_"+id];
				arrowDown.style.display = "none";
				//arrDownH = arrowDown.offsetHeight;
				
			}
			
			if (this.conf.overflow_limit > 0 && this.conf.overflow_limit < itemCount)  {
				// set fixed size
				this.idPull[pId].childNodes[1].style.height = this.conf.of_ih[this.conf.skin]*this.conf.overflow_limit+"px";
				arrowUp.style.width = arrowDown.style.width = this.idPull[pId].childNodes[1].style.width = this.idPull[pId].childNodes[1].childNodes[0].offsetWidth+"px";
				this.idPull[pId].childNodes[1].scrollTop = 0;
				
				arrowUp.style.display = "";
				arrUpH = arrowUp.offsetHeight;
				
				arrowDown.style.display = "";
				arrDownH = arrowDown.offsetHeight;
					
			} else {
				// remove fixed size
				this.idPull[pId].childNodes[1].style.height = "";
				this.idPull[pId].childNodes[1].style.width = "";
			}
			
			
			if (this.itemPull[id] != null) {
				var parPoly = "polygon_"+this.itemPull[id]["parent"];
			} else if (this.conf.context) {
				var parPoly = this.idPull[this.idPrefix+this.topId];
			}
			
			// define position
			var srcX = (this.idPull[id].tagName != null ? window.dhx4.absLeft(this.idPull[id]) : this.idPull[id][0]);
			var srcY = (this.idPull[id].tagName != null ? window.dhx4.absTop(this.idPull[id]) : this.idPull[id][1]);
			var srcW = (this.idPull[id].tagName != null ? this.idPull[id].offsetWidth : 0);
			var srcH = (this.idPull[id].tagName != null ? this.idPull[id].offsetHeight : 0);
			
			var x = 0;
			var y = 0;
			var w = this.idPull[pId].offsetWidth;
			var h = this.idPull[pId].offsetHeight;
			
			// pos
			if (openType == "bottom") {
				if (this.conf.rtl) {
					x = srcX + (srcW!=null?srcW:0) - w;
				} else {
					if (this.conf.align == "right") {
						x = srcX + srcW - w;
					} else {
						x = srcX - 1 + (openType==this.conf.dir_toplv?this.conf.tl_rmarg:0);
					}
				}
				y = srcY - 1 + srcH + this.conf.tl_botmarg;
			}
			if (openType == "right") { x = srcX + srcW - 1; y = srcY + 2; }
			if (openType == "left") { x = srcX - this.idPull[pId].offsetWidth + 2; y = srcY + 2; }
			if (openType == "top") { x = srcX - 1; y = srcY - h + 2; }
			
			// overflow check
			if (this.conf.fixed_pos) {
				// use fixed document.body/window dimension if required
				var mx = 65536;
				var my = 65536;
			} else {
				var mx = (this.conf.v.x2!=null?this.conf.v.x2:0);
				var my = (this.conf.v.y2!=null?this.conf.v.y2:0);
				
				if (mx == 0) {
					if (window.innerWidth) {
						mx = window.innerWidth;
						my = window.innerHeight;
					} else {
						mx = document.body.offsetWidth;
						my = document.body.scrollHeight;
					}
				}
			}
			if (x+w > mx && !this.conf.rtl) {
				// no space on right, open to left
				x = srcX - w + 2;
			}
			if (x < this.conf.v.x1 && this.conf.rtl) {
				// no space on left, open to right
				x = srcX + srcW - 2;
			}
			if (x < 0) {
				// menu floats left
				x = 0;
			}
			if (y+h > my && this.conf.v.y2 != null) {
				y = Math.max(srcY + srcH - h + 2, (this.conf.v_enabled?this.conf.v.y1+2:2));
				// open from top level
				if (this.conf.context && this.idPrefix+this.topId == id && arrowDown != null) {
					// autoscroll prevent because menu mouse pointer will right over downarrow
					y = y-2;
				}
				if (this.itemPull[id] != null && !this.conf.context) {
					if (this.itemPull[id]["parent"] == this.idPrefix+this.topId) y = y - this.base.offsetHeight;
				}
			}
			//
			this.idPull[pId].style.left = x+"px";
			//this.idPull[pId].style.top = y+arrUpH+"px";
			this.idPull[pId].style.top = y+"px";
			//
			if (typeof(this._menuEffect) != "undefined" && this._menuEffect !== false) {
				this._showPolygonEffect(pId);
			} else {
				this.idPull[pId].style.visibility = "";
				
				if (this.conf.overflow_limit > 0 && this.conf.overflow_limit < itemCount)  {
					this.idPull[pId].childNodes[1].scrollTop = 0;
					this._checkArrowsState(id);
				}
				
				// show ie6 cover
				if (window.dhx4.isIE6) {
					var pIdIE6 = pId+"_ie6cover";
					if (this.idPull[pIdIE6] == null) {
						var ifr = document.createElement("IFRAME");
						ifr.className = "dhtmlxMenu_IE6CoverFix_"+this.conf.skin;
						ifr.frameBorder = 0;
						ifr.setAttribute("src", "javascript:false;");
						document.body.insertBefore(ifr, document.body.firstChild);
						this.idPull[pIdIE6] = ifr;
					}
					this.idPull[pIdIE6].style.left = x+"px";
					this.idPull[pIdIE6].style.top = y+"px";
					this.idPull[pIdIE6].style.width = this.idPull[pId].offsetWidth+"px";
					this.idPull[pIdIE6].style.height = this.idPull[pId].offsetHeight+"px";
					this.idPull[pIdIE6].style.zIndex = this.idPull[pId].style.zIndex-1;
					this.idPull[pIdIE6].style.display = "";
				}
			}
			
			id = String(id).replace(this.idPrefix, "");
			if (id == this.topId) id = null;
			this.callEvent("onShow", [id]);
			
			// corners
			if (id != null && this.conf.skin == "dhx_terrace" && this.itemPull[this.idPrefix+id].parent == this.idPrefix+this.topId) {
				this._improveTerraceButton(this.idPrefix+id, false);
			}
			
		}
	}
	
	this._redistribSubLevelSelection = function(id, parentId) {
		// clear previosly selected items
		while (this.conf.opened_poly.length > 0) this.conf.opened_poly.pop();
		// this.conf.opened_poly = new Array();
		var i = this._getSubItemToDeselectByPolygon(parentId);
		this._removeSubItemFromSelected(-1, -1);
		for (var q=0; q<i.length; q++) { if ((this.idPull[i[q]] != null) && (i[q] != id)) { if (this.itemPull[i[q]]["state"] == "enabled") { this.idPull[i[q]].className = "sub_item"; } } }
		// hide polygons
		for (var q=0; q<this.conf.opened_poly.length; q++) { if (this.conf.opened_poly[q] != parentId) { this._hidePolygon(this.conf.opened_poly[q]); } }
		// add new selection into list new
		if (this.itemPull[id]["state"] == "enabled") {
			this.idPull[id].className = "sub_item_selected";
			if (this.itemPull[id]["complex"] && this.conf.dload && (this.itemPull[id]["loaded"]=="no")) {
				if (this.conf.dload_icon == true) { this._updateLoaderIcon(id, true); }
				this.itemPull[id].loaded = "get";
				var xmlParentId = id.replace(this.idPrefix,"");
				this._dhxdataload.onBeforeXLS = function() {
					var p = {params:{}};
					p.params[this.conf.dload_pid] = xmlParentId;
					for (var a in this.conf.dload_params) p.params[a] = this.conf.dload_params[a];
					return p;
				};
				this.loadStruct(this.conf.dload_url);
			}
			// show
			if (this.itemPull[id]["complex"] || (this.conf.dload && (this.itemPull[id]["loaded"] == "yes"))) {
				// make arrow over
				if ((this.itemPull[id]["complex"]) && (this.idPull["polygon_" + id] != null))  {
					this._updateItemComplexState(id, true, true);
					this._showPolygon(id, this.conf.dir_sublv);
				}
			}
			this._addSubItemToSelected(id, parentId);
			this.conf.selected = id;
		}
	}
	
	this._doOnClick = function(id, type, casState) {
		this.conf.last_click = id;
		// href
		if (this.itemPull[this.idPrefix+id]["href_link"] != null && this.itemPull[this.idPrefix+id].state == "enabled") {
			var form = document.createElement("FORM");
			var k = String(this.itemPull[this.idPrefix+id]["href_link"]).split("?");
			form.action = k[0];
			if (k[1] != null) {
				var p = String(k[1]).split("&");
				for (var q=0; q<p.length; q++) {
					var j = String(p[q]).split("=");
					var m = document.createElement("INPUT");
					m.type = "hidden";
					m.name = (j[0]||"");
					m.value = (j[1]||"");
					form.appendChild(m);
				}
			}
			if (this.itemPull[this.idPrefix+id]["href_target"] != null) { form.target = this.itemPull[this.idPrefix+id]["href_target"]; }
			form.style.display = "none";
			document.body.appendChild(form);
			form.submit();
			if (form != null) {
				document.body.removeChild(form);
				form = null;
			}
			return;
		}
		//
		// some fixes
		if (type.charAt(0)=="c") return; // can't click on complex item
		if (type.charAt(1)=="d") return; // can't click on disabled item
		if (type.charAt(2)=="s") return; // can't click on separator
		//
		if (this.checkEvent("onClick")) {
			this.callEvent("onClick", [id, this.conf.ctx_zoneid, casState]);
		} else {
			if ((type.charAt(1) == "d") || (this.conf.mode == "win" && type.charAt(2) == "t")) return;
		}
		if (this.conf.context && this._isContextMenuVisible() && this.conf.ctx_autohide) {
			this._hideContextMenu();
		} else {
			// if menu unloaded from click event
			if (this._clearAndHide) this._clearAndHide();
		}
	}
	// onTouchMenu action - select topLevel item
	this._doOnTouchMenu = function(id) {
		if (this.conf.is_touched == false) {
			this.conf.is_touched = true;
			if (this.checkEvent("onTouch")) {
				this.callEvent("onTouch", [id]);
			}
		}
	}
	
	// return menu array of all nested objects
	this._searchMenuNode = function(node, menu) {
		var m = new Array();
		for (var q=0; q<menu.length; q++) {
			if (typeof(menu[q]) == "object") {
				if (menu[q].length == 5) { if (typeof(menu[q][0]) != "object") { if ((menu[q][0].replace(this.idPrefix, "") == node) && (q == 0)) { m = menu; } } }
				var j = this._searchMenuNode(node, menu[q]);
				if (j.length > 0) { m = j; }
			}
		}
		return m;
	}
	// return array of subitems for single menu object
	this._getMenuNodes = function(node) {
		var m = new Array;
		for (var a in this.itemPull) { if (this.itemPull[a]["parent"] == node) { m[m.length] = a; } }
		return m;
	}
	// generate random string with specified length
	this._genStr = function(w) {
		var s = "dhxId_";
		var z = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
		for (var q=0; q<w; q++) s += z.charAt(Math.round(Math.random() * (z.length-1)));
		return s;
	}
	
	this.getItemType = function(id) {
		id = this.idPrefix+id;
		if (this.itemPull[id] == null) { return null; }
		return this.itemPull[id]["type"];
	}
	
	this.forEachItem = function(handler) {
		for (var a in this.itemPull) { handler(String(a).replace(this.idPrefix, "")); }
	}
	
	// clear selection and hide menu on onbody click event
	this._clearAndHide = function() {
		that.conf.selected = -1;
		that.conf.last_click = -1;
		while (that.conf.opened_poly.length > 0) { that.conf.opened_poly.pop(); }
		for (var q=0; q<that.conf.selected_sub.length; q++) {
			var id = that.conf.selected_sub[q][0];
			// clear all selection
			if (that.idPull[id] != null) {
				if (that.itemPull[id]["state"] == "enabled") {
					if (that.idPull[id].className == "sub_item_selected") that.idPull[id].className = "sub_item";
					if (that.idPull[id].className == "dhtmlxMenu_"+that.conf.skin+"_TopLevel_Item_Selected") {
						// custom css
						if (that.itemPull[id]["cssNormal"] != null) {
							that.idPull[id].className = that.itemPull[id]["cssNormal"];
						} else {
							// default css
							that.idPull[id].className = "dhtmlxMenu_"+that.conf.skin+"_TopLevel_Item_Normal";
						}
					}
				}
			}
			that._hidePolygon(id);
		}
		
		that.conf.is_touched = false;
		
		// hide all contextmenu polygons on mouseout
		if (that.conf.context && that.conf.ctx_hideall) that._hidePolygon(that.idPrefix+that.topId);
		
	}
	
	/* show sublevel item */
	this._showSubLevelItem = function(id,back) {
		if (document.getElementById("arrow_" + this.idPrefix + id) != null) { document.getElementById("arrow_" + this.idPrefix + id).style.display = (back?"none":""); }
		if (document.getElementById("image_" + this.idPrefix + id) != null) { document.getElementById("image_" + this.idPrefix + id).style.display = (back?"none":""); }
		if (document.getElementById(this.idPrefix + id) != null) { document.getElementById(this.idPrefix + id).style.display = (back?"":"none"); }
	}
	/* hide sublevel item */
	this._hideSubLevelItem = function(id) {
		this._showSubLevelItem(id,true)
	}
	// generating id prefix
	this.idPrefix = this._genStr(12)+"_";
	
	/* attach body events */
	this._bodyClick = function(e) {
		e = e||event;
		if (e.button == 2 || (window.dhx4.isOpera && e.ctrlKey == true)) return;
		if (that.conf.context) {
			if (that.conf.ctx_autohide && (!window.dhx4.isOpera || (that._isContextMenuVisible() && window.dhx4.isOpera))) that._hideContextMenu();
		} else {
			if (that._clearAndHide) that._clearAndHide();
		}
	}
	this._bodyContext = function(e) {
		e = e||event;
		var t = String((e.srcElement||e.target).className);
		if (t.search("dhtmlxMenu") != -1 && t.search("SubLevelArea") != -1) return;
		var toHide = true;
		var testZone = e.target || e.srcElement;
		while (testZone != null) {
			if (testZone.id != null) if (that.isContextZone(testZone.id)) toHide = false;
			if (testZone == document.body) toHide = false;
			testZone = testZone.parentNode;
		}
		if (toHide) that.hideContextMenu();
	}
	
	if (typeof(window.addEventListener) != "undefined") {
		window.addEventListener("click", this._bodyClick, false);
		window.addEventListener("contextmenu", this._bodyContext, false);
	} else {
		document.body.attachEvent("onclick", this._bodyClick);
		document.body.attachEvent("oncontextmenu", this._bodyContext);
	}
	
	this.unload = function() {
		
		window.dhx4._eventable(this, "clear");
		
		// remove menu from global store
		dhtmlXMenuObject.prototype.liveInst[this.conf.live_id] = null;
		try { delete dhtmlXMenuObject.prototype.liveInst[this.conf.live_id]; } catch(e) {}
		this.conf.live_id = null;
		
		if (typeof(window.addEventListener) == "function") {
			window.removeEventListener("click", this._bodyClick, false);
			window.removeEventListener("contextmenu", this._bodyContext, false);
		} else {
			document.body.detachEvent("onclick", this._bodyClick);
			document.body.detachEvent("oncontextmenu", this._bodyContext);
		}
		this._bodyClick = null;
		this._bodyContext = null;
		
		// will recursively remove all items
		this.removeItem(this.idPrefix+this.topId, true);
		
		this.itemPull = null;
		this.idPull = null;
		
		// clear context zones
		if (this.conf.context) for (var a in this.conf.ctx_zones) this.removeContextZone(a);
		
		if (this.cont != null) {
			this.cont.className = "";
			this.cont.parentNode.removeChild(this.cont);
			this.cont = null;
		}
		
		if (this.base != null) {
			if (!this.conf.context) this.base.className = "";
			if (!this.conf.context) this.base.oncontextmenu = (this.base._oldContextMenuHandler||null);
			this.base.onselectstart = null;
			this.base = null;
		}
		
		for (var a in this) this[a] = null;
		that = null;
		
	}
	
	// register instance
	dhtmlXMenuObject.prototype.liveInst[this.conf.live_id] = this;
	
	window.dhx4._enableDataLoading(this, "_initObj", "_xmlToJson", this.conf.tags.root, {struct:true});
	window.dhx4._eventable(this);
	
	// autoload
	if (window.dhx4.s2b(this.conf.autoload.context) == true) this.renderAsContextMenu();
	
	if (this.conf.autoload.dynamic != null) {
		this.enableDynamicLoading(this.conf.autoload.dynamic, window.dhx4.s2b(this.conf.autoload.dynamic_icon));
	} else if (this.conf.autoload.items != null) {
		this.loadStruct(this.conf.autoload.items, this.conf.autoload.onload);
	} else if (this.conf.autoload.json != null) {
		this.loadStruct(this.conf.autoload.json, this.conf.autoload.onload);
	} else if (this.conf.autoload.xml != null) {
		this.loadStruct(this.conf.autoload.xml, this.conf.autoload.onload);
	}
	
	for (var a in {onclick:1,oncheckboxclick:1,onradioclick:1}) {
		if (this.conf.autoload[a] != null) {
			if (typeof(this.conf.autoload[a]) == "function") {
				this.attachEvent(a, this.conf.autoload[a]);
			} else if (typeof(window[this.conf.autoload[a]]) == "function") {
				this.attachEvent(a, window[this.conf.autoload[a]]);
			}
		}
	}
	
	if (this.conf.autoload.top_text != null) this.setTopText(this.conf.autoload.top_text);
	if (this.conf.autoload.align != null) this.setAlign(this.conf.autoload.align);
	if (this.conf.autoload.open_mode != null) this.setOpenMode(this.conf.autoload.open_mode);
	if (this.conf.autoload.overflow != null) this.setOverflowHeight(this.conf.autoload.overflow);
	
	if (this.conf.autoload.iconset == "awesome") {
		this.conf.icons_css = true;
	}
	
	//
	for (var a in this.conf.autoload) {
		this.conf.autoload[a] = null;
		delete this.conf.autoload[a];
	}
	this.conf.autoload = null;
	
	//
	return this;
	
};

dhtmlXMenuObject.prototype._init = function() {
	if (this._isInited == true) return;
	if (this.conf.dload) {
		this._dhxdataload.onBeforeXLS = function() {
			var p = {params:{}};
			for (var a in this.conf.dload_params) p.params[a] = this.conf.dload_params[a];
			return p;
		};
		this.loadStruct(this.conf.dload_url);
	} else {
		this._initTopLevelMenu();
		this._isInited = true;
	}
};

dhtmlXMenuObject.prototype._countVisiblePolygonItems = function(id) {
	
	var count = 0;
	
	for (var a in this.itemPull) {
		
		var par = this.itemPull[a]["parent"];
		var tp = this.itemPull[a]["type"];
		if (this.idPull[a] != null) {
			if (par == id && (tp == "item" || tp == "radio" || tp == "checkbox") && this.idPull[a].style.display != "none") {
				count++;
			}
		}
	}
	return count;
};

dhtmlXMenuObject.prototype._redefineComplexState = function(id) {
	// alert(id)
	if (this.idPrefix+this.topId == id) { return; }
	if ((this.idPull["polygon_"+id] != null) && (this.idPull[id] != null)) {
		var u = this._countVisiblePolygonItems(id);
		if ((u > 0) && (!this.itemPull[id]["complex"])) { this._updateItemComplexState(id, true, false); }
		if ((u == 0) && (this.itemPull[id]["complex"])) { this._updateItemComplexState(id, false, false); }
	}
};

dhtmlXMenuObject.prototype._updateItemComplexState = function(id, state, over) {
	// 0.2 FIX :: topLevel's items can have complex items with arrow
	if ((!this.conf.context) && (this._getItemLevelType(id.replace(this.idPrefix,"")) == "TopLevel")) {
		// 30.06.2008 fix > complex state for top level item, state only, no arrow
		this.itemPull[id]["complex"] = state;
		return;
	}
	if ((this.idPull[id] == null) || (this.itemPull[id] == null)) { return; }
	// 0.2 FIX :: end
	this.itemPull[id]["complex"] = state;
	// fixed in 0.4 for context
	if (id == this.idPrefix+this.topId) return;
	// end fix
	// try to retrieve arrow img object
	var arrowObj = null;
	
	
	var item = this.idPull[id].childNodes[this.conf.rtl?0:2];
	if (item.childNodes[0]) if (String(item.childNodes[0].className).search("complex_arrow") === 0) arrowObj = item.childNodes[0];
	
	if (this.itemPull[id]["complex"]) {
		// create arrow
		if (arrowObj == null) {
			arrowObj = document.createElement("DIV");
			arrowObj.className = "complex_arrow";
			arrowObj.id = "arrow_"+id;
			while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
			item.appendChild(arrowObj);
		}
		// over state added in 0.4
		
		if (this.conf.dload && (this.itemPull[id].loaded == "get") && this.conf.dload_icon) {
			// change arrow to loader
			if (arrowObj.className != "complex_arrow_loading") arrowObj.className = "complex_arrow_loading";
		} else {
			arrowObj.className = "complex_arrow";
		}
		
		return;
	}
	
	if ((!this.itemPull[id]["complex"]) && (arrowObj!=null)) {
		item.removeChild(arrowObj);
		if (this.itemPull[id]["hotkey_backup"] != null && this.setHotKey) { this.setHotKey(id.replace(this.idPrefix, ""), this.itemPull[id]["hotkey_backup"]); }
	}
	
};

dhtmlXMenuObject.prototype._getItemLevelType = function(id) {
	return (this.itemPull[this.idPrefix+id]["parent"]==this.idPrefix+this.topId?"TopLevel":"SubLevelArea");
};

dhtmlXMenuObject.prototype.setIconsPath = function(path) {
	this.conf.icons_path = path;
};

/* real-time update icon in menu */
dhtmlXMenuObject.prototype._updateItemImage = function(id, levelType) {
	// search existsing image
	id = this.idPrefix+id;
	
	var tp = this.itemPull[id]["type"];
	if (tp == "checkbox" || tp == "radio") return;
	
	var isTopLevel = (this.itemPull[id]["parent"] == this.idPrefix+this.topId && !this.conf.context);
	
	// search existing image
	var imgObj = null;
	if (isTopLevel) {
		for (var q=0; q<this.idPull[id].childNodes.length; q++) {
			if (imgObj == null && (this.idPull[id].childNodes[q].className || "") == "dhtmlxMenu_TopLevel_Item_Icon" || (this.idPull[id].childNodes[q].tagName||"").toLowerCase() == "i") {
				imgObj = this.idPull[id].childNodes[q];
			}
		}
	} else {
		try { var imgObj = this.idPull[id].childNodes[this.conf.rtl?2:0].childNodes[0]; } catch(e) { }
		if (!(imgObj != null && typeof(imgObj.className) != "undefined" && (imgObj.className == "sub_icon" || imgObj.tagName.toLowerCase() == "i"))) imgObj = null;
	}
	
	var imgSrc = this.itemPull[id][(this.itemPull[id]["state"]=="enabled"?"imgen":"imgdis")];
	
	if (imgSrc.length > 0) {
		if (imgObj != null) {
			if (this.conf.icons_css == true) {
				imgObj.className = this.conf.icons_path+imgSrc;
			} else {
				imgObj.src = this.conf.icons_path+imgSrc;
			}
		} else {
			if (isTopLevel) {
				if (this.conf.icons_css == true) {
					var imgObj = document.createElement("i");
					imgObj.className = this.conf.icons_path+imgSrc;
				} else {
					var imgObj = document.createElement("IMG");
					imgObj.className = "dhtmlxMenu_TopLevel_Item_Icon";
					imgObj.src = this.conf.icons_path+imgSrc;
					imgObj.border = "0";
					imgObj.id = "image_"+id;
				}
				if (!this.conf.rtl && this.idPull[id].childNodes.length > 0) this.idPull[id].insertBefore(imgObj,this.idPull[id].childNodes[0]); else this.idPull[id].appendChild(imgObj);				
			} else {
				if (this.conf.icons_css == true) {
					var item = this.idPull[id].childNodes[this.conf.rtl?2:0];
					item.innerHTML = "<i class='"+this.conf.icons_path+imgSrc+"'></i>";
				} else {
					var imgObj = document.createElement("IMG");
					imgObj.className = "sub_icon";
					imgObj.src = this.conf.icons_path+imgSrc;
					imgObj.border = "0";
					imgObj.id = "image_"+id;
					var item = this.idPull[id].childNodes[this.conf.rtl?2:0];
					while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
					item.appendChild(imgObj);
				}
			}
		}
	} else {
		if (imgObj != null) {
			if (isTopLevel) {
				imgObj.parentNode.removeChild(imgObj);
				imgObj = null;
			} else {
				var p = imgObj.parentNode;
				p.removeChild(imgObj);
				p.innerHTML = "&nbsp;";
				p = imgObj = null;
			}
		}
	}
};

// collect parents for remove complex item
dhtmlXMenuObject.prototype._getAllParents = function(id) {
	var parents = new Array();
	for (var a in this.itemPull) {
		if (this.itemPull[a]["parent"] == id) {
			parents[parents.length] = this.itemPull[a]["id"];
			if (this.itemPull[a]["complex"]) {
				var t = this._getAllParents(this.itemPull[a]["id"]);
				for (var q=0; q<t.length; q++) { parents[parents.length] = t[q]; }
			}
		}
	}
	return parents;
};

// visible area
dhtmlXMenuObject.prototype._autoDetectVisibleArea = function() {
	if (this.conf.v_enabled) return;
	var d = window.dhx4.screenDim();
	this.conf.v.x1 = d.left;
	this.conf.v.x2 = d.right;
	this.conf.v.y1 = d.top;
	this.conf.v.y2 = d.bottom;
};

dhtmlXMenuObject.prototype.getItemPosition = function(id) {
	id = this.idPrefix+id;
	var pos = -1;
	if (this.itemPull[id] == null) return pos;
	var parent = this.itemPull[id]["parent"];
	// var obj = (this.idPull["polygon_"+parent]!=null?this.idPull["polygon_"+parent].tbd:this.base);
	var obj = (this.idPull["polygon_"+parent]!=null?this.idPull["polygon_"+parent].tbd:this.cont);
	for (var q=0; q<obj.childNodes.length; q++) { if (obj.childNodes[q]==this.idPull["separator_"+id]||obj.childNodes[q]==this.idPull[id]) { pos = q; } }
	return pos;
};

dhtmlXMenuObject.prototype.setItemPosition = function(id, pos) {
	id = this.idPrefix+id;
	if (this.idPull[id] == null) { return; }
	// added in 0.4
	var isOnTopLevel = (this.itemPull[id]["parent"] == this.idPrefix+this.topId);
	//
	var itemData = this.idPull[id];
	var itemPos = this.getItemPosition(id.replace(this.idPrefix,""));
	var parent = this.itemPull[id]["parent"];
	// var obj = (this.idPull["polygon_"+parent]!=null?this.idPull["polygon_"+parent].tbd:this.base);
	var obj = (this.idPull["polygon_"+parent]!=null?this.idPull["polygon_"+parent].tbd:this.cont);
	obj.removeChild(obj.childNodes[itemPos]);
	if (pos < 0) pos = 0;
	// added in 0.4
	if (isOnTopLevel && pos < 1) { pos = 1; }
	//
	if (pos < obj.childNodes.length) { obj.insertBefore(itemData, obj.childNodes[pos]); } else { obj.appendChild(itemData); }
};

dhtmlXMenuObject.prototype.getParentId = function(id) {
	id = this.idPrefix+id;
	if (this.itemPull[id] == null) { return null; }
	return ((this.itemPull[id]["parent"]!=null?this.itemPull[id]["parent"]:this.topId).replace(this.idPrefix,""));
};


// hide any opened polygons
dhtmlXMenuObject.prototype.hide = function() {
	this._clearAndHide();
};
dhtmlXMenuObject.prototype.clearAll = function() {
	this.removeItem(this.idPrefix+this.topId, true);
	this._isInited = false;
	this.idPrefix = this._genStr(12)+"_";
	this.itemPull = {};
};

// dhtmlxmenu global store
if (typeof(dhtmlXMenuObject.prototype.liveInst) == "undefined") {
	dhtmlXMenuObject.prototype.liveInst = {};
};

dhtmlXMenuObject.prototype.setIconset = function(name) {
	this.conf.icons_css = (name == "awesome");
};
// redistrib selection in case of top node in real-time mode
dhtmlXMenuObject.prototype._redistribTopLevelSelection = function(id, parent) {
	// kick polygons and decelect before selected menues
	var i = this._getSubItemToDeselectByPolygon("parent");
	this._removeSubItemFromSelected(-1, -1);
	for (var q=0; q<i.length; q++) {
		if (i[q] != id) { this._hidePolygon(i[q]); }
		if ((this.idPull[i[q]] != null) && (i[q] != id)) { this.idPull[i[q]].className = this.idPull[i[q]].className.replace(/Selected/g, "Normal"); }
	}
	// check if enabled
	if (this.itemPull[this.idPrefix+id]["state"] == "enabled") {
		this.idPull[this.idPrefix+id].className = "dhtmlxMenu_"+this.conf.skin+"_TopLevel_Item_Selected";
		//
		this._addSubItemToSelected(this.idPrefix+id, "parent");
		this.conf.selected = (this.conf.mode=="win"?(this.conf.selected!=-1?id:this.conf.selected):id);
		if ((this.itemPull[this.idPrefix+id]["complex"]) && (this.conf.selected != -1)) { this._showPolygon(this.idPrefix+id, this.conf.dir_toplv); }
	}
};

dhtmlXMenuObject.prototype._initTopLevelMenu = function() {
	
	this.conf.dir_toplv = "bottom";
	this.conf.dir_sublv = (this.conf.rtl?"left":"right");
	if (this.conf.context) {
		this.idPull[this.idPrefix+this.topId] = new Array(0,0);
		this._addSubMenuPolygon(this.idPrefix+this.topId, this.idPrefix+this.topId);
	} else {
		var m = this._getMenuNodes(this.idPrefix + this.topId);
		for (var q=0; q<m.length; q++) {
			if (this.itemPull[m[q]]["type"] == "item") this._renderToplevelItem(m[q], null);
			if (this.itemPull[m[q]]["type"] == "separator") this._renderSeparator(m[q], null);
		}
	}
};

// add top menu item, complex define that submenues are in presence
dhtmlXMenuObject.prototype._renderToplevelItem = function(id, pos) {
	var that = this;
	var m = document.createElement("DIV");
	m.id = id;
	// custom css
	if (this.itemPull[id]["state"] == "enabled" && this.itemPull[id]["cssNormal"] != null) {
		m.className = this.itemPull[id]["cssNormal"];
	} else {
		m.className = "dhtmlxMenu_"+this.conf.skin+"_TopLevel_Item_"+(this.itemPull[id]["state"]=="enabled"?"Normal":"Disabled");
	}
	
	// text
	if (this.itemPull[id]["title"] != "") {
		var t1 = document.createElement("DIV");
		t1.className = "top_level_text";
		t1.innerHTML = this.itemPull[id]["title"];
		m.appendChild(t1);
	}
	// tooltip
	if (this.itemPull[id]["tip"].length > 0) m.title = this.itemPull[id]["tip"];
	//
	// image in top level
	if ((this.itemPull[id]["imgen"]!="")||(this.itemPull[id]["imgdis"]!="")) {
		var imgTop=this.itemPull[id][(this.itemPull[id]["state"]=="enabled")?"imgen":"imgdis"];
		if (imgTop) {
			if (this.conf.icons_css == true) {
				var i = document.createElement("i");
				i.className = this.conf.icons_path+imgTop;
				if (m.childNodes.length > 0 && !this.conf.rtl) m.insertBefore(i, m.childNodes[0]); else m.appendChild(i);
			} else {
				var img = document.createElement("IMG");
				img.border = "0";
				img.id = "image_"+id;
				img.src = this.conf.icons_path+imgTop;
				img.className = "dhtmlxMenu_TopLevel_Item_Icon";
				if (m.childNodes.length > 0 && !this.conf.rtl) m.insertBefore(img, m.childNodes[0]); else m.appendChild(img);
			}
		}
	}
	m.onselectstart = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	m.oncontextmenu = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	// add container for top-level items if not exists yet
	if (!this.cont) {
		this.cont = document.createElement("DIV");
		this.cont.dir = "ltr";
		this.cont.className = (this.conf.align=="right"?"align_right":"align_left");
		this.base.appendChild(this.cont);
	}
	// insert
	
	if (pos != null) { pos++; if (pos < 0) pos = 0; if (pos > this.cont.childNodes.length - 1) pos = null; }
	if (pos != null) this.cont.insertBefore(m, this.cont.childNodes[pos]); else this.cont.appendChild(m);
	
	this.idPull[m.id] = m;
	// create submenues
	if (this.itemPull[id]["complex"] && (!this.conf.dload)) this._addSubMenuPolygon(this.itemPull[id]["id"], this.itemPull[id]["id"]);
	// events
	m.onmouseover = function() {
		if (that.conf.mode == "web") { window.clearTimeout(that.conf.tm_handler); }
		// kick polygons and decelect before selected menues
		var i = that._getSubItemToDeselectByPolygon("parent");
		that._removeSubItemFromSelected(-1, -1);
		for (var q=0; q<i.length; q++) {
			if (i[q] != this.id) { that._hidePolygon(i[q]); }
			if ((that.idPull[i[q]] != null) && (i[q] != this.id)) {
				// custom css
				if (that.itemPull[i[q]]["cssNormal"] != null) {
					that.idPull[i[q]].className = that.itemPull[i[q]]["cssNormal"];
				} else {
					if (that.idPull[i[q]].className == "sub_item_selected") that.idPull[i[q]].className = "sub_item";
					that.idPull[i[q]].className = that.idPull[i[q]].className.replace(/Selected/g, "Normal");
				}
			}
		}
		// check if enabled
		if (that.itemPull[this.id]["state"] == "enabled") {
			this.className = "dhtmlxMenu_"+that.conf.skin+"_TopLevel_Item_Selected";
			//
			that._addSubItemToSelected(this.id, "parent");
			that.conf.selected = (that.conf.mode=="win"?(that.conf.selected!=-1?this.id:that.conf.selected):this.id);
			if (that.conf.dload) {
				if (that.itemPull[this.id].loaded == "no") {
					this._dynLoadTM = new Date().getTime();
					that.itemPull[this.id].loaded = "get";
					var xmlParentId = this.id.replace(that.idPrefix,"");
					that._dhxdataload.onBeforeXLS = function() {
						var p = {params:{}};
						p.params[this.conf.dload_pid] = xmlParentId;
						for (var a in this.conf.dload_params) p.params[a] = this.conf.dload_params[a];
						return p;
					};
					that.loadStruct(that.conf.dload_url);
				}
				if (that.conf.top_mode && that.conf.mode == "web" && !that.conf.context) {
					this._mouseOver = true;
				}
			}
			if ((!that.conf.dload) || (that.conf.dload && (!that.itemPull[this.id]["loaded"] || that.itemPull[this.id]["loaded"]=="yes"))) {
				if ((that.itemPull[this.id]["complex"]) && (that.conf.selected != -1)) {
					if (that.conf.top_mode && that.conf.mode == "web" && !that.conf.context) {
						this._mouseOver = true;
						var showItemId = this.id;
						this._menuOpenTM = window.setTimeout(function(){that._showPolygon(showItemId, that.conf.dir_toplv);}, that.conf.top_tmtime);
					} else {
						that._showPolygon(this.id, that.conf.dir_toplv);
					}
				}
			}
		}
		that._doOnTouchMenu(this.id.replace(that.idPrefix, ""));
	}
	m.onmouseout = function() {
		if (!((that.itemPull[this.id]["complex"]) && (that.conf.selected != -1)) && (that.itemPull[this.id]["state"]=="enabled")) {
			// custom css
			
			if (that.itemPull[this.id]["cssNormal"] != null) {
				// alert(1)
				m.className = that.itemPull[this.id]["cssNormal"];
			} else {
				// default css
				m.className = "dhtmlxMenu_"+that.conf.skin+"_TopLevel_Item_Normal";
			}
		}
		if (that.conf.mode == "web") {
			window.clearTimeout(that.conf.tm_handler);
			that.conf.tm_handler = window.setTimeout(function(){that._clearAndHide();}, that.conf.tm_sec, "JavaScript");
		}
		if (that.conf.top_mode && that.conf.mode == "web" && !that.conf.context) {
			this._mouseOver = false;
			window.clearTimeout(this._menuOpenTM);
		}
	}
	m.onclick = function(e) {
		if (that.conf.mode == "web") { window.clearTimeout(that.conf.tm_handler); }
		// fix, added in 0.4
		if (that.conf.mode != "web" && that.itemPull[this.id]["state"] == "disabled") { return; }
		//
		e = e || event;
		e.cancelBubble = true;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		
		if (that.conf.mode == "win") {
			if (that.itemPull[this.id]["complex"]) {
				if (that.conf.selected == this.id) { that.conf.selected = -1; var s = false; } else { that.conf.selected = this.id; var s = true; }
				if (s) { that._showPolygon(this.id, that.conf.dir_toplv); } else { that._hidePolygon(this.id); }
			}
		}
		var tc = (that.itemPull[this.id]["complex"]?"c":"-");
		var td = (that.itemPull[this.id]["state"]!="enabled"?"d":"-");
		var cas = {"ctrl": e.ctrlKey, "alt": e.altKey, "shift": e.shiftKey};
		that._doOnClick(this.id.replace(that.idPrefix, ""), tc+td+"t", cas);
		return false;
	}
	
	if (this.conf.skin == "dhx_terrace") {
		this._improveTerraceSkin();
	}
};

// recursively creates and adds submenu polygon
dhtmlXMenuObject.prototype._addSubMenuPolygon = function(id, parentId) {
	var s = this._renderSublevelPolygon(id, parentId);
	var j = this._getMenuNodes(parentId);
	for (q=0; q<j.length; q++) { if (this.itemPull[j[q]]["type"] == "separator") { this._renderSeparator(j[q], null); } else { this._renderSublevelItem(j[q], null); } }
	if (id == parentId) { var level = "topLevel"; } else { var level = "subLevel"; }
	for (var q=0; q<j.length; q++) { if (this.itemPull[j[q]]["complex"]) { this._addSubMenuPolygon(id, this.itemPull[j[q]]["id"]); } }
};

// inner: add single subpolygon/item/separator
dhtmlXMenuObject.prototype._renderSublevelPolygon = function(id, parentId) {
	var s = document.createElement("DIV");
	s.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_Polygon "+(this.conf.rtl?"dir_right":"");
	s.dir = "ltr";
	s.oncontextmenu = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; e.cancelBubble = true; return false; }
	s.id = "polygon_" + parentId;
	s.onclick = function(e) { e = e || event; e.cancelBubble = true; }
	s.style.display = "none";
	document.body.insertBefore(s, document.body.firstChild);
	//
	
	s.innerHTML = '<div style="position:relative;"></div>'+'<div style="position: relative; overflow:hidden;"></div>'+'<div style="position:relative;"></div>';
	
	var tbl = document.createElement("TABLE");
	tbl.className = "dhtmlxMebu_SubLevelArea_Tbl";
	tbl.cellSpacing = 0;
	tbl.cellPadding = 0;
	tbl.border = 0;
	var tbd = document.createElement("TBODY");
	tbl.appendChild(tbd);
	
	s.childNodes[1].appendChild(tbl);
	
	s.tbl = tbl;
	s.tbd = tbd;
	// polygon
	this.idPull[s.id] = s;
	if (this.sxDacProc != null) {
		this.idPull["sxDac_" + parentId] = new this.sxDacProc(s, s.className);
		if (window.dhx4.isIE) {
			this.idPull["sxDac_" + parentId]._setSpeed(this.dacSpeedIE);
			this.idPull["sxDac_" + parentId]._setCustomCycle(this.dacCyclesIE);
		} else {
			this.idPull["sxDac_" + parentId]._setSpeed(this.dacSpeed);
			this.idPull["sxDac_" + parentId]._setCustomCycle(this.dacCycles);
		}
	}
	return s;
};

dhtmlXMenuObject.prototype._renderSublevelItem = function(id, pos) {
	var that = this;
	
	var tr = document.createElement("TR");
	tr.className = (this.itemPull[id]["state"]=="enabled"?"sub_item":"sub_item_dis");
	
	// icon
	var t1 = document.createElement("TD");
	t1.className = "sub_item_icon";
	var tp = this.itemPull[id]["type"];
	var icon = this.itemPull[id][(this.itemPull[id]["state"]=="enabled"?"imgen":"imgdis")];
	if (icon != "") {
		if (tp=="checkbox"||tp=="radio") {
			var img = document.createElement("DIV");
			img.id = "image_"+this.itemPull[id]["id"];
			img.className = "sub_icon "+icon;
			t1.appendChild(img);
		}
		if (!(tp=="checkbox"||tp=="radio")) {
			if (this.conf.icons_css == true) {
				t1.innerHTML = "<i class='"+this.conf.icons_path+icon+"'></i>";
			} else {
				var img = document.createElement("IMG");
				img.id = "image_"+this.itemPull[id]["id"];
				img.className = "sub_icon";
				img.src = this.conf.icons_path+icon;
				t1.appendChild(img);
			}
		}
	} else {
		t1.innerHTML = "&nbsp;";
	}
	
	// text
	var t2 = document.createElement("TD");
	t2.className = "sub_item_text";
	if (this.itemPull[id]["title"] != "") {
		var t2t = document.createElement("DIV");
		t2t.className = "sub_item_text";
		t2t.innerHTML = this.itemPull[id]["title"];
		t2.appendChild(t2t);
	} else {
		t2.innerHTML = "&nbsp;";
	}
	
	// hotkey/sublevel arrow
	var t3 = document.createElement("TD");
	t3.className = "sub_item_hk";
	if (this.itemPull[id]["complex"]) {
		
		var arw = document.createElement("DIV");
		arw.className = "complex_arrow";
		arw.id = "arrow_"+this.itemPull[id]["id"];
		t3.appendChild(arw);
		
	} else {
		if (this.itemPull[id]["hotkey"].length > 0 && !this.itemPull[id]["complex"]) {
			var t3t = document.createElement("DIV");
			t3t.className = "sub_item_hk";
			t3t.innerHTML = this.itemPull[id]["hotkey"];
			t3.appendChild(t3t);
		} else {
			t3.innerHTML = "&nbsp;";
		}
	}
	tr.appendChild(this.conf.rtl?t3:t1);
	tr.appendChild(t2);
	tr.appendChild(this.conf.rtl?t1:t3);
	
	
	//
	tr.id = this.itemPull[id]["id"];
	tr.parent = this.itemPull[id]["parent"];
	// tooltip, added in 0.4
	if (this.itemPull[id]["tip"].length > 0) tr.title = this.itemPull[id]["tip"];
	//
	tr.onselectstart = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	tr.onmouseover = function(e) {
		if (that.conf.hide_tm[this.id]) window.clearTimeout(that.conf.hide_tm[this.id]);
		if (that.conf.mode == "web") window.clearTimeout(that.conf.tm_handler);
		if (!this._visible) that._redistribSubLevelSelection(this.id, this.parent); // if not visible
		this._visible = true;
	}
	tr.onmouseout = function() {
		if (that.conf.mode == "web") {
			if (that.conf.tm_handler) window.clearTimeout(that.conf.tm_handler);
			that.conf.tm_handler = window.setTimeout(function(){if(that&&that._clearAndHide)that._clearAndHide();}, that.conf.tm_sec, "JavaScript");
		}
		var k = this;
		if (that.conf.hide_tm[this.id]) window.clearTimeout(that.conf.hide_tm[this.id]);
		that.conf.hide_tm[this.id] = window.setTimeout(function(){k._visible=false;}, 50);
	}
	tr.onclick = function(e) {
		// added in 0.4, preven complex closing if user event not defined
		if (!that.checkEvent("onClick") && that.itemPull[this.id]["complex"]) return;
		//
		e = e || event; e.cancelBubble = true;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		tc = (that.itemPull[this.id]["complex"]?"c":"-");
		td = (that.itemPull[this.id]["state"]=="enabled"?"-":"d");
		var cas = {"ctrl": e.ctrlKey, "alt": e.altKey, "shift": e.shiftKey};
		switch (that.itemPull[this.id]["type"]) {
			case "checkbox":
				that._checkboxOnClickHandler(this.id.replace(that.idPrefix, ""), tc+td+"n", cas);
				break;
			case "radio":
				that._radioOnClickHandler(this.id.replace(that.idPrefix, ""), tc+td+"n", cas);
				break;
			case "item":
				that._doOnClick(this.id.replace(that.idPrefix, ""), tc+td+"n", cas);
				break;
		}
		return false;
	}
	// add
	var polygon = this.idPull["polygon_"+this.itemPull[id]["parent"]];
	if (pos != null) { pos++; if (pos < 0) pos = 0; if (pos > polygon.tbd.childNodes.length - 1) pos = null; }
	if (pos != null && polygon.tbd.childNodes[pos] != null) polygon.tbd.insertBefore(tr, polygon.tbd.childNodes[pos]); else polygon.tbd.appendChild(tr);
	this.idPull[tr.id] = tr;
};

dhtmlXMenuObject.prototype._renderSeparator = function(id, pos) {
	var level = (this.conf.context?"SubLevelArea":(this.itemPull[id]["parent"]==this.idPrefix+this.topId?"TopLevel":"SubLevelArea"));
	if (level == "TopLevel" && this.conf.context) return;
	
	var that = this;
	
	if (level != "TopLevel") {
		var tr = document.createElement("TR");
		tr.className = "sub_sep";
		var td = document.createElement("TD");
		td.colSpan = "3";
		tr.appendChild(td);
	}
	
	var k = document.createElement("DIV");
	k.id = "separator_"+id;
	k.className = (level=="TopLevel"?"top_sep":"sub_sep");
	k.onselectstart = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	k.onclick = function(e) {
		e = e || event; e.cancelBubble = true;
		var cas = {"ctrl": e.ctrlKey, "alt": e.altKey, "shift": e.shiftKey};
		that._doOnClick(this.id.replace("separator_" + that.idPrefix, ""), "--s", cas);
	}
	if (level == "TopLevel") {
		if (pos != null) {
			pos++; if (pos < 0) { pos = 0; }
			// if (this.base.childNodes[pos] != null) { this.base.insertBefore(k, this.base.childNodes[pos]); } else { this.base.appendChild(k); }
			if (this.cont.childNodes[pos] != null) { this.cont.insertBefore(k, this.cont.childNodes[pos]); } else { this.cont.appendChild(k); }
		} else {
			// add as a last item
			// var last = this.base.childNodes[this.base.childNodes.length-1];
			var last = this.cont.childNodes[this.cont.childNodes.length-1];
			// if (String(last).search("TopLevel_Text") == -1) { this.base.appendChild(k); } else { this.base.insertBefore(k, last); }
			if (String(last).search("TopLevel_Text") == -1) { this.cont.appendChild(k); } else { this.cont.insertBefore(k, last); }
		}
		this.idPull[k.id] = k;
	} else {
		var polygon = this.idPull["polygon_"+this.itemPull[id]["parent"]];
		if (pos != null) { pos++; if (pos < 0) pos = 0; if (pos > polygon.tbd.childNodes.length - 1) pos = null; }
		if (pos != null && polygon.tbd.childNodes[pos] != null) polygon.tbd.insertBefore(tr, polygon.tbd.childNodes[pos]); else polygon.tbd.appendChild(tr);
		td.appendChild(k);
		this.idPull[k.id] = tr;
	}
};

dhtmlXMenuObject.prototype.addNewSeparator = function(nextToId, itemId) {
	itemId = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
	var parentId = this.idPrefix+this.getParentId(nextToId);
	
	this._addItemIntoGlobalStrorage(itemId, parentId, "", "separator", false, "", "");
	this._renderSeparator(itemId, this.getItemPosition(nextToId));
};


dhtmlXMenuObject.prototype._initObj = function(items, nested, parentId) {
	
	if (!(items instanceof Array)) {
		parentId = items.parentId;
		if (parentId != null && String(parentId).indexOf(this.idPrefix) !== 0) parentId = this.idPrefix+String(parentId);
		items = items.items;
	}
	
	for (var q=0; q<items.length; q++) {
		
		// api-init, items w/o id
		if (typeof(items[q].id) == "undefined" || items[q].id == null) {
			items[q].id = this._genStr(24);
		}
		
		// empty text fix
		if (items[q].text == null) items[q].text = "";
		
		// api-init, add idPrefix
		if (String(items[q].id).indexOf(this.idPrefix) !== 0) {
			items[q].id = this.idPrefix+String(items[q].id);
		}
		
		var k = {type: "item", tip: "", hotkey: "", state: "enabled", imgen: "", imgdis: ""};
		for (var a in k) { if (typeof(items[q][a]) == "undefined") items[q][a] = k[a]; }
		
		//
		if (items[q].imgen == "" && items[q].img != null) items[q].imgen = items[q].img;
		if (items[q].imgdis == "" && items[q].img_disabled != null) items[q].imgdis = items[q].img_disabled;
		if (items[q].title == null && items[q].text != null) items[q].title = items[q].text;
		
		// hrefs
		if (items[q].href != null) {
			if (items[q].href.link != null) items[q].href_link = items[q].href.link;
			if (items[q].href.target != null) items[q].href_target = items[q].href.target;
		}
		
		// userdata
		if (items[q].userdata != null) {
			for (var a in items[q].userdata) this.userData[items[q].id+"_"+a] = items[q].userdata[a];
		}

		
		// en/dis
		if (typeof(items[q].enabled) != "undefined" && window.dhx4.s2b(items[q].enabled) == false) {
			items[q].state = "disabled";
		} else if (typeof(items[q].disabled) != "undefined" && window.dhx4.s2b(items[q].disabled) == true) {
			items[q].state = "disabled";
		}
		
		//
		if (typeof(items[q].parent) == "undefined") {
			items[q].parent = (parentId != null ? parentId : this.idPrefix+this.topId);
		}
		
		
		// checkbox
		if (items[q].type == "checkbox") {
			items[q].checked = window.dhx4.s2b(items[q].checked);
			items[q].imgen = items[q].imgdis = "chbx_"+(items[q].checked?"1":"0"); // set classname
		}
		// radio
		if (items[q].type == "radio") {
			items[q].checked = window.dhx4.s2b(items[q].checked);
			items[q].imgen = items[q].imgdis = "rdbt_"+(items[q].checked?"1":"0");
			// group
			if (typeof(items[q].group) == "undefined" || items[q].group == null) items[q].group = this._genStr(24);
			if (this.radio[items[q].group] == null) this.radio[items[q].group] = [];
			this.radio[items[q].group].push(items[q].id);
		}
		
		//
		this.itemPull[items[q].id] = items[q];
		if (items[q].items != null && items[q].items.length > 0) {
			this.itemPull[items[q].id].complex = true;
			this._initObj(items[q].items, true, items[q].id);
		} else if (this.conf.dload && items[q].complex == true) {
			this.itemPull[items[q].id].loaded = "no";
		}
		this.itemPull[items[q].id].items = null;
		
	}
	
	if (nested !== true) {
		if (this.conf.dload == true) {
			if (parentId == null) {
				this._initTopLevelMenu();
			} else {
				this._addSubMenuPolygon(parentId, parentId);
				if (this.conf.selected == parentId) {
					var isTop = (this.itemPull[parentId].parent == this.idPrefix+this.topId);
					var level = (isTop && !this.conf.context ? this.conf.dir_toplv:this.conf.dir_sublv);
					var isShow = false;
					if (isTop && this.conf.top_mode && this.conf.mode == "web" && !this.conf.context) {
						var item = this.idPull[parentId];
						if (item._mouseOver == true) {
							var delay = this.conf.top_tmtime - (new Date().getTime()-item._dynLoadTM);
							if (delay > 1) {
								var pId = parentId;
								var that = this;
								item._menuOpenTM = window.setTimeout(function(){
									that._showPolygon(pId, level);
									that = pId = null;
								}, delay);
								isShow = true;
							}
						}
					}
					if (!isShow) this._showPolygon(parentId, level);
				}
				
				this.itemPull[parentId].loaded = "yes";
				if (this.conf.dload_icon == true) this._updateLoaderIcon(parentId, false);
			}
		} else {
			this._init();
		}
	}
	
};

dhtmlXMenuObject.prototype._xmlToJson = function(xml, parentId) {
	
	var items = [];
	
	if (parentId == null) {
		var root = xml.getElementsByTagName(this.conf.tags.root);
		if (root == null || (root != null && root.length == 0)) return {items:[]};
		root = root[0];
	} else {
		root = xml;
	}
	
	if (root.getAttribute("parentId") != null) {
		parentId = this.idPrefix+root.getAttribute("parentId");
	}
	
	for (var q=0; q<root.childNodes.length; q++) {
		if (typeof(root.childNodes[q].tagName) != "undefined" && String(root.childNodes[q].tagName).toLowerCase() == this.conf.tags.item) {
			var r = root.childNodes[q];
			var item = {
				// basic
				id: this.idPrefix+(r.getAttribute("id")||this._genStr(24)),
				title: r.getAttribute("text")||"",
				// images
				imgen: r.getAttribute("img")||"",
				imgdis: r.getAttribute("imgdis")||"",
				tip: "",
				hotkey: "",
				//
				type: r.getAttribute("type")||"item"
			};
			// custom css
			if (r.getAttribute("cssNormal") != null) {
				item.cssNormal = r.getAttribute("cssNormal");
			}
			// checkbox
			if (item.type == "checkbox") item.checked = r.getAttribute("checked");
			// radio
			if (item.type == "radio") {
				item.checked = r.getAttribute("checked");
				item.group = r.getAttribute("group");
			}
			// en/dis
			item.state = "enabled";
			if (r.getAttribute("enabled") != null && window.dhx4.s2b(r.getAttribute("enabled")) == false) {
				item.state = "disabled";
			} else if (r.getAttribute("disabled") != null && window.dhx4.s2b(r.getAttribute("disabled")) == true) {
				item.state = "disabled";
			}
			
			item.parent = (parentId != null ? parentId : this.idPrefix+this.topId);
			// is complex item
			if (this.conf.dload) {
				item.complex = (r.getAttribute("complex") != null);
				if (item.complex) item.loaded = "no";
			} else {
				var i = this._xmlToJson(r, item.id);
				item.items = i.items;
				item.complex = (item.items.length > 0);
			}
			
			// misc
			for (var w=0; w<r.childNodes.length; w++) {
				if (typeof(r.childNodes[w].tagName) != "undefined") {
					var t = String(r.childNodes[w].tagName||"").toLowerCase();
					// userdata
					if (t == this.conf.tags.userdata) {
						var d = r.childNodes[w];
						if (d.getAttribute("name") != null) {
							this.userData[item.id+"_"+d.getAttribute("name")] = (d.firstChild != null && d.firstChild.nodeValue != null ? d.firstChild.nodeValue : "");
						}
					}
					// extended text
					if (t == this.conf.tags.text_ext) {
						item.title = r.childNodes[w].firstChild.nodeValue;
					}
					// tooltips
					if (t == this.conf.tags.tooltip) {
						item.tip = r.childNodes[w].firstChild.nodeValue;
					}
					// hotkeys
					if (t == this.conf.tags.hotkey) {
						item.hotkey = r.childNodes[w].firstChild.nodeValue;
					}
					// hrefs
					if (t == this.conf.tags.href && item.type == "item") {
						item.href_link = r.childNodes[w].firstChild.nodeValue;
						if (r.childNodes[w].getAttribute("target") != null) {
							item.href_target = r.childNodes[w].getAttribute("target");
						}
					}
				}
			}
			items.push(item);
		}
	}
	
	var r = {
		parentId: parentId,//(root.getAttribute("parentId")||null),
		items: items
	};
	
	return r;
};

// dynload
dhtmlXMenuObject.prototype.enableDynamicLoading = function(url, icon) {
	this.conf.dload = true;
	this.conf.dload_url = url;
	this.conf.dload_sign = (String(this.conf.dload_url).search(/\?/)==-1?"?":"&");
	this.conf.dload_icon = icon;
	this._init();
};

dhtmlXMenuObject.prototype._updateLoaderIcon = function(id, state) {
	
	if (this.idPull[id] == null) return;
	if (String(this.idPull[id].className).search("TopLevel_Item") >= 0) return;
	// get arrow
	var ind = (this.conf.rtl?0:2);
	if (!this.idPull[id].childNodes[ind]) return;
	if (!this.idPull[id].childNodes[ind].childNodes[0]) return;
	var aNode = this.idPull[id].childNodes[ind].childNodes[0];
	if (String(aNode.className).search("complex_arrow") === 0) aNode.className = "complex_arrow"+(state?"_loading":"");

};



// add/remove
dhtmlXMenuObject.prototype.addNewSibling = function(nextToId, itemId, itemText, disabled, imgEnabled, imgDisabled) {
	var id = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
	var parentId = this.idPrefix+(nextToId!=null?this.getParentId(nextToId):this.topId);
	
	this._addItemIntoGlobalStrorage(id, parentId, itemText, "item", disabled, imgEnabled, imgDisabled);
	if ((parentId == this.idPrefix+this.topId) && (!this.conf.context)) {
		this._renderToplevelItem(id, this.getItemPosition(nextToId));
	} else {
		this._renderSublevelItem(id, this.getItemPosition(nextToId));
	}
};

dhtmlXMenuObject.prototype.addNewChild = function(parentId, pos, itemId, itemText, disabled, imgEnabled, imgDisabled) {
	if (parentId == null) {
		if (this.conf.context) {
			parentId = this.topId;
		} else {
			this.addNewSibling(parentId, itemId, itemText, disabled, imgEnabled, imgDisabled);
			if (pos != null) this.setItemPosition(itemId, pos);
			return;
		}
	}
	itemId = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
	// remove hotkey, added in 0.4
	if (this.setHotKey) this.setHotKey(parentId, "");
	//
	parentId = this.idPrefix+parentId;
	this._addItemIntoGlobalStrorage(itemId, parentId, itemText, "item", disabled, imgEnabled, imgDisabled);
	if (this.idPull["polygon_"+parentId] == null) { this._renderSublevelPolygon(parentId, parentId); }
	this._renderSublevelItem(itemId, pos-1);
	
	this._redefineComplexState(parentId);
};

dhtmlXMenuObject.prototype.removeItem = function(id, _isTId, _recCall) {
	if (!_isTId) id = this.idPrefix + id;
	
	var pId = null;
	
	if (id != this.idPrefix+this.topId) {
		
		if (this.itemPull[id] == null) return;
		
		// effects
		if (this.idPull["polygon_"+id] && this.idPull["polygon_"+id]._tmShow) window.clearTimeout(this.idPull["polygon_"+id]._tmShow);
		
		// separator top
		var t = this.itemPull[id]["type"];
		
		if (t == "separator") {
			var item = this.idPull["separator_"+id];
			if (this.itemPull[id]["parent"] == this.idPrefix+this.topId) {
				item.onclick = null;
				item.onselectstart = null;
				item.id = null;
				item.parentNode.removeChild(item);
			} else {
				item.childNodes[0].childNodes[0].onclick = null;
				item.childNodes[0].childNodes[0].onselectstart = null;
				item.childNodes[0].childNodes[0].id = null;
				item.childNodes[0].removeChild(item.childNodes[0].childNodes[0]);
				item.removeChild(item.childNodes[0]);
				item.parentNode.removeChild(item);
			}
			this.idPull["separator_"+id] = null;
			this.itemPull[id] = null;
			delete this.idPull["separator_"+id];
			delete this.itemPull[id];
			item = null;
		} else {
			// item checkbox radio
			pId = this.itemPull[id]["parent"];
			var item = this.idPull[id];
			item.onclick = null;
			item.oncontextmenu = null;
			item.onmouseover = null;
			item.onmouseout = null;
			item.onselectstart = null;
			item.id = null;
			while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
			item.parentNode.removeChild(item);
			this.idPull[id] = null;
			this.itemPull[id] = null;
			delete this.idPull[id];
			delete this.itemPull[id];
			item = null;
			
		}
		t = null;
	}
	
	// clear nested items
	for (var a in this.itemPull) if (this.itemPull[a]["parent"] == id) this.removeItem(a, true, true);
	
	// check if empty polygon left
	var p2 = new Array(id);
	if (pId != null && !_recCall) {
		if (this.idPull["polygon_"+pId] != null) {
			if (this.idPull["polygon_"+pId].tbd.childNodes.length == 0) {
				p2.push(pId);
				this._updateItemComplexState(pId, false, false);
			}
		}
	}
	
	// delete nested polygons and parent's if any
	for (var q=0; q<p2.length; q++) {
		if (this.idPull["polygon_"+p2[q]]) {
			var p = this.idPull["polygon_"+p2[q]];
			p.onclick = null;
			p.oncontextmenu = null;
			p.tbl.removeChild(p.tbd);
			p.tbd = null;
			p.childNodes[1].removeChild(p.tbl);
			p.tbl = null;
			p.id = null;
			p.parentNode.removeChild(p);
			p = null;
			if (window.dhx4.isIE6) {
				var pc = "polygon_"+p2[q]+"_ie6cover";
				if (this.idPull[pc] != null) { document.body.removeChild(this.idPull[pc]); delete this.idPull[pc]; }
			}
			if (this.idPull["arrowup_"+id] != null && this._removeArrow) this._removeArrow("arrowup_"+id);
			if (this.idPull["arrowdown_"+id] != null && this._removeArrow) this._removeArrow("arrowdown_"+id);
			//
			this.idPull["polygon_"+p2[q]] = null;
			delete this.idPull["polygon_"+p2[q]];
		}
	}
	p2 = null;
	
	// update corners
	if (this.conf.skin == "dhx_terrace" && arguments.length == 1) this._improveTerraceSkin();
	
};


// add item to storage
dhtmlXMenuObject.prototype._addItemIntoGlobalStrorage = function(itemId, itemParentId, itemText, itemType, disabled, img, imgDis) {
	var item = {
		id:	itemId,
		title:	itemText,
		imgen:	(img!=null?img:""),
		imgdis:	(imgDis!=null?imgDis:""),
		type:	itemType,
		state:	(disabled==true?"disabled":"enabled"),
		parent:	itemParentId,
		complex:false,
		hotkey:	"",
		tip:	""};
	this.itemPull[item.id] = item;
};

dhtmlXMenuObject.prototype.renderAsContextMenu = function() {
	this.conf.context = true;
	if (this.base._autoSkinUpdate == true) {
		this.base.className = this.base.className.replace("dhtmlxMenu_"+this.conf.skin+"_Middle","");
		this.base._autoSkinUpdate = false;
	}
	if (this.conf.ctx_baseid != null) { this.addContextZone(this.conf.ctx_baseid); }
};

dhtmlXMenuObject.prototype.addContextZone = function(zoneId) {
	if (zoneId == document.body) {
		zoneId = "document.body."+this.idPrefix;
		var zone = document.body;
	} else if (typeof(zoneId) == "string") {
		var zone = document.getElementById(zoneId);
	} else {
		var zone = zoneId;
	}
	var zoneExists = false;
	for (var a in this.conf.ctx_zones) { zoneExists = zoneExists || (a == zoneId) || (this.conf.ctx_zones[a] == zone); }
	if (zoneExists == true) return false;
	this.conf.ctx_zones[zoneId] = zone;
	var that = this;
	if (window.dhx4.isOpera) {
		this.operaContext = function(e){ that._doOnContextMenuOpera(e, that); }
		zone.addEventListener("mouseup", this.operaContext, false);
		//
	} else {
		if (zone.oncontextmenu != null && !zone._oldContextMenuHandler) zone._oldContextMenuHandler = zone.oncontextmenu;
		zone.oncontextmenu = function(e) {
			// autoclose any other opened context menues
			for (var q in dhtmlXMenuObject.prototype.liveInst) {
				if (q != that.conf.live_id) {
					if (dhtmlXMenuObject.prototype.liveInst[q].context) {
						dhtmlXMenuObject.prototype.liveInst[q]._hideContextMenu();
					}
				}
			}
			//
			e = e||event;
			e.cancelBubble = true;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			that._doOnContextBeforeCall(e, this);
			return false;
		}
	}
};
dhtmlXMenuObject.prototype._doOnContextMenuOpera = function(e, that) {
	// autoclose any other opened context menues
	for (var q in dhtmlXMenuObject.prototype.liveInst) {
		if (q != that.conf.live_id) {
			if (dhtmlXMenuObject.prototype.liveInst[q].context) {
				dhtmlXMenuObject.prototype.liveInst[q]._hideContextMenu();
			}
		}
	}
	//
	e.cancelBubble = true;
	if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
	if (e.button == 0 && e.ctrlKey == true) { that._doOnContextBeforeCall(e, this); }
	return false;
};

dhtmlXMenuObject.prototype.removeContextZone = function(zoneId) {
	if (!this.isContextZone(zoneId)) return false;
	if (zoneId == document.body) zoneId = "document.body."+this.idPrefix;
	var zone = this.conf.ctx_zones[zoneId];
	if (window.dhx4.isOpera) {
		zone.removeEventListener("mouseup", this.operaContext, false);
	} else {
		zone.oncontextmenu = (zone._oldContextMenuHandler!=null?zone._oldContextMenuHandler:null);
		zone._oldContextMenuHandler = null;
	}
	try {
		this.conf.ctx_zones[zoneId] = null;
		delete this.conf.ctx_zones[zoneId];
 	} catch(e){}
	return true;
};

dhtmlXMenuObject.prototype.isContextZone = function(zoneId) {
	if (zoneId == document.body && this.conf.ctx_zones["document.body."+this.idPrefix] != null) return true;
	var isZone = false;
	if (this.conf.ctx_zones[zoneId] != null) { if (this.conf.ctx_zones[zoneId] == document.getElementById(zoneId)) isZone = true; }
	return isZone;
};
dhtmlXMenuObject.prototype._isContextMenuVisible = function() {
	if (this.idPull["polygon_"+this.idPrefix+this.topId] == null) return false;
	return (this.idPull["polygon_"+this.idPrefix+this.topId].style.display == "");
};
dhtmlXMenuObject.prototype._showContextMenu = function(x, y, zoneId) {
	// hide any opened context menu/polygons
	this._clearAndHide();
	// open
	if (this.idPull["polygon_"+this.idPrefix+this.topId] == null) return false;
	window.clearTimeout(this.conf.tm_handler);
	this.idPull[this.idPrefix+this.topId] = new Array(x, y);
	this._showPolygon(this.idPrefix+this.topId, "bottom");
	this.callEvent("onContextMenu", [zoneId]);
};
dhtmlXMenuObject.prototype._hideContextMenu = function() {
	if (this.idPull["polygon_"+this.idPrefix+this.topId] == null) return false;
	this._clearAndHide();
	this._hidePolygon(this.idPrefix+this.topId);
};

dhtmlXMenuObject.prototype._doOnContextBeforeCall = function(e, cZone) {
	this.conf.ctx_zoneid = cZone.id;
	this._clearAndHide();
	this._hideContextMenu();
	
	// scroll settings
	if (window.dhx4.isChrome == true || window.dhx4.isEdge == true || window.dhx4.isOpera == true || window.dhx4.isIE11 == true) {
		var mx = window.dhx4.absLeft(e.target)+e.offsetX;
		var my = window.dhx4.absTop(e.target)+e.offsetY;
	} else if (window.dhx4.isIE6 == true || window.dhx4.isIE7 == true || window.dhx4.isIE == true) { // old IE or emulation
		var mx = window.dhx4.absLeft(e.srcElement)+e.x||0;
		var my = window.dhx4.absTop(e.srcElement)+e.y||0;
	} else { // the rest
		var p = (e.srcElement||e.target);
		var px = (window.dhx4.isIE||window.dhx4.isKHTML?e.offsetX:e.layerX);
		var py = (window.dhx4.isIE||window.dhx4.isKHTML?e.offsetY:e.layerY);
		var mx = window.dhx4.absLeft(p)+px;
		var my = window.dhx4.absTop(p)+py;
	}
	
	if (this.checkEvent("onBeforeContextMenu")) {
		if (this.callEvent("onBeforeContextMenu", [cZone.id,e])) {
			if (this.conf.ctx_autoshow) {
				this._showContextMenu(mx, my, cZone.id);
				this.callEvent("onAfterContextMenu", [cZone.id,e]);
			}
		}
	} else {
		if (this.conf.ctx_autoshow) {
			this._showContextMenu(mx, my, cZone.id);
			this.callEvent("onAfterContextMenu", [cZone.id]);
		}
	}
};

dhtmlXMenuObject.prototype.showContextMenu = function(x, y) {
	this._showContextMenu(x, y, false);
};

dhtmlXMenuObject.prototype.hideContextMenu = function() {
	this._hideContextMenu();
};

dhtmlXMenuObject.prototype.setAutoShowMode = function(mode) {
	this.conf.ctx_autoshow = (mode==true?true:false);
};

dhtmlXMenuObject.prototype.setAutoHideMode = function(mode) {
	this.conf.ctx_autohide = (mode==true?true:false);
};

dhtmlXMenuObject.prototype.setContextMenuHideAllMode = function(mode) {
	this.conf.ctx_hideall = (mode==true?true:false);
};

dhtmlXMenuObject.prototype.getContextMenuHideAllMode = function() {
	return this.conf.ctx_hideall;
};

dhtmlXMenuObject.prototype._improveTerraceSkin = function() {
	
	for (var a in this.itemPull) {
		
		if (this.itemPull[a].parent == this.idPrefix+this.topId && this.idPull[a] != null) { // this.idPull[a] will null for separator
			
			var bl = false;
			var br = false;
			
			// left side, first item, not sep
			if (this.idPull[a].parentNode.firstChild == this.idPull[a]) {
				bl = true;
			}
			
			// right side, last item, not sep
			if (this.idPull[a].parentNode.lastChild == this.idPull[a]) {
				br = true;
			}
			
			// check siblings
			for (var b in this.itemPull) {
				if (this.itemPull[b].type == "separator" && this.itemPull[b].parent == this.idPrefix+this.topId) {
					if (this.idPull[a].nextSibling == this.idPull["separator_"+b]) {
						br = true;
					}
					if (this.idPull[a].previousSibling == this.idPull["separator_"+b]) {
						bl = true;
					}
				}
			}
			
			this.idPull[a].style.borderLeftWidth = (bl?"1px":"0px");
			this.idPull[a].style.borderTopLeftRadius = this.idPull[a].style.borderBottomLeftRadius = (bl?"3px":"0px");
			
			this.idPull[a].style.borderTopRightRadius = this.idPull[a].style.borderBottomRightRadius = (br?"3px":"0px");
			
			this.idPull[a]._bl = bl;
			this.idPull[a]._br = br;
			
		}
	}
	
};

dhtmlXMenuObject.prototype._improveTerraceButton = function(id, state) {
	if (state) {
		this.idPull[id].style.borderBottomLeftRadius = (this.idPull[id]._bl ? "3px" : "0px");
		this.idPull[id].style.borderBottomRightRadius = (this.idPull[id]._br ? "3px" : "0px");
	} else {
		this.idPull[id].style.borderBottomLeftRadius = "0px";
		this.idPull[id].style.borderBottomRightRadius = "0px";
	}
};

if (typeof(window.dhtmlXCellObject) != "undefined") {
	
	dhtmlXCellObject.prototype._createNode_menu = function(obj, type, htmlString, append, node) {
		
		if (typeof(node) != "undefined") {
			obj = node;
		} else {
			obj = document.createElement("DIV");
			obj.className = "dhx_cell_menu_"+(this.conf.borders?"def":"no_borders");
			obj.appendChild(document.createElement("DIV"));
		}
		
		this.cell.insertBefore(obj, this.cell.childNodes[this.conf.idx.toolbar||this.conf.idx.cont]); // before toolbar or before cont, 0=hdr
		
		this.conf.ofs_nodes.t.menu = true;
		this._updateIdx();
		// adjust cont will performed after toolbar init
		
		return obj;
		
	};
	
	dhtmlXCellObject.prototype.attachMenu = function(conf) {
		
		if (this.dataNodes.menu) return; // return this.dataNodes.menu?
		
		this.callEvent("_onBeforeContentAttach", ["menu"]);
		
		if (typeof(conf) == "undefined") conf = {};
		if (typeof(conf.skin) == "undefined") conf.skin = this.conf.skin;
		conf.parent = this._attachObject("menu").firstChild;
		
		this.dataNodes.menu = new dhtmlXMenuObject(conf);
		this._adjustCont(this._idd);
		
		conf.parent = null;
		conf = null;
		
		this.callEvent("_onContentAttach", []);
		
		return this.dataNodes.menu;
		
	};
	
	dhtmlXCellObject.prototype.detachMenu = function() {
		
		if (this.dataNodes.menu == null) return;
		
		if (typeof(this.dataNodes.menu.unload) == "function") this.dataNodes.menu.unload();
		this.dataNodes.menu = null;
		delete this.dataNodes.menu;
		
		this._detachObject("menu");
		
	};
	
	dhtmlXCellObject.prototype.showMenu = function() {
		this._mtbShowHide("menu", "");
	};
	
	dhtmlXCellObject.prototype.hideMenu = function() {
		this._mtbShowHide("menu", "none");
	};
	
	dhtmlXCellObject.prototype.getAttachedMenu = function() {
		return this.dataNodes.menu;
	};
	
}


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

// enable/disable

dhtmlXMenuObject.prototype.setItemEnabled = function(id) {
	this._changeItemState(id, "enabled", this._getItemLevelType(id));
};
dhtmlXMenuObject.prototype.setItemDisabled = function(id) {
	this._changeItemState(id, "disabled", this._getItemLevelType(id));
};
dhtmlXMenuObject.prototype.isItemEnabled = function(id) {
	return (this.itemPull[this.idPrefix+id]!=null?(this.itemPull[this.idPrefix+id]["state"]=="enabled"):false);
};

// enable/disable sublevel item
dhtmlXMenuObject.prototype._changeItemState = function(id, newState, levelType) {
	var t = false;
	var j = this.idPrefix + id;
	if ((this.itemPull[j] != null) && (this.idPull[j] != null)) {
		if (this.itemPull[j]["state"] != newState) {
			this.itemPull[j]["state"] = newState;
			if (this.itemPull[j]["parent"] == this.idPrefix+this.topId && !this.conf.context) {
				this.idPull[j].className = "dhtmlxMenu_"+this.conf.skin+"_TopLevel_Item_"+(this.itemPull[j]["state"]=="enabled"?"Normal":"Disabled");
			} else {
				this.idPull[j].className = "sub_item"+(this.itemPull[j]["state"]=="enabled"?"":"_dis");
			}
			
			this._updateItemComplexState(this.idPrefix+id, this.itemPull[this.idPrefix+id]["complex"], false);
			this._updateItemImage(id, levelType);
			// if changeItemState attached to onClick event and changing applies to selected item all selection should be reparsed
			if ((this.idPrefix + this.conf.last_click == j) && (levelType != "TopLevel")) {
				this._redistribSubLevelSelection(j, this.itemPull[j]["parent"]);
			}
			if (levelType == "TopLevel" && !this.conf.context) { // rebuild style.left and show nested polygons
				// this._redistribTopLevelSelection(id, "parent");
			}
		}
	}
	return t;
};


// set-get text
dhtmlXMenuObject.prototype.getItemText = function(id) {
	return (this.itemPull[this.idPrefix+id]!=null?this.itemPull[this.idPrefix+id]["title"]:"");
};

dhtmlXMenuObject.prototype.setItemText = function(id, text) {
	id = this.idPrefix + id;
	if ((this.itemPull[id] != null) && (this.idPull[id] != null)) {
		this._clearAndHide();
		this.itemPull[id]["title"] = text;
		if (this.itemPull[id]["parent"] == this.idPrefix+this.topId && !this.conf.context) {
			// top level
			var tObj = null;
			for (var q=0; q<this.idPull[id].childNodes.length; q++) {
				try { if (this.idPull[id].childNodes[q].className == "top_level_text") tObj = this.idPull[id].childNodes[q]; } catch(e) {}
			}
			if (String(this.itemPull[id]["title"]).length == "" || this.itemPull[id]["title"] == null) {
				if (tObj != null) tObj.parentNode.removeChild(tObj);
			} else {
				if (!tObj) {
					tObj = document.createElement("DIV");
					tObj.className = "top_level_text";
					if (this.conf.rtl && this.idPull[id].childNodes.length > 0) this.idPull[id].insertBefore(tObj,this.idPull[id].childNodes[0]); else this.idPull[id].appendChild(tObj);
				}
				tObj.innerHTML = this.itemPull[id]["title"];
			}
		} else {
			// sub level
			var tObj = null;
			for (var q=0; q<this.idPull[id].childNodes[1].childNodes.length; q++) {
				if (String(this.idPull[id].childNodes[1].childNodes[q].className||"") == "sub_item_text") tObj = this.idPull[id].childNodes[1].childNodes[q];
			}
			if (String(this.itemPull[id]["title"]).length == "" || this.itemPull[id]["title"] == null) {
				if (tObj) {
					tObj.parentNode.removeChild(tObj);
					tObj = null;
					this.idPull[id].childNodes[1].innerHTML = "&nbsp;";
				}
			} else {
				if (!tObj) {
					tObj = document.createElement("DIV");
					tObj.className = "sub_item_text";
					this.idPull[id].childNodes[1].innerHTML = "";
					this.idPull[id].childNodes[1].appendChild(tObj);
				}
				tObj.innerHTML = this.itemPull[id]["title"];
			}
		}
	}
};

// load from html
dhtmlXMenuObject.prototype.loadFromHTML = function(objId, clearAfterAdd, onLoad) {
	
	var t = this.conf.tags.item;
	this.conf.tags.item = "div";
	
	var node = (typeof(objId)=="string"?document.getElementById(objId):objId);
	var items = this._xmlToJson(node, this.idPrefix+this.topId);
	this._initObj(items);
	
	this.conf.tags.item = t;
	
	if (clearAfterAdd) node.parentNode.removeChild(node);
	node = objOd = null;
	
	if (onload != null) {
		if (typeof(onLoad) == "function") {
			onLoad();
		} else if (typeof(window[onLoad]) == "function") {
			window[onLoad]();
		}
	}
};

// show/hide items
dhtmlXMenuObject.prototype.hideItem = function(id) {
	this._changeItemVisible(id, false);
};

dhtmlXMenuObject.prototype.showItem = function(id) {
	this._changeItemVisible(id, true);
};

dhtmlXMenuObject.prototype.isItemHidden = function(id) {
	var isHidden = null;
	if (this.idPull[this.idPrefix+id] != null) { isHidden = (this.idPull[this.idPrefix+id].style.display == "none"); }
	return isHidden;
};

dhtmlXMenuObject.prototype._changeItemVisible = function(id, visible) {
	var itemId = this.idPrefix+id;
	if (this.itemPull[itemId] == null) return;
	if (this.itemPull[itemId]["type"] == "separator") { itemId = "separator_"+itemId; }
	if (this.idPull[itemId] == null) return;
	this.idPull[itemId].style.display = (visible?"":"none");
	this._redefineComplexState(this.itemPull[this.idPrefix+id]["parent"]);
};

// userdata
dhtmlXMenuObject.prototype.setUserData = function(id, name, value) {
	this.userData[this.idPrefix+id+"_"+name] = value;
};

dhtmlXMenuObject.prototype.getUserData = function(id, name) {
	return (this.userData[this.idPrefix+id+"_"+name]!=null?this.userData[this.idPrefix+id+"_"+name]:null);
};

// open-mode (win/web)
dhtmlXMenuObject.prototype.setOpenMode = function(mode) {
	this.conf.mode = (mode=="win"?"win":"web");
};

// web-mode timeout
dhtmlXMenuObject.prototype.setWebModeTimeout = function(tm) {
	this.conf.tm_sec = (!isNaN(tm)?tm:400);
};

// icons
dhtmlXMenuObject.prototype.getItemImage = function(id) {
	var imgs = new Array(null, null);
	id = this.idPrefix+id;
	if (this.itemPull[id]["type"] == "item") {
		imgs[0] = this.itemPull[id]["imgen"];
		imgs[1] = this.itemPull[id]["imgdis"];
	}
	return imgs;
};

dhtmlXMenuObject.prototype.setItemImage = function(id, img, imgDis) {
	if (this.itemPull[this.idPrefix+id]["type"] != "item") return;
	this.itemPull[this.idPrefix+id]["imgen"] = img;
	this.itemPull[this.idPrefix+id]["imgdis"] = imgDis;
	this._updateItemImage(id, this._getItemLevelType(id));
};

dhtmlXMenuObject.prototype.clearItemImage = function(id) {
	this.setItemImage(id, "", "");
};

// visible area
dhtmlXMenuObject.prototype.setVisibleArea = function(x1, x2, y1, y2) {
	this.conf.v_enabled = true;
	this.conf.v.x1 = x1;
	this.conf.v.x2 = x2;
	this.conf.v.y1 = y1;
	this.conf.v.y2 = y2;
};

// tooltips
dhtmlXMenuObject.prototype.setTooltip = function(id, tip) {
	id = this.idPrefix+id;
	if (!(this.itemPull[id] != null && this.idPull[id] != null)) return;
	this.idPull[id].title = (tip.length > 0 ? tip : null);
	this.itemPull[id]["tip"] = tip;
};

dhtmlXMenuObject.prototype.getTooltip = function(id) {
	if (this.itemPull[this.idPrefix+id] == null) return null;
	return this.itemPull[this.idPrefix+id]["tip"];
};



dhtmlXMenuObject.prototype.setTopText = function(text) {
	if (this.conf.context) return;
	if (this._topText == null) {
		this._topText = document.createElement("DIV");
		this._topText.className = "dhtmlxMenu_TopLevel_Text_"+(this.conf.rtl?"left":(this.conf.align=="left"?"right":"left"));
		this.base.appendChild(this._topText);
	}
	this._topText.innerHTML = text;
};

dhtmlXMenuObject.prototype.setAlign = function(align) {
	if (this.conf.align == align) return;
	if (align == "left" || align == "right") {
		// if (this.setRTL) this.setRTL(false);
		this.conf.align = align;
		if (this.cont) this.cont.className = (this.conf.align=="right"?"align_right":"align_left");
		if (this._topText != null) this._topText.className = "dhtmlxMenu_TopLevel_Text_"+(this.conf.align=="left"?"right":"left");
	}
};

dhtmlXMenuObject.prototype.setHref = function(itemId, href, target) {
	if (this.itemPull[this.idPrefix+itemId] == null) return;
	this.itemPull[this.idPrefix+itemId]["href_link"] = href;
	if (target != null) this.itemPull[this.idPrefix+itemId]["href_target"] = target;
};

dhtmlXMenuObject.prototype.clearHref = function(itemId) {
	if (this.itemPull[this.idPrefix+itemId] == null) return;
	delete this.itemPull[this.idPrefix+itemId]["href_link"];
	delete this.itemPull[this.idPrefix+itemId]["href_target"];
};
/*
File [id="file"] -> Open [id="open"] -> Last Save [id="lastsave"]
getCircuit("lastsave") will return Array("file", "open", "lastsave");
*/

dhtmlXMenuObject.prototype.getCircuit = function(id) {
	var parents = new Array(id);
	while (this.getParentId(id) != this.topId) {
		id = this.getParentId(id);
		parents[parents.length] = id;
	}
	return parents.reverse();
};

// checkboxes
dhtmlXMenuObject.prototype._getCheckboxState = function(id) {
	if (this.itemPull[this.idPrefix+id] == null) return null;
	return this.itemPull[this.idPrefix+id]["checked"];
};

dhtmlXMenuObject.prototype._setCheckboxState = function(id, state) {
	if (this.itemPull[this.idPrefix+id] == null) return;
	this.itemPull[this.idPrefix+id]["checked"] = state;
};

dhtmlXMenuObject.prototype._updateCheckboxImage = function(id) {
	if (this.idPull[this.idPrefix+id] == null) return;
	this.itemPull[this.idPrefix+id]["imgen"] = "chbx_"+(this._getCheckboxState(id)?"1":"0");
	this.itemPull[this.idPrefix+id]["imgdis"] = this.itemPull[this.idPrefix+id]["imgen"];
	try { this.idPull[this.idPrefix+id].childNodes[(this.conf.rtl?2:0)].childNodes[0].className = "sub_icon "+this.itemPull[this.idPrefix+id]["imgen"]; } catch(e){}
};

dhtmlXMenuObject.prototype._checkboxOnClickHandler = function(id, type, casState) {
	if (type.charAt(1)=="d") return;
	if (this.itemPull[this.idPrefix+id] == null) return;
	var state = this._getCheckboxState(id);
	if (this.checkEvent("onCheckboxClick")) {
		if (this.callEvent("onCheckboxClick", [id, state, this.conf.ctx_zoneid, casState])) {
			this.setCheckboxState(id, !state);
		}
	} else {
		this.setCheckboxState(id, !state);
	}
	// call onClick if exists
	if (this.checkEvent("onClick")) this.callEvent("onClick", [id]);
};

dhtmlXMenuObject.prototype.setCheckboxState = function(id, state) {
	this._setCheckboxState(id, state);
	this._updateCheckboxImage(id);
};

dhtmlXMenuObject.prototype.getCheckboxState = function(id) {
	return this._getCheckboxState(id);
};

dhtmlXMenuObject.prototype.addCheckbox = function(mode, nextToId, pos, itemId, itemText, state, disabled) {
	// checks
	if (this.conf.context && nextToId == this.topId) {
		// adding checkbox as first element to context menu
		// do nothing
	} else {
		if (this.itemPull[this.idPrefix+nextToId] == null) return;
		if (mode == "child" && this.itemPull[this.idPrefix+nextToId]["type"] != "item") return;
	}
	//
	var img = "chbx_"+(state?"1":"0");
	var imgDis = img;
	//
	
	if (mode == "sibling") {
		
		var id = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
		var parentId = this.idPrefix+this.getParentId(nextToId);
		this._addItemIntoGlobalStrorage(id, parentId, itemText, "checkbox", disabled, img, imgDis);
		this.itemPull[id]["checked"] = state;
		this._renderSublevelItem(id, this.getItemPosition(nextToId));
	} else {
		
		var id = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
		var parentId = this.idPrefix+nextToId;
		this._addItemIntoGlobalStrorage(id, parentId, itemText, "checkbox", disabled, img, imgDis);
		this.itemPull[id]["checked"] = state;
		if (this.idPull["polygon_"+parentId] == null) { this._renderSublevelPolygon(parentId, parentId); }
		this._renderSublevelItem(id, pos-1);
		this._redefineComplexState(parentId);
	}
};


// hot-keys
dhtmlXMenuObject.prototype.setHotKey = function(id, hkey) {
	
	id = this.idPrefix+id;
	
	if (!(this.itemPull[id] != null && this.idPull[id] != null)) return;
	if (this.itemPull[id]["parent"] == this.idPrefix+this.topId && !this.conf.context) return;
	if (this.itemPull[id]["complex"]) return;
	var t = this.itemPull[id]["type"];
	if (!(t == "item" || t == "checkbox" || t == "radio")) return;
	
	// retrieve obj
	var hkObj = null;
	try { if (this.idPull[id].childNodes[this.conf.rtl?0:2].childNodes[0].className == "sub_item_hk") hkObj = this.idPull[id].childNodes[this.conf.rtl?0:2].childNodes[0]; } catch(e){}
	
	if (hkey.length == 0) {
		// remove if exists
		this.itemPull[id]["hotkey_backup"] = this.itemPull[id]["hotkey"];
		this.itemPull[id]["hotkey"] = "";
		if (hkObj != null) hkObj.parentNode.removeChild(hkObj);
		
	} else {
		
		// add if needed or change
		this.itemPull[id]["hotkey"] = hkey;
		this.itemPull[id]["hotkey_backup"] = null;
		//
		if (hkObj == null) {
			hkObj = document.createElement("DIV");
			hkObj.className = "sub_item_hk";
			var item = this.idPull[id].childNodes[this.conf.rtl?0:2];
			while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
			item.appendChild(hkObj);
		}
		hkObj.innerHTML = hkey;

	}
};

dhtmlXMenuObject.prototype.getHotKey = function(id) {
	if (this.itemPull[this.idPrefix+id] == null) return null;
	return this.itemPull[this.idPrefix+id]["hotkey"];
};


// overflow control
dhtmlXMenuObject.prototype._clearAllSelectedSubItemsInPolygon = function(polygon) {
	var subIds = this._getSubItemToDeselectByPolygon(polygon);
	// hide opened polygons and selected items
	for (var q=0; q<this.conf.opened_poly.length; q++) {
		if (this.conf.opened_poly[q] != polygon) this._hidePolygon(this.conf.opened_poly[q]);
	}
	for (var q=0; q<subIds.length; q++) {
		if (this.idPull[subIds[q]] != null && this.itemPull[subIds[q]]["state"] == "enabled") {
			this.idPull[subIds[q]].className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_Item_Normal";
		}
	}
};

// define normal/disabled arrows in polygon
dhtmlXMenuObject.prototype._checkArrowsState = function(id) {
	var polygon = this.idPull["polygon_"+id].childNodes[1];
	var arrowUp = this.idPull["arrowup_"+id];
	var arrowDown = this.idPull["arrowdown_"+id];
	if (polygon.scrollTop == 0) {
		arrowUp.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowUp_Disabled";
	} else {
		arrowUp.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowUp" + (arrowUp.over ? "_Over" : "");
	}
	if (polygon.scrollTop + polygon.offsetHeight < polygon.scrollHeight) {
		arrowDown.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowDown" + (arrowDown.over ? "_Over" : "");
	} else {
		arrowDown.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowDown_Disabled";
	}
	polygon = arrowUp = arrowDown = null;
};

// add up-limit-arrow
dhtmlXMenuObject.prototype._addUpArrow = function(id) {
	var that = this;
	var arrow = document.createElement("DIV");
	arrow.pId = this.idPrefix+id;
	arrow.id = "arrowup_"+this.idPrefix+id;
	arrow.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowUp";
	
	arrow.over = false;
	arrow.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	arrow.oncontextmenu = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	// actions
	arrow.onmouseover = function() {
		if (that.conf.mode == "web") { window.clearTimeout(that.conf.tm_handler); }
		that._clearAllSelectedSubItemsInPolygon(this.pId);
		if (this.className == "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowUp_Disabled") return;
		this.className = "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowUp_Over";
		this.over = true;
		that._canScrollUp = true;
		that._doScrollUp(this.pId, true);
	}
	arrow.onmouseout = function() {
		if (that.conf.mode == "web") {
			window.clearTimeout(that.conf.tm_handler);
			that.conf.tm_handler = window.setTimeout(function(){that._clearAndHide();}, that.conf.tm_sec, "JavaScript");
		}
		this.over = false;
		that._canScrollUp = false;
		if (this.className == "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowUp_Disabled") return;
		this.className = "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowUp";
		window.clearTimeout(that.conf.of_utm);
	}
	arrow.onclick = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		e.cancelBubble = true;
		return false;
	}
	
	var polygon = this.idPull["polygon_"+this.idPrefix+id];
	polygon.childNodes[0].appendChild(arrow);
	
	this.idPull[arrow.id] = arrow;
	polygon = arrow = null;
};

dhtmlXMenuObject.prototype._addDownArrow = function(id) {
	
	var that = this;
	var arrow = document.createElement("DIV");
	arrow.pId = this.idPrefix+id;
	arrow.id = "arrowdown_"+this.idPrefix+id;
	arrow.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowDown";
	
	arrow.over = false;
	arrow.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	arrow.oncontextmenu = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	
	// actions
	arrow.onmouseover = function() {
		if (that.conf.mode == "web") { window.clearTimeout(that.conf.tm_handler); }
		that._clearAllSelectedSubItemsInPolygon(this.pId);
		if (this.className == "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowDown_Disabled") return;
		this.className = "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowDown_Over";
		this.over = true;
		that._canScrollDown = true;
		that._doScrollDown(this.pId, true);
	}
	arrow.onmouseout = function() {
		if (that.conf.mode == "web") {
			window.clearTimeout(that.conf.tm_handler);
			that.conf.tm_handler = window.setTimeout(function(){that._clearAndHide();}, that.conf.tm_sec, "JavaScript");
		}
		this.over = false;
		that._canScrollDown = false;
		if (this.className == "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowDown_Disabled") return;
		this.className = "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowDown";
		window.clearTimeout(that.conf.of_dtm);
	}
	arrow.onclick = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		e.cancelBubble = true;
		return false;
	}
	
	var polygon = this.idPull["polygon_"+this.idPrefix+id];
	polygon.childNodes[2].appendChild(arrow);
	
	this.idPull[arrow.id] = arrow;
	polygon = arrow = null;
};

dhtmlXMenuObject.prototype._removeUpArrow = function(id) {
	var fullId = "arrowup_"+this.idPrefix+id;
	this._removeArrow(fullId);
};

dhtmlXMenuObject.prototype._removeDownArrow = function(id) {
	var fullId = "arrowdown_"+this.idPrefix+id;
	this._removeArrow(fullId);
};

dhtmlXMenuObject.prototype._removeArrow = function(fullId) {
	var arrow = this.idPull[fullId];
	arrow.onselectstart = null;
	arrow.oncontextmenu = null;
	arrow.onmouseover = null;
	arrow.onmouseout = null;
	arrow.onclick = null;
	if (arrow.parentNode) arrow.parentNode.removeChild(arrow);
	arrow = null;
	this.idPull[fullId] = null;
	try { delete this.idPull[fullId]; } catch(e) {}
};

dhtmlXMenuObject.prototype._isArrowExists = function(id) {
	if (this.idPull["arrowup_"+id] != null && this.idPull["arrowdown_"+id] != null) return true;
	return false;
};

// scroll down
dhtmlXMenuObject.prototype._doScrollUp = function(id, checkArrows) {
	var polygon = this.idPull["polygon_"+id].childNodes[1];
	if (this._canScrollUp && polygon.scrollTop > 0) {
		var theEnd = false;
		var nextScrollTop = polygon.scrollTop - this.conf.of_ustep;
		if (nextScrollTop < 0) {
			theEnd = true;
			nextScrollTop = 0;
		}
		polygon.scrollTop = nextScrollTop;
		if (!theEnd) {
			var that = this;
			this.conf.of_utm = window.setTimeout(function() {
				that._doScrollUp(id, false);
				that = null;
			}, this.conf.of_utime);
		} else {
			checkArrows = true;
		}
	} else {
		this._canScrollUp = false;
		this._checkArrowsState(id);
	}
	if (checkArrows) {
		this._checkArrowsState(id);
	}
};

dhtmlXMenuObject.prototype._doScrollDown = function(id, checkArrows) {
	var polygon = this.idPull["polygon_"+id].childNodes[1];
	if (this._canScrollDown && polygon.scrollTop + polygon.offsetHeight <= polygon.scrollHeight) {
		var theEnd = false;
		var nextScrollTop = polygon.scrollTop + this.conf.of_dstep;
		if (nextScrollTop + polygon.offsetHeight >= polygon.scrollHeight) {
			theEnd = true;
			nextScrollTop = polygon.scrollHeight - polygon.offsetHeight;
		}
		polygon.scrollTop = nextScrollTop;
		if (!theEnd) {
			var that = this;
			this.conf.of_dtm = window.setTimeout(function() {
				that._doScrollDown(id, false);
				that = null;
			}, this.conf.of_dtime);
		} else {
			checkArrows = true;
		}
	} else {
		this._canScrollDown = false;
		this._checkArrowsState(id);
	}
	if (checkArrows) {
		this._checkArrowsState(id);
	}
};

dhtmlXMenuObject.prototype._countPolygonItems = function(id) {
	var count = 0;
	for (var a in this.itemPull) {
		var par = this.itemPull[a]["parent"];
		var tp = this.itemPull[a]["type"];
		if (par == this.idPrefix+id && (tp == "item" || tp == "radio" || tp == "checkbox")) { count++; }
	}
	return count;
};

dhtmlXMenuObject.prototype.setOverflowHeight = function(itemsNum) {
	
	// set auto overflow mode
	if (itemsNum === "auto") {
		this.conf.overflow_limit = 0;
		this.conf.auto_overflow = true;
		return;
	}
	
	// no existing limitation, now new limitation
	if (this.conf.overflow_limit == 0 && itemsNum <= 0) return;
	
	// hide menu to prevent visible changes
	this._clearAndHide();
	
	// redefine existing limitation, arrows will added automatically with showPlygon
	if (this.conf.overflow_limit >= 0 && itemsNum > 0) {
		this.conf.overflow_limit = itemsNum;
		return;
	}
	
	// remove existing limitation
	if (this.conf.overflow_limit > 0 && itemsNum <= 0) {
		for (var a in this.itemPull) {
			if (this._isArrowExists(a)) {
				var b = String(a).replace(this.idPrefix, "");
				this._removeUpArrow(b);
				this._removeDownArrow(b);
				// remove polygon's height
				this.idPull["polygon_"+a].childNodes[1].style.height = "";
			}
		}
		this.conf.overflow_limit = 0;
		return;
	}
};


// radiobuttons
dhtmlXMenuObject.prototype._getRadioImgObj = function(id) {
	try { var imgObj = this.idPull[this.idPrefix+id].childNodes[(this.conf.rtl?2:0)].childNodes[0] } catch(e) { var imgObj = null; }
	return imgObj;
};

dhtmlXMenuObject.prototype._setRadioState = function(id, state) {
	// if (this.itemPull[this.idPrefix+id]["state"] != "enabled") return;
	var imgObj = this._getRadioImgObj(id);
	if (imgObj != null) {
		// fix, added in 0.4
		var rObj = this.itemPull[this.idPrefix+id];
		rObj["checked"] = state;
		rObj["imgen"] = "rdbt_"+(rObj["checked"]?"1":"0");
		rObj["imgdis"] = rObj["imgen"];
		imgObj.className = "sub_icon "+rObj["imgen"];
	}
};

dhtmlXMenuObject.prototype._radioOnClickHandler = function(id, type, casState) {
	if (type.charAt(1)=="d" || this.itemPull[this.idPrefix+id]["group"]==null) return;
	// deselect all from the same group
	var group = this.itemPull[this.idPrefix+id]["group"];
	if (this.checkEvent("onRadioClick")) {
		if (this.callEvent("onRadioClick", [group, this.getRadioChecked(group), id, this.conf.ctx_zoneid, casState])) {
			this.setRadioChecked(group, id);
		}
	} else {
		this.setRadioChecked(group, id);
	}
	// call onClick if exists
	if (this.checkEvent("onClick")) this.callEvent("onClick", [id]);
};

dhtmlXMenuObject.prototype.getRadioChecked = function(group) {
	var id = null;
	for (var q=0; q<this.radio[group].length; q++) {
		var itemId = this.radio[group][q].replace(this.idPrefix, "");
		var imgObj = this._getRadioImgObj(itemId);
		if (imgObj != null) {
			var checked = (imgObj.className).match(/rdbt_1$/gi);
			if (checked != null) id = itemId;
		}
	}
	return id;
};

dhtmlXMenuObject.prototype.setRadioChecked = function(group, id) {
	if (this.radio[group] == null) return;
	for (var q=0; q<this.radio[group].length; q++) {
		var itemId = this.radio[group][q].replace(this.idPrefix, "");
		this._setRadioState(itemId, (itemId==id));
	}
}

dhtmlXMenuObject.prototype.addRadioButton = function(mode, nextToId, pos, itemId, itemText, group, state, disabled) {
	// radiobutton
	if (this.conf.context && nextToId == this.topId) {
		// adding radiobutton as first element to context menu
		// do nothing
	} else {
		if (this.itemPull[this.idPrefix+nextToId] == null) return;
		if (mode == "child" && this.itemPull[this.idPrefix+nextToId]["type"] != "item") return;
	}
	
	var id = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
	var img = "rdbt_"+(state?"1":"0");
	var imgDis = img;
	//
	if (mode == "sibling") {
		var parentId = this.idPrefix+this.getParentId(nextToId);
		this._addItemIntoGlobalStrorage(id, parentId, itemText, "radio", disabled, img, imgDis);
		this._renderSublevelItem(id, this.getItemPosition(nextToId));
	} else {
		var parentId = this.idPrefix+nextToId;
		this._addItemIntoGlobalStrorage(id, parentId, itemText, "radio", disabled, img, imgDis);
		if (this.idPull["polygon_"+parentId] == null) { this._renderSublevelPolygon(parentId, parentId); }
		this._renderSublevelItem(id, pos-1);
		this._redefineComplexState(parentId);
	}
	//
	var gr = (group!=null?group:this._genStr(24));
	this.itemPull[id]["group"] = gr;
	//
	if (this.radio[gr]==null) { this.radio[gr] = new Array(); }
	this.radio[gr][this.radio[gr].length] = id;
	//
	if (state == true) this.setRadioChecked(gr, String(id).replace(this.idPrefix, ""));
};


// serialize
dhtmlXMenuObject.prototype.serialize = function() {
	var xml = "<menu>"+this._readLevel(this.idPrefix+this.topId)+"</menu>";
	return xml;
};

dhtmlXMenuObject.prototype._readLevel = function(parentId) {
	var xml = "";
	for (var a in this.itemPull) {
		if (this.itemPull[a]["parent"] == parentId) {
			var imgEn = "";
			var imgDis = "";
			var hotKey = "";
			var itemId = String(this.itemPull[a]["id"]).replace(this.idPrefix,"");
			var itemType = "";
			var itemText = (this.itemPull[a]["title"]!=""?' text="'+this.itemPull[a]["title"]+'"':"");
			var itemState = "";
			if (this.itemPull[a]["type"] == "item") {
				if (this.itemPull[a]["imgen"] != "") imgEn = ' img="'+this.itemPull[a]["imgen"]+'"';
				if (this.itemPull[a]["imgdis"] != "") imgDis = ' imgdis="'+this.itemPull[a]["imgdis"]+'"';
				if (this.itemPull[a]["hotkey"] != "") hotKey = '<hotkey>'+this.itemPull[a]["hotkey"]+'</hotkey>';
			}
			if (this.itemPull[a]["type"] == "separator") {
				itemType = ' type="separator"';
			} else {
				if (this.itemPull[a]["state"] == "disabled") itemState = ' enabled="false"';
			}
			if (this.itemPull[a]["type"] == "checkbox") {
				itemType = ' type="checkbox"'+(this.itemPull[a]["checked"]?' checked="true"':"");
			}
			if (this.itemPull[a]["type"] == "radio") {
				itemType = ' type="radio" group="'+this.itemPull[a]["group"]+'" '+(this.itemPull[a]["checked"]?' checked="true"':"");
			}
			xml += "<item id='"+itemId+"'"+itemText+itemType+imgEn+imgDis+itemState+">";
			xml += hotKey;
			if (this.itemPull[a]["complex"]) xml += this._readLevel(a);
			xml += "</item>";
		}
	}
	return xml;
};


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

// effects: opacity, slide
dhtmlXMenuObject.prototype.enableEffect = function(name, maxOpacity, effectSpeed) {
	
	this._menuEffect = (name=="opacity"||name=="slide"||name=="slide+"?name:false);
	
	this._pOpStyleIE = (navigator.userAgent.search(/MSIE\s[678]\.0/gi)>=0); // opacity was added in IE9
	
	for (var a in this.idPull) {
		if (a.search(/polygon/) === 0) {
			this._pOpacityApply(a,(this._pOpStyleIE?100:1));
			this.idPull[a].style.height = "";
		}
		
	}
	
	// opacity max value
	this._pOpMax = (typeof(maxOpacity)=="undefined"?100:maxOpacity)/(this._pOpStyleIE?1:100);
	
	// opacity css styles
	this._pOpStyleName = (this._pOpStyleIE?"filter":"opacity");
	this._pOpStyleValue = (this._pOpStyleIE?"progid:DXImageTransform.Microsoft.Alpha(Opacity=#)":"#");
	
	
	// count of steps to open full polygon
	this._pSlSteps = (this._pOpStyleIE?10:20);
	
	// timeout to open polygon
	this._pSlTMTimeMax = effectSpeed||50;
	
};

// extended show
dhtmlXMenuObject.prototype._showPolygonEffect = function(pId) {
	this._pShowHide(pId, true);
};

// extended hide
dhtmlXMenuObject.prototype._hidePolygonEffect = function(pId) {
	this._pShowHide(pId, false);
};

// apply opacity css
dhtmlXMenuObject.prototype._pOpacityApply = function(pId, val) {
	this.idPull[pId].style[this._pOpStyleName] = String(this._pOpStyleValue).replace("#", val||this.idPull[pId]._op);
};

dhtmlXMenuObject.prototype._pShowHide = function(pId, mode) {
	
	if (!this.idPull) return;
	
	// check if mode in progress
	if (this.idPull[pId]._tmShow != null) {
		if ((this.idPull[pId]._step_h > 0 && mode == true) || (this.idPull[pId]._step_h < 0 && mode == false)) return;
		window.clearTimeout(this.idPull[pId]._tmShow);
		this.idPull[pId]._tmShow = null;
		this.idPull[pId]._max_h = null;
	}
	
	if (mode == false && (this.idPull[pId].style.visibility == "hidden" || this.idPull[pId].style.display == "none")) return;
	
	if (mode == true && this.idPull[pId].style.display == "none") {
		this.idPull[pId].style.visibility = "hidden";
		this.idPull[pId].style.display = "";
	}
	
	// init values or show-hide revert
	if (this.idPull[pId]._max_h == null) {
		
		this.idPull[pId]._max_h = parseInt(this.idPull[pId].offsetHeight);
		this.idPull[pId]._h = (mode==true?0:this.idPull[pId]._max_h);
		this.idPull[pId]._step_h = Math.round(this.idPull[pId]._max_h/this._pSlSteps)*(mode==true?1:-1);
		if (this.idPull[pId]._step_h == 0) return;
		this.idPull[pId]._step_tm = Math.round(this._pSlTMTimeMax/this._pSlSteps);
		
		if (this._menuEffect == "slide+" || this._menuEffect == "opacity") {
			this.idPull[pId].op_tm = this.idPull[pId]._step_tm;
			this.idPull[pId].op_step = (this._pOpMax/this._pSlSteps)*(mode==true?1:-1);
			if (this._pOpStyleIE) this.idPull[pId].op_step = Math.round(this.idPull[pId].op_step);
			this.idPull[pId]._op = (mode==true?0:this._pOpMax);
			this._pOpacityApply(pId);
		} else {
			this.idPull[pId]._op = (this._pOpStyleIE?100:1);
			this._pOpacityApply(pId);
		}
		
		// show first time
		if (this._menuEffect.search(/slide/) === 0) this.idPull[pId].style.height = "0px";
		this.idPull[pId].style.visibility = "visible";
		
	}
	
	// run cycle
	this._pEffectSet(pId, this.idPull[pId]._h+this.idPull[pId]._step_h);
	
};

dhtmlXMenuObject.prototype._pEffectSet = function(pId, t) {
	
	if (!this.idPull) return;
	
	if (this.idPull[pId]._tmShow) window.clearTimeout(this.idPull[pId]._tmShow);
	
	// check and apply next step
	this.idPull[pId]._h = Math.max(0,Math.min(t,this.idPull[pId]._max_h));
	if (this._menuEffect.search(/slide/) === 0) this.idPull[pId].style.height = this.idPull[pId]._h+"px";
	
	t += this.idPull[pId]._step_h;
	
	if (this._menuEffect == "slide+" || this._menuEffect == "opacity") {
		this.idPull[pId]._op = Math.max(0,Math.min(this._pOpMax,this.idPull[pId]._op+this.idPull[pId].op_step));
		this._pOpacityApply(pId);
	}
	
	if ((this.idPull[pId]._step_h > 0 && t <= this.idPull[pId]._max_h) || (this.idPull[pId]._step_h < 0 && t >= 0)) {
		// continue
		var k = this;
		this.idPull[pId]._tmShow = window.setTimeout(function(){k._pEffectSet(pId,t);}, this.idPull[pId]._step_tm);
	} else {
		
		// clear height
		if (this._menuEffect.search(/slide/) === 0) this.idPull[pId].style.height = "";
		
		// hide completed
		if (this.idPull[pId]._step_h < 0) this.idPull[pId].style.visibility = "hidden";
		
		if (this._menuEffect == "slide+" || this._menuEffect == "opacity") {
			this.idPull[pId]._op = (this.idPull[pId]._step_h<0?(this._pOpStyleIE?100:1):this._pOpMax);
			this._pOpacityApply(pId);
		}
		
		// clear values
		this.idPull[pId]._tmShow = null;
		this.idPull[pId]._h = null;
		this.idPull[pId]._max_h = null;
		///this.idPull[pId]._step_h = null;
		this.idPull[pId]._step_tm = null;
	}
	
};



/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXRibbon(struct) {
	
	var that = this, _skin, cont;
	
	this.conf = {
		type: "ribbon",
		icons_path: (struct && struct.icons_path)?struct.icons_path:"",
		icons_css: (struct && struct.iconsset == "awesome"),
		arrows_mode: (struct && struct.arrows_mode)?struct.arrows_mode:null,
		skin: "dhx_skyblue"
	};
	
	this._eventHandlers = {};
	this._base = null;
	this._items = {};
	this._tabbar = null;
	this.childIds = [];
	
	if (typeof(struct) == "string") {
		cont = struct;
		
	} else if (struct && struct.tagName) {
		cont = struct;
		
	} else if (struct && struct.parent) {
		if (struct.parent.tagName || typeof(struct.parent) == "string") {
			cont = struct.parent;
		}
	}
	
	/***   ***/
	this._doOnHighlight0 = function(e) {
		e = e || event;
		var target = e.target || e.srcElement;
		var el = that._findItemByNode(target);
		var item = that._items[el._dhx_ribbonId];
		
		if (item.conf.disable) {
			return;
		}
		
		if (that.items[item.type] && typeof(that.items[item.type].mouseover) == "function") {
			if (that.items[item.type].mouseover(item, that, e) != true) {
				return false;
			}
		}
		
		if (!/dhxrb_highlight0/.test(el.className)) {
			el.className += " dhxrb_highlight0";
		}
	};
	
	this._doOffHighlight0 = function(e) {
		e = e || event;
		var target = e.target || e.srcElement;
		var el = that._findItemByNode(target);
		var item = that._items[el._dhx_ribbonId];
		
		if (item.conf.disable) {
			return;
		}
		
		if (that.items[item.type] && typeof(that.items[item.type].mouseout) == "function") {
			if  (that.items[item.type].mouseout(item, that, e) != true) {
				return false;
			}
		}
		
		if (/dhxrb_highlight1/.test(el.className)) {
			el.className = el.className.replace(/\s?dhxrb_highlight1/, "");
		}
		
		if (/dhxrb_highlight0/.test(el.className)) {
			el.className = el.className.replace(/\s?dhxrb_highlight0/, "");
		}
		
	};
	
	this._doOnHighlight1 = function (e) {
		e = e || event;
		var target = e.target || e.srcElement;
		var el = that._findItemByNode(target);
		var item = that._items[el._dhx_ribbonId];
		
		if (item.conf.disable) {
			return;
		}
		
		that.callEvent("_showPopup",[item.id]);
		
		if (that.items[item.type] && typeof(that.items[item.type].mousedown) == "function") {
			if (that.items[item.type].mousedown(item, that, e) != true) {
				return false;
			}
		}
			
		if (!/dhxrb_highlight1/.test(el.className)) {
			el.className += " dhxrb_highlight1";
		}
	};
	
	this._doOffHighlight1 = function (e) {
		e = e || event;
		var target = e.target || e.srcElement;
		var el = that._findItemByNode(target);
		var item = that._items[el._dhx_ribbonId];
		
		if (item.conf.disable) {
			return;
		}
		
		if (that.items[item.type] && typeof(that.items[item.type].mouseup) == "function") {
			if (that.items[item.type].mouseup(item, that, e) != true) {
				return false;
			}
		}
		
		if (/dhxrb_highlight1/.test(el.className)) {
			el.className = el.className.replace(/\s?dhxrb_highlight1/, "");
		}
	};
	
	this._doOnClick = function(e) {
		e = e || event;
		var target = e.target || e.srcElement;
		var el = that._findItemByNode(target);
		var item = that._items[el._dhx_ribbonId];
		
		if (item.conf.disable) {
			return;
		}
		
		if (that.items[item.type] && typeof(that.items[item.type].click) == "function") {
			that.items[item.type].click(item, that, e);
		}
	};
	
	this._doOnFocus = function(e) {
		e = e || event;
		var target = e.target || e.srcElement;
		var el = that._findItemByNode(target);
		var item = that._items[el._dhx_ribbonId];
		
		if (item.conf.disable) {
			return;
		}
		
		that.callEvent("_showPopup",[item.id]);
		
		if (that.items[item.type] && typeof(that.items[item.type].focus) == "function") {
			that.items[item.type].focus(item, that, e);
		}
	};
	
	this._doOnBlur = function(e) {
		e = e || event;
		var target = e.target || e.srcElement;
		var el = that._findItemByNode(target);
		var item = that._items[el._dhx_ribbonId];
		
		if (item.conf.disable) {
			return;
		}
		
		if (that.items[item.type] && typeof(that.items[item.type].blur) == "function") {
			that.items[item.type].blur(item, that, e);
		}
	};
	
	this._doOnChange = function(e) {
		e = e || event;
		var target = e.target || e.srcElement;
		var el = that._findItemByNode(target);
		var item = that._items[el._dhx_ribbonId];
		
		if (item.conf.disable) {
			return;
		}
		
		if (that.items[item.type] && typeof(that.items[item.type].change) == "function") {
			that.items[item.type].change(item, that, e);
		}
	};
	
	this._doOnKeydown = function(e) {
		e = e || event;
		var target = e.target || e.srcElement;
		var el = that._findItemByNode(target);
		var item = that._items[el._dhx_ribbonId];
		
		if (item.conf.disable) {
			return;
		}
		
		if (that.items[item.type] && typeof(that.items[item.type].keydown) == "function") {
			that.items[item.type].keydown(item, that, e);
		}
	};
	/***   ***/
	this._tabCustomApi = {
		enable: function(actvId, isCall) {
			/* @var this  dhtmlXCellObject */
			var item = null;
			
			isCall = isCall || false;
			if (isCall != true) {
				item = that._items[this._idd];
				for (var q=0; q<item.childIds.length; q++) {
					that.enable(item.childIds[q]);
				}
			}
			
			return that._tabOriginalApi.enable.apply(this,[actvId]);
		},
		
		disable: function(actvId, isCall) {
			/* @var this  dhtmlXCellObject */
			var item = null;
			
			if (isCall != false) {
				item = that._items[this._idd];
				for (var q=0; q<item.childIds.length; q++) {
					that.disable(item.childIds[q]);
				}
			}
			
			return that._tabOriginalApi.disable.apply(this,[actvId]);
		},
		
		close: function(actvId) {
			/* @var this  dhtmlXCellObject */
			var item = that._items[this._idd];
			
			that._removeTab(item);
			
			that._tabOriginalApi.close.apply(this,[actvId]);
			
			for (var key in that._tabOriginalApi) this[key] = null;
			
		}
	};
	/***  ***/
	this._attachEventTabbar  = function() {
		this._tabbar.attachEvent("onSelect",function() {
			return that.callEvent("onSelect",arguments);
		});
		
		this._tabbar.attachEvent("onTabClick",function() {
			return that.callEvent("onTabClick",arguments);
		});
		
		this._tabbar.attachEvent("onTabClose",function() {
			return that.callEvent("onTabClose",arguments);
		});
	};
	
	if (typeof(cont) == "string") {
		this._base = document.getElementById(cont);
	} else if (cont && cont.tagName) {
		this._base = cont;
	} else {
		this._base = document.createElement('div');
		this._base._dhx_remove = true;
		if (document.body.firstChild) {
			document.body.insertBefore(this._base,document.body.firstChild);
		} else {
			document.body.appendChild(this._base);
		}
	}
	
	_skin = dhx4.skin || (typeof(dhtmlx)!="undefined"?dhtmlx.skin:null) || dhx4.skinDetect("dhtmlxribbon") || "material";
	
	if (typeof(struct) == "object" && struct.skin) {
		_skin = struct.skin;
	}
	
	this.setSkin(_skin);
	
	dhx4._eventable(this);
	dhx4._enableDataLoading(this, "_renderData", "_xmlToJson", "ribbon", {struct:true});
	
	this.attachEvent("_onHeightChanged", function() {
		this.conf.inited = true;
	});
	
	this._base.className += " dhxrb_without_tabbar";
	this._base.innerHTML = "<div class='dhxrb_background_area'></div>";
	
	if (struct != null) {
		if (struct.json) {
			this.loadStruct(struct.json, struct.onload);
		} else if (struct.xml) {
			this.loadStruct(struct.xml, struct.onload);
		} else {
			this._renderData(struct);
		}
	}
	
	this.unload = function() {
		var chs = [];
		
		for (var q=0; q<this.childIds.length; q++) {
			chs.push(this.childIds[q]);
		}
		
		dhx4._enableDataLoading(this, null, null, null, "clear");
		dhx4._eventable(this, "clear");
		
		for (var q=0; q<chs.length; q++) {
			if (this._items[chs[q]].type == "tab") {
				this.tabs(chs[q]).close(false);
			} else {
				this.removeItem(chs[q]);
		    }
		}
		
		if (this._tabbar) {
			this._tabbar.unload();
			this._tabbar = null;
		}
		
		this._base.innerHTML = "";
		
		if (this._base._dhx_remove) {
			this._base.parentNode.removeChild(this._base);
		} else {
			this._base.className = this._base.className.replace(/\s?(dhtmlx|dhxrb)(\S*)/ig,"");
		}
		
		for (var a in this) {
			this[a] = null;
		}
		
		that = null;
	};
}

dhtmlXRibbon.prototype.setSizes = function() {
	if (this._tabbar != null && typeof(this.setSizes) == "function") {
		this._tabbar.setSizes();
	}
};

dhtmlXRibbon.prototype._renderData = function(data) {
	var cont = this._base.firstChild;
	
	if (data != null) {
		this.conf.icons_path = data.icons_path || this.conf.icons_path;
		this.conf.icons_css = (data.iconset=="awesome");
		
		if (data.tabs instanceof Array) {
			this._base.className = this._base.className.replace(/\s?dhxrb_without_tabbar/i, "");
			cont.className = "dhxrb_with_tabbar";
			this._tabbar = new dhtmlXTabBar(cont);
			this._attachEventTabbar();
			this._tabbar.setSkin(this.conf.skin);
			if (this.conf.arrows_mode != null) this._tabbar.setArrowsMode(this.conf.arrows_mode);
			
			this.childIds = this._appendTabs(data.tabs);
		} else if (data.items instanceof Array) {
			if (!/\s?dhxrb_without_tabbar/i.test(this._base.className)) {
				this._base.className += " dhxrb_without_tabbar";
			}
			
			if (/\s?dhxrb_background_area/i.test(cont.className)) {
				cont.className = "dhxrb_background_area";
			}
			cont.innerHTML = "<div class='dhxrb_g_area'></div>";
			this.childIds = this._appendBlocks(data.items,cont.firstChild);
		}
		this.callEvent("_onHeightChanged",[]);
	}
};

dhtmlXRibbon.prototype._xmlToJson = function(xml) {
	var root = xml.lastChild || null,
		answer = {}, list = [];
	
	if (root && root.tagName == "ribbon") {
		list = this._convertXmlNodeListIntoObject(root.childNodes);
	}
	
	if (list[0] && list[0].type && list[0].type.toLowerCase() == 'block') {
		answer.items = list;
	} else {
		answer.tabs = list;
	}
	
	return answer;
};

dhtmlXRibbon.prototype._convertXmlNodeListIntoObject = function(nodeList) {
	var i, l, answer = [], item;
	
	l = nodeList.length;
	for (i=0; i<l; i++) {
		item = this._covertXmlNodeToObject(nodeList[i]);
		if (item) answer.push(item);
	}
	
	return answer;
};

dhtmlXRibbon.prototype._covertXmlNodeToObject = function(node) {
	if (!node || !node.tagName || !(node.tagName.toLowerCase() == "item" || node.tagName.toLowerCase() == "tab")) {
		return null;
	}
	
	var i, l, attrs = node.attributes, answer={};
	l = attrs.length;
	
	for (i=0; i<l; i++) {
		switch (attrs[i].name) {
			case "isbig":
				answer["isbig"] = dhx4.s2b(attrs[i].value);
				break;
			case "state":
				answer["state"] = dhx4.s2b(attrs[i].value);
				break;
			default:
				answer[attrs[i].name] = attrs[i].value;
		}
	}
	
	if (node.childNodes.length) {
		if (node.getAttribute('type') == "buttonCombo" || node.getAttribute('type') == "buttonSelect") {
			answer.data = node;
		} else if (node.tagName.toLowerCase() == "tab") {
			answer.items = this._convertXmlNodeListIntoObject(node.childNodes);
		} else {
			answer.list = this._convertXmlNodeListIntoObject(node.childNodes);
		}
	}
	
	return answer;
};

dhtmlXRibbon.prototype._appendTabs = function(data) {
	var i,l,tab, answer = [];
	l = data.length;
	
	for (i=0; i<l; i++) {
		tab = this._addTab(data[i]);
		
		if (data[i].items instanceof Array) {
			tab.childIds = this._appendBlocks(data[i].items,tab.base,tab);
		}
		
		answer.push(tab.id);
	}
	
	return answer;
};

dhtmlXRibbon.prototype._addTab = function(data) {
	var key, tabCall;
	var tab = {
		conf: {
			active: false,
			text: "",
			width: null,
			position: null,
			disable: false
		},
		base: document.createElement('div'),
		type: "tab",
		childIds: []
	};
	
	for (key in data) {
		if (key == "items") continue;
		tab.conf[key] = data[key];
	}
	
	if (!data.id) {
		tab.id = dhx4.newId();
	} else {
		tab.id = data.id;
	}
	while (this._items[tab.id]) tab.id = dhx4.newId();
	
	this._tabbar.addTab(tab.id, tab.conf.text, tab.conf.width, tab.conf.position, tab.conf.active);
	
	tab.base.className = "dhxrb_g_area";
	tab.base._dhx_ribbonId = tab.id;
	
	this.tabs(tab.id).attachObject(tab.base);
	
	this._changeApiForTab(this.tabs(tab.id));
	
	this._items[tab.id] = tab;
	
	return tab;
};

dhtmlXRibbon.prototype._changeApiForTab = function(tab) {
	var key;
	for (key in this._tabOriginalApi) {
		this._tabOriginalApi[key] = this._tabOriginalApi[key] || tab[key];
		tab[key] = this._tabCustomApi[key];
	}
};

dhtmlXRibbon.prototype._tabOriginalApi = {
	enable: null,
	disable: null,
	close: null
};

dhtmlXRibbon.prototype._appendBlocks = function(blocks,cont,tab) {
	var i,l,_block,_list, w, q, answer = [];
	tab = tab || null;
	
	l = blocks.length;
	for (i=0; i<l; i++) {
		if (typeof(blocks[i]) == "object" && blocks[i].type == "block") {
			_block = this._addBlock(blocks[i], cont);
			
			if (blocks[i].list && (blocks[i].list instanceof Array)) {
				_list = blocks[i].list;
				w = _list.length;
				
				for (q=0; q<w; q++) {
					this._addItem(_block.id, null, null, _list[q]);
				}
			}
			
			if (tab != null) {
				_block.parentId = tab.id;
			}
			
			if (_block.conf.disable) {
				this.disable(_block.id);
			}
			answer.push(_block.id);
		}
	}
	
	return answer;
};

dhtmlXRibbon.prototype._addBlock = function (data,parent) {
	var i,l, block, key;
	
	block = {
		conf:  {
			text: "",
			text_pos: "bottom",
			type: "block",
			mode: "cols",
			disable: false
		},
		type: "block",
		childIds: [],
		base: document.createElement('div'),
		contForItems: document.createElement("div"),
		contForText: document.createElement("div")
	};
	
	for (key in data) {
		if (key == "list" || key == "type" || key == "id") continue;
		block.conf[key] = data[key];
	};
	
	if (!data.id) block.id = dhx4.newId();
	else block.id = data.id;
	while (this._items[block.id]) block.id = dhx4.newId();
	
	block.base.className = "dhxrb_block_base";
	parent.appendChild(block.base);
	
	block.contForItems.className = "dhxrb_block_items";
	block.contForText.className = "dhxrb_block_label";
	
	block.base.appendChild(block.contForItems);
	if (block.conf.text) {
		block.contForText.innerHTML = block.conf.text;
		if (block.conf.text_pos == "top") {
			block.base.insertBefore(block.contForText,block.contForItems);
		} else {
			block.base.appendChild(block.contForText);
		}
	}
	
	block.base._dhx_ribbonId = block.id;
	
	this._items[block.id] = block;
	
	return block;
};

dhtmlXRibbon.prototype._addItem = function(blockId, nextToId, itemId, data) {
	var block = this._items[blockId], base, cont_small_item, item = null, that = this, itemData;
	
	if (data.type != "newLevel" && !this.items[data.type]) {
		return null;
	}
	
	if (data.type == "newLevel") {
		this._addNewLevel(block);
	} else if (block.type == "group") {
		base = document.createElement('div');
		base.className = "dhxrb_in_group";
		block.base.appendChild(base);
	} else if (data.isbig) {
		base = document.createElement('div');
		base.className = "dhxrb_big_button";
		block.contForItems.appendChild(base);
	} else {
		cont_small_item = this._getContainerForSmallItem(block);
		base = document.createElement('div');
		base.className = (block.conf.mode == "rows")?"dhxrb_in_row":"dhxrb_3rows_button";
		cont_small_item.appendChild(base);
	}
	
	if (base) {
		this._attachEventForItem(base);
		
		itemData = {
			icons_path: data.icons_path || this.conf.icons_path,
			icons_css: this.conf.icons_css,
			skin: this.conf.skin
		};
		
		for (var key in data) {
			itemData[key] = data[key];
		};
		
		if (!itemData.id) itemData.id = dhx4.newId();
		while (this._items[itemData.id]) itemData.id = dhx4.newId();
		
		item = (this.items[itemData.type] && this.items[itemData.type].render)?this.items[itemData.type].render(base,itemData):null;
	}
	
	if (item != null) {
		this._items[item.id] = item;
		item.parentId = block.id;
		block.childIds.push(item.id);
		base._dhx_ribbonId = item.id;
		
		if (itemData.onclick && (typeof(itemData.onclick) == "function")) {
			this._eventHandlers[item.id] = this._eventHandlers[item.id] || {};
			this._eventHandlers[item.id]["onclick"] = itemData.onclick;
		}
		
		item.callEvent = function() {
			that.callEvent.apply(that,arguments);
		};
		item._callHandler = function() {
			that._callHandler.apply(that,arguments);
		};
		
		if (this.items[itemData.type] && typeof(this.items[itemData.type].callAfterInit) == "function") {
			this.items[itemData.type].callAfterInit.apply(this,[item]);
		}
	}
	
	return item;
};

dhtmlXRibbon.prototype._callHandler = function(id, arg) {
	if (this._eventHandlers[id] && this._eventHandlers[id].onclick) {
		this._eventHandlers[id].onclick.apply(this, arg);
	}
};

/*****************  items  *************************************/

dhtmlXRibbon.prototype.items = {};

dhtmlXRibbon.prototype.items.button = {
	render: function(cont, itemData) {
		var key, item;
		
		item = {
			base: cont,
			id: itemData.id,
			type: itemData.type,
			conf: {
				text: "",
				text_pos: (itemData.isbig)?"bottom":"right",
				img: null,
				imgdis: null,
				isbig: false,
				disable: false,
				skin: itemData.skin,
				icons_css: itemData.icons_css
			}
		};
		
		for (key in itemData) {
			if (key == "id" || key == "onclick" || key == "type") {
				continue;
			}
			
			item.conf[key] = itemData[key];
		}
		
		if (item.conf.icons_css == true) {
			var img = "<i class='"+item.conf.icons_path+(item.conf.img||"")+"'></i>";
		} else {
			var img = "<img class='dhxrb_image"+((item.conf.img)?"'":" dhxrb_invisible'")+" src='"+((item.conf.img)?item.conf.icons_path+item.conf.img:"")+"' />"
		}
		
		cont.innerHTML = img+"<div class='dhxrb_label_button'>"+item.conf.text+"</div>";
		
		if (typeof(this.afterRender) == "function") {
			this.afterRender(item);
		}
		
		if (item.conf.disable) {
			this.disable(item);
		}
		
		return item;
	},
	
	getText: function(item) {
		return item.conf.text;
	},
	
	setText: function(item, text) {
		var contForText = item.base.childNodes[1];
		
		item.conf.text = text;
		contForText.innerHTML = text;
	},
	
	setImage: function(item, img) {
		item.conf.img = img;
		if (item.conf.disable == false) {
			item.base.childNodes[0][item.conf.icons_css?"className":"src"] = item.conf.icons_path+item.conf.img;
		}
	},
	
	setImageDis: function(item, imgdis) {
		item.conf.imgdis = imgdis;
		if (item.conf.disable == true) {
			item.base.childNodes[0][item.conf.icons_css?"className":"src"] = item.conf.icons_path+item.conf.imgdis;
		}
	},
	
	mousedown: function(item,rb,e) {
		return true;
	},
	
	click: function(item,ribbon,e) {
		if (e.button != 0) {
			return false;
		}
		ribbon._callHandler(item.id, [item.id]);
		item.callEvent("onClick",[item.id]);
		return false;
	},
	
	disable: function(item) {
		var contForImage = item.base.childNodes[0],
			contForText = item.base.childNodes[1];
		
		if (item.conf.imgdis) {
			contForImage[item.conf.icons_css?"className":"src"] = item.conf.icons_path+item.conf.imgdis;
			if (/\s?dhxrb_invisible/i.test(contForImage.className)) {
				contForImage.className = contForImage.className.replace(/\s?dhxrb_invisible/i, "");
			}
		}
		
		if (!/\s?dhxrb_disable_text_style/i.test(contForText.className)) {
			contForText.className += " dhxrb_disable_text_style";
		}
		
		return true;
	},
	
	enable: function(item) {
		var contForImage = item.base.childNodes[0],
			contForText = item.base.childNodes[1];
		
		if (item.conf.img) {
			contForImage[item.conf.icons_css?"className":"src"] = item.conf.icons_path+item.conf.img;
		} else {
			if (!/\s?dhxrb_invisible/i.test(contForImage.className)) {
				contForImage.className += " dhxrb_invisible";
			}
		}
		
		if (/\s?dhxrb_disable_text_style/i.test(contForText.className)) {
			contForText.className = contForText.className.replace(/\s?dhxrb_disable_text_style/i, "");
		}
			
		return true;
	}
};

dhtmlXRibbon.prototype.items.buttonTwoState = {
	click: function(item, rb, e) {
		return false;
	},
	
	afterRender: function(item) {
		if (item.conf.state) {
			this.setState(item, item.conf.state);
		}
	},
	
	mouseover: function(item) {
		if (!/dhxrb_highlight0/.test(item.base.className)) {
			item.base.className += " dhxrb_highlight0";
		}
		return false;
	},
	
	mouseout: function(item) {
		if (/dhxrb_highlight0/.test(item.base.className)) {
			item.base.className = item.base.className.replace(/\s?dhxrb_highlight0/, "");
		}
		return false;
	},
	
	mousedown: function(item, rb, e) {
		rb._callHandler(item.id,[item.id,!item.conf.state]);
		this.setState(item, !item.conf.state, true);
		return false;
	},
	
	mouseup: function(item) {
		return false;
	},
	
	setState: function(item, value, callEvent) {
		callEvent = callEvent || false;
		value = dhx4.s2b(value);
		if (value) {
			if (!/dhxrb_highlight1/.test(item.base.className)) {
				item.base.className += " dhxrb_highlight1";
			}
		} else {
			if (/dhxrb_highlight1/.test(item.base.className)) {
				item.base.className = item.base.className.replace(/\s?dhxrb_highlight1/, "");
			}
		}
		
		item.conf.state = value;
		
		if (callEvent) {
			item.callEvent("onStateChange",[item.id, item.conf.state]);
		}
	},
	
	getState: function(item) {
		return (item.conf.state == true);
	}
};

dhtmlXRibbon.prototype.items.buttonSegment = {
	click: function(item, rb, e) {
		return false;
	},
	
	mousedown: function(item, rb, e) {
		this.setState(item, rb, true);
		return false;
	},
	
	callAfterInit: function(item) {
		/* @var this dhtmlXRibbon */
		
		if (item.conf.state || dhtmlXRibbon.prototype.items.buttonSegment._getSelectedNeighbor(item, this) == null) {
			if (item.conf.state) {
				item.conf.state = false;
			}
			dhtmlXRibbon.prototype.items.buttonSegment.setState(item, this,  false);
		}
		
	},
	
	afterRender: function() {},
	
	setState: function(item, rb, callEvent) {
		callEvent = callEvent || false;
		var oldItem = null, state = dhx4.s2b(item.conf.state);
		
		if (state == false) {
			oldItem = this._getSelectedNeighbor(item,rb);
			if (oldItem != null) {
				this._unSelect(oldItem);
			}
			
			if (!/dhxrb_highlight1/.test(item.base.className)) {
				item.base.className += " dhxrb_highlight1";
			}
			
			item.conf.state = true;
			
			if (callEvent) {
				rb._callHandler(item.id,[item.id,(oldItem?oldItem.id:null)]);
				rb.callEvent("onStateChange", [item.id, (oldItem?oldItem.id:null)]);
			}
		}
	},
	
	remove: function(item, rb) {
		var state = dhx4.s2b(item.conf.state),
			firstItem = null, i=0, parent = rb._items[item.parentId],
			tempItem;
		if (state) {
			while (parent.childIds[i] && firstItem == null) {
				tempItem = rb._items[parent.childIds[i]];
				if (tempItem.type == "buttonSegment" && tempItem != item) {
					firstItem = tempItem;
				}
				i++;
			}
			
			if (firstItem) this.setState(firstItem, rb);
		}
	},
	
	_unSelect: function(item) {
		var state = dhx4.s2b(item.conf.state);
		if (state) {
			if (/dhxrb_highlight1/.test(item.base.className)) {
				item.base.className = item.base.className.replace(/\s?dhxrb_highlight1/, "");
			}
			
			item.conf.state = false;
		}
	},
	
	_getSelectedNeighbor: function(item, rb) {
		var parent = rb._items[item.parentId], i, l, neighbor, answer = null;
		l = parent.childIds.length;
		for (i=0; i<l; i++) {
			neighbor = rb._items[parent.childIds[i]];
			
			if (neighbor.type == "buttonSegment" && neighbor.conf.state) {
				answer = neighbor;
				break;
			}
		}
		
		return answer;
	}
};

dhtmlXRibbon.prototype.items.buttonSelect = {
	itemCollection: [],
	_isAttachedEventInWindow: false,
	
	afterRender: function(item) {
		var label = item.base.childNodes[1];
		label.innerHTML += "<span class='dhxrb_arrow'>&nbsp;</span>";
		item.menu = null;
		this.itemCollection.push(item);
		
		this._attachEventToWindow();
		
		label = null;
	},
	
	setText: function(item,text) {
		var arrow = item.base.childNodes[1].lastChild;
		
		item.conf.text = text;
		
		item.base.childNodes[1].innerHTML = text;
		item.base.childNodes[1].appendChild(arrow);
	},
	
	setOptionText: function(item, optId, text) {
		if (item.menu != null) {
			item.menu.setItemText(optId, text);
		} else {
			this._loopThroughItems(item.conf.items, optId, text, false); // loop through items
		}
	},
	
	getOptionText: function(item, optId) {
		if (item.menu != null) return item.menu.getItemText(optId);
		return this._loopThroughItems(item.conf.items, optId, null, true); // loop through items
	},
	
	_loopThroughItems: function(items, id, text, retValue) {
		for (var q=0; q<items.length; q++) {
			if (items[q].id == id) {
				if (retValue != true) {
					items[q].text = text; // set value
					return true;
				} else {
					return items[q].text; // get value
				}
			}
			if (items[q].items != null) { // nested
				var t = this._loopThroughItems(items[q].items, id, text, retValue);
				if (t != null) return t;
			}
		}
		return null;
	},
	
	_attachEventToWindow: function() {
		if (this._isAttachedEventInWindow == false) {
			if (typeof(window.addEventListener) == "function") {
				document.body.addEventListener("mousedown",this._hideAllMenus, false);
			} else {
				document.body.attachEvent("onmousedown",this._hideAllMenus);
			}
			this._isAttachedEventInWindow = true;
		}
	},
	
	_detachEventFromWindow: function() {
		if (typeof(window.addEventListener) == "function") {
			document.body.removeEventListener("mousedown", this._hideAllMenus, false);
		} else {
			document.body.detachEvent("onmousedown", this._hideAllMenus);
		}
		this._isAttachedEventInWindow = false;
	},
	
	_hideAllMenus: function(e) {
		e = e || event;
		var t = e.target||e.srcElement;
		var m = true;
		while (t != null && m == true) {
			 if (t.className != null && /SubLevelArea_Polygon/i.test(t.className)) {
				 m = false;
			 } else {
				 t = t.parentNode;
			 }
		}
		
		if (m == false) {
			return;
		}
		
		var items = dhtmlXRibbon.prototype.items.buttonSelect.itemCollection;
		for (var itemId in items) {
			var item = items[itemId];
			
			if (item.menu instanceof dhtmlXMenuObject) {
				if (item._skipHiding) {
					item._skipHiding = false;
				} else {
					dhtmlXRibbon.prototype.items.buttonSelect.hideMenu(item);
				}
			}
		}
	},
	
	mousedown: function(item,rb,e) {
		item._skipHiding = true;
		this.showMenu(item);
		return false;
	},
	
	mouseup: function(item) {
		return false;
	},
	
	click: function() {},
	setState: function() {},
	
	showMenu: function(item) {
		var x = dhx4.absLeft(item.base),
			y = dhx4.absTop(item.base)+item.base.offsetHeight;
		
		if (!(item.menu instanceof dhtmlXMenuObject)) {
			item.menu = new dhtmlXMenuObject({
				parent: item.base,
				icons_path: item.conf.icons_path,
				context: true,
				items: item.conf.items,
				skin: item.conf.skin
			});
			
			if (item.conf.data) {
				item.menu.loadStruct(item.conf.data);
				delete item.conf.data;
			}
			
			item.menu.setAutoHideMode(false);
			
			item.menu.attachEvent("onHide",function(id) {
				if (id == null) dhtmlXRibbon.prototype.items.buttonSelect._doOnHideMenu(item);
			});
			
			item.menu.attachEvent("onShow",function(id) {
				if (id == null) dhtmlXRibbon.prototype.items.buttonSelect._doOnShowMenu(item);
			});
			
			item.menu.attachEvent("onClick", function(id) {
				item.callEvent("onClick",[id, item.id]);
			});
			
			item.base.oncontextmenu = function() { return false; };
			dhtmlXRibbon.prototype.items.buttonSelect.showMenu(item);
		} else {
			item.menu.showContextMenu(x,y);
		}
	},
	
	hideMenu: function(item) {
		if (item.menu instanceof dhtmlXMenuObject) {
			item.menu.hideContextMenu();
		}
	},
	
	remove: function(item) {
		var itemId, l;
		
		if (item.menu instanceof dhtmlXMenuObject) {
			item.menu.unload();
			item.menu = null;
		}
		
		item.base.oncontextmenu = null;
		
		itemId = dhtmlXRibbon.prototype._indexOf(dhtmlXRibbon.prototype.items.buttonSelect.itemCollection, item);
		
		if (itemId != -1) {
			dhtmlXRibbon.prototype.items.buttonSelect.itemCollection.splice(itemId,1);
		}
		
		if (dhtmlXRibbon.prototype.items.buttonSelect.itemCollection.length == 0) {
			this._detachEventFromWindow();
		}
	},
	
	setSkin: function(item, skin) {
		if (item.menu instanceof dhtmlXMenuObject) {
			item.menu.setSkin(skin);
		}
	},
	
	_doOnHideMenu: function(item) {
		if (item._skipHiding) {
			item._skipHiding = false;
		} else {
			if (/dhxrb_highlight1/.test(item.base.className)) {
				item.base.className = item.base.className.replace(/\s?dhxrb_highlight1/, "");
			}
		}
	},
	
	_doOnShowMenu: function(item) {
		if (!/dhxrb_highlight1/.test(item.base.className)) {
			item.base.className += " dhxrb_highlight1";
		}
	}
};

dhtmlXRibbon.prototype.items.group = {
	render: function(cont, itemData) {
		var key, item;
		
		item = {
			base: cont,
			id: itemData.id,
			type: itemData.type,
			conf: {
				disable: false,
				skin: itemData.skin
			},
			childIds: []
		};
		
		cont.className = "dhxrb_group";
		
		for (key in itemData) {
			if (key == "id" || key == "onclick" || key == "type") {
				continue;
			}
			
			item.conf[key] = itemData[key];
		}
		
		return item;
	},
	
	callAfterInit: function(item) {
		/* @var this dhtmlXRibbon */
		this._detachEventFromItem(item.base);
		
		var i,l, list = item.conf.list, child, label, sep;
		l = (list)?list.length:0;
		
		for (i=0; i<l; i++) {
			
			child = this._addItem(item.id,null,null,list[i]);
			if (child == null) continue;
			
			label = child.base.childNodes[1];
			if (label && !label.innerHTML && !/\s?dhxrb_label_hide/i.test(label.className)) {
				label.className += " dhxrb_label_hide";
			}
		}
		
		dhtmlXRibbon.prototype.items.group.normalize(item);
		
		if (item.conf.disable) {
			this.disable(item.id);
		}
		
		list = undefined;
	},
	
	normalize: function(item) {
		var chidren = item.base.children;
		var l = chidren.length, flag = false, d = 0;
		var sep, lastNode;
		
		for (var i=0; i<l; i++) {
			if (!/dhxrb_separator_group/i.test(chidren[i].className)) {
				if (/dhxrb_item_hide/i.test(chidren[i].className)) {
					d++;
					continue;
				}
			}
			if ((Math.ceil((i-d)/2) - Math.floor((i-d)/2)) == 0) {
				if (/dhxrb_separator_group/i.test(chidren[i].className)) {
					chidren[i].parentNode.removeChild(chidren[i]);
					flag = true;
					break;
				}
			} else {
				if (!/dhxrb_separator_group/i.test(chidren[i].className)) {
					sep = document.createElement('div');
					sep.className = 'dhxrb_separator_groupp';
					item.base.insertBefore(sep,chidren[i]);
					flag = true;
					break;
				}
			}
		}
		
		if (flag) {
			this.normalize(item);
		} else {
			lastNode = item.base.lastChild;
			if (lastNode && /dhxrb_separator_group/i.test(lastNode.className)) {
				lastNode.parentNode.removeChild(lastNode);
			}
		}
	},
	
	hideChild: function(item, child) {
		var i = dhtmlXRibbon.prototype._indexOf(item.base.children, child.base);
		if (i == 0) i++;
		else if (i != -1) i--;
		else return;
		
		var sepNode = item.base.children[i];
		if (sepNode && /dhxrb_separator_group/i.test(sepNode.className)) {
			sepNode.parentNode.removeChild(sepNode);
		}
	},
	
	showChild: function(item) {
		this.normalize(item);
	}
};

dhtmlXRibbon.prototype.items.input = {
	render: function(cont, itemData) {
		var key, item;
		
		item = {
			base: cont,
			id: itemData.id,
			type: itemData.type,
			conf: {
				text: "",
				text_pos: (itemData.isbig)?"bottom":"right",
				img: null,
				imgdis: null,
				isbig: false,
				disable: false,
				skin: itemData.skin,
				value: ""
			}
		};
		
		for (key in itemData) {
			if (key == "id" || key == "onclick" || key == "type") {
				continue;
			}
			
			item.conf[key] = itemData[key];
		}
		
		cont.innerHTML = "<input type='text' class='dhxrb_input'><div class='dhxrb_label_button'>"+item.conf.text+"</div>";
		
		if (typeof(this.afterRender) == "function") {
			this.afterRender(item);
		}
		
		if (item.conf.disable) {
			this.disable(item);
		}
		
		if (item.conf.width) {
			this.setWidth(item, item.conf.width);
		}
		
		if (item.conf.value) {
			this.setValue(item, item.conf.value);
		}
		
		return item;
	},
	
	callAfterInit: function(item) {
		/* @var this dhtmlXRibbon */
		var contForInput = item.base.childNodes[0];
		
		this._detachEventFromItem(item.base);
		this._attachEventsToInput(contForInput);
	},
	
	setText: dhtmlXRibbon.prototype.items.button.setText,
	
	getText: dhtmlXRibbon.prototype.items.button.getText,
	
	change: function(item) {
		var contForInput = item.base.childNodes[0];
		
		item.conf.value = contForInput.value;
	},
	
	keydown: function(item, rb, e) {
		if (e.keyCode == 13) {
			var contForInput = item.base.childNodes[0];
			item.conf.value = contForInput.value;
			rb.callEvent("onEnter",[item.id, item.conf.value]);
		}
	},
	
	remove: function(item, rb) {
		var contForInput = item.base.childNodes[0];
		rb._detachEventsFromInput(contForInput);
	},
	
	getValue: function(item) {
		var contForInput = item.base.childNodes[0], value;
		
		value = contForInput.value;
		contForInput = undefined;
		
		return value;
	},
	
	setValue: function(item, value) {
		var contForInput = item.base.childNodes[0], value;
		
		contForInput.value = value;
		item.conf.value = value;
	},
	
	setWidth: function(item, value) {
		var contForInput = item.base.childNodes[0];
		
		contForInput.style.width = parseInt(value)+"px";
	},
	
	disable: function(item) {
		var contForInput = item.base.childNodes[0],
			contForText = item.base.childNodes[1];
		
		contForInput.disabled = true;
		
		if (!/\s?dhxrb_disable_text_style/i.test(contForText.className)) {
			contForText.className += " dhxrb_disable_text_style";
		}
		
		return true;
	},
	
	enable: function(item) {
		var contForInput = item.base.childNodes[0],
			contForText = item.base.childNodes[1];
		
		contForInput.disabled = false;
		
		if (/\s?dhxrb_disable_text_style/i.test(contForText.className)) {
			contForText.className = contForText.className.replace(/\s?dhxrb_disable_text_style/i, "");
		}
			
		return true;
	},
	
	getInput: function(item){
		return item.base.childNodes[0];
	}
};

dhtmlXRibbon.prototype.getInput = function(id) {
	var item = this._items[id];
	if (item == null || item.type != "input") return null;
	return this.items[item.type].getInput(item);
};

dhtmlXRibbon.prototype.items.checkbox = {
	render: function (cont, itemData) {
		var key, item;
		
		item = {
			base: cont,
			id: itemData.id,
			type: itemData.type,
			conf: {
				text: "",
				text_pos: (itemData.isbig)?"bottom":"right",
				disable: false,
				checked: false
			}
		};
		
		for (key in itemData) {
			if (key == "id" || key == "onclick" || key == "type") {
				continue;
			}
			
			item.conf[key] = itemData[key];
		}
		
		cont.innerHTML = "<div class='dhxrb_checkbox'></div><div class='dhxrb_label_checkbox'>"+item.conf.text+"</div>";
		
		if (typeof(this.afterRender) == "function") {
			this.afterRender(item);
		}
		
		if (item.conf.checked) {
			this.check(item);
		}
		
		return item;
	},
	
	callAfterInit: function(item) {
		/* @var this dhtmlXRibbon */
		
		if (item.conf.disable) {
			this.disable(item.id);
		}
	},
	
	setText: dhtmlXRibbon.prototype.items.button.setText,
	
	getText: dhtmlXRibbon.prototype.items.button.getText,
	
	mousedown: function(item) {
		return false;
	},
	
	mouseup: function(item) {
		return false;
	},
	
	click: function(item, rb, e) {
		if (e.button != 0) {
			return false;
		}
		if (item.type == "checkbox") {
			if (item.conf.checked) {
				this.uncheck(item, true);
			} else {
				this.check(item, true);
			}
		}
	},
	
	check: function(item, callEvent) {
		callEvent = callEvent || false;
		if (item.type != "checkbox") {
			return;
		}
		
		item.conf.checked = true;
		if (!/\s?dhxrb_checked/i.test(item.base.className)) {
			item.base.className += " dhxrb_checked";
		}
		
		if (callEvent) {
			item.callEvent("onCheck",[item.id, item.conf.checked]);
		}
	},
	
	uncheck: function(item, callEvent) {
		callEvent = callEvent || false;
		if (item.type != "checkbox") {
			return;
		}
		
		item.conf.checked = false;
		if (/\s?dhxrb_checked/i.test(item.base.className)) {
			item.base.className = item.base.className.replace(/\s?dhxrb_checked/i,"");
		}
		
		if (callEvent) {
			item.callEvent("onCheck",[item.id, item.conf.checked]);
		}
	},
	
	isChecked: function(item) {
		if (item.type != "checkbox") return false;
		return (item.conf.checked == true);
	},
	
	disable: function(item) {
		return true;
	},
	
	enable: function(item) {
		return true;
	}
};

dhtmlXRibbon.prototype.items.text = {
	render: function(cont, data) {
		var item = {
			base: cont,
			id: data.id,
			type: data.type,
			conf: {
				text: ""
			}
		};
		
		for (var key in data) {
			if (key == "id" || key == "type") {
				continue;
			}
			item.conf[key] = data[key];
		}
		
		
		cont.innerHTML = "<div class='dhxrb_item_text'>"+item.conf.text+"</div>";
		
		if (typeof(this.afterRender) == "function") {
			this.afterRender(item);
		}
		
		return item;
	},
	
	callAfterInit: function(item) {
		/* @var this dhtmlXRibbon */
		
		this._detachEventFromItem(item.base);
	},
	
	getText: function(item) {
		return item.conf.text;
	},
	
	setText: function(item, text) {
		item.conf.text = text;
		item.base.firstChild.innerHTML = item.conf.text
	}
};

dhtmlXRibbon.prototype.items.buttonCombo = {
	render: function(cont, dataItem) {
		var key, item, comboConf={};
		
		item = {
			base: cont,
			id: dataItem.id,
			type: dataItem.type,
			conf: {
				text: "",
				text_pos: "right",
				width: 140,
				skin: dataItem.skin,
				callEvent: true,
				mode: dataItem.comboType,
				image_path: dataItem.comboImagePath,
				default_image: dataItem.comboDefaultImage,
				default_image_dis: dataItem.comboDefaultImageDis
			}
		};
		
		for (key in dataItem) {
			if (key == "id" || key == "onclick" || key == "type") {
				continue;
			}
			
			item.conf[key] = dataItem[key];
		}
		
		for (key in item.conf) {
			if (key == "text" || key == "text_pos" || key == "disable" || key == "data") {
				continue;
			}
			
			comboConf[key] = item.conf[key];
		}
		
		item.base.className += " dhxrb_buttoncombo_cont";
		item.base.innerHTML = "<div class='dhxrb_buttoncombo'></div><div class='dhxrb_label_button'>"+item.conf.text+"</div>";
		
		comboConf.parent = item.base.firstChild;
		
		item.combo = new dhtmlXCombo(comboConf);
		
		item.combo.setSkin(comboConf.skin); // deprecated;
		
		item.combo.attachEvent("onChange", function(value, text) {
			item._callHandler(item.id, [value, text]);
			if (item.conf.callEvent == true) item.callEvent("onSelectOption", [item.id, value, text]);
			item.conf.callEvent = true;
		});
		
		if (item.conf.data) {
			item.combo.load(item.conf.data);
			delete item.conf.data;
		}
		
		if (typeof(this.afterRender) == "function") {
			this.afterRender(item);
		}
		
		if (item.conf.disable) {
			this.disable(item);
		}
		
		return item;
	},
	
	callAfterInit: function(item) {
		/* @var this dhtmlXRibbon */
		this._detachEventFromItem(item.base);
	},
	
	disable: function(item) {
		var contForText = item.base.lastChild;
		
		if (item.combo instanceof dhtmlXCombo) {
			item.combo.disable();
		}
		
		if (!/\s?dhxrb_disable_text_style/i.test(contForText.className)) {
			contForText.className += " dhxrb_disable_text_style";
		}
		
		return true;
	},
	
	enable: function(item) {
		var contForText = item.base.lastChild;
		
		if (item.combo instanceof dhtmlXCombo) {
			item.combo.enable();
		}
		
		if (/\s?dhxrb_disable_text_style/i.test(contForText.className)) {
			contForText.className = contForText.className.replace(/\s?dhxrb_disable_text_style/i, "");
		}
		
		return true;
	},
	
	remove: function(item) {
		if (item.combo instanceof dhtmlXCombo) {
			item.combo.unload();
			item.combo = null;
		}
	},
	
	getValue: function(item) {
		var answer = null;
		if (item.combo instanceof dhtmlXCombo) {
			answer = item.combo.getSelectedValue();
		}
		
		return answer;
	},
	
	setValue: function(item, value, callEvent) {
		if (item.combo instanceof dhtmlXCombo) {
			item.conf.callEvent = callEvent;
			item.combo.setComboValue(value);
			item.conf.callEvent = true;
		}
	},
	
	setSkin: function(item, skin) {
		if (item.combo instanceof dhtmlXCombo) {
			item.combo.setSkin(skin);
		}
	}
};

dhtmlXRibbon.prototype.items.slider = {
	render: function(cont, data) {
		var key, item, sliderConf={};
		
		item = {
			base: cont,
			id: data.id,
			type: data.type,
			conf: {
				text: "",
				text_pos: "right",
				size: 150,
				vertical: false,
				min: 0,
				max: 99,
				value: 0,
				step: 1,
				margin: 10,
				disabled: false,
				enableTooltip: false
			}
		};
		
		for (key in data) {
			if (key == "id" || key == "onclick" || key == "type") {
				continue;
			}
			
			item.conf[key] = data[key];
		}
		
		for (key in item.conf) {
			if (key == "text" || key == "text_pos" || key == "isbig") {
				continue;
			}
			
			sliderConf[key] = item.conf[key];
		}
		
		item.base.innerHTML = "<center><div class='dhxrb_slider'></div></center><div class='dhxrb_label_button'>"+item.conf.text+"</div>";
	
		sliderConf.parent = item.base.firstChild.firstChild;
		
		item.slider = new dhtmlXSlider(sliderConf);
	
		if (typeof(this.afterRender) == "function") {
			this.afterRender(item);
		}
		
		if (item.conf.disable) {
			this.disable(item);
		}
		
		item.slider.attachEvent("onChange", function(value) {
			item._callHandler(item.id, [value]);
			item.callEvent("onValueChange", [item.id, value]);
		});
	
		return item;
	},
	
	callAfterInit: function(item) {
		/* @var this dhtmlXRibbon */
		this._detachEventFromItem(item.base);
	},
	
	setSkin: function(item, skin) {
		if (item.slider instanceof dhtmlXSlider) {
			item.slider.setSkin(skin);
		}
	},
	
	disable: function(item) {
		var contForText = item.base.childNodes[1];
		
		if (item.slider instanceof dhtmlXSlider) {
			item.slider.disable();
		}
		
		if (!/\s?dhxrb_disable_text_style/i.test(contForText.className)) {
			contForText.className += " dhxrb_disable_text_style";
		}
		return true;
	},
	
	enable: function(item) {
		var contForText = item.base.childNodes[1];
		
		if (item.slider instanceof dhtmlXSlider) {
			item.slider.enable();
		}
		
		if (/\s?dhxrb_disable_text_style/i.test(contForText.className)) {
			contForText.className = contForText.className.replace(/\s?dhxrb_disable_text_style/i, "");
		}
		
		return true;
	},
	
	remove: function(item) {
		if (item.slider instanceof dhtmlXSlider) {
			item.slider.unload();
			item.slider = null;
		}
	},
	
	getValue: function(item) {
		var answer = null;
		if (item.slider instanceof dhtmlXSlider) {
			answer = item.slider.getValue();
		}
		
		return answer;
	},
	
	setValue: function(item,value) {
		if (item.slider instanceof dhtmlXSlider) {
			item.slider.setValue(value);
		}
	}
};

/******************************************************/

dhtmlXRibbon.prototype.items._extends = function(item,parent) {
	var key;
	
	for (key in parent) {
		item[key] = item[key] || parent[key];
	}
	
	return item;
};

dhtmlXRibbon.prototype._addNewLevel = function (block) {
	var lastNode,cont;
	if (block.conf.mode == 'rows') {
		lastNode = block.contForItems.lastChild;
		
		if (lastNode && /dhxrb_block_rows/i.test(lastNode.className) && (lastNode.childNodes.length < 3)) {
			
			cont = document.createElement('div');
			cont.className = "dhxrb_block_row";
			lastNode.appendChild(cont);
			
		} else {
			lastNode = document.createElement('div');
			lastNode.className = "dhxrb_block_rows";
			block.contForItems.appendChild(lastNode);
			cont = document.createElement('div');
			cont.className = "dhxrb_block_row";
			lastNode.appendChild(cont);
		}
		
	} else {
		var cont = document.createElement("div");
		cont.className = "dhxrb_3rows_block";
		block.contForItems.appendChild(cont);
	}
};

dhtmlXRibbon.prototype._attachEventForItem = function(cont) {
	if (typeof(window.addEventListener) == "function") {
		cont.addEventListener("mouseover", this._doOnHighlight0, false);
		cont.addEventListener("mouseout", this._doOffHighlight0, false);
		cont.addEventListener("mousedown", this._doOnHighlight1, false);
		cont.addEventListener("mouseup", this._doOffHighlight1, false);
		cont.addEventListener("click", this._doOnClick, false);
	} else {
		cont.attachEvent("onmouseover", this._doOnHighlight0);
		cont.attachEvent("onmouseout", this._doOffHighlight0);
		cont.attachEvent("onmousedown", this._doOnHighlight1);
		cont.attachEvent("onmouseup", this._doOffHighlight1);
		cont.attachEvent("onclick", this._doOnClick);
	}
};

dhtmlXRibbon.prototype._detachEventFromItem = function(cont) {
	if (typeof(window.addEventListener) == "function") {
		cont.removeEventListener("mouseover", this._doOnHighlight0, false);
		cont.removeEventListener("mouseout", this._doOffHighlight0, false);
		cont.removeEventListener("mousedown", this._doOnHighlight1, false);
		cont.removeEventListener("mouseup", this._doOffHighlight1, false);
		cont.removeEventListener("click", this._doOnClick, false);
	} else {
		cont.detachEvent("onmouseover", this._doOnHighlight0);
		cont.detachEvent("onmouseout", this._doOffHighlight0);
		cont.detachEvent("onmousedown", this._doOnHighlight1);
		cont.detachEvent("onmouseup", this._doOffHighlight1);
		cont.detachEvent("onclick", this._doOnClick);
	}
};

dhtmlXRibbon.prototype._attachEventsToInput = function(cont) {
	if (typeof(window.addEventListener) == "function") {
		cont.addEventListener("focus", this._doOnFocus, false);
		cont.addEventListener("blur", this._doOnBlur, false);
		cont.addEventListener("change", this._doOnChange, false);
		cont.addEventListener("keydown", this._doOnKeydown, false);
	} else {
		cont.attachEvent("onfocus", this._doOnFocus);
		cont.attachEvent("onblur", this._doOnBlur);
		cont.attachEvent("onchange", this._doOnChange);
		cont.attachEvent("onkeydown", this._doOnKeydown);
	}
};

dhtmlXRibbon.prototype._detachEventsFromInput = function(cont) {
	if (typeof(window.addEventListener) == "function") {
		cont.removeEventListener("focus", this._doOnFocus, false);
		cont.removeEventListener("blur", this._doOnBlur, false);
		cont.removeEventListener("change", this._doOnChange, false);
		cont.removeEventListener("keydown", this._doOnKeydown, false);
	} else {
		cont.detachEvent("onfocus", this._doOnFocus);
		cont.detachEvent("onblur", this._doOnBlur);
		cont.detachEvent("onchange", this._doOnChange);
		cont.detachEvent("onkeydown", this._doOnKeydown);
	}
};

dhtmlXRibbon.prototype._getContainerForSmallItem = function(parent) {
	var last_el = parent.contForItems.lastChild, cont = null;
	
	if (parent.conf.mode == "rows") {
		
		if (last_el && /\s?dhxrb_block_rows/i.test(last_el.className)) {
			cont = last_el.lastChild;
			if (!cont) {
				cont = document.createElement('div');
				cont.className = "dhxrb_block_row";
				last_el.appendChild(cont);
			}
		} else {
			last_el = document.createElement('div');
			last_el.className = "dhxrb_block_rows";
			parent.contForItems.appendChild(last_el);
			cont = document.createElement('div');
			cont.className = "dhxrb_block_row";
			last_el.appendChild(cont);
		}
	} else {
		
		if (last_el && /dhxrb_3rows_block/i.test(last_el.className) && (last_el.childNodes.length < 3)) {
			cont = last_el;
		} else {
			cont = document.createElement("div");
			cont.className = "dhxrb_3rows_block";
			parent.contForItems.appendChild(cont);
		}
		
	}
	
	return cont;
};

dhtmlXRibbon.prototype._findItemByNode = function(el) {
	while (el && !el._dhx_ribbonId) {
		el = el.parentNode;
	}
	return el;
};

dhtmlXRibbon.prototype._indexOf =  function(arr,item) {
	var i,l;
	l = arr.length;
	for (i=0; i<l; i++) {
		if (arr[i] == item) {
			return i;
		}
	}
	
	return -1;
};

dhtmlXRibbon.prototype._removeItem = function(item) {
	var parentNode, ind=-1, parent = this._items[item.parentId];
	
	if (item.type == "group") {
		this._removeGroup(item);
		return;
	}
	
	delete this._items[item.id];
	parentNode = item.base.parentNode;
	
	this._detachEventFromItem(item.base);
	parentNode.removeChild(item.base);
	
	if (parent.type == "block") {
		if (parentNode != parent.contForItems && parentNode.childNodes.length == 0) {
			parentNode.parentNode.removeChild(parentNode);
		}
	} else if (parent.type == "group") {
		dhtmlXRibbon.prototype.items.group.normalize(parent);
	}
	
	ind = this._indexOf(parent.childIds, item.id);
	
	if (ind != -1) {
		parent.childIds.splice(ind,1);
	}
	
	if (this.items[item.type] && (typeof(this.items[item.type].remove) == "function")) {
		this.items[item.type].remove(item, this);
	}
};

dhtmlXRibbon.prototype._removeGroup = function(item) {
	var items = [], ind, parent = this._items[item.parentId], parentNode = item.base.parentNode;
	
	for (var q=0; q<item.childIds.length; q++) {
		items.push(this._items[item.childIds[q]]);
	}
	
	for (var q=0; q<items.length; q++) {
		this._removeItem(items[q]);
	}
	
	delete this._items[item.id];
	if (item.base.parentNode) parentNode.removeChild(item.base);
	
	if (parentNode.childNodes.length == 0) {
		parentNode.parentNode.removeChild(parentNode);
	}
	
	ind = this._indexOf(parent.childIds, item.id);
	if (ind != -1) {
		parent.childIds.splice(ind,1);
	}
	
	if (this.items[item.type] && (typeof(this.items[item.type].remove) == "function")) {
		this.items[item.type].remove(item);
	}
};

dhtmlXRibbon.prototype._removeBlock = function(block) {
	var items = [], ind, parent;
	
	for (var q=0; q<block.childIds.length; q++) {
		items.push(this._items[block.childIds[q]]);
	}
	
	for (var q=0; q<items.length; q++) {
		this._removeItem(items[q]);
	}
	
	delete this._items[block.id];
	
	block.base.parentNode.removeChild(block.base);
	
	if (block.parentId) {
		parent = this._items[block.parentId];
	} else {
		parent = this;
	}
	
	ind = this._indexOf(parent.childIds,block.id);
	
	if (ind != -1) {
		parent.childIds.splice(ind,1);
	}
};

dhtmlXRibbon.prototype._removeTab = function(tab,activeTabId) {
	var blocks = [], ind;
	
	for (var q=0; q<tab.childIds.length; q++) {
		blocks.push(this._items[tab.childIds[q]]);
	}
	
	for (var q=0; q<blocks.length; q++) {
		this._removeBlock(blocks[q]);
	}
	
	delete this._items[tab.id];
	
	ind = this._indexOf(this.childIds,tab.id);
	
	if (ind != -1) {
		this.childIds.splice(ind,1);
	}
};

dhtmlXRibbon.prototype._skinCollection = {
	dhx_skyblue: true,
	dhx_web: true,
	dhx_terrace: true,
	material: true
};

dhtmlXRibbon.prototype._setSkinForItems = function(value) {
	var key, item;
	
	for (key in this._items) {
		item = this._items[key];
		
		item.conf.skin = value;
		
		if (dhtmlXRibbon.prototype.items[item.type] && typeof(dhtmlXRibbon.prototype.items[item.type].setSkin) == "function") {
			dhtmlXRibbon.prototype.items[item.type].setSkin(item,value);
		}
		
	}
	
	item = undefined, key = undefined;
};

dhtmlXRibbon.prototype._setBlockText = function(item, text) {
	item.conf.text = text;
	item.contForText.innerHTML = text;
	
	if (!text && (text != 0) && item.contForText.parentNode) {
		item.contForText.parentNode.removeChild(item.contForText);
	} else if (!item.contForText.parentNode) {
		if (item.conf.text_pos == "top") {
			item.base.insertBefore(item.contForText, item.contForItems);
		} else {
			item.base.appendChild(item.contForText);
		}
	}
};

/* Public API */

dhtmlXRibbon.prototype.hide = function(id) {
	var item = this._items[id];
	
	if (this.items[item.type] && (typeof(this.items[item.type].hide) == "function")) {
		if (this.items[item.type].hide(item) != true) {
			return;
		}
	}
	
	if (item.type == "tab") {
		return;
	} else if (!/\s?dhxrb_item_hide/i.test(item.base.className)) {
		item.base.className += " dhxrb_item_hide";
	}
	
	var parent = this._items[item.parentId];
	if (parent && this.items[parent.type] && (typeof(this.items[parent.type].hideChild) == "function")) {
		this.items[parent.type].hideChild(parent, item);
	}
};

dhtmlXRibbon.prototype.show = function(id) {
	var item = this._items[id];
	
	if (this.items[item.type] && (typeof(this.items[item.type].show) == "function")) {
		if (this.items[item.type].show(item) != true) {
			return;
		}
	}
	
	if (item.type == "tab") {
		return;
	} else if (/\s?dhxrb_item_hide/i.test(item.base.className)) {
		item.base.className = item.base.className.replace(/\s?dhxrb_item_hide/i, "");
	}
	
	var parent = this._items[item.parentId];
	if (parent && this.items[parent.type] && (typeof(this.items[parent.type].showChild) == "function")) {
		this.items[parent.type].showChild(parent, item);
	}
};

dhtmlXRibbon.prototype.check = function(id,callEvent) {
	callEvent = dhx4.s2b(callEvent);
	var item  = this._items[id];
	
	if (item && !item.conf.checked && typeof(this.items[item.type].check) == "function") {
		this.items[item.type].check(item);
		if (callEvent) this.callEvent("onCheck",[item.id, item.conf.checked]);
	}
};

dhtmlXRibbon.prototype.uncheck = function(id, callEvent) {
	callEvent = dhx4.s2b(callEvent);
	var item  = this._items[id];
	
	if (item && item.conf.checked && typeof(this.items[item.type].uncheck) == "function") {
		this.items[item.type].uncheck(item);
		if (callEvent) this.callEvent("onCheck",[item.id, item.conf.checked]);
	}
};

dhtmlXRibbon.prototype.isChecked = function(id) {
	var item  = this._items[id];
	if (item && typeof(this.items[item.type].isChecked) == "function") {
		return this.items[item.type].isChecked(item);
	}
};

dhtmlXRibbon.prototype.disable = function(id,activetab) {
	var item = this._items[id];
	
	if (this.items[item.type] && (typeof(this.items[item.type].disable) == "function")) {
		if (this.items[item.type].disable(item) != true) return;
	}
	
	if (item.type == "tab") {
		return;
	} else if (item.type == "block" || item.type == "group") {
		for (var q=0; q<item.childIds.length; q++) {
			this.disable(item.childIds[q]);
		}
	}
	
	if (!/\s?dhxrb_item_disable/i.test(item.base.className)) {
		item.base.className += " dhxrb_item_disable";
	}
	
	if (item.base.className.match(/dhxrb_highlight/gi) != null) {
		if (item.type == "buttonTwoState") {
			item.base.className = item.base.className.replace(/\s*dhxrb_highlight0/gi, "");
		} else {
			item.base.className = item.base.className.replace(/\s*dhxrb_highlight\d/gi, "");
		}
	}
	
	item.conf.disable = true;
};

dhtmlXRibbon.prototype.enable = function(id,activetab) {
	var item = this._items[id];
	
	if (this.items[item.type] && (typeof(this.items[item.type].enable) == "function")) {
		if (this.items[item.type].enable(item) != true) {
			return;
		}
	}
	
	if (item.type == "tab") {
		return;
	} else if (item.type == "block" || item.type == "group") {
		for (q=0; q<item.childIds.length; q++) {
			this.enable(item.childIds[q]);
		}
	}
	
	if (/\s?dhxrb_item_disable/i.test(item.base.className)) {
		item.base.className = item.base.className.replace(/\s?dhxrb_item_disable/i, "");
	}
	
	item.conf.disable = false;
};

dhtmlXRibbon.prototype.isEnabled = function(id) {
	var item = this._items[id];
	
	if (this.items[item.type] && typeof(this.items[item.type].isEnabled) == "function") {
		return this.items[item.type].isEnabled(item);
	}
	
	if (item.type == "tab") {
		return;
	} else {
		return item.conf.disable != true;
	}
};

dhtmlXRibbon.prototype.isVisible = function(id) {
	var item = this._items[id];
	
	if (this.items[item.type] && (typeof(this.items[item.type].isVisible) == "function")) {
		return this.items[item.type].isVisible(item);
	}
	
	if (item.type == "tab") {
		return;
	} else {
		return !/\s?dhxrb_item_hide/i.test(item.base.className);
	}
};

dhtmlXRibbon.prototype.setItemState = function(id, value, callEvent) {
	value = dhx4.s2b(value);
	callEvent = dhx4.s2b(callEvent);
	var item = this._items[id];
	
	if (item && (typeof(this.items[item.type].setState) == "function")) {
		switch (item.type) {
			case "buttonSegment":
				this.items[item.type].setState(item, this, callEvent);
				break;
			default:
				this.items[item.type].setState(item,value, callEvent);
		}
	}
};

dhtmlXRibbon.prototype.getItemState = function(id) {
	var item = this._items[id];
	if (item && (typeof(this.items[item.type].getState) == "function")) {
		switch (item.type) {
			case "buttonTwoState":
			case "buttonSegment":
				return this.items[item.type].getState(item);
				break;
		}
	}
	return null;
};

dhtmlXRibbon.prototype.setIconPath = function(str) {
	this.conf.icons_path = str;
};

dhtmlXRibbon.prototype.setIconset = function(name) {
	this.conf.icons_css = (name == "awesome");
};

dhtmlXRibbon.prototype.removeItem = function(id) {
	var item = this._items[id];
	if (item == null) return;
	switch (item.type) {
		case "tab":
			break;
		case "block":
			this._removeBlock(item);
			break;
		case "group":
			this._removeGroup(item);
			break;
		default:
			this._removeItem(item);
	}
};

dhtmlXRibbon.prototype.setSkin = function(skin) {
	skin = (typeof(skin) == "string")?skin.toLowerCase():"";
	
	if (this._skinCollection[skin] != true) {
		return;
	}
	
	var classes, _int = -1, skinName, className = "dhtmlxribbon";
	
	classes = this._base.className.match(/\S\w+/ig);
	
	if (classes instanceof Array) {
		for (skinName in this._skinCollection) {
			if (_int == -1) {
				_int = this._indexOf(classes, className+"_"+skinName);
			} else {
				break;
			}
		}
		
		_int = (_int == -1)?classes.length:_int;
	} else {
		classes = [];
		_int = 0;
	}
	
	classes[_int] = className+"_"+skin;
	
	this._base.className = classes.join(" ");
	this.conf.skin = skin;
	
	if (this._tabbar != null) {
		this._tabbar.setSkin(skin);
	}
	
	this._setSkinForItems(skin);
};

dhtmlXRibbon.prototype.tabs = function(id) {
	if (this._tabbar instanceof dhtmlXTabBar) {
		return this._tabbar.tabs(id);
	} else {
		return undefined;
	}
};

dhtmlXRibbon.prototype.getItemType = function(id) {
	var item = this._items[id];
	if (item) {
		return item.type;
	} else {
		return undefined;
	}
};

dhtmlXRibbon.prototype.getValue = function(id) {
	var item = this._items[id], answer = undefined;
	
	if (item && this.items[item.type] && typeof(this.items[item.type].getValue) == "function") {
		answer = this.items[item.type].getValue(item);
	}
	
	return answer;
};

dhtmlXRibbon.prototype.setValue = function(id, value, callEvent) {
	
	var item = this._items[id];
	callEvent = (callEvent === false ? false : true);
	
	if (item && this.items[item.type] && typeof(this.items[item.type].setValue) == "function") {
		this.items[item.type].setValue(item, value, callEvent);
	}
};

dhtmlXRibbon.prototype.getItemText = function(id) {
	var item = this._items[id];
	
	if (!item) {
		return null;
		
	} else if (item.type == "tab") {
		return this.tabs(item.id).getText();
		
	} else if (item.type == "block") {
		return this.items.button.getText(item);
		
	} else if (this.items[item.type] && typeof(this.items[item.type].getText) == "function") {
		return this.items[item.type].getText(item);
		
	} else {
		return null;
	}
};

dhtmlXRibbon.prototype.setItemText = function(id, text) {
	var item = this._items[id];
	
	if (!item) {
		return;
	} else if (item.type == "tab") {
		this.tabs(item.id).setText(text);
		
	} else if (item.type == "block") {
		this._setBlockText(item, text);
		
	} else if (this.items[item.type] && typeof(this.items[item.type].setText) == "function") {
		this.items[item.type].setText(item,text);
	}
};

// button select's menu
dhtmlXRibbon.prototype.setItemOptionText = function(id, optId, text) {
	var item = this._items[id];
	if (item.type == "buttonSelect") this.items[item.type].setOptionText(item, optId, text);
};

dhtmlXRibbon.prototype.getItemOptionText = function(id, optId) {
	var item = this._items[id];
	if (item.type == "buttonSelect") return this.items[item.type].getOptionText(item, optId);
	return null;
};

dhtmlXRibbon.prototype.setItemImage = function(id, img) {
	var item = this._items[id];
	
	if (item != null && this.items[item.type] != null && typeof(this.items[item.type].setImage) == "function") {
		this.items[item.type].setImage(item, img);
	}
};
dhtmlXRibbon.prototype.setItemImageDis = function(id, imgdis) {
	var item = this._items[id];
	
	if (item != null && this.items[item.type] != null && typeof(this.items[item.type].setImageDis) == "function") {
		this.items[item.type].setImageDis(item, imgdis);
	}
};

// combo's
dhtmlXRibbon.prototype.getCombo = function(id) {
	var item = this._items[id];
	if (item != null && item.type == "buttonCombo") return item.combo;
	return null;
};

(function(){
	var i = dhtmlXRibbon.prototype.items;
	i.buttonTwoState = i._extends(i.buttonTwoState, i.button);
	i.buttonSelect = i._extends(i.buttonSelect, i.buttonTwoState);
	i.buttonSegment = i._extends(i.buttonSegment, i.buttonTwoState);
})();
if (typeof(window.dhtmlXCellObject) != "undefined") {
	
	dhtmlXCellObject.prototype._createNode_ribbon = function(obj, type, htmlString, append, node) {
		
		if (typeof(node) != "undefined") {
			obj = node;
		} else {
			obj = document.createElement("DIV");
			obj.className = "dhx_cell_ribbon_"+(this.conf.borders?"def":"no_borders");
			obj.appendChild(document.createElement("DIV"));
		}
		
		this.cell.insertBefore(obj, this.cell.childNodes[this.conf.idx.cont]); // before cont only
		this.conf.ofs_nodes.t.ribbon = true;
		this._updateIdx();
		this._adjustCont(this._idd);
		
		return obj;
	};
	
	dhtmlXCellObject.prototype.attachRibbon = function(conf) {
		
		if (!(this.dataNodes.ribbon == null && this.dataNodes.toolbar == null)) return;
		
		this.callEvent("_onBeforeContentAttach", ["ribbon"]);
		
		if (typeof(conf) == "undefined") conf = {};
		if (typeof(conf.skin) == "undefined") conf.skin = this.conf.skin;
		
		conf.parent = this._attachObject("ribbon").firstChild;
		
		this.dataNodes.ribbon = new dhtmlXRibbon(conf);
		
		var t = this;
		this.dataNodes.ribbon.attachEvent("_onHeightChanged", function(){
				t._adjustCont(t._idd);
		});
		
		this._adjustCont();
		
		conf.parent = null;
		conf = null;
		
		this.callEvent("_onContentAttach", []);
		
		return this.dataNodes.ribbon;
		
	};
	
	dhtmlXCellObject.prototype.detachRibbon = function() {
		
		if (this.dataNodes.ribbon == null) return;
		
		if (typeof(this.dataNodes.ribbon.unload) == "function") this.dataNodes.ribbon.unload();
		this.dataNodes.ribbon = null;
		delete this.dataNodes.ribbon;
		
		this._detachObject("ribbon");
		
	};
	
	dhtmlXCellObject.prototype.showRibbon = function() {
		this._mtbShowHide("ribbon", "");
	};
	
	dhtmlXCellObject.prototype.hideRibbon = function() {
		this._mtbShowHide("ribbon", "none");
	};
	
	dhtmlXCellObject.prototype.getAttachedRibbon = function() {
		return this.dataNodes.ribbon;
	};
	
}


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXToolbarObject(base, skin) {
	
	var main_self = this;
	
	this.conf = {
		skin: (skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxtoolbar")||"material"),
		align: "left",
		align_autostart: "left",
		icons_path: "",
		icons_css: false,
		iconSize: 18,
		sel_ofs_x: 0,
		sel_ofs_y: 0,
		xml_autoload: null,
		items_autoload: null,
		cssShadow: (dhx4.isIE6||dhx4.isIE7||dhx4.isIE8?"":" dhx_toolbar_shadow") // for material
	}
	
	if (typeof(base) == "object" && base != null && typeof(base.tagName) == "undefined") {
		// object-api init
		if (base.icons_path != null || base.icon_path != null) this.conf.icons_path = (base.icons_path||base.icon_path);
		if (base.icons_size != null) this.conf.icons_size_autoload = base.icons_size;
		if (base.iconset != null) this.conf.icons_css = (base.iconset == "awesome");
		if (base.json != null) this.conf.json_autoload = base.json;
		if (base.xml != null) this.conf.xml_autoload = base.xml;
		if (base.onload != null) this.conf.onload_autoload = base.onload;
		if (base.onclick != null || base.onClick != null) this.conf.auto_onclick = (base.onclick|| base.onClick);
		if (base.items != null) this.conf.items_autoload = base.items;
		if (base.skin != null) this.conf.skin = base.skin;
		if (base.align != null) this.conf.align_autostart = base.align;
		base = base.parent;
	}
	
	this.cont = (typeof(base)!="object")?document.getElementById(base):base;
	while (this.cont.childNodes.length > 0) this.cont.removeChild(this.cont.childNodes[0]);
	
	base = null;
	
	this.cont.dir = "ltr";
	
	this.base = document.createElement("DIV");
	this.base.className = "dhxtoolbar_float_left";
	this.cont.appendChild(this.base);
	
	this.cont.ontouchstart = function(e){
		e = e||event;
		if ((String(e.target.tagName||"").toLowerCase()=="input")) return true;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		e.cancelBubble = true;
		return false;
	}
	
	this.setSkin(this.conf.skin);
	
	this.objPull = {};
	this.anyUsed = null;
	
	/* random prefix */
	this._genStr = function(w) {
		var s = "dhxId_";
		var z = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
		for (var q=0; q<w; q++) s += z.charAt(Math.round(Math.random() * (z.length-1)));
		return s;
	}
	this.rootTypes = new Array("button", "buttonSelect", "buttonTwoState", "separator", "label", "slider", "text", "buttonInput");
	this.idPrefix = this._genStr(12);
	//
	
	window.dhx4._enableDataLoading(this, "_initObj", "_xmlToJson", "toolbar", {struct:true});
	window.dhx4._eventable(this);
	//
	// return obj if exists by tagname
	this._getObj = function(obj, tag) {
		var targ = null;
		for (var q=0; q<obj.childNodes.length; q++) {
			if (obj.childNodes[q].tagName != null) {
				if (String(obj.childNodes[q].tagName).toLowerCase() == String(tag).toLowerCase()) targ = obj.childNodes[q];
			}
		}
		return targ;
	}
	// create and return image object
	this._addImgObj = function(obj) {
		var imgObj = document.createElement(this.conf.icons_css==true?"I":"IMG");
		if (obj.childNodes.length > 0) obj.insertBefore(imgObj, obj.childNodes[0]); else obj.appendChild(imgObj);
		return imgObj;
	}
	// set/clear item image/imagedis
	this._setItemImage = function(item, url, dis) {
		if (dis == true) item.imgEn = url; else item.imgDis = url;
		if ((!item.state && dis == true) || (item.state && dis == false)) return;
		if (this.conf.icons_css == true) {
			var imgObj = this._getObj(item.obj, "i");
			if (imgObj == null) imgObj = this._addImgObj(item.obj);
			imgObj.className = this.conf.icons_path+url;
		} else {
			var imgObj = this._getObj(item.obj, "img");
			if (imgObj == null) imgObj = this._addImgObj(item.obj);
			imgObj.src = this.conf.icons_path+url;
		}
	}
	this._clearItemImage = function(item, dis) {
		if (dis == true) item.imgEn = ""; else item.imgDis = "";
		if ((!item.state && dis == true) || (item.state && dis == false)) return;
		var imgObj = this._getObj(item.obj, (this.conf.icons_css?"i":"img"));
		if (imgObj != null) imgObj.parentNode.removeChild(imgObj);
	}
	// set/get item text
	this._setItemText = function(item, text) {
		var txtObj = this._getObj(item.obj, "div");
		if (text == null || text.length == 0) {
			if (txtObj != null) txtObj.parentNode.removeChild(txtObj);
			return;
		}
		if (txtObj == null) {
			txtObj = document.createElement("DIV");
			txtObj.className = "dhxtoolbar_text";
			item.obj.appendChild(txtObj);
		}
		txtObj.innerHTML = text;
	}
	this._getItemText = function(item) {
		var txtObj = this._getObj(item.obj, "div");
		if (txtObj != null) return txtObj.innerHTML;
		return "";
	}
	
	// enable/disable btn
	this._enableItem = function(item) {
		if (item.state) return;
		item.state = true;
		if (this.objPull[item.id]["type"] == "buttonTwoState" && this.objPull[item.id]["obj"]["pressed"] == true) {
			item.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_pres";
			item.obj.renderAs = "dhx_toolbar_btn dhxtoolbar_btn_over";
		} else {
			item.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
			item.obj.renderAs = item.obj.className; 
		}
		if (item.arw) item.arw.className = String(item.obj.className).replace("btn","arw");
		var imgObj = this._getObj(item.obj, (this.conf.icons_css?"i":"img"));
		if (item.imgEn != "") {
			if (imgObj == null) imgObj = this._addImgObj(item.obj);
			imgObj[this.conf.icons_css?"className":"src"] = this.conf.icons_path+item.imgEn;
		} else {
			if (imgObj != null) imgObj.parentNode.removeChild(imgObj);
		}
	}
	this._disableItem = function(item) {
		if (!item.state) return;
		item.state = false;
		item.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(this.objPull[item.id]["type"]=="buttonTwoState"&&item.obj.pressed?"pres_":"")+"dis";
		item.obj.renderAs = "dhx_toolbar_btn dhxtoolbar_btn_def";
		if (item.arw) item.arw.className = String(item.obj.className).replace("btn","arw");
		var imgObj = this._getObj(item.obj, (this.conf.icons_css?"i":"img"));
		if (item.imgDis != "") {
			if (imgObj == null) imgObj = this._addImgObj(item.obj);
			imgObj[this.conf.icons_css?"className":"src"] = this.conf.icons_path+item.imgDis;
		} else {
			if (imgObj != null) imgObj.parentNode.removeChild(imgObj);
		}
		// if (this.objPull[item.id]["type"] == "buttonTwoState") this.objPull[item.id]["obj"]["pressed"] = false;
		// hide opened polygon if any
		if (item.polygon != null) {
			if (item.polygon.style.display != "none") {
				window.dhx4.zim.clear(item.polygon._idd);
				item.polygon.style.display = "none";
				if (item.polygon._ie6cover) item.polygon._ie6cover.style.display = "none";
				// fix border
				if (this.conf.skin == "dhx_terrace") this._improveTerraceButtonSelect(item.id, true);
				// event
				this.callEvent("onButtonSelectHide", [item.obj.idd]);
			}
		}
		this.anyUsed = null;
	}
	
	this.clearAll = function() {
		for (var a in this.objPull) this._removeItem(String(a).replace(this.idPrefix,""));
	}
	
	
	//
	this._doOnClick = function(e) {
		if (main_self && main_self.forEachItem) {
			main_self.forEachItem(function(itemId){
				if (main_self.objPull[main_self.idPrefix+itemId].type == "buttonSelect") {
					// hide any opened buttonSelect's polygons, clear selection if any
					var item = main_self.objPull[main_self.idPrefix+itemId];
					if (item.arw._skip === true) {
						item.arw._skip = false;
					} else if (item.polygon.style.display != "none") {
						item.obj.renderAs = "dhx_toolbar_btn dhxtoolbar_btn_def";
						item.obj.className = item.obj.renderAs;
						item.arw.className = String(item.obj.renderAs).replace("btn","arw");
						main_self.anyUsed = null;
						main_self.conf.touch_id = null;
						window.dhx4.zim.clear(item.polygon._idd);
						item.polygon.style.display = "none";
						if (item.polygon._ie6cover) item.polygon._ie6cover.style.display = "none";
						// fix border
						if (main_self.conf.skin == "dhx_terrace") main_self._improveTerraceButtonSelect(item.id, true);
						// event
						main_self.callEvent("onButtonSelectHide", [item.obj.idd]);
					}
				}
			});
		}
	}
	
	if (typeof(window.addEventListener) != "undefined") {
		window.addEventListener("mousedown", this._doOnClick, false);
		window.addEventListener("touchstart", this._doOnClick, false);
	} else {
		document.body.attachEvent("onmousedown", this._doOnClick);
	}
	
	if (this.conf.icons_size_autoload != null) {
		this.setIconSize(this.conf.icons_size_autoload);
		this.conf.icons_size_autoload = null;
	}
	
	if (this.conf.items_autoload != null) {
		this.loadStruct(this.conf.items_autoload, this.conf.onload_autoload);
		this.conf.items_autoload = null;
	} else if (this.conf.json_autoload != null) {
		this.loadStruct(this.conf.json_autoload, this.conf.onload_autoload);
		this.conf.json_autoload = null;
	} else if (this.conf.xml_autoload != null) {
		this.loadStruct(this.conf.xml_autoload, this.conf.onload_autoload);
		this.conf.xml_autoload = null;
	}
	
	if (this.conf.align_autostart != this.conf.align) {
		this.setAlign(this.conf.align_autostart);
		this.conf.align_autostart = null;
	}
	
	if (typeof(this.conf.auto_onclick) == "function") {
		this.attachEvent("onClick", this.conf.auto_onclick);
	} else if (typeof(this.conf.auto_onclick) == "string" && typeof(window[this.conf.auto_onclick]) == "function") {
		this.attachEvent("onClick", window[this.conf.auto_onclick]);
	}
	
	//
	return this;
}
dhtmlXToolbarObject.prototype.addSpacer = function(nextToId) {
	var nti = this.idPrefix+nextToId;
	if (this._spacer != null) {
		// spacer already at specified position
		if (this._spacer.idd == nextToId) return;
		// if current spacer contain nextToId item
		// move all items from first to nextToId to this.base
		if (this._spacer == this.objPull[nti].obj.parentNode) {
			var doMove = true;
			while (doMove) {
				var idd = this._spacer.childNodes[0].idd;
				this.base.appendChild(this._spacer.childNodes[0]);
				if (idd == nextToId || this._spacer.childNodes.length == 0) {
					if (this.objPull[nti].arw != null) this.base.appendChild(this.objPull[nti].arw);
					doMove = false;
				}
			}
			this._spacer.idd = nextToId;
			this._fixSpacer();
			return;
		}
		// if this.base contain nextToId item, move (insertBefore[0])
		if (this.base == this.objPull[nti].obj.parentNode) {
			var doMove = true;
			var chArw = (this.objPull[nti].arw!=null);
			while (doMove) {
				var q = this.base.childNodes.length-1;
				if (chArw == true) if (this.base.childNodes[q] == this.objPull[nti].arw) doMove = false;
				if (this.base.childNodes[q].idd == nextToId) doMove = false;
				if (doMove) { if (this._spacer.childNodes.length > 0) this._spacer.insertBefore(this.base.childNodes[q], this._spacer.childNodes[0]); else this._spacer.appendChild(this.base.childNodes[q]); }
			}
			this._spacer.idd = nextToId;
			this._fixSpacer();
			return;
		}
		
	} else {
		var np = null;
		for (var q=0; q<this.base.childNodes.length; q++) {
			if (this.base.childNodes[q] == this.objPull[this.idPrefix+nextToId].obj) {
				np = q;
				if (this.objPull[this.idPrefix+nextToId].arw != null) np = q+1;
			}
		}
		if (np != null) {
			this._spacer = document.createElement("DIV");
			this._spacer.className = (this.conf.align=="right"?" dhxtoolbar_float_left":" dhxtoolbar_float_right");
			this._spacer.dir = "ltr";
			this._spacer.idd = nextToId;
			while (this.base.childNodes.length > np+1) this._spacer.appendChild(this.base.childNodes[np+1]);
			this.cont.appendChild(this._spacer);
			this._fixSpacer();
		}
	}
	if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
}
dhtmlXToolbarObject.prototype.removeSpacer = function() {
	if (!this._spacer) return;
	while (this._spacer.childNodes.length > 0) this.base.appendChild(this._spacer.childNodes[0]);
	this._spacer.parentNode.removeChild(this._spacer);
	this._spacer = null;
	if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
}
dhtmlXToolbarObject.prototype._fixSpacer = function() {
	// IE icons mixing fix
	if (typeof(window.addEventListener) == "undefined" && this._spacer != null) {
		this._spacer.style.borderLeft = "1px solid #a4bed4";
		var k = this._spacer;
		window.setTimeout(function(){k.style.borderLeft="0px solid #a4bed4";k=null;},1);
	}
}

dhtmlXToolbarObject.prototype.getType = function(itemId) {
	var parentId = this.getParentId(itemId);
	if (parentId != null) {
		var typeExt = null;
		var itemData = this.objPull[this.idPrefix+parentId]._listOptions[itemId];
		if (itemData != null) if (itemData.sep != null) typeExt = "buttonSelectSeparator"; else typeExt = "buttonSelectButton";
		return typeExt;
	} else {
		if (this.objPull[this.idPrefix+itemId] == null) return null;
		return this.objPull[this.idPrefix+itemId]["type"];
	}
}

dhtmlXToolbarObject.prototype.getTypeExt = function(itemId) {
	var type = this.getType(itemId);
	if (type == "buttonSelectButton" || type == "buttonSelectSeparator") {
		if (type == "buttonSelectButton") type = "button"; else type = "separator";
		return type;
	}
	return null;
}
dhtmlXToolbarObject.prototype.inArray = function(array, value) {
	for (var q=0; q<array.length; q++) { if (array[q]==value) return true; }
	return false;
}
dhtmlXToolbarObject.prototype.getParentId = function(listId) {
	var parentId = null;
	for (var a in this.objPull) if (this.objPull[a]._listOptions) for (var b in this.objPull[a]._listOptions) if (b == listId) parentId = String(a).replace(this.idPrefix,"");
	return parentId;
}
/* adding items */
dhtmlXToolbarObject.prototype._addItem = function(itemData, pos) {
	if (typeof(itemData.text) == "string") {
		itemData.text = window.dhx4.trim(itemData.text);
		if (itemData.text.length == 0) itemData.text = null;
	}
	this._addItemToStorage(itemData, pos);
	if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
}

dhtmlXToolbarObject.prototype.addButton = function(id, pos, text, imgEnabled, imgDisabled) {
	this._addItem({id:id, type:"button", text:text, img:imgEnabled, imgdis:imgDisabled}, pos);
}

dhtmlXToolbarObject.prototype.addText = function(id, pos, text) {
	this._addItem({id:id,type:"text",text:text}, pos);
}

dhtmlXToolbarObject.prototype.addButtonSelect = function(id, pos, text, opts, imgEnabled, imgDisabled, renderSelect, openAll, maxOpen, mode) { 
	var options = [];
	for (var q=0; q<opts.length; q++) {
		var u = {};
		if (opts[q] instanceof Array) {
			u.id = opts[q][0];
			u.type = (opts[q][1]=="obj"?"button":"separator");
			u.text = (opts[q][2]||null);
			u.img = (opts[q][3]||null);
		} else if (opts[q] instanceof Object && opts[q] != null && typeof(opts[q].id) != "undefined" && typeof(opts[q].type) != "undefined") {
			u.id = opts[q].id;
			u.type = (opts[q].type=="obj"?"button":"separator");
			u.text = opts[q].text;
			u.img = opts[q].img;
		}
		options.push(u);
	}
	this._addItem({id:id, type:"buttonSelect", text:text, img:imgEnabled, imgdis:imgDisabled, renderSelect:renderSelect, openAll:openAll, options:options, maxOpen:maxOpen, mode:mode}, pos);
}

dhtmlXToolbarObject.prototype.addButtonTwoState = function(id, pos, text, imgEnabled, imgDisabled) {
	this._addItem({id:id, type:"buttonTwoState", img:imgEnabled, imgdis:imgDisabled, text:text}, pos);
}

dhtmlXToolbarObject.prototype.addSeparator = function(id, pos) {
	this._addItem({id:id,type:"separator"}, pos);
}

dhtmlXToolbarObject.prototype.addSlider = function(id, pos, len, valueMin, valueMax, valueNow, textMin, textMax, tip) {
	this._addItem({id:id, type:"slider", length:len, valueMin:valueMin, valueMax:valueMax, valueNow:valueNow, textMin:textMin, textMax:textMax, toolTip:tip}, pos);
}

dhtmlXToolbarObject.prototype.addInput = function(id, pos, value, width) {
	this._addItem({id:id,type:"buttonInput",value:value,width:width}, pos);
}

dhtmlXToolbarObject.prototype.forEachItem = function(handler) {
	for (var a in this.objPull) {
		if (this.inArray(this.rootTypes, this.objPull[a]["type"])) {
			handler(this.objPull[a]["id"].replace(this.idPrefix,""));
		}
	}
};
(function(){
	var list="isVisible,enableItem,disableItem,isEnabled,setItemText,getItemText,setItemToolTip,getItemToolTip,getInput,setItemImage,setItemImageDis,clearItemImage,clearItemImageDis,setItemState,getItemState,setItemToolTipTemplate,getItemToolTipTemplate,setValue,getValue,setMinValue,getMinValue,setMaxValue,getMaxValue,setWidth,getWidth,setMaxOpen".split(",")
	var ret=[false,"","",false,"","","","","","","","","",false,"","","",null,"",[null,null],"",[null,null],"",null]
	var functor=function(name,res){
		return function(itemId,a,b){
			itemId = this.idPrefix+itemId;
			if (this.objPull[itemId][name] != null) return this.objPull[itemId][name].call(this.objPull[itemId],a,b); else return res;
		};
	}
	for (var i=0; i<list.length; i++){
		var name=list[i];
		var res=ret[i];
		dhtmlXToolbarObject.prototype[name] = functor(name,res);
	}
})();

dhtmlXToolbarObject.prototype.showItem = function(itemId) {
	itemId = this.idPrefix+itemId;
	if (this.objPull[itemId] != null && this.objPull[itemId].showItem != null) {
		this.objPull[itemId].showItem();
		if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
	}
}

dhtmlXToolbarObject.prototype.hideItem = function(itemId) {
	itemId = this.idPrefix+itemId;
	if (this.objPull[itemId] != null && this.objPull[itemId].hideItem != null) {
		this.objPull[itemId].hideItem();
		if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
	}
}
dhtmlXToolbarObject.prototype.getPosition = function(itemId) {
	return this._getPosition(itemId);
}
dhtmlXToolbarObject.prototype._getPosition = function(id, getRealPosition) {
	
	if (this.objPull[this.idPrefix+id] == null) return null;
	
	var pos = null;
	var w = 0;
	for (var q=0; q<this.base.childNodes.length; q++) {
		if (this.base.childNodes[q].idd != null) {
			if (this.base.childNodes[q].idd == id) pos = w;
			w++;
		}
	}
	if (!pos && this._spacer != null) {
		for (var q=0; q<this._spacer.childNodes.length; q++) {
			if (this._spacer.childNodes[q].idd != null) {
				if (this._spacer.childNodes[q].idd == id) pos = w;
				w++;
			}
		}
	}
	return pos;
}

dhtmlXToolbarObject.prototype.setPosition = function(itemId, pos) {
	this._setPosition(itemId, pos);
}

dhtmlXToolbarObject.prototype._setPosition = function(id, pos) {
	
	if (this.objPull[this.idPrefix+id] == null) return;
	
	var spacerId = null;
	if (this._spacer) {
		spacerId = this._spacer.idd;
		this.removeSpacer();
	}
	
	if (isNaN(pos)) pos = this.base.childNodes.length;
	if (pos < 0) pos = 0;
	
	var item = this.objPull[this.idPrefix+id];
	this.base.removeChild(item.obj);
	if (item.arw) this.base.removeChild(item.arw);
	
	var newPos = this._getIdByPosition(pos, true);
	
	if (newPos[0] == null) {
		this.base.appendChild(item.obj);
		if (item.arw) this.base.appendChild(item.arw);
	} else {
		this.base.insertBefore(item.obj, this.base.childNodes[newPos[1]]);
		if (item.arw) this.base.insertBefore(item.arw, this.base.childNodes[newPos[1]+1]);
	}
	if (spacerId != null) this.addSpacer(spacerId);
	
}
dhtmlXToolbarObject.prototype._getIdByPosition = function(pos, retRealPos) {
	
	var id = null;
	var w = 0;
	var realPos = 0;
	for (var q=0; q<this.base.childNodes.length; q++) {
		if (this.base.childNodes[q]["idd"] != null && id == null) {
			if ((w++) == pos) id = this.base.childNodes[q]["idd"];
		}
		if (id == null) realPos++;
	}
	realPos = (id==null?null:realPos);
	return (retRealPos==true?new Array(id, realPos):id);
}

dhtmlXToolbarObject.prototype.removeItem = function(itemId) {
	this._removeItem(itemId);
	if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
};

dhtmlXToolbarObject.prototype._removeItem = function(itemId) {
	
	var t = this.getType(itemId);
	
	itemId = this.idPrefix+itemId;
	var p = this.objPull[itemId];
	
	
	if ({button:1, buttonTwoState:1}[t] == 1) {
		
		if (window.dhx4.isIE) p.obj.onselectstart = null;
		this._evs.clear.apply(p, [p.obj.evs, p.obj]);
		
		for (var a in p.obj) if (typeof(p.obj[a]) == "function") p.obj[a] = null;
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;
		
		for (var a in p) p[a] = null;
		
	}
	
	if (t == "buttonSelect") {
		
		for (var a in p._listOptions) this.removeListOption(itemId, a);
		p._listOptions = null;
		
		if (p.polygon._ie6cover) {
			document.body.removeChild(p.polygon._ie6cover);
			p.polygon._ie6cover = null;
		}
		
		p.p_tbl.removeChild(p.p_tbody);
		p.polygon.removeChild(p.p_tbl);
		p.polygon.onselectstart = null;
		document.body.removeChild(p.polygon);
		
		if (window.dhx4.isIE) {
			p.obj.onselectstart = null;
			p.arw.onselectstart = null;
		}
		this._evs.clear.apply(p, [p.obj.evs, p.obj]);
		this._evs.clear.apply(p, [p.arw.evs, p.arw]);
		
		for (var a in p.obj) if (typeof(p.obj[a]) == "function") p.obj[a] = null;
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;
		
		for (var a in p.arw) if (typeof(p.arw[a]) == "function") p.arw[a] = null;
		p.arw.parentNode.removeChild(p.arw);
		p.arw = null;
		
		for (var a in p) p[a] = null;
		
		
	}
	
	if (t == "buttonInput") {
		
		p.obj.childNodes[0].onkeydown = null;
		p.obj.removeChild(p.obj.childNodes[0]);
		
		p.obj.w = null;
		p.obj.idd = null;
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;
		
		p.id = null;
		p.type = null;
		
		p.enableItem = null;
		p.disableItem = null;
		p.isEnabled = null;
		p.showItem = null;
		p.hideItem = null;
		p.isVisible = null;
		p.setItemToolTip = null;
		p.getItemToolTip = null;
		p.setWidth = null;
		p.getWidth = null;
		p.setValue = null;
		p.getValue = null;
		p.setItemText = null;
		p.getItemText = null;
		
	}
	
	if (t == "slider") {
		
		if (window.dhx4.isIPad) {
			document.removeEventListener("touchmove", pen._doOnMouseMoveStart, false);
			document.removeEventListener("touchend", pen._doOnMouseMoveEnd, false);
		} else {
			if (typeof(window.addEventListener) == "function") {
				window.removeEventListener("mousemove", p.pen._doOnMouseMoveStart, false);
				window.removeEventListener("mouseup", p.pen._doOnMouseMoveEnd, false);
			} else {
				document.body.detachEvent("onmousemove", p.pen._doOnMouseMoveStart);
				document.body.detachEvent("onmouseup", p.pen._doOnMouseMoveEnd);
			}
		}
		
		p.pen.allowMove = null;
		p.pen.initXY = null;
		p.pen.maxX = null;
		p.pen.minX = null;
		p.pen.nowX = null;
		p.pen.newNowX = null;
		p.pen.valueMax = null;
		p.pen.valueMin = null;
		p.pen.valueNow = null;
		
		p.pen._definePos = null;
		p.pen._detectLimits = null;
		p.pen._doOnMouseMoveStart = null;
		p.pen._doOnMouseMoveEnd = null;
		p.pen.onmousedown = null;
		
		p.obj.removeChild(p.pen);
		p.pen = null;
		
		p.label.tip = null;
		document.body.removeChild(p.label);
		p.label = null;
		
		p.obj.onselectstart = null;
		p.obj.idd = null;
		while (p.obj.childNodes.length > 0) p.obj.removeChild(p.obj.childNodes[0]);
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;
		
		p.id = null;
		p.type = null;
		p.state = null;
		
		p.enableItem = null;
		p.disableItem = null;
		p.isEnabled = null;
		p.setItemToolTipTemplate = null;
		p.getItemToolTipTemplate = null;
		p.setMaxValue = null;
		p.setMinValue = null;
		p.getMaxValue = null;
		p.getMinValue = null;
		p.setValue = null;
		p.getValue = null;
		p.showItem = null;
		p.hideItem = null;
		p.isVisible = null;
		
	}
	
	if (t == "separator") {
		
		p.obj.onselectstart = null;
		p.obj.idd = null;
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;
		
		p.id = null;
		p.type = null;
		
		p.showItem = null;
		p.hideItem = null;
		p.isVisible = null;
		
	}
	
	if (t == "text") {
		
		p.obj.onselectstart = null;
		p.obj.idd = null;
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;
		
		p.id = null;
		p.type = null;
		
		p.showItem = null;
		p.hideItem = null;
		p.isVisible = null;
		p.setWidth = null;
		p.setItemText = null;
		p.getItemText = null;
		
	}
	
	t = null;
	p = null;
	this.objPull[this.idPrefix+itemId] = null;
	delete this.objPull[this.idPrefix+itemId];
	
	
};
//#tool_list:06062008{
(function(){
	var list="addListOption,removeListOption,showListOption,hideListOption,isListOptionVisible,enableListOption,disableListOption,isListOptionEnabled,setListOptionPosition,getListOptionPosition,setListOptionText,getListOptionText,setListOptionToolTip,getListOptionToolTip,setListOptionImage,getListOptionImage,clearListOptionImage,forEachListOption,getAllListOptions,setListOptionSelected,getListOptionSelected".split(",")
	var functor = function(name){
				return function(parentId,a,b,c,d,e){
				parentId = this.idPrefix+parentId;
				if (this.objPull[parentId] == null) return;
				if (this.objPull[parentId]["type"] != "buttonSelect") return;
				return this.objPull[parentId][name].call(this.objPull[parentId],a,b,c,d,e);
			}
		}
	for (var i=0; i<list.length; i++){
		var name=list[i];
		dhtmlXToolbarObject.prototype[name]=functor(name)
	}
})();

dhtmlXToolbarObject.prototype._rtlParseBtn = function(t1, t2) {
	return t1+t2;
}
/*****************************************************************************************************************************************************************
	object: separator
*****************************************************************************************************************************************************************/
dhtmlXToolbarObject.prototype._separatorObject = function(that, id, data) {
	//
	this.id = that.idPrefix+id;
	this.obj = document.createElement("DIV");
	this.obj.className = "dhx_toolbar_sep";
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.idd = String(id);
	this.obj.title = (data.title||"");
	this.obj.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	
	this.obj.ontouchstart = function(e){
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		e.cancelBubble = true;
		return false;
	}
	
	//
	// add object
	that.base.appendChild(this.obj);
	
	// functions
	this.showItem = function() {
		this.obj.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display == "");
	}
	//
	return this;
}
/*****************************************************************************************************************************************************************
	object: text
*****************************************************************************************************************************************************************/
dhtmlXToolbarObject.prototype._textObject = function(that, id, data) {
	this.id = that.idPrefix+id;
	this.obj = document.createElement("DIV");
	this.obj.className = "dhx_toolbar_text";
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.idd = String(id);
	this.obj.title = (data.title||"");
	this.obj.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	
	this.obj.ontouchstart = function(e){
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		e.cancelBubble = true;
		return false;
	}
	
	//
	this.obj.innerHTML = (data.text||"");
	//
	that.base.appendChild(this.obj);
	//
	this.showItem = function() {
		this.obj.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display == "");
	}
	this.setItemText = function(text) {
		this.obj.innerHTML = text;
	}
	this.getItemText = function() {
		return this.obj.innerHTML;
	}
	this.setWidth = function(width) {
		this.obj.style.width = width+"px";
	}
	this.setItemToolTip = function(t) {
		this.obj.title = t;
	}
	this.getItemToolTip = function() {
		return this.obj.title;
	}
	//
	return this;
}
/*****************************************************************************************************************************************************************
	object: button
******************************************************************************************************************************************************************/
dhtmlXToolbarObject.prototype._buttonObject = function(that, id, data) {
	
	this.id = that.idPrefix+id;
	this.state = (data.enabled!=null?false:true);
	this.imgEn = (data.img||"");
	this.imgDis = (data.imgdis||"");
	this.img = (this.state?(this.imgEn!=""?this.imgEn:""):(this.imgDis!=""?this.imgDis:""));
	
	//
	this.obj = document.createElement("DIV");
	this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(this.state?"def":"dis");
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.allowClick = false;
	this.obj.extAction = (data.action||null);
	this.obj.renderAs = this.obj.className;
	this.obj.idd = String(id);
	this.obj.title = (data.title||"");
	this.obj.pressed = false;
	//
	var img = (that.conf.icons_css?"<i class='"+that.conf.icons_path+this.img+"'></i>":"<img src='"+that.conf.icons_path+this.img+"'>");
	this.obj.innerHTML = that._rtlParseBtn((this.img!=""?img:""), (data.text!=null?"<div class='dhxtoolbar_text'>"+data.text+"</div>":""));
	
	// add object
	that.base.appendChild(this.obj);
	
	if (window.dhx4.isIE) {
		this.obj.onselectstart = function(e) {
			e = e||event;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			return false;
		}
	}
	
	var t = this;
	this._doOnMouseOver = function(e) {
		e = e||event;
		if (t.state == false || t.obj.pressed == true || t.obj.over == true) return;
		if (t.obj.className.match(/dhxtoolbar_btn_over/gi) == null) t.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_over";
		t.obj.over = true;
	}
	
	this._doOnMouseOut = function(e) {
		e = e||event;
		if (t.state == false) return;
		if (t.obj.className.match(/dhxtoolbar_btn_over/gi) != null) t.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
		t.obj.over = t.obj.pressed = false;
	}
	
	this._doOnMouseDown = function(e) {
		e = e||event;
		if (e.type == "touchstart") {
			if (e.preventDefault) e.preventDefault();
			e.cancelBubble = true;
			if (that.conf.touch_id != null && that.conf.touch_id != t.id) return; // multiple touches?
			that.conf.touch_id = t.id;
		}
		if (t.state == false) return;
		if (t.obj.className.match(/dhxtoolbar_btn_pres/gi) == null) t.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_pres";
		t.obj.pressed = true;
	}
	
	this._doOnMouseUp = function(e) {
		e = e||event;
		if (e.type == "touchend") {
			if (e.preventDefault) e.preventDefault();
			e.cancelBubble = true;
			if (that.conf.touch_id == t.id) that.conf.touch_id = null;
		}
		if (t.state == false || t.obj.pressed == false) return;
		if (t.obj.className.match(/dhxtoolbar_btn_pres/gi) != null) t.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(t.obj.over?"over":"def");
		t.obj.pressed = false;
		if (t.obj.extAction){window.setTimeout(function(){try{if(t&&t.obj)window[t.obj.extAction](t.id);}catch(e){}},1);}
		that.callEvent("onClick", [t.obj.idd.replace(that.idPrefix,"")]);
	}
	
	// add mouse events
	this.obj.evs = {
		mouseover: "_doOnMouseOver",
		mouseout: "_doOnMouseOut",
		mousedown: "_doOnMouseDown",
		mouseup: "_doOnMouseUp",
		touchstart: "_doOnMouseDown",
		touchend: "_doOnMouseUp"
	};
	
	that._evs.add.apply(this, [this.obj.evs, this.obj]);
	
	// functions
	this.enableItem = function() {
		that._enableItem(this);
	}
	this.disableItem = function() {
		that._disableItem(this);
	}
	this.isEnabled = function() {
		return this.state;
	}
	this.showItem = function() {
		this.obj.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display == "");
	}
	this.setItemText = function(text) {
		that._setItemText(this, text);
	}
	this.getItemText = function() {
		return that._getItemText(this);
	}
	this.setItemImage = function(url) {
		that._setItemImage(this, url, true);
	}
	this.clearItemImage = function() {
		that._clearItemImage(this, true);
	}
	this.setItemImageDis = function(url) {
		that._setItemImage(this, url, false);
	}
	this.clearItemImageDis = function() {
		that._clearItemImage(this, false);
	}
	this.setItemToolTip = function(tip) {
		this.obj.title = tip;
	}
	this.getItemToolTip = function() {
		return this.obj.title;
	}
	return this;
}

/******************************************************************************************************************************************************************
	object: buttonSelect
*******************************************************************************************************************************************************************/
dhtmlXToolbarObject.prototype._buttonSelectObject = function(that, id, data) {
	this.id = that.idPrefix+id;
	this.state = (data.enabled!=null?(data.enabled=="true"?true:false):true);
	this.imgEn = (data.img||"");
	this.imgDis = (data.imgdis||"");
	this.img = (this.state?(this.imgEn!=""?this.imgEn:""):(this.imgDis!=""?this.imgDis:""));
	
	this.mode = (data.mode||"button"); // button, select
	if (this.mode == "select") {
		this.openAll = true;
		this.renderSelect = false;
		if (!data.text||data.text.length==0) data.text = "&nbsp;"
	} else {
		this.openAll = (window.dhx4.s2b(data.openAll)==true);
		this.renderSelect = (data.renderSelect == null ? true : window.dhx4.s2b(data.renderSelect));
	}
	this.maxOpen = (!isNaN(data.maxOpen?data.maxOpen:"")?data.maxOpen:null);
	
	this._maxOpenTest = function() {
		if (!isNaN(this.maxOpen)) {
			if (!that._sbw) {
				var t = document.createElement("DIV");
				t.className = "dhxtoolbar_maxopen_test";
				document.body.appendChild(t);
				var k = document.createElement("DIV");
				k.className = "dhxtoolbar_maxopen_test2";
				t.appendChild(k);
				that._sbw = t.offsetWidth-k.offsetWidth;
				t.removeChild(k);
				k = null;
				document.body.removeChild(t);
				t = null;
			}
		}
	}
	this._maxOpenTest();
	
	//
	this.obj = document.createElement("DIV");
	this.obj.allowClick = false;
	this.obj.extAction = (data.action||null);
	this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(this.state?"def":"dis");
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.renderAs = this.obj.className;
	this.obj.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	this.obj.idd = String(id);
	this.obj.title = (data.title||"");
	this.obj.pressed = false;
	
	this.callEvent = false;
	
	
	var img = (that.conf.icons_css?"<i class='"+that.conf.icons_path+this.img+"'></i>":"<img src='"+that.conf.icons_path+this.img+"'>");
	this.obj.innerHTML = that._rtlParseBtn((this.img!=""?img:""),(data.text!=null?"<div class='dhxtoolbar_text'>"+data.text+"</div>":""));
	
	// add object
	that.base.appendChild(this.obj);
	
	this.arw = document.createElement("DIV");
	this.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_"+(this.state?"def":"dis");
	this.arw.style.display = this.obj.style.display;
	this.arw.innerHTML = "<div class='arwimg'>&nbsp;</div>";
	
	this.arw.title = this.obj.title;
	this.arw.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	that.base.appendChild(this.arw);
	
	var self = this;
	
	if (window.dhx4.isIE) {
		this.arw.onselectstart = this.obj.onselectstart = function(e) {
			e = e||event;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			return false;
		}
	}
	
	this._doOnMouseOver = function(e) {
		e = e||event;
		if (self.state == false || self.obj.over == true || that.anyUsed == self.obj.idd) return;
		if (self.obj.className.match(/dhxtoolbar_btn_over/gi) == null) {
			self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_over";
			self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_over";
		}
		self.obj.over = true;
	}
	
	this._doOnMouseOut = function(e) {
		e = e||event;
		if (self.state == false || that.anyUsed == self.obj.idd || that.anyUsed == self.obj.idd) return;
		if (self.obj.className.match(/dhxtoolbar_btn_over/gi) != null) {
			self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
			self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_def";
		}
		self.obj.over = self.obj.pressed = false;
	}
	
	this._doOnMouseDown = function(e) {
		e = e||event;
		if (e.type == "touchstart") {
			if (e.preventDefault) e.preventDefault();
			e.cancelBubble = true;
			if (that.conf.touch_id != null && that.conf.touch_id != self.id) return; // multiple touches?
			that.conf.touch_id = self.id;
		}
		if (self.state == false) return;
		
		if (that.anyUsed == self.obj.idd) {
			// hide polygon
			if (self.obj.over == true) {
				self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_over";
				self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_over";
			} else {
				self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
				self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_def";
			}
			self._hidePoly(true);
			that.anyUsed = null;
		} else {
			// show polygon
			var node = (e.target||e.srcElement);
			if (self.openAll == true || node == self.arw || node.parentNode == self.arw) {
				if (e.type == "touchstart") self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_over";
				self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_pres";
				self.arw._skip = true;
				self._showPoly(true);
				that.anyUsed = self.obj.idd;
			} else {
				if (self.obj.className.match(/dhxtoolbar_btn_pres/gi) == null) {
					self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_pres";
					self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_pres";
				}
				self.obj.pressed = true;
			}
		}
	}
	
	this._doOnMouseUp = function(e) {
		e = e||event;
		if (e.type == "touchend") {
			if (self.polygon.style.display == "") return;
			if (e.preventDefault) e.preventDefault();
			e.cancelBubble = true;
			if (that.conf.touch_id == self.id) that.conf.touch_id = null;
		}
		if (self.state == false || self.obj.pressed == false) return;
		if (self.obj.className.match(/dhxtoolbar_btn_pres/gi) != null) {
			self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(self.obj.over?"over":"def");
			self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_"+(self.obj.over?"over":"def");
		}
		// event
		if (this.extAction) {var k = this;window.setTimeout(function(){try{window[k.extAction](id);}catch(e){};k=null;},1);}
		that.callEvent("onClick", [self.obj.idd.replace(that.idPrefix,"")]);
	}
	
	// add mouse events
	this.arw.evs = {
		mouseover: "_doOnMouseOver",
		mouseout: "_doOnMouseOut",
		mousedown: "_doOnMouseDown",
		touchstart: "_doOnMouseDown"
	};
	that._evs.add.apply(this, [this.arw.evs, this.arw]);
	
	this.obj.evs = {
		mouseover: "_doOnMouseOver",
		mouseout: "_doOnMouseOut",
		mousedown: "_doOnMouseDown",
		mouseup: "_doOnMouseUp",
		touchstart: "_doOnMouseDown",
		touchend: "_doOnMouseUp"
	};
	that._evs.add.apply(this, [this.obj.evs, this.obj]);
	
	this._showPoly = function(callEvent) {
		// hide other if already opened
		if (that.anyUsed != null) {
			if (that.objPull[that.idPrefix+that.anyUsed].type == "buttonSelect") {
				var item = that.objPull[that.idPrefix+that.anyUsed];
				if (item.polygon.style.display != "none") {
					item.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
					item.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_def";
					item.obj.over = false;
					window.dhx4.zim.clear(item.polygon._idd);
					item.polygon.style.display = "none";
					if (item.polygon._ie6cover) item.polygon._ie6cover.style.display = "none";
					// fix border
					if (that.conf.skin == "dhx_terrace") that._improveTerraceButtonSelect(item.id, true);
					// event
					that.callEvent("onButtonSelectHide", [item.obj.idd]);
				}
			}
		}
		// show
		this.polygon.style.top = "0px";
		this.polygon.style.visibility = "hidden";
		this.polygon.style.zIndex = window.dhx4.zim.reserve(this.polygon._idd);
		this.polygon.style.display = "";
		// fix border
		if (that.conf.skin == "dhx_terrace") that._improveTerraceButtonSelect(this.id, false);
		// check maxOpen
		this._fixMaxOpenHeight(this.maxOpen||null);
		// detect overlay by Y axis
		that._autoDetectVisibleArea();
		// calculate top position
		var newTop = window.dhx4.absTop(this.obj)+this.obj.offsetHeight+that.conf.sel_ofs_y;
		var newH = this.polygon.offsetHeight;
		if (newTop + newH > that.tY2) {
			// if maxOpen mode enabled, check if at bottom at least one item can be shown
			// and show it, if no space - show on top. in maxOpen mode not enabled, show at top
			var k0 = (this.maxOpen!=null?Math.floor((that.tY2-newTop)/22):0); // k0 = count of items that can be visible
			if (k0 >= 1) {
				this._fixMaxOpenHeight(k0);
			} else {
				newTop = window.dhx4.absTop(this.obj)-newH-that.conf.sel_ofs_y;
				if (newTop < 0) newTop = 0;
			}
		}
		this.polygon.style.top = newTop+"px";
		// calculate left position
		if (that.rtl) {
			this.polygon.style.left = window.dhx4.absLeft(this.obj)+this.obj.offsetWidth-this.polygon.offsetWidth+that.conf.sel_ofs_x+"px";
		} else {
			var x1 = document.body.scrollLeft;
			var x2 = x1+(window.innerWidth||document.body.clientWidth);
			var newLeft = window.dhx4.absLeft(this.obj)+that.conf.sel_ofs_x;
			if (newLeft+this.polygon.offsetWidth > x2) newLeft = window.dhx4.absLeft(this.arw)+this.arw.offsetWidth-this.polygon.offsetWidth;
			this.polygon.style.left = Math.max(newLeft,5)+"px";
		}
		this.polygon.style.visibility = "visible";
		// show IE6 cover if needed
		if (this.polygon._ie6cover) {
			this.polygon._ie6cover.style.left = this.polygon.style.left;
			this.polygon._ie6cover.style.top = this.polygon.style.top;
			this.polygon._ie6cover.style.width = this.polygon.offsetWidth+"px";
			this.polygon._ie6cover.style.height = this.polygon.offsetHeight+"px";
			this.polygon._ie6cover.style.display = "";
		}
		// event, added in 4.5
		if (callEvent) that.callEvent("onButtonSelectShow", [this.obj.idd]);
	}
	
	this._hidePoly = function(callEvent) {
		window.dhx4.zim.clear(this.polygon._idd);
		this.polygon.style.display = "none";
		if (this.polygon._ie6cover) this.polygon._ie6cover.style.display = "none";
		// fix border
		if (that.conf.skin == "dhx_terrace") that._improveTerraceButtonSelect(this.id, true);
		if (callEvent) that.callEvent("onButtonSelectHide", [this.obj.idd]); // event, added in 4.5
		// reset touch event if any
		that.conf.touch_id = null;
	}
	
	this.obj.iddPrefix = that.idPrefix;
	this._listOptions = {};
	
	this._fixMaxOpenHeight = function(maxOpen) {
		var h = "auto";
		var h0 = false;
		if (maxOpen !== null) {
			var t = 0;
			for (var a in this._listOptions) t++;
			if (t > maxOpen) {
				this._ph = 22*maxOpen;
				h = this._ph+"px";
			} else {
				h0 = true;
			}
		}
		this.polygon.style.width = "auto";
		this.polygon.style.height = "auto";
		if (!h0 && self.maxOpen != null) {
			this.polygon.style.width = this.p_tbl.offsetWidth+that._sbw+"px";
			this.polygon.style.height = h;
		}
	}
	
	// inner objects: separator
	this._separatorButtonSelectObject = function(id, data, pos) {
		
		this.obj = {};
		this.obj.tr = document.createElement("TR");
		this.obj.tr.className = "tr_sep";
		this.obj.tr.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		this.obj.td = document.createElement("TD");
		this.obj.td.colSpan = "2";
		this.obj.td.className = "td_btn_sep";
		this.obj.td.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		
		if (isNaN(pos)) pos = self.p_tbody.childNodes.length+1; else if (pos < 1) pos = 1;
		if (pos > self.p_tbody.childNodes.length) self.p_tbody.appendChild(this.obj.tr); else self.p_tbody.insertBefore(this.obj.tr, self.p_tbody.childNodes[pos-1]);
		
		this.obj.tr.appendChild(this.obj.td);
		
		this.obj.sep = document.createElement("DIV");
		this.obj.sep.className = "btn_sep";
		this.obj.sep.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		this.obj.td.appendChild(this.obj.sep);
		
		self._listOptions[id] = this.obj;
		return this;
	}
	// inner objects: button
	this._buttonButtonSelectObject = function(id, data, pos) {
		
		var en = true;
		if (typeof(data.enabled) != "undefined") {
			en = window.dhx4.s2b(data.enabled);
		} else if (typeof(data.disabled) != "undefined") {
			en = window.dhx4.s2b(data.disabled);
		}
		
		this.obj = {};
		this.obj.tr = document.createElement("TR");
		this.obj.tr.en = en;
		this.obj.tr.extAction = (data.action||null);
		this.obj.tr._selected = (data.selected!=null);
		this.obj.tr.className = "tr_btn"+(this.obj.tr.en?(this.obj.tr._selected&&self.renderSelect?" tr_btn_selected":""):" tr_btn_disabled");
		this.obj.tr.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		this.obj.tr.idd = String(id);
		
		if (isNaN(pos)) pos = self.p_tbody.childNodes.length+1; else if (pos < 1) pos = 1;
		if (pos > self.p_tbody.childNodes.length) self.p_tbody.appendChild(this.obj.tr); else self.p_tbody.insertBefore(this.obj.tr, self.p_tbody.childNodes[pos-1]);
		
		this.obj.td_a = document.createElement("TD");
		this.obj.td_a.className = "td_btn_img";
		this.obj.td_a.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		this.obj.td_b = document.createElement("TD");
		this.obj.td_b.className = "td_btn_txt";
		this.obj.td_b.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		
		if (that.rtl) {
			this.obj.tr.appendChild(this.obj.td_b);
			this.obj.tr.appendChild(this.obj.td_a);
		} else {
			this.obj.tr.appendChild(this.obj.td_a);
			this.obj.tr.appendChild(this.obj.td_b);
		}
		
		// image
		if (data.img != null) {
			if (that.conf.icons_css == true) {
				this.obj.td_a.innerHTML = "<i class='"+that.conf.icons_path+data.img+"'></i>";
			} else {
				this.obj.td_a.innerHTML = "<img class='btn_sel_img' src='"+that.conf.icons_path+data.img+"' border='0'>";
			}
			this.obj.tr._img = data.img;
		} else {
			this.obj.td_a.innerHTML = "&nbsp;";
		}
		
		// text
		var itemText = (data.text!=null?data.text:(data.itemText||""));
		this.obj.td_b.innerHTML = "<div class='btn_sel_text'>"+itemText+"</div>";
		
		this.obj.tr.onmouseover = function(e) {
			e = e||event;
			if (e.type.match(/touch/) != null) return;
			if (!this.en || (this._selected && self.renderSelect)) return;
			this.className = "tr_btn tr_btn_over";
		}
		
		this.obj.tr.onmouseout = function(e) {
			e = e||event;
			if (e.type.match(/touch/) != null) return;
			if (!this.en) return;
			if (this._selected && self.renderSelect) {
				if (String(this.className).search("tr_btn_selected") == -1) this.className = "tr_btn tr_btn_selected";
			} else {
				this.className = "tr_btn";
			}
		}
		
		this.obj.tr.ontouchstart = this.obj.tr.onmousedown = function(e) {
			e = e||event;
			if (this._etype == null) this._etype = e.type;
		}
		this.obj.tr.onclick = function(e) {
			
			e = e||event;
			e.cancelBubble = true;
			if (!this.en) return;
			
			self.setListOptionSelected(this.idd.replace(that.idPrefix,""));
			
			self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
			self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_def";
			self.obj.over = false;
			
			if (this._etype != null && this._etype.match(/touch/) == null) {
				window.dhx4.zim.clear(self.polygon._idd);
				self.polygon.style.display = "none";
				if (self.polygon._ie6cover) self.polygon._ie6cover.style.display = "none";
			} else {
				var p = self.polygon;
				window.setTimeout(function(){
					window.dhx4.zim.clear(p._idd);
					p.style.display = "none";
					p = null;
				}, 500);
			}
			this._etype = null;
			
			// fix border
			if (that.conf.skin == "dhx_terrace") that._improveTerraceButtonSelect(self.id, true);
			that.anyUsed = null;
			that.conf.touch_id = null;
			// event
			that.callEvent("onButtonSelectHide", [self.obj.idd]);
			// event
			var id = this.idd.replace(that.idPrefix,"");
			if (this.extAction) try {window[this.extAction](id);} catch(e){};
			that.callEvent("onClick", [id]);
		}		
		self._listOptions[id] = this.obj;
		
		return this;
		
	}
	
	// add polygon
	this.polygon = document.createElement("DIV");
	this.polygon.dir = "ltr";
	this.polygon.style.display = "none";
	this.polygon.className = "dhx_toolbar_poly_"+that.conf.skin+" dhxtoolbar_icons_"+that.conf.iconSize+that.conf.cssShadow;
	this.polygon.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	this.polygon.onmousedown = function(e) { e = e||event; e.cancelBubble = true; }
	this.polygon.style.overflowY = "auto";
	this.polygon._idd = window.dhx4.newId();
	
	this.polygon.ontouchstart = function(e){
		e = e||event;
		e.cancelBubble = true;
	}
	this.polygon.ontouchend = function(e){
		e = e||event;
		e.cancelBubble = true;
	}
	
	this.p_tbl = document.createElement("TABLE");
	this.p_tbl.className = "buttons_cont";
	this.p_tbl.cellSpacing = "0";
	this.p_tbl.cellPadding = "0";
	this.p_tbl.border = "0";
	this.polygon.appendChild(this.p_tbl);
	
	this.p_tbody = document.createElement("TBODY");
	this.p_tbl.appendChild(this.p_tbody);
	
	//
	if (data.options != null) {
		for (var q=0; q<data.options.length; q++) {
			var t = "_"+(data.options[q].type||"")+"ButtonSelectObject";
			if (data.options[q].id == null) data.options[q].id = that._genStr(24);
			if (typeof(this[t]) == "function") new this[t](data.options[q].id, data.options[q]);
		}
	}
	
	document.body.appendChild(this.polygon);
	
	// add poly ie6cover
	if (window.dhx4.isIE6) {
		this.polygon._ie6cover = document.createElement("IFRAME");
		this.polygon._ie6cover.frameBorder = 0;
		this.polygon._ie6cover.style.position = "absolute";
		this.polygon._ie6cover.style.border = "none";
		this.polygon._ie6cover.style.backgroundColor = "#000000";
		this.polygon._ie6cover.style.filter = "alpha(opacity=100)";
		this.polygon._ie6cover.style.display = "none";
		this.polygon._ie6cover.setAttribute("src","javascript:false;");
		document.body.appendChild(this.polygon._ie6cover);
	}
	
	// functions
	// new engine
	this.setWidth = function(width) {
		this.obj.style.width = width-this.arw.offsetWidth+"px";
		this.polygon.style.width = this.obj.offsetWidth+this.arw.offsetWidth-2+"px";
		this.p_tbl.style.width = this.polygon.style.width;
	}
	this.enableItem = function() {
		that._enableItem(this);
	}
	this.disableItem = function() {
		that._disableItem(this);
	}
	this.isEnabled = function() {
		return this.state;
	}
	this.showItem = function() {
		this.obj.style.display = "";
		this.arw.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
		this.arw.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display == "");
	}
	this.setItemText = function(text) {
		that._setItemText(this, text);
	}
	this.getItemText = function() {
		return that._getItemText(this);
	}
	this.setItemImage = function(url) {
		that._setItemImage(this, url, true);
	}
	this.clearItemImage = function() {
		that._clearItemImage(this, true);
	}
	this.setItemImageDis = function(url) {
		that._setItemImage(this, url, false);
	}
	this.clearItemImageDis = function() {
		that._clearItemImage(this, false);
	}
	this.setItemToolTip = function(tip) {
		this.obj.title = tip;
		this.arw.title = tip;
	}
	this.getItemToolTip = function() {
		return this.obj.title;
	}
	/* list option functions */
	// new engine
	this.addListOption = function(id, pos, type, text, img) {
		if (!(type == "button" || type == "separator")) return;
		var dataItem = {id:id,type:type,text:text,img:img};
		new this["_"+type+"ButtonSelectObject"](id, dataItem, pos);
	}
	// new engine
	this.removeListOption = function(id) {
		if (!this._isListButton(id, true)) return;
		var item = this._listOptions[id];
		if (item.td_a != null && item.td_b != null) {
			// button
			item.td_a.onselectstart = null;
			item.td_b.onselectstart = null;
			while (item.td_a.childNodes.length > 0) item.td_a.removeChild(item.td_a.childNodes[0]);
			while (item.td_b.childNodes.length > 0) item.td_b.removeChild(item.td_b.childNodes[0]);
			item.tr.onselectstart = null;
			item.tr.onmouseover = null;
			item.tr.onmouseout = null;
			item.tr.onclick = null;
			item.tr.ontouchstart = null;
			item.tr.onmousedown = null;
			while (item.tr.childNodes.length > 0) item.tr.removeChild(item.tr.childNodes[0]);
			item.tr.parentNode.removeChild(item.tr);
			item.td_a = null;
			item.td_b = null;
			item.tr = null;
		} else {
			// separator
			item.sep.onselectstart = null;
			item.td.onselectstart = null;
			item.tr.onselectstart = null;
			while (item.td.childNodes.length > 0) item.td.removeChild(item.td.childNodes[0]);
			while (item.tr.childNodes.length > 0) item.tr.removeChild(item.tr.childNodes[0]);
			item.tr.parentNode.removeChild(item.tr);
			item.sep = null;
			item.td = null;
			item.tr = null;
		}
		item = null;
		this._listOptions[id] = null;
		try { delete this._listOptions[id]; } catch(e) {}
	}
	// new engine
	this.showListOption = function(id) {
		if (!this._isListButton(id, true)) return;
		this._listOptions[id].tr.style.display = "";
	}
	// new engine
	this.hideListOption = function(id) {
		if (!this._isListButton(id, true)) return;
		this._listOptions[id].tr.style.display = "none";
	}
	// new engine
	this.isListOptionVisible = function(id) {
		if (!this._isListButton(id, true)) return;
		return (this._listOptions[id].tr.style.display != "none");
	}
	// new engine
	this.enableListOption = function(id) {
		if (!this._isListButton(id)) return;
		this._listOptions[id].tr.en = true;
		this._listOptions[id].tr.className = "tr_btn"+(this._listOptions[id].tr._selected&&that.renderSelect?" tr_btn_selected":"");
	}
	// new engine
	this.disableListOption = function(id) {
		if (!this._isListButton(id)) return;
		this._listOptions[id].tr.en = false;
		this._listOptions[id].tr.className = "tr_btn tr_btn_disabled";
	}
	// new engine
	this.isListOptionEnabled = function(id) {
		if (!this._isListButton(id)) return;
		return this._listOptions[id].tr.en;
	}
	// new engine
	this.setListOptionPosition = function(id, pos) {
		if (!this._listOptions[id] || this.getListOptionPosition(id) == pos || isNaN(pos)) return;
		if (pos < 1) pos = 1;
		var tr = this._listOptions[id].tr;
		this.p_tbody.removeChild(tr);
		if (pos > this.p_tbody.childNodes.length) this.p_tbody.appendChild(tr); else this.p_tbody.insertBefore(tr, this.p_tbody.childNodes[pos-1]);
		tr = null;
	}
	// new engine
	this.getListOptionPosition = function(id) {
		var pos = -1;
		if (!this._listOptions[id]) return pos;
		for (var q=0; q<this.p_tbody.childNodes.length; q++) if (this.p_tbody.childNodes[q] == this._listOptions[id].tr) pos=q+1;
		return pos;
	}
	// new engine
	this.setListOptionImage = function(id, img) {
		if (!this._isListButton(id)) return;
		var td = this._listOptions[id].tr.childNodes[(that.rtl?1:0)];
		td.innerHTML = (that.conf.icons_css?"<i class='"+that.conf.icons_path+img+"'></i>":"<img src='"+that.conf.icons_path+img+"' class='btn_sel_img'>");
		td = null;
	}
	// new engine
	this.getListOptionImage = function(id) {
		if (!this._isListButton(id)) return;
		var td = this._listOptions[id].tr.childNodes[(that.rtl?1:0)];
		var src = null;
		if (td.childNodes.length > 0) src = td.childNodes[0][(that.conf.icons_css?"className":"src")];
		td = null;
		return src;
	}
	// new engine
	this.clearListOptionImage = function(id) {
		if (!this._isListButton(id)) return;
		var td = this._listOptions[id].tr.childNodes[(that.rtl?1:0)];
		while (td.childNodes.length > 0) td.removeChild(td.childNodes[0]);
		td.innerHTML = "&nbsp;";
		td = null;
	}
	// new engine
	this.setListOptionText = function(id, text) {
		if (!this._isListButton(id)) return;
		this._listOptions[id].tr.childNodes[(that.rtl?0:1)].childNodes[0].innerHTML = text;
	}
	// new engine
	this.getListOptionText = function(id) {
		if (!this._isListButton(id)) return;
		return this._listOptions[id].tr.childNodes[(that.rtl?0:1)].childNodes[0].innerHTML;
	}
	// new engine
	this.setListOptionToolTip = function(id, tip) {
		if (!this._isListButton(id)) return;
		this._listOptions[id].tr.title = tip;
	}
	// new engine
	this.getListOptionToolTip = function(id) {
		if (!this._isListButton(id)) return;
		return this._listOptions[id].tr.title;
	}
	// works
	this.forEachListOption = function(handler) {
		for (var a in this._listOptions) handler(a);
	}
	// works, return array with ids
	this.getAllListOptions = function() {
		var listData = new Array();
		for (var a in this._listOptions) listData[listData.length] = a;
		return listData;
	}
	// new engine
	this.setListOptionSelected = function(id) {
		for (var a in this._listOptions) {
			var item = this._listOptions[a];
			if (item.td_a != null && item.td_b != null && item.tr.en) {
				if (a == id) {
					item.tr._selected = true;
					item.tr.className = "tr_btn"+(this.renderSelect?" tr_btn_selected":"");
					//
					if (this.mode == "select") {
						if (item.tr._img) this.setItemImage(item.tr._img); else this.clearItemImage();
						this.setItemText(this.getListOptionText(id));
					}
				} else {
					item.tr._selected = false;
					item.tr.className = "tr_btn";
				}
			}
			item = null;
		}
	}
	// new engine
	this.getListOptionSelected = function() {
		var id = null;
		for (var a in this._listOptions) if (this._listOptions[a].tr._selected == true) id = a;
		return id;
	}
	// inner, return tru if list option is button and is exists
	this._isListButton = function(id, allowSeparator) {
		if (this._listOptions[id] == null) return false;
		if (!allowSeparator && this._listOptions[id].tr.className == "tr_sep") return false;
		return true;
	}
	
	this.setMaxOpen = function(r) {
		this._ph = null;
		if (typeof(r) == "number") {
			this.maxOpen = r;
			this._maxOpenTest();
			return;
		}
		this.maxOpen = null;
	}
	
	if (data.width) this.setWidth(data.width);
	
	if (this.mode == "select" && typeof(data.selected) != "undefined") this.setListOptionSelected(data.selected);
	
	//
	return this;
}

/*****************************************************************************************************************************************************************
	object: buttonInput
***************************************************************************************************************************************************************** */
dhtmlXToolbarObject.prototype._buttonInputObject = function(that, id, data) {
	//
	this.id = that.idPrefix+id;
	this.obj = document.createElement("DIV");
	this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.idd = String(id);
	this.obj.w = (data.width!=null?data.width:100);
	this.obj.title = (data.title!=null?data.title:"");
	//
	this.obj.innerHTML = "<input class='dhxtoolbar_input' type='text' style='width:"+this.obj.w+"px;'"+(data.value!=null?" value='"+data.value+"'":"")+">";
	
	var th = that;
	var self = this;
	this.obj.childNodes[0].onkeydown = function(e) {
		e = e||event;
		if (e.keyCode == 13) { th.callEvent("onEnter", [self.obj.idd, this.value]); }
	}
	// add
	that.base.appendChild(this.obj);
	//
	this.enableItem = function() {
		this.obj.childNodes[0].disabled = false;
	}
	this.disableItem = function() {
		this.obj.childNodes[0].disabled = true;
	}
	this.isEnabled = function() {
		return (!this.obj.childNodes[0].disabled);
	}
	this.showItem = function() {
		this.obj.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display != "none");
	}
	this.setValue = function(value) {
		this.obj.childNodes[0].value = value;
	}
	this.getValue = function() {
		return this.obj.childNodes[0].value;
	}
	this.setWidth = function(width) {
		this.obj.w = width;
		this.obj.childNodes[0].style.width = this.obj.w+"px";
	}
	this.getWidth = function() {
		return this.obj.w;
	}
	this.setItemToolTip = function(tip) {
		this.obj.title = tip;
	}
	this.getItemToolTip = function() {
		return this.obj.title;
	}
	this.getInput = function() {
		return this.obj.firstChild;
	}
	
	if (typeof(data.enabled) != "undefined" && window.dhx4.s2b(data.enabled) == false) {
		this.disableItem();
	}
	
	//
	return this;
}

/*****************************************************************************************************************************************************************
	object: buttonTwoState
***************************************************************************************************************************************************************** */
dhtmlXToolbarObject.prototype._buttonTwoStateObject = function(that, id, data) {
	this.id = that.idPrefix+id;
	this.state = (data.enabled!=null?false:true);
	this.imgEn = (data.img!=null?data.img:"");
	this.imgDis = (data.imgdis!=null?data.imgdis:"");
	this.img = (this.state?(this.imgEn!=""?this.imgEn:""):(this.imgDis!=""?this.imgDis:""));
	//
	this.obj = document.createElement("DIV");
	this.obj.pressed = (data.selected!=null);
	this.obj.extAction = (data.action||null);
	this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(this.obj.pressed?"pres"+(this.state?"":"_dis"):(this.state?"def":"dis"));
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.renderAs = this.obj.className;
	this.obj.idd = String(id);
	this.obj.title = (data.title||"");
	if (this.obj.pressed) { this.obj.renderAs = "dhx_toolbar_btn dhxtoolbar_btn_over"; }
	
	var img = (that.conf.icons_css?"<i class='"+that.conf.icons_path+this.img+"'></i>":"<img src='"+that.conf.icons_path+this.img+"'>");
	this.obj.innerHTML = that._rtlParseBtn((this.img!=""?img:""),(data.text!=null?"<div class='dhxtoolbar_text'>"+data.text+"</div>":""));
	
	// add object
	that.base.appendChild(this.obj);
	
	if (window.dhx4.isIE) {
		this.obj.onselectstart = function(e) {
			e = e||event;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			return false;
		}
	}
	
	var t = this;
	this._doOnMouseOver = function(e) {
		e = e||event;
		if (t.state == false || t.obj.over == true) return;
		if (t.obj.pressed != true && t.obj.className.match(/dhxtoolbar_btn_over/gi) == null) t.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_over";
		t.obj.over = true;
	}
	
	this._doOnMouseOut = function(e) {
		e = e||event;
		if (t.state == false) return;
		if (t.obj.pressed != true && t.obj.className.match(/dhxtoolbar_btn_over/gi) != null) t.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
		t.obj.over = false;
	}
	
	this._doOnMouseDown = function(e) {
		e = e||event;
		if (e.type == "touchstart") {
			if (e.preventDefault) e.preventDefault();
			e.cancelBubble = true;
			if (that.conf.touch_id != null && that.conf.touch_id != t.id) return; // multiple touches?
			that.conf.touch_id = t.id;
		}
		if (t.state == false) return;
		if (that.callEvent("onBeforeStateChange", [t.obj.idd.replace(that.idPrefix, ""), t.obj.pressed]) !== true) return;
		t.obj.pressed = !t.obj.pressed;
		t.obj.className = "dhx_toolbar_btn " + (t.obj.pressed == true ? "dhxtoolbar_btn_pres" : (t.obj.over == true? "dhxtoolbar_btn_over" : "dhxtoolbar_btn_def"));
		//
		var id = t.obj.idd.replace(that.idPrefix, "");
		if (t.obj.extAction) try {window[t.obj.extAction](idd, t.obj.pressed);} catch(e){};
		that.callEvent("onStateChange", [id, t.obj.pressed]);
	}
	this._doOnMouseUp = function(e) {
		e = e||event;
		if (e.type == "touchend") {
			if (e.preventDefault) e.preventDefault();
			e.cancelBubble = true;
			if (that.conf.touch_id == t.id) that.conf.touch_id = null;
		}
	}
	
	
	// mouse events
	this.obj.evs = {
		mouseover: "_doOnMouseOver",
		mouseout: "_doOnMouseOut",
		mousedown: "_doOnMouseDown",
		touchstart: "_doOnMouseDown",
		touchend: "_doOnMouseUp"
	};
	
	that._evs.add.apply(this, [this.obj.evs, this.obj]);
	
	// functions
	this.setItemState = function(state, callEvent) {
		if (this.obj.pressed != state) {
			if (state == true) {
				this.obj.pressed = true;
				this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_pres"+(this.state?"":"_dis");
			} else {
				this.obj.pressed = false;
				this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(this.state?"def":"dis");
			}
			if (callEvent == true) {
				var id = this.obj.idd.replace(that.idPrefix, "");
				if (this.obj.extAction) try {window[this.obj.extAction](id, this.obj.pressed);} catch(e){};
				that.callEvent("onStateChange", [id, this.obj.pressed]);
			}
		}
	}
	this.getItemState = function() {
		return this.obj.pressed;
	}
	this.enableItem = function() {
		that._enableItem(this);
	}
	this.disableItem = function() {
		that._disableItem(this);
	}
	this.isEnabled = function() {
		return this.state;
	}
	this.showItem = function() {
		this.obj.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display == "");
	}
	this.setItemText = function(text) {
		that._setItemText(this, text);
	}
	this.getItemText = function() {
		return that._getItemText(this);
	}
	this.setItemImage = function(url) {
		that._setItemImage(this, url, true);
	}
	this.clearItemImage = function() {
		that._clearItemImage(this, true);
	}
	this.setItemImageDis = function(url) {
		that._setItemImage(this, url, false);
	}
	this.clearItemImageDis = function() {
		that._clearItemImage(this, false);
	}
	this.setItemToolTip = function(tip) {
		this.obj.title = tip;
	}
	this.getItemToolTip = function() {
		return this.obj.title;
	}
	//
	return this;
}

/*****************************************************************************************************************************************************************
	object: slider
***************************************************************************************************************************************************************** */
dhtmlXToolbarObject.prototype._sliderObject = function(that, id, data) {
	this.id = that.idPrefix+id;
	this.state = (data.enabled!=null?(data.enabled=="true"?true:false):true);
	this.obj = document.createElement("DIV");
	this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(this.state?"def":"dis");
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	this.obj.idd = String(id);
	this.obj.len = (data.length!=null?Number(data.length):50);
	//
	this.obj.innerHTML = "<div class='dhxtoolbar_text'>"+(data.textMin||"")+"</div>"+
				"<div class='dhxtoolbar_sl_bg_l'></div>"+
				"<div class='dhxtoolbar_sl_bg_m' style='width:"+this.obj.len+"px;'></div>"+
				"<div class='dhxtoolbar_sl_bg_r'></div>"+
				"<div class='dhxtoolbar_text'>"+(data.textMax||"")+"</div>";
	// add object
	that.base.appendChild(this.obj);
	var self = this;
	
	this.pen = document.createElement("DIV");
	this.pen.className = "dhxtoolbar_sl_pen";
	this.obj.appendChild(this.pen);
	var pen = this.pen;
	
	this.label = document.createElement("DIV");
	this.label.dir = "ltr";
	this.label.className = "dhx_toolbar_slider_label_"+that.conf.skin+(that.rtl?"_rtl":"");
	this.label.style.display = "none";
	this.label.tip = (data.toolTip||"%v");
	this.label._zi = window.dhx4.newId();
	document.body.appendChild(this.label);
	var label = this.label;
	
	// mix-max value
	this.pen.valueMin = (data.valueMin!=null?Number(data.valueMin):0);
	this.pen.valueMax = (data.valueMax!=null?Number(data.valueMax):100);
	if (this.pen.valueMin > this.pen.valueMax) this.pen.valueMin = this.pen.valueMax;
	
	// init value
	this.pen.valueNow = (data.valueNow!=null?Number(data.valueNow):this.pen.valueMax);
	if (this.pen.valueNow > this.pen.valueMax) this.pen.valueNow = this.pen.valueMax;
	if (this.pen.valueNow < this.pen.valueMin) this.pen.valueNow = this.pen.valueMin;
	
	// min/max x coordinate
	this.pen._detectLimits = function() {
		this.minX = self.obj.childNodes[1].offsetLeft+2;
		this.maxX = self.obj.childNodes[3].offsetLeft-this.offsetWidth+1;
	}
	this.pen._detectLimits();
	
	// position
	this.pen._definePos = function() {
		this.nowX = Math.round((this.valueNow-this.valueMin)*(this.maxX-this.minX)/(this.valueMax-this.valueMin)+this.minX);
		this.style.left = this.nowX+"px";
		this.newNowX = this.nowX;
	}
	this.pen._definePos();

	this.pen.initXY = 0;
	this.pen.allowMove = false;
	this.pen[window.dhx4.isIPad?"ontouchstart":"onmousedown"] = function(e) {
		if (self.state == false) return;
		e = e||event;
		this.initXY = (window.dhx4.isIPad?e.touches[0].clientX:e.clientX); //e.clientX;
		this.newValueNow = this.valueNow;
		this.allowMove = true;
		this.className = "dhxtoolbar_sl_pen dhxtoolbar_over";
		if (label.tip != "") {
			label.style.visibility = "hidden";
			label.style.display = "";
			label.innerHTML = label.tip.replace("%v", this.valueNow);
			label.style.left = Math.round(window.dhx4.absLeft(this)+this.offsetWidth/2-label.offsetWidth/2)+"px";
			label.style.top = window.dhx4.absTop(this)-label.offsetHeight-3+"px";
			label.style.visibility = "";
			label.style.zIndex = window.dhx4.zim.reserve(label._zi);
		}
	}
	
	this.pen._doOnMouseMoveStart = function(e) {
		// optimized for destructor
		e=e||event;
		if (!pen.allowMove) return;
		var ecx = (window.dhx4.isIPad?e.touches[0].clientX:e.clientX);
		var ofst = ecx - pen.initXY;
		
		// mouse goes out to left/right from pen
		if (ecx < window.dhx4.absLeft(pen)+Math.round(pen.offsetWidth/2) && pen.nowX == pen.minX) return;
		if (ecx > window.dhx4.absLeft(pen)+Math.round(pen.offsetWidth/2) && pen.nowX == pen.maxX) return;
		
		pen.newNowX = pen.nowX + ofst;
		
		if (pen.newNowX < pen.minX) pen.newNowX = pen.minX;
		if (pen.newNowX > pen.maxX) pen.newNowX = pen.maxX;
		pen.nowX = pen.newNowX;
		pen.style.left = pen.nowX+"px";
		pen.initXY = ecx;
		pen.newValueNow = Math.round((pen.valueMax-pen.valueMin)*(pen.newNowX-pen.minX)/(pen.maxX-pen.minX)+pen.valueMin);
		if (label.tip != "") {
			label.innerHTML = label.tip.replace(/%v/gi, pen.newValueNow);
			label.style.left = Math.round(window.dhx4.absLeft(pen)+pen.offsetWidth/2-label.offsetWidth/2)+"px";
			label.style.top = window.dhx4.absTop(pen)-label.offsetHeight-3+"px";
		}
		e.cancelBubble = true;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		return false;
	}
	this.pen._doOnMouseMoveEnd = function() {
		if (!pen.allowMove) return;
		pen.className = "dhxtoolbar_sl_pen";
		pen.allowMove = false;
		pen.nowX = pen.newNowX;
		pen.valueNow = pen.newValueNow;
		if (label.tip != "") {
			label.style.display = "none";
			window.dhx4.zim.clear(label._zi);
		}
		that.callEvent("onValueChange", [self.obj.idd.replace(that.idPrefix, ""), pen.valueNow]);
	}
	
	if (window.dhx4.isIPad) {
		document.addEventListener("touchmove", pen._doOnMouseMoveStart, false);
		document.addEventListener("touchend", pen._doOnMouseMoveEnd, false);
	} else {
		if (typeof(window.addEventListener) != "undefined") {
			window.addEventListener("mousemove", pen._doOnMouseMoveStart, false);
			window.addEventListener("mouseup", pen._doOnMouseMoveEnd, false);
		} else {
			document.body.attachEvent("onmousemove", pen._doOnMouseMoveStart);
			document.body.attachEvent("onmouseup", pen._doOnMouseMoveEnd);
		}
	}
	// functions
	this.enableItem = function() {
		if (this.state) return;
		this.state = true;
		this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
	}
	this.disableItem = function() {
		if (!this.state) return;
		this.state = false;
		this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_dis";
	}
	this.isEnabled = function() {
		return this.state;
	}
	this.showItem = function() {
		this.obj.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display == "");
	}
	this.setValue = function(value, callEvent) {
		value = Number(value);
		if (value < this.pen.valueMin) value = this.pen.valueMin;
		if (value > this.pen.valueMax) value = this.pen.valueMax;
		this.pen.valueNow = value;
		this.pen._definePos();
		if (callEvent == true) that.callEvent("onValueChange", [this.obj.idd.replace(that.idPrefix, ""), this.pen.valueNow]);
	}
	this.getValue = function() {
		return this.pen.valueNow;
	}
	this.setMinValue = function(value, label) {
		value = Number(value);
		if (value > this.pen.valueMax) return;
		this.obj.childNodes[0].innerHTML = label;
		this.obj.childNodes[0].style.display = (label.length>0?"":"none");
		this.pen.valueMin = value;
		if (this.pen.valueNow < this.pen.valueMin) this.pen.valueNow = this.pen.valueMin;
		this.pen._detectLimits();
		this.pen._definePos();
	}
	this.setMaxValue = function(value, label) {
		value = Number(value);
		if (value < this.pen.valueMin) return;
		this.obj.childNodes[4].innerHTML = label;
		this.obj.childNodes[4].style.display = (label.length>0?"":"none");
		this.pen.valueMax = value;
		if (this.pen.valueNow > this.pen.valueMax) this.pen.valueNow = this.pen.valueMax;
		this.pen._detectLimits();
		this.pen._definePos();
	}
	this.getMinValue = function() {
		var label = this.obj.childNodes[0].innerHTML;
		var value = this.pen.valueMin;
		return new Array(value, label);
	}
	this.getMaxValue = function() {
		var label = this.obj.childNodes[4].innerHTML;
		var value = this.pen.valueMax;
		return new Array(value, label);
	}
	this.setItemToolTipTemplate = function(template) {
		this.label.tip = template;
	}
	this.getItemToolTipTemplate = function() {
		return this.label.tip;
	}
	//
	return this;
}

dhtmlXToolbarObject.prototype.unload = function() {
	
	if (typeof(window.addEventListener) == "function") {
		window.removeEventListener("mousedown", this._doOnClick, false);
		window.removeEventListener("touchstart", this._doOnClick, false);
	} else {
		document.body.detachEvent("onmousedown", this._doOnClick);
	}
	
	this._doOnClick = null;
	
	this.clearAll();
	this.objPull = null;
	
	if (this._xmlLoader) {
		this._xmlLoader.destructor();
		this._xmlLoader = null;
	}
	
	while (this.base.childNodes.length > 0) this.base.removeChild(this.base.childNodes[0]);
	this.cont.removeChild(this.base);
	this.base = null;
	
	while (this.cont.childNodes.length > 0) this.cont.removeChild(this.cont.childNodes[0]);
	this.cont.className = "";
	this.cont = null;
	
	window.dhx4._enableDataLoading(this, null, null, null, "clear");
	window.dhx4._eventable(this, "clear");
	
	this.tX1 = null;
	this.tX2 = null;
	this.tY1 = null;
	this.tY2 = null;
	
	this.anyUsed = null;
	this.idPrefix = null;
	this.rootTypes = null;
	
	this._rtl = null;
	this._rtlParseBtn = null;
	this.setRTL = null;
	
	this._sbw = null;
	this._getObj = null;
	this._addImgObj = null;
	this._setItemImage = null;
	this._clearItemImage = null;
	this._setItemText = null;
	this._getItemText = null;
	this._enableItem = null;
	this._disableItem = null;
	this._xmlParser = null;
	
	this._addItemToStorage = null;
	this._genStr = null;
	this._addItem = null;
	this._getPosition = null;
	this._setPosition = null;
	this._getIdByPosition = null;
	this._separatorObject = null;
	this._textObject = null;
	this._buttonObject = null;
	this._buttonSelectObject = null;
	this._buttonInputObject = null;
	this._buttonTwoStateObject = null;
	this._sliderObject = null;
	this._autoDetectVisibleArea = null;
	this._removeItem = null;
	this.setAlign = null;
	this.setSkin = null;
	this.setIconsPath = null;
	this.setIconPath = null;
	this.loadXML = null;
	this.loadXMLString = null;
	this.clearAll = null;
	this.addSpacer = null;
	this.removeSpacer = null;
	this.getType = null;
	this.getTypeExt = null;
	this.inArray = null;
	this.getParentId = null;
	this.addButton = null;
	this.addText = null;
	this.addButtonSelect = null;
	this.addButtonTwoState = null;
	this.addSeparator = null;
	this.addSlider = null;
	this.addInput = null;
	this.forEachItem = null;
	this.showItem = null;
	this.hideItem = null;
	this.isVisible = null;
	this.enableItem = null;
	this.disableItem = null;
	this.isEnabled = null;
	this.setItemText = null;
	this.getItemText = null;
	this.setItemToolTip = null;
	this.getItemToolTip = null;
	this.setItemImage = null;
	this.setItemImageDis = null;
	this.clearItemImage = null;
	this.clearItemImageDis = null;
	this.setItemState = null;
	this.getItemState = null;
	this.setItemToolTipTemplate = null;
	this.getItemToolTipTemplate = null;
	this.setValue = null;
	this.getValue = null;
	this.setMinValue = null;
	this.getMinValue = null;
	this.setMaxValue = null;
	this.getMaxValue = null;
	this.setWidth = null;
	this.getWidth = null;
	this.getPosition = null;
	this.setPosition = null;
	this.removeItem = null;
	this.addListOption = null;
	this.removeListOption = null;
	this.showListOption = null;
	this.hideListOption = null;
	this.isListOptionVisible = null;
	this.enableListOption = null;
	this.disableListOption = null;
	this.isListOptionEnabled = null;
	this.setListOptionPosition = null;
	this.getListOptionPosition = null;
	this.setListOptionText = null;
	this.getListOptionText = null;
	this.setListOptionToolTip = null;
	this.getListOptionToolTip = null;
	this.setListOptionImage = null;
	this.getListOptionImage = null;
	this.clearListOptionImage = null;
	this.forEachListOption = null;
	this.getAllListOptions = null;
	this.setListOptionSelected = null;
	this.getListOptionSelected = null;
	this.unload = null;
	this.setUserData = null;
	this.getUserData = null;
	this.setMaxOpen = null;
	this.items = null;
	this.conf = null;
};

dhtmlXToolbarObject.prototype._autoDetectVisibleArea = function() {
	var d = window.dhx4.screenDim();
	this.tX1 = d.left;
	this.tX2 = d.right;
	this.tY1 = d.top;
	this.tY2 = d.bottom;
};

dhtmlXToolbarObject.prototype.setIconset = function(name) {
	this.conf.icons_css = (name=="awesome");
};
dhtmlXToolbarObject.prototype._evs = {
	add: function(evs, obj) { // this->calle
		for (var a in evs) {
			if (typeof(window.addEventListener) == "function") {
				obj.addEventListener(a, this[evs[a]], false);
			} else if (a.match(/^touch/) == null) {
				obj.attachEvent("on"+a, this[evs[a]]);
			}
		}
		obj = evs = null;
	},
	clear: function(evs, obj) {
		for (var a in evs) {
			if (typeof(window.addEventListener) == "function") {
				obj.removeEventListener(a, this[evs[a]], false);
			} else if (a.match(/^touch/) == null) {
				obj.detachEvent("on"+a, this[evs[a]]);
			}
		}
		obj = evs = null;
	}
};
dhtmlXToolbarObject.prototype._initObj = function(data) {
	for (var q=0; q<data.length; q++) this._addItemToStorage(data[q]);
	if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
};

dhtmlXToolbarObject.prototype._xmlToJson = function(xml) {
	
	var data = [];
	var root = xml.getElementsByTagName("toolbar");
	
	if (root != null && root[0] != null) {
		
		root = root[0];
		
		var getExtText = function(node) {
			var t = null;
			for (var q=0; q<node.childNodes.length; q++) {
				if (t == null && node.childNodes[q].tagName == "itemText") {
					t = window.dhx4._xmlNodeValue(node.childNodes[q]);
					break;
				}
			}
			return t;
		}
		
		var t = ["id", "type", "hidden", "title", "text", "enabled", "img", "imgdis", "action", "openAll", "renderSelect", "mode", "maxOpen", "width", "value", "selected", "length", "textMin", "textMax", "toolTip", "valueMin", "valueMax", "valueNow"];
		var p = ["id", "type", "enabled", "disabled", "action", "selected", "img", "text"];
		//
		for (var q=0; q<root.childNodes.length; q++) {
			if (root.childNodes[q].tagName == "item") {
				
				var itemData = {};
				for (var w=0; w<t.length; w++) {
					var val = root.childNodes[q].getAttribute(t[w]);
					if (val != null) itemData[t[w]] = val;
				}
				
				for (var e=0; e<root.childNodes[q].childNodes.length; e++) {
					if (root.childNodes[q].childNodes[e].tagName == "item" && itemData.type == "buttonSelect") {
						var u = {};
						for (var w=0; w<p.length; w++) {
							var val = root.childNodes[q].childNodes[e].getAttribute(p[w]);
							if (val != null) u[p[w]] = val;
						}
						// listed options userdata
						var h = root.childNodes[q].childNodes[e].getElementsByTagName("userdata");
						for (var w=0; w<h.length; w++) {
							if (!u.userdata) u.userdata = {};
							var r = {};
							try { r.name = h[w].getAttribute("name"); } catch(k) { r.name = null; }
							try { r.value = h[w].firstChild.nodeValue; } catch(k) { r.value = ""; }
							if (r.name != null) u.userdata[r.name] = r.value;
						}
						// get extended <itemText>
						u.text = getExtText(root.childNodes[q].childNodes[e])||u.text;
						//
						if (itemData.options == null) itemData.options = [];
						itemData.options.push(u);
					}
					
					// items userdata
					if (root.childNodes[q].childNodes[e].tagName == "userdata") {
						if (itemData.userdata == null) itemData.userdata = {};
						var u = {};
						try { u.name = root.childNodes[q].childNodes[e].getAttribute("name"); } catch(k) { u.name = null; }
						try { u.value = root.childNodes[q].childNodes[e].firstChild.nodeValue; } catch(k) { u.value = ""; }
						if (u.name != null) itemData.userdata[u.name] = u.value;
					}
				}
				
				// get extended <itemText>
				itemData.text = getExtText(root.childNodes[q])||itemData.text;
				
				data.push(itemData);
			}
		}
		
		getExtText = null;
	}
	
	return data;
};

dhtmlXToolbarObject.prototype._addItemToStorage = function(data, pos) {
	
	var id = (data.id||this._genStr(24));
	var type = (data.type||"");
	
	if (type == "spacer") {
		this.addSpacer(this._lastId);
	} else {
		this._lastId = id;
	}
	
	if (type != "" && this["_"+type+"Object"] != null) {
		
		if (type == "buttonSelect") {
			if (data.options != null) {
				for (var q=0; q<data.options.length; q++) { // js-array button select init used obj/sep
					if (data.options[q].type == "obj") data.options[q].type = "button";
					if (data.options[q].type == "sep") data.options[q].type = "separator";
				}
			}
		}
		
		if (type == "slider") {
			var k = {
				tip_template: "toolTip",
				value_min: "valueMin",
				value_max: "valueMax",
				value_now: "valueNow",
				text_min: "textMin",
				text_max: "textMax"
			};
			for (var a in k) {
				if (data[k[a]] == null && data[a] != null) data[k[a]] = data[a];
			}
		}
		
		if (type == "buttonInput") {
			if (data.value == null && data.text != null) data.value = data.text;
		}
		
		if (type == "buttonTwoState") {
			if (typeof(data.selected) == "undefined" && typeof(data.pressed) != "undefined" && window.dhx4.s2b(data.pressed)) {
				data.selected = true;
			}
		}
		
		// common
		if (typeof(data.enabled) == "undefined" && typeof(data.disabled) != "undefined" && window.dhx4.s2b(data.disabled)) {
			data.enabled = false;
		}
		if (data.imgDis == null && data.img_disabled != null) {
			data.imgdis = data.img_disabled;
		}
		
		if ((typeof(data.openAll) == "undefined" || data.openAll == null) && this.conf.skin == "dhx_terrace") data.openAll = true;
		this.objPull[this.idPrefix+id] = new this["_"+type+"Object"](this, id, data);
		this.objPull[this.idPrefix+id]["type"] = type;
		this.setPosition(id, pos);
	}
	
	// userdata
	if (data.userdata != null) {
		for (var a in data.userdata) this.setUserData(id, a, data.userdata[a]);
	}
	// userdata for options
	if (data.options != null) {
		for (var q=0; q<data.options.length; q++) {
			if (data.options[q].userdata != null) {
				for (var a in data.options[q].userdata) {
					this.setListOptionUserData(data.id, data.options[q].id, a, data.options[q].userdata[a]);
				}
			}
		}
	}

};

// skin
dhtmlXToolbarObject.prototype.setSkin = function(skin, onlyIcons) {
	if (onlyIcons === true) {
		// prevent of removing skin postfixes when attached to layout/acc/etc
		this.cont.className = this.cont.className.replace(/dhxtoolbar_icons_\d{1,}/,"dhxtoolbar_icons_"+this.conf.iconSize);
	} else {
		this.conf.skin = skin;
		if (this.conf.skin == "dhx_skyblue") {
			this.conf.sel_ofs_y = 1;
		}
		if (this.conf.skin == "dhx_web") {
			this.conf.sel_ofs_y = 1;
			this.conf.sel_ofs_x = 1;
		}
		if (this.conf.skin == "dhx_terrace") {
			this.conf.sel_ofs_y = -1;
			this.conf.sel_ofs_x = 0;
		}
		if (this.conf.skin == "material") {
			this.conf.sel_ofs_y = -1;
			this.conf.sel_ofs_x = 0;
		}
		this.cont.className = "dhx_toolbar_"+this.conf.skin+" dhxtoolbar_icons_"+this.conf.iconSize+this.conf.cssShadow;
	}
	
	for (var a in this.objPull) {
		var item = this.objPull[a];
		if (item["type"] == "slider") {
			item.pen._detectLimits();
			item.pen._definePos();
			item.label.className = "dhx_toolbar_slider_label_"+this.conf.skin;
		}
		if (item["type"] == "buttonSelect") {
			item.polygon.className = "dhx_toolbar_poly_"+this.conf.skin+" dhxtoolbar_icons_"+this.conf.iconSize+this.conf.cssShadow;
		}
	}
	if (skin == "dhx_terrace") this._improveTerraceSkin();
};

dhtmlXToolbarObject.prototype.setAlign = function(align) {
	this.conf.align = (align=="right"?"right":"left");
	this.base.className = (align=="right"?"dhxtoolbar_float_right":"dhxtoolbar_float_left");
	if (this._spacer) this._spacer.className = (align=="right"?" dhxtoolbar_float_left":" dhxtoolbar_float_right")
};

dhtmlXToolbarObject.prototype.setIconSize = function(size) {
	this.conf.iconSize = ({18:true,24:true,32:true,48:true}[size]?size:18);
	this.setSkin(this.conf.skin, true);
	this.callEvent("_onIconSizeChange",[this.conf.iconSize]);
};

dhtmlXToolbarObject.prototype.setIconsPath = function(path) {
	this.conf.icons_path = path;
};


// user data
dhtmlXToolbarObject.prototype.setUserData = function(id, name, value) {
	id = this.idPrefix+id;
	if (this.objPull[id] != null) {
		if (this.objPull[id].userData == null) this.objPull[id].userData = {};
		this.objPull[id].userData[name] = value;
	}
};
dhtmlXToolbarObject.prototype.getUserData = function(id, name) {
	id = this.idPrefix+id;
	if (this.objPull[id] != null && this.objPull[id].userData != null) return this.objPull[id].userData[name]||null;
	return null;
};
// userdata for listed options
dhtmlXToolbarObject.prototype._isListOptionExists = function(listId, optionId) {
	if (this.objPull[this.idPrefix+listId] == null) return false;
	var item = this.objPull[this.idPrefix+listId];
	if (item.type != "buttonSelect") return false;
	if (item._listOptions[optionId] == null) return false;
	return true;
};
dhtmlXToolbarObject.prototype.setListOptionUserData = function(listId, optionId, name, value) {
	// is exists?
	if (!this._isListOptionExists(listId, optionId)) return;
	// set userdata
	var opt = this.objPull[this.idPrefix+listId]._listOptions[optionId];
	if (opt.userData == null) opt.userData = {};
	opt.userData[name] = value;
};
dhtmlXToolbarObject.prototype.getListOptionUserData = function(listId, optionId, name) {
	// is exists?
	if (!this._isListOptionExists(listId, optionId)) return null;
	// get userdata
	var opt = this.objPull[this.idPrefix+listId]._listOptions[optionId];
	if (!opt.userData) return null;
	return (opt.userData[name]?opt.userData[name]:null);
};


// terrace skin fixes
dhtmlXToolbarObject.prototype._improveTerraceSkin = function() {
	
	if (this.conf.terrace_radius == null) this.conf.terrace_radius = "3px";
	
	var p = [];
	var bn = {separator: true, text: true}; // border-less items
	
	var e = [this.base];
	if (this._spacer != null) e.push(this._spacer);
	for (var w=0; w<e.length; w++) {
		p[w] = [];
		for (var q=0; q<e[w].childNodes.length; q++) {
			if (e[w].childNodes[q].idd != null && e[w].childNodes[q].style.display != "none") {
				var a = this.idPrefix+e[w].childNodes[q].idd;
				if (this.objPull[a] != null && this.objPull[a].obj == e[w].childNodes[q]) {
					p[w].push({a:a,type:this.objPull[a].type,node:this.objPull[a][this.objPull[a].type=="buttonSelect"?"arw":"obj"]});
				}
			}
		}
		e[w] = null;
	}
	
	for (var w=0; w<p.length; w++) {
		for (var q=0; q<p[w].length; q++) {
			
			var t = p[w][q];
			
			// check if border-right/border-left needed
			var br = false;
			var bl = false;
			
			if (!bn[t.type]) {
				
				// right side - check if item last-child or next-sibling is borderless item
				if (q == p[w].length-1 || (p[w][q+1] != null && bn[p[w][q+1].type])) br = true;
				
				// left side, check if item first-child or prev-sibling is borderless item
				if (q == 0 || (q-1 >= 0 && p[w][q-1] != null && bn[p[w][q-1].type])) bl = true;
				
			}
			
			t.node.style.borderRightWidth = (br?"1px":"0px");
			t.node.style.borderTopRightRadius = t.node.style.borderBottomRightRadius = (br?this.conf.terrace_radius:"0px");
			
			if (t.type == "buttonSelect") {
				t.node.previousSibling.style.borderTopLeftRadius = t.node.previousSibling.style.borderBottomLeftRadius = (bl?this.conf.terrace_radius:"0px");
				t.node.previousSibling._br = br;
				t.node.previousSibling._bl = bl;
			} else {
				t.node.style.borderTopLeftRadius = t.node.style.borderBottomLeftRadius = (bl?this.conf.terrace_radius:"0px");
			}
			
			t.node._br = br;
			t.node._bl = bl;
			
		}
	}
	
	for (var w=0; w<p.length; w++) {
		for (var q=0; q<p[w].length; q++) {
			for (var a in p[w][q]) p[w][q][a] = null;
			p[w][q] = null;
		}
		p[w] = null;
	}
	
	p = e = null;
};

// enable/disable riunded corners when sublist opened
dhtmlXToolbarObject.prototype._improveTerraceButtonSelect = function(id, state) {
	var item = this.objPull[id];
	if (state == true) {
		item.obj.style.borderBottomLeftRadius = (item.obj._bl?this.conf.terrace_radius:"0px");
		item.arw.style.borderBottomRightRadius = (item.obj._br?this.conf.terrace_radius:"0px");
	} else {
		item.obj.style.borderBottomLeftRadius = "0px";
		item.arw.style.borderBottomRightRadius = "0px";
	}
	item = null;
};

if (typeof(window.dhtmlXCellObject) != "undefined") {
	
	dhtmlXCellObject.prototype._createNode_toolbar = function(obj, type, htmlString, append, node) {
		
		if (typeof(node) != "undefined") {
			obj = node;
		} else {
			obj = document.createElement("DIV");
			obj.className = "dhx_cell_toolbar_"+(this.conf.borders?"def":"no_borders");
			obj.appendChild(document.createElement("DIV"));
			obj.firstChild.className = "dhx_toolbar_base_18_dhx_skyblue";
		}
		
		this.cell.insertBefore(obj, this.cell.childNodes[this.conf.idx.cont]); // before cont only
		
		this.conf.ofs_nodes.t.toolbar = true;
		this._updateIdx();
		// adjust cont will performed after toolbar init
		
		return obj;
		
	}
	
	dhtmlXCellObject.prototype.attachToolbar = function(conf) {
		
		if (!(this.dataNodes.ribbon == null && this.dataNodes.toolbar == null)) return;
		
		this.callEvent("_onBeforeContentAttach", ["toolbar"]);
		
		if (typeof(conf) == "undefined") {
			conf = {};
		} else if (typeof(conf) == "string") {
			conf = {skin:conf};
		}
		if (typeof(conf.skin) == "undefined") conf.skin = this.conf.skin;
		conf.parent = this._attachObject("toolbar").firstChild;
		
		this.dataNodes.toolbar = new dhtmlXToolbarObject(conf);
		this._adjustCont(this._idd);
		
		this.dataNodes.toolbar._masterCell = this;
		this.dataNodes.toolbar.attachEvent("_onIconSizeChange", function(){
			this._masterCell._adjustCont();
		});
		
		conf.parent = null;
		conf = null;
		
		this.callEvent("_onContentAttach", []);
		
		return this.dataNodes.toolbar;
		
	};
	
	dhtmlXCellObject.prototype.detachToolbar = function() {
		
		if (this.dataNodes.toolbar == null) return;
		
		this.dataNodes.toolbar._masterCell = null; // link to this
		if (typeof(this.dataNodes.toolbar.unload) == "function") this.dataNodes.toolbar.unload();
		this.dataNodes.toolbar = null;
		delete this.dataNodes.toolbar;
		
		this._detachObject("toolbar");
		
	};
	
	dhtmlXCellObject.prototype.showToolbar = function() {
		this._mtbShowHide("toolbar", "");
	};
	
	dhtmlXCellObject.prototype.hideToolbar = function() {
		this._mtbShowHide("toolbar", "none");
	};
	

	
	dhtmlXCellObject.prototype.getAttachedToolbar = function() {
		return this.dataNodes.toolbar;
	};
	
}


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXEditor(base, skin) {
	
	var that = this;
	
	this.conf = {
		// set content after load
		content: "", // first if set
		contentHTML: "", // second
		// resize
		resizeTM: null,
		resizeTMTime: 100,
		// readonly
		roMode: false,
		// extended toolbar
		toolbar: false,
		iconsPath: "",
		// frame events
		evs: ["focus", "blur", "keydown", "keyup", "keypress", "mouseup", "mousedown", "click", "touchend"], // touchend is dev_event for fix on iOS/iPad
		// focus fix on iOS/iPad
		iOSfix: (navigator.userAgent.match(/Mobile/gi) != null && navigator.userAgent.match(/iPad/gi) != null && navigator.userAgent.match(/AppleWebKit/gi) != null),
		// extended font conf
		extra_css: "",
		font: {family: "Tahoma", size: "12px", color: "black"}
	};
	
	this._doOnFocusChanged = null;
	this._doOnAccess = null;
	
	if (typeof(base) == "object" && base != null && base.tagName == null) {
		skin = base.skin;
		if (base.content != null) this.conf.content = base.content;
		if (base.contentHTML != null) this.conf.contentHTML = base.contentHTML;
		if (base.iconsPath != null) this.conf.iconsPath = base.iconsPath;
		if (base.extraCss != null) this.conf.extra_css = base.extraCss;
		if (base.toolbar != null) this.conf.toolbar = window.dhx4.s2b(base.toolbar);
		if (base.onFocusChanged != null) this._doOnFocusChanged = base.onFocusChanged;
		if (base.onAccess != null) this._doOnAccess = base.onAccess;
		base = base.parent;
	}
	
	// skin config
	this.conf.skin = (skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxeditor")||"material");
	
	// configure base
	if (typeof(base) == "string") base = document.getElementById(base);
	this.base = base;
	this.base.className += " dhxeditor_"+this.conf.skin;
	
	while (this.base.childNodes.length > 0) this.base.removeChild(this.base.childNodes[0]);
	
	// configure base for dhxcont
	var pos = (window.dhx4.isIE ? this.base.currentStyle["position"] : (window.getComputedStyle != null? window.getComputedStyle(this.base, null).getPropertyValue("position") : "" ));
	if (!(pos == "relative" || pos == "absolute")) this.base.style.position = "relative";
	
	// init dhxcont
	this.cell = new dhtmlXEditorCell(window.dhx4.newId(), this);
	this.base.appendChild(this.cell.cell);
	
	this.cBlock = document.createElement("DIV");
	this.cBlock.className = "dhxcont_content_blocker";
	this.cBlock.style.display = "none";
	this.base.appendChild(this.cBlock);
	
	// editable area
	this.editor = document.createElement("IFRAME");
	this.editor.className = "dhxeditor_mainiframe";
	this.editor.frameBorder = 0;
	if (window.dhx4.isOpera) this.editor.scrolling = "yes";
	
	// adjust self
	this.setSizes();
	
	// onAccess event - focus/blue as param
	var fr = this.editor;
	if (typeof(window.addEventListener) != "undefined") {
		fr.onload = function() {
			for (var q=0; q<that.conf.evs.length; q++) {
				fr.contentWindow.addEventListener(that.conf.evs[q], that._ev, false);
			}
		}
	} else {
		fr.onreadystatechange = function(a) {
			if (typeof(fr.readyState) != "undefined" && fr.readyState == "complete") {
				try {
					for (var q=0; q<that.conf.evs.length; q++) {
						fr.contentWindow.document.body.attachEvent("on"+that.conf.evs[q], that._ev);
					}
				} catch(e){};
			}
		}
	}
	
	this._ev = function(e) {
		e = e||event;
		var type = e.type;
		if (that.conf.iOSfix == true && type == "touchend") {
			that.editor.contentWindow.focus();
			return;
		}
		that.callEvent("onAccess", [type, e]);
		if (typeof(that._doOnAccess) == "function") {
			that._doOnAccess(type, e);
		} else if (typeof(that._doOnAccess) == "string" && typeof(window[that._doOnAccess]) == "function") {
			window[that._doOnAccess](type, e);
		}
	}
	this._focus = function() {
		if (window.dhx4.isIE) {
			this.editor.contentWindow.document.body.focus();
		} else {
			this.editor.contentWindow.focus();
		}
	}
	
	this.cell.attachObject(this.editor);
	this.edWin = this.editor.contentWindow;
	this.edDoc = this.edWin.document;
	
	this._prepareContent = function(saveContent, roMode) {
		
		var storedContent = "";
		if (saveContent === true && this.getContent != null) storedContent = this.getContent();
		
		var edDoc = this.editor.contentWindow.document;
		edDoc.open("text/html", "replace");
		if (window.dhx4.isOpera) {
			edDoc.write("<html><head>"+this.conf.extra_css+
					"<style> html, body { overflow:auto;-webkit-overflow-scrolling: touch; padding:0px; height:100%; margin:0px; background-color:#ffffff; "+this._fontConf()+"} </style>"+
					"</head><body "+(roMode!==true?"contenteditable='true'":"")+" tabindex='0'></body></html>");
		} else {
			if (window.dhx4.isKHTML) {
				edDoc.write("<html><head>"+this.conf.extra_css+
						"<style> html {overflow-x: auto;-webkit-overflow-scrolling: touch; overflow-y: auto;} body { overflow: auto; overflow-y: scroll;} "+
							"html,body { padding:0px; height:100%; margin:0px; background-color:#ffffff; "+this._fontConf()+"} </style>"+
						"</head><body "+(roMode!==true?"contenteditable='true'":"")+" tabindex='0'></body></html>");
			} else {
				if (window.dhx4.isIE) {
					// && navigator.appVersion.indexOf("MSIE 9.0")!= -1
					edDoc.write("<html><head>"+this.conf.extra_css+
							"<style> html {overflow-y: auto;} body {overflow-y: scroll;-webkit-overflow-scrolling: touch;} "+
								"html,body { overflow-x: auto; padding:0px; height:100%; margin:0px; background-color: #ffffff; outline: none; "+this._fontConf()+"} </style>"+
							"</head><body "+(roMode!==true?"contenteditable='true'":"")+" tabindex='0'></body></html>");
				} else {
					edDoc.write("<html><head>"+this.conf.extra_css+
							"<style> html,body { overflow-x: auto; overflow-y:-webkit-overflow-scrolling: touch; scroll; "+
								"padding:0px; height:100%; margin:0px; background-color:#ffffff; "+this._fontConf()+"} </style>"+
							"</head><body "+(roMode!==true?"contenteditable='true'":"")+" tabindex='0'></body></html>");
				}
			}
		}
		edDoc.close();
		
		if (window.dhx4.isIE) edDoc.contentEditable = (roMode!==true); else edDoc.designMode = (roMode!==true?"On":"Off");
		if (window.dhx4.isFF) try { edDoc.execCommand("useCSS", false, true); } catch(e) {}
		if (saveContent === true && this.setContent != null) this.setContent(storedContent);
		
	}
	
	// fix
	this._prepareContent();
	
	// resize
	this._doOnResize = function() {
		window.clearTimeout(that.conf.resizeTM);
		that.conf.resizeTM = window.setTimeout(function(){if(that.setSizes)that.setSizes();}, that.conf.resizeTMTime);
	}
	
	// toolbar buttons
	this._runCommand = function(name,param){
		if (this.conf.roMode === true) return;
		if (arguments.length < 2) param = null;
		if (window.dhx4.isIE) this.edWin.focus();
		try {
			var edDoc = this.editor.contentWindow.document
			edDoc.execCommand(name,false,param);
		} catch(e){}
		if (window.dhx4.isIE) {
			this.edWin.focus();
			var self = this;
			window.setTimeout(function(){
				self.edWin.focus();
				self = null;
			},1);
		}
	}
	
	// commands
	this.applyBold = function() {
		this._runCommand("Bold");
	}
	this.applyItalic = function() {
		this._runCommand("Italic");
	}
	this.applyUnderscore = function() {
		this._runCommand("Underline");
	}
	this.clearFormatting = function() {
		this._runCommand("RemoveFormat");
		var k = this.getContent();
		k = k.replace(/<\/?h\d>/gi, "");
		this.setContent(k);
	}
	
	this._doOnClick = function(e) {
		var ev = e||window.event;
		var el = ev.target||ev.srcElement;
		that._showInfo(el);
	}
	
	this._doOnMouseDown = function(e) { // opera only
		var ev = e||window.event;
		var el = ev.target||ev.srcElement;
		that._showInfo(el);
	}
	
	this._doOnKeyUp = function(e) {
		var ev = e||window.event;
		var key = ev.keyCode;
		var el = ev.target||ev.srcElement;
		if ({37:1,38:1,39:1,40:1,13:1}[key] == 1) that._showInfo(el);
	}
	

	this._getParentByTag = function(node, tag_name) {
		tag_name = tag_name.toLowerCase();
		var p = node;
		do {
			if (tag_name == '' || p.nodeName.toLowerCase() == tag_name) return p;
		} while (p = p.parentNode);
		return node;
	}
	
	this._isStyleProperty = function(node, tag_name, name, value){
		tag_name = tag_name.toLowerCase();
		var n = node;
		do {
			if ((n.nodeName.toLowerCase() == tag_name) && (n.style[name] == value)) return true;
   		} while (n = n.parentNode);
   		return false;
	}
	
	this._setStyleProperty = function(el, prop) {
		this.style[prop] = false;
		var n = this._getParentByTag(el, prop);
		if (n && (n.tagName.toLowerCase() == prop)) this.style[prop] = true;
		if (prop == "del" && this._getParentByTag(el, "strike") && this._getParentByTag(el,"strike").tagName.toLowerCase() == "strike") this.style.del = true;
	}
	
	this._showInfo = function(el) {
		
		var el = (this._getSelectionBounds().end)?this._getSelectionBounds().end : el;
		if (!el || !this._setStyleProperty) return;
		
		try {
			if (this.edWin.getComputedStyle) {
				var st = this.edWin.getComputedStyle(el, null);
				var fw = ((st.getPropertyValue("font-weight")==401)?700:st.getPropertyValue("font-weight"));
				this.style = {
					fontStyle	: st.getPropertyValue("font-style"),
					fontSize	: st.getPropertyValue("font-size"),
					textDecoration	: st.getPropertyValue("text-decoration"),
					fontWeight	: fw,
					fontFamily	: st.getPropertyValue("font-family"),
					textAlign	: st.getPropertyValue("text-align")
				};
				if (window.dhx4.isKHTML) { // safari
					this.style.fontStyle = st.getPropertyValue("font-style");
					this.style.vAlign = st.getPropertyValue("vertical-align");
					this.style.del = this._isStyleProperty(el,"span","textDecoration","line-through");
					this.style.u = this._isStyleProperty(el,"span","textDecoration","underline");
				}
			} else {
				var st = el.currentStyle;
				this.style = {
					fontStyle	: st.fontStyle,
					fontSize	: st.fontSize,
					textDecoration	: st.textDecoration,
					fontWeight	:  st.fontWeight,
					fontFamily	: st.fontFamily,
					textAlign	: st.textAlign
				};
			}
			this._setStyleProperty(el,"h1");
			this._setStyleProperty(el,"h2");
			this._setStyleProperty(el,"h3");
			this._setStyleProperty(el,"h4");
			if (!window.dhx4.isKHTML) {
				this._setStyleProperty(el,"del");
				this._setStyleProperty(el,"sub");
				this._setStyleProperty(el,"sup");
				this._setStyleProperty(el,"u");
			}
			this.callEvent("onFocusChanged", [this.style, st])
		} catch(e){ return null; }
	}
	
	this._getSelectionBounds = function() {
   		var range, root, start, end;
		if (this.edWin.getSelection) {
			var selection = this.edWin.getSelection();
			if (window.dhx4.isEdge && selection.rangeCount == 0) return {root: null, start: null, end: null};
			range = selection.getRangeAt(selection.rangeCount-1);
			start = range.startContainer;
			end = range.endContainer;
			root = range.commonAncestorContainer;
			if (start.nodeName == "#text") root = root.parentNode;
			if (start.nodeName == "#text") start = start.parentNode;
			if (start.nodeName.toLowerCase() == "body") start = start.firstChild;
			if (end.nodeName == "#text") end = end.parentNode;
			if (end.nodeName.toLowerCase() == "body") end = end.lastChild;
			if (start == end) root = start;
			return {
				root: root,
				start: start,
				end: end
			};
		} else if (this.edWin.document.selection) {
			range = this.edDoc.selection.createRange()
			if(!range.duplicate) return null;
			root = range.parentElement();
			var r1 = range.duplicate();
			var r2 = range.duplicate();
			r1.collapse(true);
			r2.moveToElementText(r1.parentElement());
			r2.setEndPoint("EndToStart",r1);
			start = r1.parentElement();
			r1 = range.duplicate();
			r2 = range.duplicate();
			r2.collapse(false);
			r1.moveToElementText(r2.parentElement());
			r1.setEndPoint("StartToEnd", r2);
			end = r2.parentElement();
	   		if (start.nodeName.toLowerCase() == "body") start = start.firstChild;
			if (end.nodeName.toLowerCase() == "body") end = end.lastChild;
			
			if (start == end) root = start;
			return {
				root: root,
				start: start,
				end: end
			};
   		}
   		return null;
	}
	
	this.getContent = function(){
		if (!this.edDoc.body) {
			return "";
		} else {
			if (window.dhx4.isFF || window.dhx4.isChrome) return this.editor.contentWindow.document.body.innerHTML.replace(/<\/{0,}br\/{0,}>\s{0,}$/gi,"");
			if (window.dhx4.isIE && this.edDoc.body.innerText.length == 0) return "";
			return this.edDoc.body.innerHTML;
		}
	}
	
	this.setContent = function(str){
		str = str||"";
		if (this.edDoc.body) {
			var ffTest = false;
			if (window.dhx4.isFF) {
				var k = navigator.userAgent.match(/Firefox\/(\d*)/);
				ffTest = (k != null && k[1] < 28);
			}
			if (ffTest) {
				if (typeof(this.conf.ffTest) == "undefined") {
					this.editor.contentWindow.document.body.innerHTML = "";
					this._runCommand("InsertHTML", "test");
					this.conf.ffTest = (this.editor.contentWindow.document.body.innerHTML.length > 0);
				}
				if (this.conf.ffTest) {
					// FF 4.x+
					this.editor.contentWindow.document.body.innerHTML = str;
				} else {
					// FF 2.x, 3.x
					this.editor.contentWindow.document.body.innerHTML = "";
					if (str.length == 0) str=" ";
					this._runCommand("InsertHTML", str);
				}
			} else {
				this.editor.contentWindow.document.body.innerHTML = str;
			}
			this.callEvent("onContentSet",[]);
		} else {
			if (!this.conf.firstLoadEv) {
				this.conf.firstLoadEv = true;
				this.conf.firstLoadData = str;
				this._onFirstLoad = function() {
					that.setContent(that.conf.firstLoadData);
					if (typeof(window.addEventListener) == "function") {
						that.edWin.removeEventListener("load", that._onFirstLoad, false);
					} else {
						that.edWin.detachEvent("onload", that._onFirstLoad);
					}
					that.conf.firstLoadData = null;
					that.conf.firstLoadEv = false;
					that._onFirstLoad = null;
				}
				if (typeof(window.addEventListener) == "function") {
					this.edWin.addEventListener("load", this._onFirstLoad, false);
				} else {
					this.edWin.attachEvent("onload", this._onFirstLoad);
				}
			}
		}
	}
	
	this.setContentHTML = function(url) {
		window.dhx4.ajax.get(url, function(r) {
			if (r.xmlDoc.responseText != null) that.setContent(r.xmlDoc.responseText);
		});
	}
	
	// events
	window.dhx4._eventable(this);
	
	this.attachEvent("onFocusChanged", function(state){
		if (typeof(this._doOnFocusChanged) == "function") {
			this._doOnFocusChanged(state);
		} else if (typeof(this._doOnFocusChanged) == "string" && typeof(window[this._doOnFocusChanged]) == "function") {
			window[this._doOnFocusChanged](state);
		}
	});
	
	if (typeof(window.addEventListener) == "function") {
		window.addEventListener("resize", this._doOnResize, false);
		this.edDoc.addEventListener("click", this._doOnClick, false);
		this.edDoc.addEventListener("keyup", this._doOnKeyUp, false);
		if (window.dhx4.isOpera) this.edDoc.addEventListener("mousedown", this._doOnMouseDown, false);
	} else {
		window.attachEvent("onresize", this._doOnResize);
		this.edDoc.attachEvent("onclick", this._doOnClick);
		this.edDoc.attachEvent("onkeyup", this._doOnKeyUp);
	}
	
	this.unload = function() {
		
		// first detach events from iframe
		if (typeof(window.addEventListener) == "function") {
			window.removeEventListener("resize", this._doOnResize, false);
			this.edDoc.removeEventListener("click", this._doOnClick, false);
			this.edDoc.removeEventListener("keyup", this._doOnKeyUp, false);
			if (window.dhx4.isOpera) this.edDoc.removeEventListener("mousedown", this._doOnMouseDown, false);
			// editor's
			for (var q=0; q<that.conf.evs.length; q++) {
				fr.contentWindow.removeEventListener(that.conf.evs[q], that._ev, false);
			}
			// iOS fix
			if (this.tb != null && this.conf.iOSfix == true) {
				this.tb.cont.removeEventListener("touchend", this._doOnIOSFix, false);
				this._doOnIOSFix = null;
			}
		} else {
			window.detachEvent("onresize", this._doOnResize, false);
			this.edDoc.detachEvent("onclick", this._doOnClick);
			this.edDoc.detachEvent("onkeyup", this._doOnKeyUp);
			// editor's
			for (var q=0; q<that.conf.evs.length; q++) {
				fr.contentWindow.document.body.detachEvent("on"+that.conf.evs[q], that._ev);
			}
		}
		
		this._doOnAccess = null;
		this._doOnFocusChanged = null;
		
		// remove editor
		if (typeof(window.addEventListener) == "function") {
			this.editor.onload = null;
		} else {
			this.editor.onreadystatechange = null;
		}
		this.editor.parentNode.removeChild(this.editor);
		this.editor = null;
		this.edDoc = null;
		this.edWin = null;
		
		// unload cell
		this.cell._unload();
		this.cell = null;
		
		// extended toolbar
		this.tb = null;
		
		window.dhx4._eventable(this, "clear");
		
		this.cBlock.parentNode.removeChild(this.cBlock);
		this.cBlock = null;
		
		// clear container features
		this.base.className = String(this.base.className).replace(new RegExp("\\s{0,}dhxeditor_"+this.conf.skin),"");
		while (this.base.childNodes.length > 0) this.base.removeChild(this.base.childNodes[0]);
		this.base = null;
		
		this._doOnClick = null;
		this._doOnKeyUp = null;
		this._doOnMouseDown = null;
		
		this._ev = null;
		this._focus = null;
		this._prepareContent = null;
		this._doOnResize = null;
		this.setIconsPath = null;
		this.init = null;
		this.setSizes = null;
		this._runCommand = null;
		this.applyBold = null;
		this.applyItalic = null;
		this.applyUnderscore = null;
		this.clearFormatting = null;
		this._showInfo = null;
		this._getSelectionBounds = null;
		this.getContent = null;
		this.setContent = null;
		this.setContentHTML = null;
		this.setReadonly = null;
		this.isReadonly = null;
		this.unload = null;
		
		that = fr = null;
	}
	
	// load extended toolbar if any
	if (this.conf.toolbar == true && typeof(this.attachToolbar) == "function" && typeof(window.dhtmlXToolbarObject) == "function") {
		this.attachToolbar(this.conf.iconsPath);
		if (this.conf.iOSfix == true) {
			this._doOnIOSFix = function() { that.editor.contentWindow.focus(); }
			this.tb.cont.addEventListener("touchend", this._doOnIOSFix, false);
		}
	}
	this.setIconsPath = function(iconsPath) {
		this.conf.iconsPath = iconsPath;
	}
	
	// load content if any
	if (this.conf.content.length > 0) {
		this.setContent(this.conf.content);
		this.conf.content = "";
	} else if (this.conf.contentHTML.length > 0) {
		this.setContentHTML(this.conf.contentHTML);
		this.conf.contentHTML = "";
	}
	
	return this;
};

dhtmlXEditor.prototype.setSizes = function() {
	this.cell._setSize(0, 0, this.base.clientWidth, this.base.clientHeight);
	if (this.editor != null) {
		this.editor.style.left = "5px";
		this.editor.style.width = this.base.clientWidth-5+"px";
	}
};

dhtmlXEditor.prototype.setReadonly = function(mode) {
	this.conf.roMode = (mode===true);
	this._prepareContent(true, this.conf.roMode);
	this.cBlock.style.display = (this.conf.roMode?"":"none");
};

dhtmlXEditor.prototype.isReadonly = function(mode) {
	return (this.conf.roMode||false);
};

dhtmlXEditor.prototype.setSkin = function(skin) {
	this.base.className = String(this.base.className).replace(new RegExp("dhxeditor_"+this.conf.skin),"dhxeditor_"+skin);
	this.conf.skin = this.cell.conf.skin = skin;
	if (this.tb) {
		this.cell.detachToolbar(skin);
		this.tb = null;
		this.attachToolbar();
	}
	this.setSizes();
};

dhtmlXEditor.prototype._fontConf = function() {
	if (this.conf.skin == "") {
		var data = {family: this.conf.font.family, size: this.conf.font.size, color: this.conf.font.color};
	} else {
		var data = {family: "Roboto, Arial, Helvetica", size: "14px", color: "#404040"};
	}
	return window.dhx4.template("font-size: #size#; font-family: #family#; color: #color#;", data);
};
window.dhtmlXEditorCell = function(id, editor) {
	
	dhtmlXCellObject.apply(this, [id, "_editor"]);
	
	var that = this;
	this.editor = editor;
	
	this.conf.skin = this.editor.conf.skin;
	
	this.attachEvent("_onCellUnload", function(){
		
		// unload simple toolbar
		this._stbUnload();
		
		this.editor = null;
		that = null;
		
	});
	
	// simple toolbar init
	this._stbInit();
	
	return this;
};

dhtmlXEditorCell.prototype = new dhtmlXCellObject();

// simple toolbar
dhtmlXEditorCell.prototype._stbInit = function() {
	
	var that = this;
	
	var t = document.createElement("DIV");
	t.className = "dhx_cell_stb"+(dhx4.isIE6||dhx4.isIE7||dhx4.isIE8?"":" dhx_cell_stb_shadow");
	this.cell.insertBefore(t, this.cell.childNodes[this.conf.idx.cont]);
	
	t.onselectstart = function(e) {
		e = e||event;
		e.cancelBubble = true;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		return false;
	}
	
	var items = {
		bold: "applyBold",
		italic: "applyItalic",
		underline: "applyUnderscore",
		clearformat: "clearFormatting"
	};
	
	for (var k in items) {
		
		var a = document.createElement("A");
		a.href = "javascript:void(0);";
		a.tabIndex = -1;
		t.appendChild(a);
		
		a.onmousedown = a.onclick = function(e){
			e = e||event;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			return false;
		}
		
		var d = document.createElement("DIV");
		d.className = "dhx_cell_stb_button btn_"+k;
		d._actv = k.charAt(0);
		d._cmd = items[k];
		a.appendChild(d);
		
		d.onclick = function(e){
			e = e||event;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			return false;
		}
		d.onmousedown = function(e){
			e = e||event;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			that.editor[this._cmd]();
			that.editor.callEvent("onToolbarClick",[this._actv]);
		}
		
		d = a = null;
	}
	
	t = null;
	
	this._stbUnload = function() {
		
		var t = this.cell.childNodes[this.conf.idx.stb];
		t.onselectstart = null;
		
		while (t.childNodes.length > 0) {
			t.lastChild.onmousedown = t.lastChild.onclick = null;
			t.lastChild.firstChild.onmousedown = t.lastChild.firstChild.onclick = null;
			t.lastChild.firstChild._actv = t.lastChild.firstChild._cmd = null;
			t.lastChild.removeChild(t.lastChild.firstChild);
			t.removeChild(t.lastChild);
		}
		t.parentNode.removeChild(t);
		t = that = null;
		
		this.conf.idx_data.stb = this.conf.ofs_nodes.t._getStbHeight = null;
		delete this.conf.ofs_nodes.t._getStbHeight
		delete this.conf.idx_data.stb;
		
		this._updateIdx();
		
	};
	
	this.conf.stb_visible = true;
	
	// include into content top offset calculation
	this.conf.ofs_nodes.t._getStbHeight = "func";
	
	// include into index
	this.conf.idx_data.stb = "dhx_cell_stb";
	this._updateIdx();
	
};

dhtmlXEditorCell.prototype._stbHide = function() {
	this.cell.childNodes[this.conf.idx.stb].style.display = "none";
	this.conf.stb_visible = false;
};

dhtmlXEditorCell.prototype._getStbHeight = function() {
	if (this.conf.stb_visible == true && this.conf.skin == "material") {
		if (this.conf.stb_height == null) {
			this.conf.stb_height = window.dhx4.readFromCss("dhxeditor_material stb_height_detect", "scrollHeight", "<div class='dhx_cell_editor'><div class='dhx_cell_stb'></div></div>");
		}
		return this.conf.stb_height;
	}
	return this.cell.childNodes[this.conf.idx.stb].offsetHeight;
};

dhtmlXCellObject.prototype.attachEditor = function(conf) {
	
	this.callEvent("_onBeforeContentAttach",["editor"]);
	
	var obj = document.createElement("DIV");
	obj.style.width = "100%";
	obj.style.height = "100%";
	obj.style.position = "relative";
	obj.style.overflow = "hidden";
	this._attachObject(obj);
	
	if (!(typeof(conf) == "object" && conf != null)) conf = {};
	conf.parent = obj;
	
	this.dataType = "editor";
	this.dataObj = new dhtmlXEditor(conf);
	
	obj = null;
	conf.parent = null;
	conf = null;
	
	// attach to portal extended logic
	if (typeof(window.dhtmlXPortalCell) == "function" && this instanceof window.dhtmlXPortalCell) {
		
		if (this.portal.conf.editor_ev == null) {
			
			var e1 = this.portal.attachEvent("onBeforeDrag", function(id) {
				if (this.cdata[id].dataType == "editor") {
					this.cdata[id].conf.editor_cont = this.cdata[id].dataObj.getContent();
				}
				return true;
			});
			
			var e2 = this.portal.attachEvent("onDrop", function(id) {
				if (this.cdata[id].dataType == "editor") {
					this.cdata[id].dataObj.setContent(this.cdata[id].conf.editor_cont);
					this.cdata[id].dataObj._prepareContent(true);
					this.cdata[id].conf.editor_cont = null;
				}
			});
			
			this.portal.conf.editor_ev = [e1, e2];
		}
		
		this.conf.editor_ev = this.attachEvent("_onBeforeContentDetach", function(){
			
			this.detachEvent(this.conf.editor_ev);
			this.conf.editor_ev = null;
			
			if (this instanceof window.dhtmlXPortalCell) {
				
				var ed = false;
				for (var a in this.portal.cdata) {
					if (this.portal.cdata[a] != this && this.portal.cdata[a].dataType == "editor") {
						ed = true; // portal still have attached editors
					}
				}
				// no more editors, clear events
				if (ed == false) {
					for (var q=0; q<this.portal.conf.editor_ev.length; q++) {
						this.portal.detachEvent(this.portal.conf.editor_ev[q]);
					}
					this.portal.conf.editor_ev = null;
				}
			}
		});
		
	}
	
	this.callEvent("_onContentAttach",[]);
	
	return this.dataObj;
	
};


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXEditor.prototype.attachToolbar = function(iconsPath) {
	
	if (this.tb != null) return;
	
	if (iconsPath != null) this.conf.iconsPath = iconsPath;
	
	this.cell._stbHide();
	this.tb = this.cell.attachToolbar({
		icons_path: this.conf.iconsPath+"/dhxeditor_"+String(this.conf.skin).replace(/^dhx_/,"")+"/",
		skin: this.conf.skin
	});
	this.setSizes();
	
	var ext = (this.conf.skin=="material"?"png":"gif");
	
	this._availFonts = new Array("Arial", "Arial Narrow", "Comic Sans MS", "Courier", "Georgia", "Impact", "Tahoma", "Times New Roman", "Verdana");
	this._initFont = this._availFonts[0];
	this._xmlFonts = "";
	for (var q=0; q<this._availFonts.length; q++) {
		var fnt = String(this._availFonts[q]).replace(/\s/g,"_");
		this._xmlFonts += '<item type="button" id="applyFontFamily:'+fnt+'"><itemText><![CDATA[<img src="'+this.tb.imagePath+'font_'+String(fnt).toLowerCase()+'.'+ext+'" border="0" style="/*margin-top:1px;margin-bottom:1px;*/width:110px;height:16px;">]]></itemText></item>';
	}
	//
	this._availSizes = {"1":"8pt", "2":"10pt", "3":"12pt", "4":"14pt", "5":"18pt", "6":"24pt", "7":"36pt"};
	this._xmlSizes = "";
	for (var a in this._availSizes) {
		this._xmlSizes += '<item type="button" id="applyFontSize:'+a+':'+this._availSizes[a]+'" text="'+this._availSizes[a]+'"/>';
	}
	this.tbXML = '<toolbar>'+
				// h1-h4
				'<item id="applyH1" type="buttonTwoState" img="h1.'+ext+'" imgdis="h4_dis.'+ext+'" title="H1"/>'+
				'<item id="applyH2" type="buttonTwoState" img="h2.'+ext+'" imgdis="h4_dis.'+ext+'" title="H2"/>'+
				'<item id="applyH3" type="buttonTwoState" img="h3.'+ext+'" imgdis="h4_dis.'+ext+'" title="H3"/>'+
				'<item id="applyH4" type="buttonTwoState" img="h4.'+ext+'" imgdis="h4_dis.'+ext+'" title="H4"/>'+
				'<item id="separ01" type="separator"/>'+
				// text
				'<item id="applyBold" type="buttonTwoState" img="bold.'+ext+'" imgdis="bold_dis.'+ext+'" title="Bold Text"/>'+
				'<item id="applyItalic" type="buttonTwoState" img="italic.'+ext+'" imgdis="italic_dis.'+ext+'" title="Italic Text"/>'+
				'<item id="applyUnderscore" type="buttonTwoState" img="underline.'+ext+'" imgdis="underline_dis.'+ext+'" title="Underscore Text"/>'+
				'<item id="applyStrikethrough" type="buttonTwoState" img="strike.'+ext+'" imgdis="strike_dis.'+ext+'" title="Strikethrough Text"/>'+
				'<item id="separ02" type="separator"/>'+
				// align
				'<item id="alignLeft" type="buttonTwoState" img="align_left.'+ext+'" imgdis="align_left_dis.'+ext+'" title="Left Alignment"/>'+
				'<item id="alignCenter" type="buttonTwoState" img="align_center.'+ext+'" imgdis="align_center_dis.'+ext+'" title="Center Alignment"/>'+
				'<item id="alignRight" type="buttonTwoState" img="align_right.'+ext+'" imgdis="align_right_dis.'+ext+'" title="Right Alignment"/>'+
				'<item id="alignJustify" type="buttonTwoState" img="align_justify.'+ext+'" title="Justified Alignment"/>'+
				'<item id="separ03" type="separator"/>'+
				// sub/super script
				'<item id="applySub" type="buttonTwoState" img="script_sub.'+ext+'" imgdis="script_sub.'+ext+'" title="Subscript"/>'+
				'<item id="applySuper" type="buttonTwoState" img="script_super.'+ext+'" imgdis="script_super_dis.'+ext+'" title="Superscript"/>'+
				'<item id="separ04" type="separator"/>'+
				// etc
				'<item id="createNumList" type="button" img="list_number.'+ext+'" imgdis="list_number_dis.'+ext+'" title="Number List"/>'+
				'<item id="createBulList" type="button" img="list_bullet.'+ext+'" imgdis="list_bullet_dis.'+ext+'" title="Bullet List"/>'+
				'<item id="separ05" type="separator"/>'+
				//
				'<item id="increaseIndent" type="button" img="indent_inc.'+ext+'" imgdis="indent_inc_dis.'+ext+'" title="Increase Indent"/>'+
				'<item id="decreaseIndent" type="button" img="indent_dec.'+ext+'" imgdis="indent_dec_dis.'+ext+'" title="Decrease Indent"/>'+
				'<item id="separ06" type="separator"/>'+
				'<item id="clearFormatting" type="button" img="clear.'+ext+'" title="Clear Formatting"/>'+
			'</toolbar>';
	
	this.tb.loadStruct(this.tbXML);
	
	this._checkAlign = function(alignSelected) {
		this.tb.setItemState("alignCenter", false);
		this.tb.setItemState("alignRight", false);
		this.tb.setItemState("alignJustify", false);
		this.tb.setItemState("alignLeft", false);
		if (alignSelected) this.tb.setItemState(alignSelected, true);
	}
	
	this._checkH = function(h) {
		this.tb.setItemState("applyH1", false);
		this.tb.setItemState("applyH2", false);
		this.tb.setItemState("applyH3", false);
		this.tb.setItemState("applyH4", false);
		if (h) this.tb.setItemState(h, true);
	}
	
	this._doOnFocusChanged = function(state) {
		/*bold*/
		if(!state.h1&&!state.h2&&!state.h3&&!state.h4){
			var bold = (String(state.fontWeight).search(/bold/i) != -1) || (Number(state.fontWeight) >= 700);
			this.tb.setItemState("applyBold", bold);
		} else this.tb.setItemState("applyBold", false);
		// align
		var alignId = "alignLeft";
		if (String(state.textAlign).search(/center/) != -1) { alignId = "alignCenter"; }
		if (String(state.textAlign).search(/right/) != -1) { alignId = "alignRight"; }
		if (String(state.textAlign).search(/justify/) != -1) { alignId = "alignJustify"; }
		this.tb.setItemState(alignId, true);
		this._checkAlign(alignId);
		/*heading*/
		this.tb.setItemState("applyH1", state.h1);
		this.tb.setItemState("applyH2", state.h2);
		this.tb.setItemState("applyH3", state.h3);
		this.tb.setItemState("applyH4", state.h4);
		if (window._KHTMLrv) {
			/*for Safari*/
			state.sub = (state.vAlign == "sub");
			state.sup = (state.vAlign == "super");
		}
		this.tb.setItemState("applyItalic", (state.fontStyle == "italic"));
		this.tb.setItemState("applyStrikethrough", state.del);
		this.tb.setItemState("applySub", state.sub);
		this.tb.setItemState("applySuper", state.sup);
		this.tb.setItemState("applyUnderscore", state.u);
	}
	
	this._doOnToolbarClick = function(id) {
		var action = String(id).split(":");
		if (this[action[0]] != null) {
			if (typeof(this[action[0]]) == "function") {
				this[action[0]](action[1]);
				this.callEvent("onToolbarClick",[id]);
			}
		}
	}
	
	this._doOnStateChange = function(itemId, state) {
		this[itemId]();
		switch (itemId) {
			case "alignLeft":
			case "alignCenter":
			case "alignRight":
			case "alignJustify":
				this._checkAlign(itemId);
				break;
			case "applyH1":
			case "applyH2":
			case "applyH3":
			case "applyH4":
				this._checkH(itemId);
				break;
		}
		this.callEvent("onToolbarClick",[itemId]);
	}
	this._doOnBeforeStateChange = function(itemId, state) {
		if ((itemId == "alignLeft" || itemId == "alignCenter" || itemId == "alignRight" || itemId == "alignJustify") && state == true) {
			return false;
		}
		return true;
	}
	var that = this;
	
	this.tb.attachEvent("onClick", function(id){that._doOnToolbarClick(id);});
	this.tb.attachEvent("onStateChange", function(id,st){that._doOnStateChange(id,st);});
	this.tb.attachEvent("onBeforeStateChange", function(id,st){return that._doOnBeforeStateChange(id,st);});
	
	this.applyBold = function(){
		this._runCommand("Bold");
	}
	
	this.applyItalic = function(){
		this._runCommand("Italic");
	}
	
	this.applyUnderscore = function(){
		this._runCommand("Underline");
	}
	
	this.applyStrikethrough = function(){
		this._runCommand("StrikeThrough");
	}
	
	this.alignLeft = function(){
		this._runCommand("JustifyLeft");
	}
	
	this.alignRight = function(){
		this._runCommand("JustifyRight");
	}
	
	this.alignCenter = function(){
		this._runCommand("JustifyCenter");
	}
	
	this.alignJustify = function(){
		this._runCommand("JustifyFull");
	}
	
	this.applySub = function(){
		this._runCommand("Subscript");
	}
	
	this.applySuper = function(){
		this._runCommand("Superscript");
	}
	
	this.applyH1 = function(){
		this._runCommand("FormatBlock","<H1>");
	}
	
	this.applyH2 = function(){
		this._runCommand("FormatBlock","<H2>");
	}
	
	this.applyH3 = function(){
		this._runCommand("FormatBlock","<H3>");
	}
	
	this.applyH4 = function(){
		this._runCommand("FormatBlock","<H4>");
	}
	
	this.createNumList = function(){
		this._runCommand("InsertOrderedList");
	}
	
	this.createBulList = function(){
		this._runCommand("InsertUnorderedList");
	}
	
	this.increaseIndent = function(){
		this._runCommand("Indent");
	}
	
	this.decreaseIndent = function(){
		this._runCommand("Outdent");
	}
	this.clearFormatting = function() {
		this._runCommand("RemoveFormat");
		this.tb.setItemState("applyBold", false);
		this.tb.setItemState("applyItalic", false);
		this.tb.setItemState("applyStrikethrough", false);
		this.tb.setItemState("applySub", false);
		this.tb.setItemState("applySuper", false);
		this.tb.setItemState("applyUnderscore", false);
		var k = this.getContent();
		k = k.replace(/<\/?h\d>/gi, "");
		this.setContent(k);
	}
	
};


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/


/* DHX DEPEND FROM FILE 'group.js'*/


/*DHX:Depend datastore.js*/
/*DHX:Depend dhtmlx.js*/

dhtmlx.Group = {
	_init:function(){
		dhtmlx.assert(this.data,"DataStore required for grouping");
		this.data.attachEvent("onStoreLoad",dhtmlx.bind(function(){
			if (this._settings.group)
				this.group(this._settings.group,false);
		},this));
		this.attachEvent("onBeforeRender",dhtmlx.bind(function(data){
			if (this._settings.sort){
				data.block();
				data.sort(this._settings.sort);
				data.unblock();
			}
		},this));
		this.data.attachEvent("onClearAll",dhtmlx.bind(function(){
			this.data._not_grouped_order = this.data._not_grouped_pull = null;
		},this));
		this.attachEvent("onBeforeSort",dhtmlx.bind(function(){
			this._settings.sort = null;
		},this));
	},
	_init_group_data_event:function(data,master){
		data.attachEvent("onClearAll",dhtmlx.bind(function(){
            this.ungroup(false);
            this.block();
            this.clearAll();
            this.unblock();
        },master));
	},
	sum:function(property, data){
		property = dhtmlx.Template.setter(property);
		
		data = data || this.data;
		var summ = 0; 
		data.each(function(obj){
			summ+=property(obj)*1;
		});
		return summ;
	},
	min:function(property, data){
		property = dhtmlx.Template.setter(property);
		
		data = data || this.data;
		var min = Infinity; 
		data.each(function(obj){
			if (property(obj)*1 < min) min = property(obj)*1;
		});
		return min*1;
	},
	max:function(property, data){
		property = dhtmlx.Template.setter(property);
		
		data = data || this.data;
		var max = -Infinity;
		data.each(function(obj){
			if (property(obj)*1 > max) max = property(obj)*1;
		});
		return max;
	},
	_split_data_by:function(stats){ 
		var any=function(property, data){
			property = dhtmlx.Template.setter(property);
			return property(data[0]);
		};
		var key = dhtmlx.Template.setter(stats.by);
		if (!stats.map[key])
			stats.map[key] = [key, any];
			
		var groups = {};
		var labels = [];
		this.data.each(function(data){
			var current = key(data);
			if (!groups[current]){
				labels.push({id:current});
				groups[current] = dhtmlx.toArray();
			}
			groups[current].push(data);
		});
		for (var prop in stats.map){
			var functor = (stats.map[prop][1]||any);
			if (typeof functor != "function")
				functor = this[functor];
				
			for (var i=0; i < labels.length; i++) {
				labels[i][prop]=functor.call(this, stats.map[prop][0], groups[labels[i].id]);
			}
		}
//		if (this._settings.sort)
//			labels.sortBy(stats.sort);

		/*this._not_grouped_data = this.data;
		this.data = new dhtmlx.DataStore();
		this.data.provideApi(this,true);
		this._init_group_data_event(this.data, this);
		this.parse(labels,"json");*/

		this.data._not_grouped_order = this.data.order;
		this.data._not_grouped_pull = this.data.pull;

		this.data.order = dhtmlx.toArray();
		this.data.pull = {};
		for (var i=0; i < labels.length; i++){
			var id = this.data.id(labels[i]);
			/*if(!labels[i].id)
				labels[i].id = dhtmlx.uid();
			var id = labels[i].id;*/
			this.data.pull[id] = labels[i];
			this.data.order.push(id);
		}

		this.callEvent("onStoreUpdated",[]);
	},
	group:function(config,mode){
		this.ungroup(false);
		this._split_data_by(config);
		if (mode!==false)
			this.data.callEvent("onStoreUpdated",[]);
	},
	ungroup:function(mode){
		/*if (this._not_grouped_data){
			this.data = this._not_grouped_data;
			this.data.provideApi(this, true);
		}*/
		if (this.data._not_grouped_order){
			this.data.order = this.data._not_grouped_order;
			this.data.pull = this.data._not_grouped_pull;
			this.data._not_grouped_pull = this.data._not_grouped_order = null;
		}
		if (mode!==false)
			this.data.callEvent("onStoreUpdated",[]);
	},
	group_setter:function(config){
		dhtmlx.assert(typeof config == "object", "Incorrect group value");
		dhtmlx.assert(config.by,"group.by is mandatory");
		dhtmlx.assert(config.map,"group.map is mandatory");
		return config;
	},
	//need to be moved to more appropriate object
	sort_setter:function(config){
		if (typeof config != "object")
			config = { by:config };
		
		this._mergeSettings(config,{
			as:"string",
			dir:"asc"
		});
		return config;
	}
};




/* DHX DEPEND FROM FILE 'date.js'*/


/*DHX:Depend dhtmlx.js*/

dhtmlx.Date={
	Locale: {
		month_full:["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
		month_short:["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
		day_full:["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    	day_short:["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
    },

	date_part:function(date){
		date.setHours(0);
		date.setMinutes(0);
		date.setSeconds(0);
		date.setMilliseconds(0);	
		return date;
	},
	time_part:function(date){
		return (date.valueOf()/1000 - date.getTimezoneOffset()*60)%86400;
	},
	week_start:function(date){
			var shift=date.getDay();
			if (this.config.start_on_monday){
				if (shift===0) shift=6;
				else shift--;
			}
			return this.date_part(this.add(date,-1*shift,"day"));
	},
	month_start:function(date){
		date.setDate(1);
		return this.date_part(date);
	},
	year_start:function(date){
		date.setMonth(0);
		return this.month_start(date);
	},
	day_start:function(date){
			return this.date_part(date);
	},
	add:function(date,inc,mode){
		var ndate=new Date(date.valueOf());
		switch(mode){
			case "day": ndate.setDate(ndate.getDate()+inc); break;
			case "week": ndate.setDate(ndate.getDate()+7*inc); break;
			case "month": ndate.setMonth(ndate.getMonth()+inc); break;
			case "year": ndate.setYear(ndate.getFullYear()+inc); break;
			case "hour": ndate.setHours(ndate.getHours()+inc); break;
			case "minute": ndate.setMinutes(ndate.getMinutes()+inc); break;
			default:
				return dhtmlx.Date["add_"+mode](date,inc,mode);
		}
		return ndate;
	},
	to_fixed:function(num){
		if (num<10)	return "0"+num;
		return num;
	},
	copy:function(date){
		return new Date(date.valueOf());
	},
	date_to_str:function(format,utc){
		format=format.replace(/%[a-zA-Z]/g,function(a){
			switch(a){
				case "%d": return "\"+dhtmlx.Date.to_fixed(date.getDate())+\"";
				case "%m": return "\"+dhtmlx.Date.to_fixed((date.getMonth()+1))+\"";
				case "%j": return "\"+date.getDate()+\"";
				case "%n": return "\"+(date.getMonth()+1)+\"";
				case "%y": return "\"+dhtmlx.Date.to_fixed(date.getFullYear()%100)+\""; 
				case "%Y": return "\"+date.getFullYear()+\"";
				case "%D": return "\"+dhtmlx.Date.Locale.day_short[date.getDay()]+\"";
				case "%l": return "\"+dhtmlx.Date.Locale.day_full[date.getDay()]+\"";
				case "%M": return "\"+dhtmlx.Date.Locale.month_short[date.getMonth()]+\"";
				case "%F": return "\"+dhtmlx.Date.Locale.month_full[date.getMonth()]+\"";
				case "%h": return "\"+dhtmlx.Date.to_fixed((date.getHours()+11)%12+1)+\"";
				case "%g": return "\"+((date.getHours()+11)%12+1)+\"";
				case "%G": return "\"+date.getHours()+\"";
				case "%H": return "\"+dhtmlx.Date.to_fixed(date.getHours())+\"";
				case "%i": return "\"+dhtmlx.Date.to_fixed(date.getMinutes())+\"";
				case "%a": return "\"+(date.getHours()>11?\"pm\":\"am\")+\"";
				case "%A": return "\"+(date.getHours()>11?\"PM\":\"AM\")+\"";
				case "%s": return "\"+dhtmlx.Date.to_fixed(date.getSeconds())+\"";
				case "%W": return "\"+dhtmlx.Date.to_fixed(dhtmlx.Date.getISOWeek(date))+\"";
				default: return a;
			}
		});
		if (utc) format=format.replace(/date\.get/g,"date.getUTC");
		return new Function("date","return \""+format+"\";");
	},
	str_to_date:function(format,utc){
		var splt="var temp=date.split(/[^0-9a-zA-Z]+/g);";
		var mask=format.match(/%[a-zA-Z]/g);
		for (var i=0; i<mask.length; i++){
			switch(mask[i]){
				case "%j":
				case "%d": splt+="set[2]=temp["+i+"]||1;";
					break;
				case "%n":
				case "%m": splt+="set[1]=(temp["+i+"]||1)-1;";
					break;
				case "%y": splt+="set[0]=temp["+i+"]*1+(temp["+i+"]>50?1900:2000);";
					break;
				case "%g":
				case "%G":
				case "%h": 
				case "%H":
							splt+="set[3]=temp["+i+"]||0;";
					break;
				case "%i":
							splt+="set[4]=temp["+i+"]||0;";
					break;
				case "%Y":  splt+="set[0]=temp["+i+"]||0;";
					break;
				case "%a":					
				case "%A":  splt+="set[3]=set[3]%12+((temp["+i+"]||'').toLowerCase()=='am'?0:12);";
					break;					
				case "%s":  splt+="set[5]=temp["+i+"]||0;";
					break;
			}
		}
		var code ="set[0],set[1],set[2],set[3],set[4],set[5]";
		if (utc) code =" Date.UTC("+code+")";
		return new Function("date","var set=[0,0,1,0,0,0]; "+splt+" return new Date("+code+");");
	},
		
	getISOWeek: function(ndate) {
		if(!ndate) return false;
		var nday = ndate.getDay();
		if (nday === 0) {
			nday = 7;
		}
		var first_thursday = new Date(ndate.valueOf());
		first_thursday.setDate(ndate.getDate() + (4 - nday));
		var year_number = first_thursday.getFullYear(); // year of the first Thursday
		var ordinal_date = Math.floor( (first_thursday.getTime() - new Date(year_number, 0, 1).getTime()) / 86400000); //ordinal date of the first Thursday - 1 (so not really ordinal date)
		var week_number = 1 + Math.floor( ordinal_date / 7);	
		return week_number;
	},
	
	getUTCISOWeek: function(ndate){
   	return this.getISOWeek(ndate);
   }
};






/* DHX DEPEND FROM FILE 'math.js'*/


dhtmlx.math = {};
dhtmlx.math._toHex=["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"];
dhtmlx.math.toHex = function(number, length){
	number=parseInt(number,10);
	str = "";
		while (number>0){
			str=this._toHex[number%16]+str;
			number=Math.floor(number/16);
		}
		while (str.length <length)
			str = "0"+str;
	return str;
};
dhtmlx.math.hexToDec = function(hex){
   	return parseInt(hex, 16);
};
dhtmlx.math.toRgb = function(rgb){
   	var r,g,b,rgbArr;
   	if (typeof(rgb) != 'string') {
    	r = rgb[0];
       	g = rgb[1];
       	b = rgb[2];
   	} else if (rgb.indexOf('rgb')!=-1) {
		rgbArr = rgb.substr(rgb.indexOf("(")+1,rgb.lastIndexOf(")")-rgb.indexOf("(")-1).split(",");
	   	r = rgbArr[0];
	   	g = rgbArr[1];
	   	b = rgbArr[2];
   	} else {
       	if (rgb.substr(0, 1) == '#') {
        	rgb = rgb.substr(1);
       	}
       	r = this.hexToDec(rgb.substr(0, 2));
       	g = this.hexToDec(rgb.substr(2, 2));
       	b = this.hexToDec(rgb.substr(4, 2));
   	}
   	r = (parseInt(r,10)||0);
   	g = (parseInt(g,10)||0);
   	b = (parseInt(b,10)||0);
   	if (r < 0 || r > 255)
      	r = 0;
   	if (g < 0 || g > 255)
      	g = 0;
   	if (b < 0 || b > 255)
      	b = 0;
   	return [r,g,b];
}
dhtmlx.math.hsvToRgb = function(h, s, v){
	var hi,f,p,q,t,r,g,b;
   	hi = Math.floor((h/60))%6;
   	f = h/60-hi;
   	p = v*(1-s);
   	q = v*(1-f*s);
   	t = v*(1-(1-f)*s);
   	r = 0;
   	g = 0;
   	b = 0;
   	switch(hi) {
    	case 0:
        	r = v; g = t; b = p;
         	break;
      	case 1:
        	r = q; g = v; b = p;
         	break;
      	case 2:
        	r = p; g = v; b = t;
        	 break;
      	case 3:
        	r = p; g = q; b = v;
        	break;
      	case 4:
        	r = t; g = p; b = v;
        	break;
      	case 5:
        	r = v; g = p; b = q;
         	break;
   	}
    r = Math.floor(r*255);
    g = Math.floor(g*255);
    b = Math.floor(b*255);
    return [r, g, b];
};
dhtmlx.math.rgbToHsv = function(r, g, b){
   	var r0,g0,b0,min0,max0,s,h,v;
   	r0 = r/255;
   	g0 = g/255;
   	b0 = b/255;
   	var min0 = Math.min(r0, g0, b0);
   	var max0 = Math.max(r0, g0, b0);
   	h = 0;
   	s = max0==0?0:(1-min0/max0);
   	v = max0;
   	if (max0 == min0) {
   		h = 0;
   	} else if (max0 == r0 && g0>=b0) {
    	h = 60*(g0 - b0)/(max0 - min0)+0;
   	} else if (max0 == r0 && g0 < b0) {
    	h = 60*(g0 - b0)/(max0 - min0)+360;
   	} else if (max0 == g0) {
      	h = 60*(b0 - r0)/(max0-min0)+120;
   	} else if (max0 == b0) {
      	h = 60*(r0 - g0)/(max0 - min0)+240;
   	}
   	return [h, s, v];
}




/* DHX DEPEND FROM FILE 'ext/chart/presets.js'*/


/*chart presents*/
if(!dhtmlx.presets)
    dhtmlx.presets = {};
dhtmlx.presets.chart = {
    "simple":{
        item:{
            borderColor: "#ffffff",
            color: "#2b7100",
            shadow: false,
            borderWidth:2
        },
		line:{
			color:"#8ecf03",
            width:2
		}
    },
    "plot":{
        color:"#1293f8",
        item:{
            borderColor:"#636363",
            borderWidth:1,
            color: "#ffffff",
            type:"r",
            shadow: false
        },
	    line:{
			color:"#1293f8",
            width:2
	    }
    },
    "diamond":{
        color:"#b64040",
        item:{
			borderColor:"#b64040",
			color: "#b64040",
            type:"d",
            radius:3,
            shadow:true
        },
		line:{
			color:"#ff9000",
            width:2
		}
    },
    "point":{
        color:"#fe5916",
		disableLines:true,
        fill:false,
        disableItems:false,
        item:{
            color:"#feb916",
            borderColor:"#fe5916",
            radius:2,
            borderWidth:1,
            type:"r"
	    },
        alpha:1
    },
    "line":{
        line:{
            color:"#3399ff",
            width:2
        },
        item:{
            color:"#ffffff",
            borderColor:"#3399ff",
            radius:2,
            borderWidth:2,
            type:"d"
        },
        fill:false,
        disableItems:false,
        disableLines:false,
        alpha:1
    },
    "area":{
        fill:"#3399ff",
        line:{
            color:"#3399ff",
            width:1
        },
        disableItems:true,
        alpha: 0.2,
        disableLines:false
    },
    "round":{
        item:{
            radius:3,
            borderColor:"#3f83ff",
            borderWidth:1,
            color:"#3f83ff",
            type:"r",
            shadow:false,
            alpha:0.6
        }
    },
    "square":{
         item:{
            radius:3,
            borderColor:"#447900",
            borderWidth:2,
            color:"#69ba00",
            type:"s",
            shadow:false,
            alpha:1
        }
    },
    /*bar*/
    "column":{
        color:"RAINBOW",
        gradient:false,
        width:45,
        radius:0,
        alpha:1,
        border:true
    },
    "stick":{
        width:5,
        gradient:false,
		color:"#67b5c9",
        radius:2,
        alpha:1,
        border:false
    },
    "alpha":{
        color:"#b9a8f9",
        width:70,
        gradient:"falling",
        radius:0,
        alpha:0.5,
        border:true
    }
};



/* DHX DEPEND FROM FILE 'map.js'*/


/*DHX:Depend dhtmlx.js*/
	
dhtmlx.ui.Map = function(key){
	this.name = "Map";
	this._id = "map_"+dhtmlx.uid();
	this._key = key;
	this._map = [];
	this._areas = [];
};
dhtmlx.ui.Map.prototype = {
	addRect: function(id,points,userdata) {
		this._areas.push({ index: userdata, points: points });
		this._createMapArea(id,"RECT",points,userdata);
	},
	addPoly: function(id,points,userdata) {
		this._createMapArea(id,"POLY",points,userdata);
	},
	_createMapArea:function(id,shape,coords,userdata){
		var extra_data = "";
		if(arguments.length==4) 
			extra_data = "userdata='"+userdata+"'";
		this._map.push("<area "+this._key+"='"+id+"' shape='"+shape+"' coords='"+coords.join()+"' "+extra_data+"></area>");
	},
	addSector:function(id,alpha0,alpha1,x,y,R,ky,userdata){
		var points = [];
		points.push(x);
		points.push(Math.floor(y*ky)); 
		for(var i = alpha0; i < alpha1; i+=Math.PI/18){
			points.push(Math.floor(x+R*Math.cos(i)));
			points.push(Math.floor((y+R*Math.sin(i))*ky));
		}
		points.push(Math.floor(x+R*Math.cos(alpha1)));
		points.push(Math.floor((y+R*Math.sin(alpha1))*ky));
		points.push(x);
		points.push(Math.floor(y*ky)); 
		
		return this.addPoly(id,points,userdata);
	},
	render:function(obj){
		var d = dhtmlx.html.create("DIV");
		d.style.cssText="position:absolute; width:100%; height:100%; top:0px; left:0px;";
		obj.appendChild(d);
		var src = dhtmlx._isIE?"":"src='data:image/gif;base64,R0lGODlhEgASAIAAAP///////yH5BAUUAAEALAAAAAASABIAAAIPjI+py+0Po5y02ouz3pwXADs='";
		d.innerHTML="<map id='"+this._id+"' name='"+this._id+"'>"+this._map.join("\n")+"</map><img "+src+" class='dhx_map_img' usemap='#"+this._id+"' onmousedown='return false;'>";
		
		obj._htmlmap = d; //for clearing routine
		
		this._map = [];
	}
};


/* DHX DEPEND FROM FILE 'ext/chart/chart_base.js'*/


/*DHX:Depend map.js*/
dhtmlx.chart = {};


/* DHX DEPEND FROM FILE 'ext/chart/chart_scatter.js'*/


/*DHX:Depend ext/chart/chart_base.js*/
dhtmlx.chart.scatter = {

	/**
	*   renders a graphic
	*   @param: ctx - canvas object
	*   @param: data - object those need to be displayed
	*   @param: point0  - top left point of a chart
	*   @param: point1  - right bottom point of a chart
	*   @param: sIndex - index of drawing chart
    *   @param: map - map object
	*/
	pvt_render_scatter:function(ctx, data, point0, point1, sIndex, map){
        if(!this._settings.xValue)
            return dhtmlx.log("warning","Undefined propery: xValue");
        /*max in min values*/
        var limitsY = this._getLimits();
        var limitsX = this._getLimits("h","xValue");
        /*render scale*/
        if(!sIndex){
	        if(!this.canvases["x"])
	            this.canvases["x"] = new dhtmlx.ui.Canvas(this._obj,"axis_x");
	        if(!this.canvases["y"])
	            this.canvases["y"] = new dhtmlx.ui.Canvas(this._obj,"axis_y");
            this._drawYAxis(this.canvases["y"].getCanvas(),data,point0,point1,limitsY.min,limitsY.max);
		    this._drawHXAxis(this.canvases["x"].getCanvas(),data,point0,point1,limitsX.min,limitsX.max);
        }
        limitsY = {min:this._settings.yAxis.start,max:this._settings.yAxis.end};
        limitsX = {min:this._settings.xAxis.start,max:this._settings.xAxis.end};
        var params = this._getScatterParams(ctx,data,point0,point1,limitsX,limitsY);
		this._mapStart = point0;
	    for(var i=0;i<data.length;i++){
            this._drawScatterItem(ctx,map,point0, point1, params,limitsX,limitsY,data[i],sIndex);
        }
    },
    _getScatterParams:function(ctx, data, point0, point1,limitsX,limitsY){
        var params = {};
		/*available space*/
		params.totalHeight = point1.y-point0.y;
        /*available width*/
        params.totalWidth = point1.x-point0.x;
		/*unit calculation (y_position = value*unit)*/
        this._calcScatterUnit(params,limitsX.min,limitsX.max,params.totalWidth,"X");
        this._calcScatterUnit(params,limitsY.min,limitsY.max,params.totalHeight,"Y");
		return params;
    },
    _drawScatterItem:function(ctx,map,point0, point1,params,limitsX,limitsY,obj,sIndex){
        var x0 = this._calculateScatterItemPosition(params, point1, point0, limitsX, obj, "X");
        var y0 = this._calculateScatterItemPosition(params, point0, point1, limitsY, obj, "Y");
        this. _drawItem(ctx,x0,y0,obj,this._settings.label.call(this,obj),sIndex,map);
    },
    _calculateScatterItemPosition:function(params, point0, point1, limits, obj, axis){
		/*the real value of an object*/
		var value = this._settings[axis=="X"?"xValue":"value"].call(this,obj);
		/*a relative value*/
        var valueFactor = params["valueFactor"+axis];
		var v = (parseFloat(value||0) - limits.min)*valueFactor;
		/*a vertical coordinate*/
        var unit = params["unit"+axis];
		var pos = point1[axis.toLowerCase()] - (axis=="X"?(-1):1)*Math.floor(unit*v);
		/*the limit of the minimum value is  the minimum visible value*/
		if(v<0)
			pos = point1[axis.toLowerCase()];
		/*the limit of the maximum value*/
		if(value > limits.max)
			pos = point0[axis.toLowerCase()];
		/*the limit of the minimum value*/
		if(value < limits.min)
			pos = point1[axis.toLowerCase()];
        return pos;
    },
    _calcScatterUnit:function(p,min,max,size,axis){
        var relativeValues = this._getRelativeValue(min,max);
        axis = (axis||"");
		p["relValue"+axis] = relativeValues[0];
		p["valueFactor"+axis] = relativeValues[1];
		p["unit"+axis] = (p["relValue"+axis]?size/p["relValue"+axis]:10);
    }
};



/* DHX DEPEND FROM FILE 'ext/chart/chart_radar.js'*/


/*DHX:Depend ext/chart/chart_base.js*/
dhtmlx.chart.radar = {
	pvt_render_radar:function(ctx,data,x,y,sIndex,map){
		this._renderRadarChart(ctx,data,x,y,sIndex,map);
		
	}, 
	/**
	*   renders a pie chart
	*   @param: ctx - canvas object
	*   @param: data - object those need to be displayed
	*   @param: x - the width of the container
	*   @param: y - the height of the container
	*   @param: ky - value from 0 to 1 that defines an angle of inclination (0<ky<1 - 3D chart)
	*/
	_renderRadarChart:function(ctx,data,point0,point1,sIndex,map){
		if(!data.length)
			return;
		var coord = this._getPieParameters(point0,point1);
		/*scale radius*/
		var radius = (this._settings.radius?this._settings.radius:coord.radius);
    	/*scale center*/
		var x0 = (this._settings.x?this._settings.x:coord.x);
		var y0 = (this._settings.y?this._settings.y:coord.y);
        /*angles for each unit*/
		var ratioUnits = [];
        for(var i=0;i<data.length;i++)
           ratioUnits.push(1)
		var ratios = this._getRatios(ratioUnits,data.length);
		this._mapStart = point0;
		if(!sIndex)
            this._drawRadarAxises(ratios,x0,y0,radius,data);
        this._drawRadarData(ctx,ratios,x0,y0,radius,data,sIndex,map);
	},
     _drawRadarData:function(ctx,ratios,x,y,radius,data,sIndex,map){
        var alpha0 ,alpha1, config, i, min, max, pos0, pos1, posArr,
	        r0, r1, relValue, startAlpha, value, value0, value1, valueFactor,
	        unit, unitArr;
        config = this._settings;
		/*unit calculation (item_radius_pos = value*unit)*/
        min = config.yAxis.start;
        max = config.yAxis.end;
		unitArr = this._getRelativeValue(min,max);
        relValue = unitArr[0];
		unit = (relValue?radius/relValue:radius/2);
        valueFactor = unitArr[1];

        startAlpha = -Math.PI/2;
        alpha0 =  alpha1 = startAlpha;
        posArr = [];
	    pos1 = 0;
        for(i=0;i<data.length;i++){
            if(!value1){
                value = config.value(data[i]);
                /*a relative value*/
                value0 = (parseFloat(value||0) - min)*valueFactor;
            }
            else
                value0 = value1;
            r0 = Math.floor(unit*value0);

            value = config.value((i!=(data.length-1))?data[i+1]:data[0]);
            value1 = (parseFloat(value||0) - min)*valueFactor;
            r1 = Math.floor(unit*value1);
            alpha0 = alpha1;
            alpha1 = ((i!=(data.length-1))?(startAlpha+ratios[i]-0.0001):startAlpha);
            pos0 = (pos1||this._getPositionByAngle(alpha0,x,y,r0));
            pos1 = this._getPositionByAngle(alpha1,x,y,r1);
            /*creates map area*/
			/*areaWidth  = (config.eventRadius||(parseInt(config.item.radius.call(this,data[i]),10)+config.item.borderWidth));
		    map.addRect(data[i].id,[pos0.x-areaWidth,pos0.y-areaWidth,pos0.x+areaWidth,pos0.y+areaWidth],sIndex);*/
            //this._drawLine(ctx,pos0.x,pos0.y,pos1.x,pos1.y,config.line.color.call(this,data[i]),config.line.width)
            posArr.push(pos0);
        }
         if(config.fill)
             this._fillRadarChart(ctx,posArr,data);
         if(!config.disableLines)
            this._strokeRadarChart(ctx,posArr,data);
         if(!config.disableItems)
             this._drawRadarItemMarkers(ctx,posArr,data,sIndex,map);
         posArr = null;
    },
    _drawRadarItemMarkers:function(ctx,points,data,sIndex,map){
        for(var i=0;i < points.length;i++){
            this._drawItem(ctx,points[i].x,points[i].y,data[i],this._settings.label.call(this,data),sIndex,map);
        }
    },
     _fillRadarChart:function(ctx,points,data){
        var pos0,pos1;
        ctx.globalAlpha= this._settings.alpha.call(this,{});

		ctx.beginPath();
        for(var i=0;i < points.length;i++){
            ctx.fillStyle = this._settings.fill.call(this,data[i]);
            pos0 = points[i];
            pos1 = (points[i+1]|| points[0]);
            if(!i){

                ctx.moveTo(pos0.x,pos0.y);
            }
            ctx.lineTo(pos1.x,pos1.y)
        }
         ctx.fill();
         ctx.globalAlpha=1;
    },
    _strokeRadarChart:function(ctx,points,data){
        var pos0,pos1;
        for(var i=0;i < points.length;i++){
            pos0 = points[i];
            pos1 = (points[i+1]|| points[0]);
            this._drawLine(ctx,pos0.x,pos0.y,pos1.x,pos1.y,this._settings.line.color.call(this,data[i]),this._settings.line.width)
        }
    },
    _drawRadarAxises:function(ratios,x,y,radius,data){
        var configY = this._settings.yAxis;
        var configX = this._settings.xAxis;
        var start = configY.start;
        var end = configY.end;
        var step = configY.step;
        var scaleParam= {};
        var config = this._configYAxis;
        if(typeof config.step =="undefined"||typeof config.start=="undefined"||typeof config.end =="undefined"){
            var limits = this._getLimits();
			scaleParam = this._calculateScale(limits.min,limits.max);
			start = scaleParam.start;
			end = scaleParam.end;
			step = scaleParam.step;
			configY.end = end;
			configY.start = start;
		}
        var units = [];
        var i,j,p;
        var c=0;
        var stepHeight = radius*step/(end-start);
        /*correction for small step*/
        var power,corr;
        if(step<1){
			power = Math.min(this._log10(step),(start<=0?0:this._log10(start)));
			corr = Math.pow(10,-power);
        }
        var angles = [];
	    if(!this.canvases["scale"])
	        this.canvases["scale"] =  new dhtmlx.ui.Canvas(this._obj,"radar_scale");
	    var ctx = this.canvases["scale"].getCanvas();
        for(i = end; i>=start; i -=step){
			if(scaleParam.fixNum)  i = parseFloat((new Number(i)).toFixed(scaleParam.fixNum));
            units.push(Math.floor(c*stepHeight)+ 0.5);
            if(corr){
				i = Math.round(i*corr)/corr;
			}
            var unitY = y-radius+units[units.length-1];

            this.canvases["scale"].renderTextAt("middle","left",x,unitY,
				configY.template(i.toString()),
				"dhx_axis_item_y dhx_radar"
			);
            if(ratios.length<2){
                this._drawScaleSector(ctx,"arc",x,y,radius-units[units.length-1],-Math.PI/2,3*Math.PI/2,i);
                return;
            }
            var startAlpha = -Math.PI/2;/*possibly need  to moved in config*/
            var alpha0 = startAlpha;
            var alpha1;
            for(j=0;j< ratios.length;j++){
                if(i==end)
                   angles.push(alpha0);
                alpha1 = startAlpha+ratios[j]-0.0001;
                this._drawScaleSector(ctx,(config.lineShape||"line"),x,y,radius-units[units.length-1],alpha0,alpha1,i,j,data[i]);
                alpha0 = alpha1;
            }
            c++;
        }
         /*renders radius lines and labels*/
        for(i=0;i< angles.length;i++){
            p = this._getPositionByAngle(angles[i],x,y,radius);
	        if(configX.lines.call(this,data[i],i))
                this._drawLine(ctx,x,y,p.x,p.y,(configX?configX.lineColor.call(this,data[i]):"#cfcfcf"),1);
            this._drawRadarScaleLabel(ctx,x,y,radius,angles[i],(configX?configX.template.call(this,data[i]):"&nbsp;"));
        }

    },
    _drawScaleSector:function(ctx,shape,x,y,radius,a1,a2,i,j){
         var pos1, pos2;
         if(radius<0)
            return false;
         pos1 = this._getPositionByAngle(a1,x,y,radius);
         pos2 = this._getPositionByAngle(a2,x,y,radius);
         var configY = this._settings.yAxis;
         if(configY.bg){
             ctx.beginPath();
             ctx.moveTo(x,y);
             if(shape=="arc")
                 ctx.arc(x,y,radius,a1,a2,false);
             else{
                 ctx.lineTo(pos1.x,pos1.y);
                 ctx.lineTo(pos2.x,pos2.y);
             }
             ctx.fillStyle =  configY.bg(i,j);
             ctx.moveTo(x,y);
             ctx.fill();
             ctx.closePath();
         }
         if(configY.lines.call(this,i)){
             ctx.lineWidth = 1;
             ctx.beginPath();
              if(shape=="arc")
                 ctx.arc(x,y,radius,a1,a2,false);
             else{
                 ctx.moveTo(pos1.x,pos1.y);
                 ctx.lineTo(pos2.x,pos2.y);
             }
             ctx.strokeStyle = configY.lineColor.call(this,i);
             ctx.stroke();
         }
    },
    _drawRadarScaleLabel:function(ctx,x,y,r,a,text){
         var t = this.canvases["scale"].renderText(0,0,text,"dhx_axis_radar_title",1);
         var width = t.scrollWidth;
         var height = t.offsetHeight;
         var delta = 0.001;
         var pos =  this._getPositionByAngle(a,x,y,r+5);
         var corr_x=0,corr_y=0;
         if(a<0||a>Math.PI){
             corr_y = -height;
         }
         if(a>Math.PI/2){
             corr_x = -width;
         }
         if(Math.abs(a+Math.PI/2)<delta||Math.abs(a-Math.PI/2)<delta){
            corr_x = -width/2;
         }
         else if(Math.abs(a)<delta||Math.abs(a-Math.PI)<delta){
            corr_y = -height/2;
         }
         t.style.top  = pos.y+corr_y+"px";
	     t.style.left = pos.x+corr_x+"px";
		 t.style.width = width+"px";
		 t.style.whiteSpace = "nowrap";
    }
};



/* DHX DEPEND FROM FILE 'ext/chart/chart_area.js'*/


/*DHX:Depend ext/chart/chart_base.js*/
dhtmlx.chart.area = {
	/**
	*   renders an area chart
	*   @param: ctx - canvas object
	*   @param: data - object those need to be displayed
	*   @param: width - the width of the container
	*   @param: height - the height of the container
	*   @param: sIndex - index of drawing chart
	*/
	pvt_render_area:function(ctx, data, point0, point1, sIndex, map){
		var align, config, i, mapRect, obj, params, path,
			res1, res2, x0, x1, y1, x2, y2, y0;

		params = this._calculateLineParams(ctx,data,point0,point1,sIndex);
		config = this._settings;

		//the size of map area
		mapRect = (config.eventRadius||Math.floor(params.cellWidth/2));

		if (data.length) {

			// area points
			path = [];

			//the x position of the first item
			x0 = (!config.offset?point0.x:point0.x+params.cellWidth*0.5);

			/*
				iterates over all data items:
			    calculates [x,y] for area path, adds rect to chart map and renders labels
			*/
			for(i=0; i < data.length;i ++){
				obj = data[i];

				res2 = this._getPointY(obj,point0,point1,params);
				x2 = x0 + params.cellWidth*i ;
				if(res2){
					y2 = (typeof res2 == "object"?res2.y0:res2);
					if(i && this._settings.fixOverflow){
						res1 = this._getPointY(data[i-1],point0,point1,params);
						if(res1.out && res1.out == res2.out){
							continue;
						}
						x1 = params.cellWidth*(i-1) - 0.5 + x0;
						y1 = (typeof res1 == "object"?res1.y0:res1);
						if(res1.out){
							y0 = (res1.out == "min"?point1.y:point0.y);
							path.push([this._calcOverflowX(x1,x2,y1,y2,y0),y0]);
						}
						if(res2.out){
							y0 = (res2.out == "min"?point1.y:point0.y);
							path.push([this._calcOverflowX(x1,x2,y1,y2,y0),y0]);
							if(i == (data.length-1) && y0 == point0.y)
								path.push([x2,point0.y]);
						}
					}
					if(!res2.out){
						path.push([x2,y2]);
						//map
						map.addRect(obj.id,[x2-mapRect-point0.x,y2-mapRect-point0.y,x2+mapRect-point0.x,y2+mapRect-point0.y],sIndex);
					}

					//labels
					if(!config.yAxis){
						align = (!config.offset&&(i == data.length-1)?"left":"center");
						this.canvases[sIndex].renderTextAt(false, align, x2, y2-config.labelOffset,config.label(obj));
					}
				}

			}
			if(path.length){
				path.push([x2,point1.y]);
				path.push([path[0][0],point1.y]);
			}



			//filling area
			ctx.globalAlpha = this._settings.alpha.call(this,data[0]);
			ctx.fillStyle = this._settings.color.call(this,data[0]);
			ctx.beginPath();
			this._path(ctx,path);
			ctx.fill();

			//border
			if(config.border){
				ctx.lineWidth = config.borderWidth||1;
				if(config.borderColor)
					ctx.strokeStyle =  config.borderColor.call(this,data[0]);
				else
					this._setBorderStyles(ctx,ctx.fillStyle);

				ctx.beginPath();
				this._path(ctx,path);
				ctx.stroke();

			}
			ctx.lineWidth = 1;
			ctx.globalAlpha =1;

		}
	}
};
dhtmlx.chart.stackedArea ={
	/**
	*   renders an area chart
	*   @param: ctx - canvas object
	*   @param: data - object those need to be displayed
	*   @param: width - the width of the container
	*   @param: height - the height of the container
	*   @param: sIndex - index of drawing chart
	*/
	pvt_render_stackedArea:function(ctx, data, point0, point1, sIndex, map){
		var a0, a1, align, config, i, j, lastItem, mapRect, obj, params, path, x, y, yPos;

		params = this._calculateLineParams(ctx,data,point0,point1,sIndex);

		config = this._settings;

		/*the value that defines the map area position*/
		mapRect = (config.eventRadius||Math.floor(params.cellWidth/2));

	
		/*drawing all items*/
		if (data.length) {

			// area points
			path = [];

			// y item positions
			yPos = [];

			//the x position of the first item
			x = (!config.offset?point0.x:point0.x+params.cellWidth*0.5);


			var setOffset = function(i,y){
				return sIndex?(data[i].$startY?y-point1.y+data[i].$startY:0):y;
			};

			var solveEquation  = function(x,p0,p1){
				var k = (p1.y - p0.y)/(p1.x - p0.x);
				return  k*x + p0.y - k*p0.x;
			};

			/*
			 iterates over all data items:
			 calculates [x,y] for area path, adds rect to chart map and renders labels
			 */

			for(i=0; i < data.length;i ++){
				obj = data[i];

				if(!i){
					y =  setOffset(i,point1.y);
					path.push([x,y]);
				}
				else{
					x += params.cellWidth ;
				}

				y = setOffset(i,this._getPointY(obj,point0,point1,params));

				yPos.push((isNaN(y)&&!i)?(data[i].$startY||point1.y):y);

				if(y){
					path.push([x,y]);

					//map
					map.addRect(obj.id,[x-mapRect-point0.x,y-mapRect-point0.y,x+mapRect-point0.x,y+mapRect-point0.y],sIndex);

					//labels
					if(!config.yAxis){
						align = (!config.offset&&lastItem?"left":"center");
						this.canvases[sIndex].renderTextAt(false, align, x, y-config.labelOffset,config.label(obj));
					}
				}
			}

			// bottom right point
			path.push([x,setOffset(i-1,point1.y)]);

			// lower border from the end to start
            if(sIndex){
				for(i=data.length-2; i > 0; i --){
				    x -= params.cellWidth ;
					y =  data[i].$startY;
					if(y)
						path.push([x,y]);
				}
			}

			// go to start point
			path.push([path[0][0],path[0][1]]);

			// filling path
			ctx.globalAlpha = this._settings.alpha.call(this,data[0]);
			ctx.fillStyle = this._settings.color.call(this,data[0]);
			ctx.beginPath();
			this._path(ctx,path);
			ctx.fill();

			// set y positions of the next series
			for(i=0; i < data.length;i ++){
				y =  yPos[i];

				if(!y){
					if(i == data.length-1){
						y = data[i].$startY;
					}
					for(j =i+1; j< data.length; j++){
						if(yPos[j]){
							a0 =  {x:point0.x,y:yPos[0]};
							a1 =  {x:(point0.x+params.cellWidth*j),y:yPos[j]};
							y = solveEquation(point0.x+params.cellWidth*i,a0,a1);
							break;
						}

					}
				}

				data[i].$startY = y;
			}


		}
	}
};



/* DHX DEPEND FROM FILE 'ext/chart/chart_spline.js'*/


/*DHX:Depend ext/chart/chart_base.js*/
dhtmlx.chart.spline = {
	/**
	*   renders a spline chart
	*   @param: ctx - canvas object
	*   @param: data - object those need to be displayed
	*   @param: width - the width of the container
	*   @param: height - the height of the container
	*   @param: sIndex - index of drawing chart
	*/
	pvt_render_spline:function(ctx, data, point0, point1, sIndex, map){

		var config,i,items,j,params,sparam,x,x0,x1,x2,y,y1,y2;
		params = this._calculateLineParams(ctx,data,point0,point1,sIndex);
		config = this._settings;
		this._mapStart = point0;

		/*array of all points*/
		items = [];

		/*drawing all items*/
		if (data.length) {

			/*getting all points*/
			x0 = (config.offset?point0.x+params.cellWidth*0.5:point0.x);
			for(i=0; i < data.length;i ++){
				y = this._getPointY(data[i],point0,point1,params);
				if(y){
					x = ((!i)?x0:params.cellWidth*i - 0.5 + x0);
					items.push({x:x,y:y,index:i});
				}
			}
			sparam = this._getSplineParameters(items);

			for(i =0; i< items.length; i++){
				x1 = items[i].x;
				y1 = items[i].y;
				if(i<items.length-1){
					x2 = items[i+1].x;
					y2 = items[i+1].y;
					for(j = x1; j < x2; j++){
						var sY1 = this._getSplineYPoint(j,x1,i,sparam.a,sparam.b,sparam.c,sparam.d);
						if(sY1<point0.y)
							sY1=point0.y;
						if(sY1>point1.y)
							sY1=point1.y;
						var sY2 = this._getSplineYPoint(j+1,x1,i,sparam.a,sparam.b,sparam.c,sparam.d);
						if(sY2<point0.y)
							sY2=point0.y;
						if(sY2>point1.y)
							sY2=point1.y;
						this._drawLine(ctx,j,sY1,j+1,sY2,config.line.color(data[i]),config.line.width);

					}
					this._drawLine(ctx,x2-1,this._getSplineYPoint(j,x1,i,sparam.a,sparam.b,sparam.c,sparam.d),x2,y2,config.line.color(data[i]),config.line.width);
				}
				this._drawItem(ctx,x1,y1,data[items[i].index],config.label(data[items[i].index]), sIndex, map);
				/*creates map area*/
				/*radius = (parseInt(config.item.radius.call(this,data[i-1]),10)||2);
			    areaPos = (config.eventRadius||radius+1);
				map.addRect(data[i].id,[x1-areaPos,y1-areaPos,x1+areaPos,y1+areaPos],sIndex); */

			}
			//this._drawItemOfLineChart(ctx,x2,y2,data[i],config.label(data[i]));

		}
	},
	/*gets spline parameter*/
	_getSplineParameters:function(points){
		var i,u,v,s,a,b,c,d,
		h = [],
	    m = [],
		n = points.length;
		
		for(i =0; i<n-1;i++){
			h[i] = points[i+1].x - points[i].x;
			m[i] = (points[i+1].y - points[i].y)/h[i];
		}
		u = [];	v = [];
		u[0] = 0;
		u[1] = 2*(h[0] + h[1]);
		v[0] = 0;
		v[1] = 6*(m[1] - m[0]);
		for(i =2; i < n-1; i++){
			u[i] = 2*(h[i-1]+h[i]) - h[i-1]*h[i-1]/u[i-1];
	    	v[i] = 6*(m[i]-m[i-1]) - h[i-1]*v[i-1]/u[i-1];
		}
		
		s = [];
		s[n-1] = s[0] = 0;
		for(i = n -2; i>=1; i--)
	   		s[i] = (v[i] - h[i]*s[i+1])/u[i];
	
        a = []; b = []; c = [];	d = []; 
		
		for(i =0; i<n-1;i++){
			a[i] = points[i].y;
			b[i] = - h[i]*s[i+1]/6 - h[i]*s[i]/3 + (points[i+1].y-points[i].y)/h[i];
			c[i] = s[i]/2;
			d[i] = (s[i+1] - s[i])/(6*h[i]);
		}
		return {a:a,b:b,c:c,d:d};
	},
	/*returns the y position of the spline point */
	_getSplineYPoint:function(x,xi,i,a,b,c,d){
		return a[i] + (x - xi)*(b[i] + (x-xi)*(c[i]+(x-xi)*d[i])); 
	}
};


/* DHX DEPEND FROM FILE 'ext/chart/chart_barh.js'*/


/*DHX:Depend ext/chart/chart_base.js*/
dhtmlx.chart.barH = {
	/**
	*   renders a bar chart
	*   @param: ctx - canvas object
	*   @param: data - object those need to be displayed
	*   @param: x - the width of the container
	*   @param: y - the height of the container
	*   @param: sIndex - index of drawing chart
	*/
	pvt_render_barH:function(ctx, data, point0, point1, sIndex, map){
	     var barOffset, barWidth, cellWidth, color, gradient, i, limits, maxValue, minValue,
		     innerGradient, valueFactor, relValue, radius, relativeValues,
		     startValue, totalWidth,value,  unit, x0, y0, yax;

		/*an available width for one bar*/
		cellWidth = (point1.y-point0.y)/data.length;

		limits = this._getLimits("h");

		maxValue = limits.max;
		minValue = limits.min;

		totalWidth = point1.x-point0.x;
		
		yax = !!this._settings.yAxis;
		
		/*draws x and y scales*/
		if(!sIndex)
			this._drawHScales(ctx,data,point0, point1,minValue,maxValue,cellWidth);
		
		/*necessary for automatic scale*/
		if(yax){
		    maxValue = parseFloat(this._settings.xAxis.end);
			minValue = parseFloat(this._settings.xAxis.start);
		}
		
		/*unit calculation (bar_height = value*unit)*/
		relativeValues = this._getRelativeValue(minValue,maxValue);
		relValue = relativeValues[0];
		valueFactor = relativeValues[1];
		
		unit = (relValue?totalWidth/relValue:10);
		if(!yax){
			/*defines start value for better representation of small values*/
			startValue = 10;
			unit = (relValue?(totalWidth-startValue)/relValue:10);
		}
		
		
		/*a real bar width */
		barWidth = parseInt(this._settings.width,10);


		var seriesNumber = this._series.length;
		var seriesMargin = this._settings.seriesMargin;
		var seriesPadding = this._settings.seriesPadding;

		if(this._series&&(barWidth*seriesNumber+seriesPadding + (seriesNumber>2?seriesMargin*seriesNumber:0)>cellWidth) )
			barWidth = cellWidth/seriesNumber-seriesPadding-(seriesNumber>2?seriesMargin:0);

		/*the half of distance between bars*/
		barOffset = (cellWidth - barWidth*seriesNumber - seriesMargin*(seriesNumber-1))/2;

		if(this._settings.border){
			barWidth = parseInt(barWidth,10);
			barOffset = parseInt(barOffset,10);
		}

		/*the radius of rounding in the top part of each bar*/
		radius = (typeof this._settings.radius!="undefined"?parseInt(this._settings.radius,10):Math.round(barWidth/5));
		
		innerGradient = false;
		gradient = this._settings.gradient;
	
		if (gradient&&typeof(gradient) != "function"){
			innerGradient = gradient;
			gradient = false;
		} else if (gradient){
			gradient = ctx.createLinearGradient(point0.x,point0.y,point1.x,point0.y);
			this._settings.gradient(gradient);
		}
		/*draws a black line if the horizontal scale isn't defined*/
		if(!yax){
			this._drawLine(ctx,point0.x-0.5,point0.y,point0.x-0.5,point1.y,"#000000",1); //hardcoded color!
		}
		
		
		
		for(i=0; i < data.length;i ++){
			
			
			value =  parseFloat(this._settings.value(data[i]||0));
			if(value>maxValue) value = maxValue;
			value -= minValue;
			value *= valueFactor;
			
			/*start point (bottom left)*/
			x0 = point0.x;
			y0 = point0.y + barOffset+(seriesNumber>2?seriesMargin*sIndex:0) + parseInt(i*cellWidth,10)+barWidth*sIndex;

			if((value<0&&this._settings.origin=="auto")||(this._settings.xAxis&&value===0&&!(this._settings.origin!="auto"&&this._settings.origin>minValue))){
				this.canvases[sIndex].renderTextAt("middle", "right", x0+10,y0+barWidth/2+barOffset,this._settings.label(data[i]));
				continue;
			}
			if(value<0&&this._settings.origin!="auto"&&this._settings.origin>minValue){
				value = 0;
			}
			
			/*takes start value into consideration*/
			if(!yax) value += startValue/unit;
			color = gradient||this._settings.color.call(this,data[i]);
			
			/*drawing the gradient border of a bar*/
			if(this._settings.border){
				this._drawBarHBorder(ctx,x0,y0,barWidth,minValue,radius,unit,value,color);
			}

			/*drawing bar body*/
			ctx.globalAlpha = this._settings.alpha.call(this,data[i]);
			var points = this._drawBarH(ctx,point1,x0,y0,barWidth,minValue,radius,unit,value,color,gradient,innerGradient);
			if (innerGradient!=false){
				this._drawBarHGradient(ctx,x0,y0,barWidth,minValue,radius,unit,value,color,innerGradient);

			}
			ctx.globalAlpha = 1;
			
			
			/*sets a bar label and map area*/
	
			if(points[3]==y0){
				this.canvases[sIndex].renderTextAt("middle", "left", points[0]-5,points[3]+Math.floor(barWidth/2),this._settings.label(data[i]));
				map.addRect(data[i].id,[points[0]-point0.x,points[3]-point0.y,points[2]-point0.x,points[3]+barWidth-point0.y],sIndex);
			
			}else{
				this.canvases[sIndex].renderTextAt("middle", false, points[2]+5,points[1]+Math.floor(barWidth/2),this._settings.label(data[i]));
				map.addRect(data[i].id,[points[0]-point0.x,y0-point0.y,points[2]-point0.x,points[3]-point0.y],sIndex);
			}
			  
		}
	},
	/**
	*   sets points for bar and returns the position of the bottom right point
	*   @param: ctx - canvas object
	*   @param: x0 - the x position of start point
	*   @param: y0 - the y position of start point
	*   @param: barWidth - bar width 
	*   @param: radius - the rounding radius of the top
	*   @param: unit - the value defines the correspondence between item value and bar height
	*   @param: value - item value
	*   @param: offset - the offset from expected bar edge (necessary for drawing border)
	*/
	_setBarHPoints:function(ctx,x0,y0,barWidth,radius,unit,value,offset,skipLeft){
		/*correction for displaing small values (when rounding radius is bigger than bar height)*/
		var angle_corr = 0;
		if(radius>unit*value){
			var sinA = (radius-unit*value)/radius;
			angle_corr = -Math.asin(sinA)+Math.PI/2;
		}
		/*start*/
		ctx.moveTo(x0,y0+offset);
		/*start of left rounding*/
		var x1 = x0 + unit*value - radius - (radius?0:offset);
		if(radius<unit*value)
			ctx.lineTo(x1,y0+offset);
   		/*left rounding*/
		var y2 = y0 + radius;
		if (radius&&radius>0)
			ctx.arc(x1,y2,radius-offset,-Math.PI/2+angle_corr,0,false);
   		/*start of right rounding*/
		var y3 = y0 + barWidth - radius - (radius?0:offset);
		var x3 = x1 + radius - (radius?offset:0);
		ctx.lineTo(x3,y3);
		/*right rounding*/
		if (radius&&radius>0)
			ctx.arc(x1,y3,radius-offset,0,Math.PI/2-angle_corr,false);
   		/*bottom right point*/
		var y5 = y0 + barWidth-offset;
        ctx.lineTo(x0,y5);
		/*line to the start point*/
		if(!skipLeft){
   			ctx.lineTo(x0,y0+offset);
   		}
	//	ctx.lineTo(x0,0); //IE fix!
		return [x3,y5];
	},
	 _drawHScales:function(ctx,data,point0,point1,start,end,cellWidth){
		 var x = 0;
		 if(this._settings.xAxis){
			 if(!this.canvases["x"])
			    this.canvases["x"] =  new dhtmlx.ui.Canvas(this._obj);
			 x = this._drawHXAxis(this.canvases["x"].getCanvas(),data,point0,point1,start,end);
		 }
		 if (this._settings.yAxis){
			 if(!this.canvases["y"])
			    this.canvases["y"] =  new dhtmlx.ui.Canvas(this._obj);
		    this._drawHYAxis(this.canvases["y"].getCanvas(),data,point0,point1,cellWidth,x);
		 }
	},
	_drawHYAxis:function(ctx,data,point0,point1,cellWidth,yAxisX){
		if (!this._settings.yAxis) return;
		var unitPos;
		var x0 = parseInt((yAxisX?yAxisX:point0.x),10)-0.5;
		var y0 = point1.y+0.5;
		var y1 = point0.y;
		this._drawLine(ctx,x0,y0,x0,y1,this._settings.yAxis.color,1);



		for(var i=0; i < data.length;i ++){

			/*scale labels*/
			var right = ((this._settings.origin!="auto")&&(this._settings.view=="barH")&&(parseFloat(this._settings.value(data[i]))<this._settings.origin));
			unitPos = y1+cellWidth/2+i*cellWidth;
			this.canvases["y"].renderTextAt("middle",(right?false:"left"),(right?x0+5:x0-5),unitPos,
				this._settings.yAxis.template(data[i]),
				"dhx_axis_item_y",(right?0:x0-10)
			);
			if(this._settings.yAxis.lines.call(this,data[i]))
				this._drawLine(ctx,point0.x,unitPos,point1.x,unitPos,this._settings.yAxis.lineColor.call(this,data[i]),1);
		}
		this._drawLine(ctx,point0.x+0.5,y1+0.5,point1.x,y1+0.5,this._settings.yAxis.lineColor.call(this,{}),1);
		this._setYAxisTitle(point0,point1);
	},
	_drawHXAxis:function(ctx,data,point0,point1,start,end){
		var step;
		var scaleParam= {};
		var axis = this._settings.xAxis;
		if (!axis) return;
		
		var y0 = point1.y+0.5;
		var x0 = point0.x-0.5;
		var x1 = point1.x-0.5;
		var yAxisStart = point0.x;
		this._drawLine(ctx,x0,y0,x1,y0,axis.color,1);
		
		if(axis.step)
		     step = parseFloat(axis.step);
		
		if(typeof this._configXAxis.step =="undefined"||typeof this._configXAxis.start=="undefined"||typeof this._configXAxis.end =="undefined"){
			scaleParam = this._calculateScale(start,end);
			start = scaleParam.start;
			end = scaleParam.end;
			step = scaleParam.step;
			this._settings.xAxis.end = end;
			this._settings.xAxis.start = start;
			this._settings.xAxis.step = step;
		}
		
		if(step===0) return;
		var stepHeight = (x1-x0)*step/(end-start);
		var c = 0;
		for(var i = start; i<=end; i += step){
			if(scaleParam.fixNum)  i = parseFloat((new Number(i)).toFixed(scaleParam.fixNum));
			var xi = Math.floor(x0+c*stepHeight)+ 0.5;/*canvas line fix*/
			if(!(i==start&&this._settings.origin=="auto") &&axis.lines.call(this,i))
				this._drawLine(ctx,xi,y0,xi,point0.y,this._settings.xAxis.lineColor.call(this,i),1);
			if(i == this._settings.origin) yAxisStart = xi+1;
			var label = i;
			if(step<1){
				var power = Math.min(this._log10(step),(start<=0?0:this._log10(start)));
				var corr = Math.pow(10,-power);
				label = Math.round(i*corr)/corr;
			}
			this.canvases["x"].renderTextAt(false, true,xi,y0+2,axis.template(label.toString()),"dhx_axis_item_x");
			c++;
		}
		this.canvases["x"].renderTextAt(true, false, x0,point1.y+this._settings.padding.bottom-3,
			this._settings.xAxis.title,
			"dhx_axis_title_x",
			point1.x - point0.x
		);
		/*the right border in lines in scale are enabled*/
		if (!axis.lines.call(this,{})){
			this._drawLine(ctx,x0,point0.y-0.5,x1,point0.y-0.5,this._settings.xAxis.color,0.2);
		}
		return yAxisStart;
	},
	_correctBarHParams:function(ctx,x,y,value,unit,barWidth,minValue){
		var yax = this._settings.yAxis;
		var axisStart = x;
		if(!!yax&&this._settings.origin!="auto" && (this._settings.origin>minValue)){
			x += (this._settings.origin-minValue)*unit;
			axisStart = x;
			value = value-(this._settings.origin-minValue);
			if(value < 0){
				value *= (-1);
			 	ctx.translate(x,y+barWidth);
				ctx.rotate(Math.PI);
				x = 0.5;
				y = 0;
			}
			x += 0.5;
		}
		
		return {value:value,x0:x,y0:y,start:axisStart}
	},
	_drawBarH:function(ctx,point1,x0,y0,barWidth,minValue,radius,unit,value,color,gradient,inner_gradient){
		var points;
		ctx.save();
		var p = this._correctBarHParams(ctx,x0,y0,value,unit,barWidth,minValue);	
		ctx.fillStyle = color;
		ctx.beginPath();
		if(unit*p.value>0){
			points = this._setBarHPoints(ctx,p.x0,p.y0,barWidth,radius,unit,p.value,(this._settings.border?1:0));
			if (gradient&&!inner_gradient) ctx.lineTo(point1.x,p.y0+(this._settings.border?1:0)); //fix gradient sphreading
		}
		else
			points = [p.x0,p.y0+1];

   		ctx.fill();
		ctx.restore();
		var y1 = p.y0;
		var y2 = (p.y0!=y0?y0:points[1]);
		var x1 = (p.y0!=y0?(p.start-points[0]):p.start);
		var x2 = (p.y0!=y0?p.start:points[0]);
		
		return [x1,y1,x2,y2];
	},
	_drawBarHBorder:function(ctx,x0,y0,barWidth,minValue,radius,unit,value,color){
		ctx.save();
		var p = this._correctBarHParams(ctx,x0,y0,value,unit,barWidth,minValue);	
		
		ctx.beginPath();
		this._setBorderStyles(ctx,color);
		ctx.globalAlpha =0.9;
		if(unit*p.value>0)
			this._setBarHPoints(ctx,p.x0,p.y0,barWidth,radius,unit,p.value,ctx.lineWidth/2,1);
		
		ctx.stroke();	
	    ctx.restore();
	},
	_drawBarHGradient:function(ctx,x0,y0,barWidth,minValue,radius,unit,value,color,inner_gradient){
		ctx.save();
		//y0 -= (dhx.env.isIE?0:0.5);
		var p = this._correctBarHParams(ctx,x0,y0,value,unit,barWidth,minValue);	
		var gradParam = this._setBarGradient(ctx,p.x0,p.y0+barWidth,p.x0+unit*p.value,p.y0,inner_gradient,color,"x");
		ctx.fillStyle = gradParam.gradient;
		ctx.beginPath();
		if(unit*p.value>0)
			this._setBarHPoints(ctx,p.x0,p.y0+gradParam.offset,barWidth-gradParam.offset*2,radius,unit,p.value,gradParam.offset);
		ctx.fill();
		ctx.globalAlpha = 1;
	    ctx.restore();
	}
};



/* DHX DEPEND FROM FILE 'ext/chart/chart_stackedbarh.js'*/


/*DHX:Depend ext/chart/chart_base.js*/
/*DHX:Depend ext/chart/chart_barh.js*/

dhtmlx.assert(dhtmlx.chart.barH);
dhtmlx.chart.stackedBarH = {
/**
	*   renders a bar chart
	*   @param: ctx - canvas object
	*   @param: data - object those need to be displayed
	*   @param: x - the width of the container
	*   @param: y - the height of the container
	*   @param: sIndex - index of drawing chart
	*   @param: map - map object
	*/
	pvt_render_stackedBarH:function(ctx, data, point0, point1, sIndex, map){
	   var maxValue,minValue;
		/*necessary if maxValue - minValue < 0*/
		var valueFactor;
		/*maxValue - minValue*/
		var relValue;
		
		var total_width = point1.x-point0.x;
		
		var yax = !!this._settings.yAxis;
		
		var limits = this._getStackedLimits(data);
		maxValue = limits.max;
		minValue = limits.min;
		
		/*an available width for one bar*/
		var cellWidth = Math.floor((point1.y-point0.y)/data.length);
	
		/*draws x and y scales*/
		if(!sIndex)
			this._drawHScales(ctx,data,point0, point1,minValue,maxValue,cellWidth);
		
		/*necessary for automatic scale*/
		if(yax){
		    maxValue = parseFloat(this._settings.xAxis.end);
			minValue = parseFloat(this._settings.xAxis.start);      
		}
		
		/*unit calculation (bar_height = value*unit)*/
		var relativeValues = this._getRelativeValue(minValue,maxValue);
		relValue = relativeValues[0];
		valueFactor = relativeValues[1];
		
		var unit = (relValue?total_width/relValue:10);
		if(!yax){
			/*defines start value for better representation of small values*/
			var startValue = 10;
			unit = (relValue?(total_width-startValue)/relValue:10);
		}
		
		/*a real bar width */
		var barWidth = parseInt(this._settings.width,10);
		if((barWidth+4)>cellWidth) barWidth = cellWidth-4;
		/*the half of distance between bars*/
		var barOffset = (cellWidth - barWidth)/2;
		/*the radius of rounding in the top part of each bar*/
		var radius = 0;

		var inner_gradient = false;
		var gradient = this._settings.gradient;
		if (gradient){
			inner_gradient = true;
		}
		/*draws a black line if the horizontal scale isn't defined*/
		if(!yax){
			this._drawLine(ctx,point0.x-0.5,point0.y,point0.x-0.5,point1.y,"#000000",1); //hardcoded color!
		}

		var seriesNumber = 0;
		var seriesIndex = 0;
		for(i=0; i<this._series.length; i++ ){
			if(i == sIndex){
				seriesIndex  = seriesNumber;
			}
			if(this._series[i].view == "stackedBarH")
				seriesNumber++;
		}

		for(var i=0; i < data.length;i ++){
			
			if(!seriesIndex)
			   data[i].$startX = point0.x;
			
			var value =  parseFloat(this._settings.value(data[i]||0));
			if(value>maxValue) value = maxValue;
			value -= minValue;
			value *= valueFactor;
			
			/*start point (bottom left)*/
			var x0 = point0.x;
			var y0 = point0.y+ barOffset + i*cellWidth;
			
			if(!seriesIndex)
                data[i].$startX = x0;
			else
			    x0 = data[i].$startX;
			
			if(value<0||(this._settings.yAxis&&value===0)){
				this.canvases["y"].renderTextAt("middle", true, x0+10,y0+barWidth/2,this._settings.label(data[i]));
				continue;
			}
			
			/*takes start value into consideration*/
			if(!yax) value += startValue/unit;
			var color = this._settings.color.call(this,data[i]);
			
			
			/*drawing bar body*/
			ctx.globalAlpha = this._settings.alpha.call(this,data[i]);
			ctx.fillStyle = this._settings.color.call(this,data[i]);
			ctx.beginPath();
			var points = this._setBarHPoints(ctx,x0,y0,barWidth,radius,unit,value,(this._settings.border?1:0));
			if (gradient&&!inner_gradient) ctx.lineTo(point0.x+total_width,y0+(this._settings.border?1:0)); //fix gradient sphreading
   			ctx.fill();
			
			if (inner_gradient!=false){
				var gradParam = this._setBarGradient(ctx,x0,y0+barWidth,x0,y0,inner_gradient,color,"x");
				ctx.fillStyle = gradParam.gradient;
				ctx.beginPath();
				points = this._setBarHPoints(ctx,x0,y0, barWidth,radius,unit,value,0);
				ctx.fill();
			}
			/*drawing the gradient border of a bar*/
			if(this._settings.border){
				this._drawBarHBorder(ctx,x0,y0,barWidth,minValue,radius,unit,value,color);
			}
			
			ctx.globalAlpha = 1;
			
			/*sets a bar label*/
			this.canvases[sIndex].renderTextAt("middle",true,data[i].$startX+(points[0]-data[i].$startX)/2-1, y0+(points[1]-y0)/2, this._settings.label(data[i]));
			/*defines a map area for a bar*/
			map.addRect(data[i].id,[data[i].$startX-point0.x,y0-point0.y,points[0]-point0.x,points[1]-point0.y],sIndex);
			/*the start position for the next series*/
			data[i].$startX = points[0];
		}
	}
};


/* DHX DEPEND FROM FILE 'ext/chart/chart_stackedbar.js'*/


/*DHX:Depend ext/chart/chart_base.js*/
dhtmlx.chart.stackedBar = {
	/**
	*   renders a bar chart
	*   @param: ctx - canvas object
	*   @param: data - object those need to be displayed
	*   @param: x - the width of the container
	*   @param: y - the height of the container
	*   @param: sIndex - index of drawing chart
	*/
	pvt_render_stackedBar:function(ctx, data, point0, point1, sIndex, map){
		var maxValue,minValue, xAxisY, x0, y0;
		/*necessary if maxValue - minValue < 0*/
		var valueFactor;
		/*maxValue - minValue*/
		var relValue;
		var config = this._settings;
		var total_height = point1.y-point0.y;

		var yax = !!config.yAxis;
		var xax = !!config.xAxis;

		var limits = this._getStackedLimits(data);

		var origin = (config.origin === 0);

		maxValue = limits.max;
		minValue = limits.min;
		if(!data.length)
			return;
		/*an available width for one bar*/
		var cellWidth = (point1.x-point0.x)/data.length;

		/*draws x and y scales*/
		if(!sIndex){
			xAxisY = this._drawScales(data,point0, point1,minValue,maxValue,cellWidth);
		}

		/*necessary for automatic scale*/
		if(yax){
			maxValue = parseFloat(config.yAxis.end);
			minValue = parseFloat(config.yAxis.start);
		}

		/*unit calculation (bar_height = value*unit)*/
		var relativeValues = this._getRelativeValue(minValue,maxValue);
		relValue = relativeValues[0];
		valueFactor = relativeValues[1];

		var unit = (relValue?total_height/relValue:10);

		/*a real bar width */
		var barWidth = parseInt(config.width,10);
		if(barWidth+4 > cellWidth) barWidth = cellWidth-4;
		/*the half of distance between bars*/
		var barOffset = Math.floor((cellWidth - barWidth)/2);


		var inner_gradient = (config.gradient?config.gradient:false);

		/*draws a black line if the horizontal scale isn't defined*/
		if(!xax){
			//scaleY = y-bottomPadding;
			this._drawLine(ctx,point0.x,point1.y+0.5,point1.x,point1.y+0.5,"#000000",1); //hardcoded color!
		}

		for(var i=0; i < data.length;i ++){
			var value =  parseFloat(config.value(data[i]||0));

			if(this._logScaleCalc)
				value = this._log10(value);

			/*start point (bottom left)*/
			x0 = point0.x + barOffset + i*cellWidth;
			
			var negValue = origin&&value<0;
			if(!sIndex){
				y0 = xAxisY-1;
				data[i].$startY = y0;
				if(origin){
					if(negValue)
						y0 = xAxisY+1;
					data[i].$startYN = xAxisY+1;
				}
			}
			else{
				y0 = negValue?data[i].$startYN:data[i].$startY;
			}

			if(!value)
				continue;

			/*adjusts the first tab to the scale*/
			if(!sIndex && !origin)
				value -= minValue;

			value *= valueFactor;

			/*the max height limit*/
			if(y0 < (point0.y+1)) continue;

			if(config.yAxis&&value===0){
				this.canvases["y"].renderTextAt(true, true, x0+Math.floor(barWidth/2),y0,this._settings.label(data[i]));
				continue;
			}

			var color = this._settings.color.call(this,data[i]);
			var firstSector =  Math.abs(y0-(origin?(point1.y+minValue*unit):point1.y))<3;

			/*drawing bar body*/
			ctx.globalAlpha = config.alpha.call(this,data[i]);
			ctx.fillStyle = ctx.strokeStyle = config.color.call(this,data[i]);
			ctx.beginPath();

			var y1 = y0 - unit*value + (firstSector?(negValue?-1:1):0);

			var points = this._setStakedBarPoints(ctx,x0-(config.border?0.5:0),y0,barWidth+(config.border?0.5:0),y1, 0,point0.y);
			ctx.fill();
			ctx.stroke();

			/*gradient*/
			if (inner_gradient){
				ctx.save();
				var gradParam = this._setBarGradient(ctx,x0,y0,x0+barWidth,points[1],inner_gradient,color,"y");
				ctx.fillStyle = gradParam.gradient;
				ctx.beginPath();
				points = this._setStakedBarPoints(ctx,x0+gradParam.offset,y0,barWidth-gradParam.offset*2,y1,(config.border?1:0),point0.y);
				ctx.fill();
				ctx.restore();
			}
			/*drawing the gradient border of a bar*/
			if(config.border){
				ctx.save();
				if(typeof config.border == "string")
					ctx.strokeStyle = config.border;
				else
					this._setBorderStyles(ctx,color);
				ctx.beginPath();

				this._setStakedBarPoints(ctx,x0-0.5,parseInt(y0,10)+0.5,barWidth+1,parseInt(y1,10)+0.5,0,point0.y, firstSector);
				ctx.stroke();
				ctx.restore();
			}
			ctx.globalAlpha = 1;

			/*sets a bar label*/
			this.canvases[sIndex].renderTextAt(false, true, x0+Math.floor(barWidth/2),(points[1]+(y0-points[1])/2)-7,this._settings.label(data[i]));
			/*defines a map area for a bar*/
			map.addRect(data[i].id,[x0-point0.x,points[1]-point0.y,points[0]-point0.x,data[i][negValue?"$startYN":"$startY"]-point0.y],sIndex);

			/*the start position for the next series*/

			data[i][negValue?"$startYN":"$startY"] = points[1];

		}
	},
	/**
	 *   sets points for bar and returns the position of the bottom right point
	 *   @param: ctx - canvas object
	 *   @param: x0 - the x position of start point
	 *   @param: y0 - the y position of start point
	 *   @param: barWidth - bar width
	 *   @param: radius - the rounding radius of the top
	 *   @param: unit - the value defines the correspondence between item value and bar height
	 *   @param: value - item value
	 *   @param: offset - the offset from expected bar edge (necessary for drawing border)
	 *   @param: minY - the minimum y position for the bars ()
	 */
	_setStakedBarPoints:function(ctx,x0,y0,barWidth,y1,offset,minY,skipBottom){
		/*start*/
		ctx.moveTo(x0,y0);

		/*maximum height limit*/
		if(y1<minY)
			y1 = minY;
		ctx.lineTo(x0,y1);
		var x3 = x0 + barWidth;
		var y3 = y1;
		ctx.lineTo(x3,y3);
		/*right rounding*/
		/*bottom right point*/
		var x5 = x0 + barWidth;
		ctx.lineTo(x5,y0);
		/*line to the start point*/
		if(!skipBottom){
			ctx.lineTo(x0,y0);
		}
		//	ctx.lineTo(x0,0); //IE fix!
		return [x5,y3];
	}
};



/* DHX DEPEND FROM FILE 'ext/chart/chart_line.js'*/


/*DHX:Depend ext/chart/chart_base.js*/
dhtmlx.chart.line = {

	/**
	*   renders a graphic
	*   @param: ctx - canvas object
	*   @param: data - object those need to be displayed
	*   @param: width - the width of the container
	*   @param: height - the height of the container
	*   @param: sIndex - index of drawing chart
	*/
	pvt_render_line:function(ctx, data, point0, point1, sIndex, map){

		var config,i,items,params,x0,x1,x2,y1,y2,y0,res1,res2;
	    params = this._calculateLineParams(ctx,data,point0,point1,sIndex);
		config = this._settings;
		if (data.length) {
			x0 = (config.offset?point0.x+params.cellWidth*0.5:point0.x);
			//finds items with data (excludes scale units)
			items= [];
			for(i=0; i < data.length;i++){
				res2 = this._getPointY(data[i],point0,point1,params);
				if(res2){
					x2 = ((!i)?x0:params.cellWidth*i - 0.5 + x0);
					y2 = (typeof res2 == "object"?res2.y0:res2);
					if(i && this._settings.fixOverflow){
						res1 = this._getPointY(data[i-1],point0,point1,params);
						if(res1.out && res1.out == res2.out){
							continue;
						}
						x1 = params.cellWidth*(i-1) - 0.5 + x0;
						y1 = (typeof res1 == "object"?res1.y0:res1);

						if(res1.out){
							y0 = (res1.out == "min"?point1.y:point0.y);
							items.push({x:this._calcOverflowX(x1,x2,y1,y2,y0),y:y0});
						}
						if(res2.out){
							y0 = (res2.out == "min"?point1.y:point0.y);
							items.push({x:this._calcOverflowX(x1,x2,y1,y2,y0),y:y0});
						}

					}
					if(!res2.out)
						items.push({x:x2, y: res2, index: i});
				}
			}


			this._mapStart = point0;
			for(i = 1; i <= items.length; i++){
				//line start position
				x1 = items[i-1].x;
				y1 = items[i-1].y;
				if(i<items.length){
					//line end position
					x2 = items[i].x;
					y2 = items[i].y;
					//line

					this._drawLine(ctx,x1,y1,x2,y2,config.line.color.call(this,data[i-1]),config.line.width);
					//line shadow
					if(config.line&&config.line.shadow){
						ctx.globalAlpha = 0.3;

						this._drawLine(ctx,x1+2,y1+config.line.width+8,x2+2,y2+config.line.width+8,"#eeeeee",config.line.width+3);
						ctx.globalAlpha = 1;
					}
				}
				//item
				if(typeof items[i-1].index != "undefined")
					this._drawItem(ctx,x1,y1,data[items[i-1].index],config.label(data[items[i-1].index]), sIndex, map, point0);
			}

		}
	},
	_calcOverflowX: function(x1,x2,y1,y2,y){
		return  x1 + ( y - y1 )*( x2 - x1 )/( y2 - y1 );
	},
	/**
	*   draws an item and its label
	*   @param: ctx - canvas object
	*   @param: x0 - the x position of a circle
	*   @param: y0 - the y position of a circle
	*   @param: obj - data object 
	*   @param: label - (boolean) defines wherether label needs being drawn 
	*/
	_drawItem:function(ctx,x0,y0,obj,label,sIndex,map){
		var config = this._settings.item;

		var R = parseInt(config.radius.call(this,obj),10)||0;
		var mapStart = this._mapStart;
		if(R){
			ctx.save();
			if(config.shadow){
				ctx.lineWidth = 1;
				ctx.strokeStyle = "#bdbdbd";
				ctx.fillStyle = "#bdbdbd";
				var alphas = [0.1,0.2,0.3];
				for(var i=(alphas.length-1);i>=0;i--){
					ctx.globalAlpha = alphas[i];
					ctx.strokeStyle = "#d0d0d0";
					ctx.beginPath();
					this._strokeChartItem(ctx,x0,y0+2*R/3,R+i+1,config.type);
					ctx.stroke();
				}
				ctx.beginPath();
				ctx.globalAlpha = 0.3;
				ctx.fillStyle = "#bdbdbd";
				this._strokeChartItem(ctx,x0,y0+2*R/3,R+1,config.type);
				ctx.fill();
			}
			ctx.restore();
			
			if(config.type == "image" && config.src){
				this._drawImage(ctx,x0-R,y0-R,config.src,R*2, R*2);
			}
			else{
				ctx.lineWidth = config.borderWidth;
				ctx.fillStyle = config.color.call(this,obj);
				ctx.strokeStyle = config.borderColor.call(this,obj);
				ctx.globalAlpha = config.alpha.call(this,obj);
				ctx.beginPath();
				this._strokeChartItem(ctx,x0,y0,R+1,config.type);
				ctx.fill();
				ctx.stroke();
				ctx.globalAlpha = 1;
			}
		}
		/*item label*/
		if(label)
			this.canvases[sIndex].renderTextAt(false, true, x0,y0-R-this._settings.labelOffset,this._settings.label.call(this,obj));

		var areaPos = (this._settings.eventRadius||R+1);
		map.addRect(obj.id,[x0-areaPos-mapStart.x,y0-areaPos-mapStart.y,x0+areaPos-mapStart.x,y0+areaPos-mapStart.y],sIndex);
	},
	_drawImage: function(ctx,x,y,src, width, height){
		var image = document.createElement("img");
		image.style.display = "none";
		image.style.width = width+"px";
		image.style.height = height+"px";
		document.body.appendChild(image);
		image.src = src;
		var callback = function() {
			ctx.drawImage(image, x,y);
		};
		if(image.complete) { //check if image was already loaded by the browser
			callback(image);
		}else {
			image.onload = callback;
		}
	},
    _strokeChartItem:function(ctx,x0,y0,R,type){
	    var p=[];
	    x0 = parseInt(x0,10);
	    y0 = parseInt(y0,10);
        if(type && (type=="square" || type=="s")){
		    R *= Math.sqrt(2)/2;
	        p = [
		        [x0-R-ctx.lineWidth/2,y0-R],
		        [x0+R,y0-R],
		        [x0+R,y0+R],
		        [x0-R,y0+R],
		        [x0-R,y0-R]
	        ];
		}
        else if(type && (type=="diamond" || type=="d")){
		    var corr = (ctx.lineWidth>1?ctx.lineWidth*Math.sqrt(2)/4:0);
	        p = [
		        [x0,y0-R],
		        [x0+R,y0],
		        [x0,y0+R],
		        [x0-R,y0],
		        [x0+corr,y0-R-corr]
	        ];
        }
        else if(type && (type=="triangle" || type=="t")){
	        p = [
		        [x0,y0-R],
		        [x0+Math.sqrt(3)*R/2,y0+R/2],
		        [x0-Math.sqrt(3)*R/2,y0+R/2],
		        [x0,y0-R]
	        ];
        }
		else
            p = [
	            [x0,y0,R,0,Math.PI*2,true]
            ];
	    this._path(ctx,p);
    },
	/**
	*   gets the vertical position of the item
	*   @param: data - data object
	*   @param: y0 - the y position of chart start
	*   @param: y1 - the y position of chart end
	*   @param: params - the object with elements: minValue, maxValue, unit, valueFactor (the value multiple of 10) 
	*/
	_getPointY: function(data,point0,point1,params){
		var minValue = params.minValue;
		var maxValue = params.maxValue;
		var unit = params.unit;
		var valueFactor = params.valueFactor;
		/*the real value of an object*/
		var value = this._settings.value(data);
		/*a relative value*/
		var v = (parseFloat(value||0) - minValue)*valueFactor;
		if(!this._settings.yAxis)
			v += params.startValue/unit;
		/*a vertical coordinate*/
		var y = point1.y - unit*v;

		/*the limit of the max and min values*/
		if(this._settings.fixOverflow && ( this._settings.view == "line" || this._settings.view == "area")){
			if(value > maxValue)
				y = {y: point0.y, y0:  y, out: "max"};
			else if(v<0 || value < minValue)
				y = {y: point1.y, y0:  y, out: "min"};
		}
		else{
			if(value > maxValue)
				y =  point0.y;
			if(v<0 || value < minValue)
				y =  point1.y;
		}
		return y;
	},
	_calculateLineParams: function(ctx,data,point0,point1,sIndex){
		var params = {};
		
		/*maxValue - minValue*/
		var relValue;
		
		/*available height*/
		params.totalHeight = point1.y-point0.y;
		
		/*a space available for a single item*/
		//params.cellWidth = Math.round((point1.x-point0.x)/((!this._settings.offset&&this._settings.yAxis)?(data.length-1):data.length)); 
		params.cellWidth = (point1.x-point0.x)/((!this._settings.offset)?(data.length-1):data.length);
		
		/*scales*/
		var yax = !!this._settings.yAxis;
		
		var limits = (this._settings.view.indexOf("stacked")!=-1?this._getStackedLimits(data):this._getLimits());
		params.maxValue = limits.max;
		params.minValue = limits.min;
		
		/*draws x and y scales*/
		if(!sIndex)
			this._drawScales(data, point0, point1,params.minValue,params.maxValue,params.cellWidth);
		
		/*necessary for automatic scale*/
		if(yax){
		    params.maxValue = parseFloat(this._settings.yAxis.end);
			params.minValue = parseFloat(this._settings.yAxis.start);      
		}
		
		/*unit calculation (y_position = value*unit)*/
		var relativeValues = this._getRelativeValue(params.minValue,params.maxValue);
		relValue = relativeValues[0];
		params.valueFactor = relativeValues[1];
		params.unit = (relValue?params.totalHeight/relValue:10);
		
		params.startValue = 0;
		if(!yax){
			/*defines start value for better representation of small values*/
			params.startValue = 10;
			if(params.unit!=params.totalHeight)
				params.unit = (relValue?(params.totalHeight - params.startValue)/relValue:10);
		}
		return params;
	}
};



/* DHX DEPEND FROM FILE 'ext/chart/chart_bar.js'*/


/*DHX:Depend ext/chart/chart_base.js*/
dhtmlx.chart.bar = {
	/**
	*   renders a bar chart
	*   @param: ctx - canvas object
	*   @param: data - object those need to be displayed
	*   @param: x - the width of the container
	*   @param: y - the height of the container
	*   @param: sIndex - index of drawing chart
	*/
	pvt_render_bar:function(ctx, data, point0, point1, sIndex, map){
	    var barWidth, cellWidth,
		    i,
		    limits, maxValue, minValue,
		    relValue, valueFactor, relativeValues,
		    startValue, unit,
		    xax, yax,
		    totalHeight = point1.y-point0.y;


		

		
		yax = !!this._settings.yAxis;
		xax = !!this._settings.xAxis;
		
		limits = this._getLimits();
		maxValue = limits.max;
		minValue = limits.min;
		
		/*an available width for one bar*/
		cellWidth = (point1.x-point0.x)/data.length;
		
		/*draws x and y scales*/
		if(!sIndex&&!(this._settings.origin!="auto"&&!yax)){
			this._drawScales(data,point0, point1,minValue,maxValue,cellWidth);
		}
		
		/*necessary for automatic scale*/
		if(yax){
		    maxValue = parseFloat(this._settings.yAxis.end);
			minValue = parseFloat(this._settings.yAxis.start);      
		}
		
		/*unit calculation (bar_height = value*unit)*/
		relativeValues = this._getRelativeValue(minValue,maxValue);
		relValue = relativeValues[0];
		valueFactor = relativeValues[1];
		
		unit = (relValue?totalHeight/relValue:relValue);

		if(!yax&&!(this._settings.origin!="auto"&&xax)){
			/*defines start value for better representation of small values*/
			startValue = 10;
			unit = (relValue?(totalHeight-startValue)/relValue:startValue);
		}
		/*if yAxis isn't set, but with custom origin */
		if(!sIndex&&(this._settings.origin!="auto"&&!yax)&&this._settings.origin>minValue){
			this._drawXAxis(ctx,data,point0,point1,cellWidth,point1.y-unit*(this._settings.origin-minValue));
		}
		
		/*a real bar width */
		barWidth = parseInt(this._settings.width,10);
		var seriesNumber = 0;
		var seriesIndex = 0;
		for(i=0; i<this._series.length; i++ ){
			if(i == sIndex){
				seriesIndex  = seriesNumber;
			}
			if(this._series[i].view == "bar")
				seriesNumber++;
		}

		var seriesMargin = this._settings.seriesMargin;
		var seriesPadding = this._settings.seriesPadding;

		if(this._series&&(barWidth*seriesNumber+seriesPadding + (seriesNumber>2?seriesMargin*seriesNumber:0)>cellWidth) )
			barWidth = cellWidth/seriesNumber-seriesPadding-(seriesNumber>2?seriesMargin:0);

		/*the half of distance between bars*/
		var barOffset = (cellWidth - barWidth*seriesNumber - seriesMargin*(seriesNumber-1))/2 ;

		if(this._settings.border){
			barWidth = parseInt(barWidth,10);
			barOffset = parseInt(barOffset,10);
		}

		/*the radius of rounding in the top part of each bar*/
		var radius = (typeof this._settings.radius!="undefined"?parseInt(this._settings.radius,10):Math.round(barWidth/5));

		var inner_gradient = false;
		var gradient = this._settings.gradient;
		
		if(gradient && typeof(gradient) != "function"){
			inner_gradient = gradient;
			gradient = false;
		} else if (gradient){
			gradient = ctx.createLinearGradient(0,point1.y,0,point0.y);
			this._settings.gradient(gradient);
		}
		/*draws a black line if the horizontal scale isn't defined*/
		if(!xax){
			this._drawLine(ctx,point0.x,point1.y+0.5,point1.x,point1.y+0.5,"#000000",1); //hardcoded color!
		}
		
		for(i=0; i < data.length;i ++){

			var value =  parseFloat(this._settings.value(data[i])||0);
			if(isNaN(value))
				continue;
			if(value>maxValue) value = maxValue;
			value -= minValue;
			value *= valueFactor;
			
			/*start point (bottom left)*/
			var x0 = point0.x + barOffset+(seriesNumber>2?seriesMargin*seriesIndex:0) + i*cellWidth + barWidth*seriesIndex;
			var y0 = point1.y;
		
			if(value<0||(this._settings.yAxis&&value===0&&!(this._settings.origin!="auto"&&this._settings.origin>minValue))){
				this.canvases[sIndex].renderTextAt(true, true, x0+Math.floor(barWidth/2),y0,this._settings.label(data[i]));
				continue;
			}
			
			/*takes start value into consideration*/
			if(!yax&&!(this._settings.origin!="auto"&&xax)) value += startValue/unit;
			
			var color = gradient||this._settings.color.call(this,data[i]);
	
			
			/*drawing bar body*/
			ctx.globalAlpha = this._settings.alpha.call(this,data[i]);
			var points = this._drawBar(ctx,point0,x0,y0,barWidth,minValue,radius,unit,value,color,gradient,inner_gradient);
			if (inner_gradient){
				this._drawBarGradient(ctx,x0,y0,barWidth,minValue,radius,unit,value,color,inner_gradient);
			}
			/*drawing the gradient border of a bar*/
			if(this._settings.border)
				this._drawBarBorder(ctx,x0,y0,barWidth,minValue,radius,unit,value,color);
			
			ctx.globalAlpha = 1;
			
			/*sets a bar label*/
			if(points[0]!=x0)
				this.canvases[sIndex].renderTextAt(false, true, x0+Math.floor(barWidth/2),points[1],this._settings.label(data[i]));
			else
				this.canvases[sIndex].renderTextAt(true, true, x0+Math.floor(barWidth/2),points[3],this._settings.label(data[i]));
			/*defines a map area for a bar*/
			map.addRect(data[i].id,[x0-point0.x,points[3]-point0.y,points[2]-point0.x,points[1]-point0.y],sIndex);
			//this._addMapRect(map,data[i].id,[{x:x0,y:points[3]},{x:points[2],y:points[1]}],point0,sIndex);
		}
	},
	_correctBarParams:function(ctx,x,y,value,unit,barWidth,minValue){
		var xax = this._settings.xAxis;
		var axisStart = y;
		if(!!xax&&this._settings.origin!="auto" && (this._settings.origin>minValue)){
			y -= (this._settings.origin-minValue)*unit;
			axisStart = y;
			value = value-(this._settings.origin-minValue);
			if(value < 0){
				value *= (-1);
			 	ctx.translate(x+barWidth,y);
				ctx.rotate(Math.PI);
				x = 0;
				y = 0;
			}
			y -= 0.5;
		}
		
		return {value:value,x0:x,y0:y,start:axisStart}
	},
	_drawBar:function(ctx,point0,x0,y0,barWidth,minValue,radius,unit,value,color,gradient,inner_gradient){
		var points;
		ctx.save();
		ctx.fillStyle = color;
		var p = this._correctBarParams(ctx,x0,y0,value,unit,barWidth,minValue);
		if( unit*p.value > 0)
			points = this._setBarPoints(ctx,p.x0,p.y0,barWidth,radius,unit,p.value,(this._settings.border?1:0));
		else
			points = [p.x0,p.y0];
		if (gradient&&!inner_gradient) ctx.lineTo(p.x0+(this._settings.border?1:0),point0.y); //fix gradient sphreading

   		ctx.fill();

	    ctx.restore();
		var x1 = p.x0;
		var x2 = (p.x0!=x0?x0+points[0]:points[0]);
		var y1 = (p.x0!=x0?(p.start-points[1]-p.y0):p.y0);
		var y2 = (p.x0!=x0?p.start-p.y0:points[1]);

		return [x1,y1,x2,y2];
	},

	_drawBarBorder:function(ctx,x0,y0,barWidth,minValue,radius,unit,value,color){
	    var p;
		ctx.save();
		p = this._correctBarParams(ctx,x0,y0,value,unit,barWidth,minValue);
		this._setBorderStyles(ctx,color);
		if( unit*p.value > 0)
			this._setBarPoints(ctx,p.x0,p.y0,barWidth,radius,unit,p.value,ctx.lineWidth/2,1);
		ctx.stroke();
		/*ctx.fillStyle = color;
		this._setBarPoints(ctx,p.x0,p.y0,barWidth,radius,unit,p.value,0);
		ctx.lineTo(p.x0,0);
		ctx.fill()
	   
				
		ctx.fillStyle = "#000000";
		ctx.globalAlpha = 0.37;
		
		this._setBarPoints(ctx,p.x0,p.y0,barWidth,radius,unit,p.value,0);
		ctx.fill()
		*/
	    ctx.restore();
	},
	_drawBarGradient:function(ctx,x0,y0,barWidth,minValue,radius,unit,value,color,inner_gradient){
		ctx.save();
		//y0 -= (dhtmlx._isIE?0:0.5);
		var p = this._correctBarParams(ctx,x0,y0,value,unit,barWidth,minValue);
		var gradParam = this._setBarGradient(ctx,p.x0,p.y0,p.x0+barWidth,p.y0-unit*p.value+2,inner_gradient,color,"y");
		var borderOffset = this._settings.border?1:0;
		ctx.fillStyle = gradParam.gradient;
		if( unit*p.value > 0)
			this._setBarPoints(ctx,p.x0+gradParam.offset,p.y0,barWidth-gradParam.offset*2,radius,unit,p.value,gradParam.offset+borderOffset);
		ctx.fill();
	    ctx.restore();
	},
	/**
	*   sets points for bar and returns the position of the bottom right point
	*   @param: ctx - canvas object
	*   @param: x0 - the x position of start point
	*   @param: y0 - the y position of start point
	*   @param: barWidth - bar width 
	*   @param: radius - the rounding radius of the top
	*   @param: unit - the value defines the correspondence between item value and bar height
	*   @param: value - item value
	*   @param: offset - the offset from expected bar edge (necessary for drawing border)
	*/
	_setBarPoints:function(ctx,x0,y0,barWidth,radius,unit,value,offset,skipBottom){
		/*correction for displaing small values (when rounding radius is bigger than bar height)*/
		ctx.beginPath();
		//y0 = 0.5;
		var angle_corr = 0;
		if(radius>unit*value){
			var cosA = (radius-unit*value)/radius;
			if(cosA<=1&&cosA>=-1)
				angle_corr = -Math.acos(cosA)+Math.PI/2;
		}
		/*start*/
		ctx.moveTo(x0+offset,y0);
		/*start of left rounding*/
		var y1 = y0 - Math.floor(unit*value) + radius + (radius?0:offset);
		if(radius<unit*value)
			ctx.lineTo(x0+offset,y1);
   		/*left rounding*/
		var x2 = x0 + radius;
		if (radius&&radius>0)
			ctx.arc(x2,y1,radius-offset,-Math.PI+angle_corr,-Math.PI/2,false);
   		/*start of right rounding*/
		var x3 = x0 + barWidth - radius - offset;
		var y3 = y1 - radius + (radius?offset:0);
		ctx.lineTo(x3,y3);
		/*right rounding*/
		if (radius&&radius>0)
			ctx.arc(x3,y1,radius-offset,-Math.PI/2,0-angle_corr,false);
   		/*bottom right point*/
		var x5 = x0 + barWidth-offset;
        ctx.lineTo(x5,y0);
		/*line to the start point*/
		if(!skipBottom){
   			ctx.lineTo(x0+offset,y0);
		}
   	//	ctx.lineTo(x0,0); //IE fix!
		return [x5,y3];
	}
};


/* DHX DEPEND FROM FILE 'ext/chart/chart_pie.js'*/


/*DHX:Depend ext/chart/chart_base.js*/
/*DHX:Depend ext/chart/chart_base.js*/
dhtmlx.chart.pie = {
	pvt_render_pie:function(ctx,data,x,y,sIndex,map){
		this._renderPie(ctx,data,x,y,1,map,sIndex);

	},
	/**
	 *   renders a pie chart
	 *   @param: ctx - canvas object
	 *   @param: data - object those need to be displayed
	 *   @param: x - the width of the container
	 *   @param: y - the height of the container
	 *   @param: ky - value from 0 to 1 that defines an angle of inclination (0<ky<1 - 3D chart)
	 */
	_renderPie:function(ctx,data,point0,point1,ky,map,sIndex){
		if(!data.length)
			return;
		var coord = this._getPieParameters(point0,point1);
		/*pie radius*/
		var radius = (this._settings.radius?this._settings.radius:coord.radius);
		if(radius<0)
			return;

		/*real values*/
		var values = this._getValues(data);

		var totalValue = this._getTotalValue(values);

		/*weighed values (the ratio of object value to total value)*/
		var ratios = this._getRatios(values,totalValue);

		/*pie center*/
		var x0 = (this._settings.x?this._settings.x:coord.x);
		var y0 = (this._settings.y?this._settings.y:coord.y);
		/*adds shadow to the 2D pie*/
		if(ky==1&&this._settings.shadow)
			this._addShadow(ctx,x0,y0,radius);

		/*changes vertical position of the center according to 3Dpie cant*/
		y0 = y0/ky;
		/*the angle defines the 1st edge of the sector*/
		var alpha0 = -Math.PI/2;
		var alpha1;
		var angles = [];
		/*changes Canvas vertical scale*/
		ctx.scale(1,ky);
		/*adds radial gradient to a pie*/
		if (this._settings.gradient){
			var x1 = (ky!=1?x0+radius/3:x0);
			var y1 = (ky!=1?y0+radius/3:y0);
			this._showRadialGradient(ctx,x0,y0,radius,x1,y1);
		}

		if(this._settings.labelLines)
			this._labelMargins = this._getLabelMargins(ratios,radius);


		for(var i = 0; i < data.length;i++){
			if (!values[i]) continue;
			/*drawing sector*/
			//ctx.lineWidth = 2;
			ctx.strokeStyle = (data.length==1?this._settings.color.call(this,data[i]):this._settings.lineColor.call(this,data[i]));
			ctx.beginPath();
			ctx.moveTo(x0,y0);
			angles.push(alpha0);
			/*the angle defines the 2nd edge of the sector*/
			alpha1 = -Math.PI/2+ratios[i]-0.0001;
			ctx.arc(x0,y0,radius,alpha0,alpha1,false);
			ctx.lineTo(x0,y0);

			var color = this._settings.color.call(this,data[i]);
			ctx.fillStyle = color;
			ctx.fill();

			/*text that needs being displayed inside the sector*/
			if(this._settings.pieInnerText)
				this._drawSectorLabel(x0,y0,5*radius/6,alpha0,alpha1,ky,this._settings.pieInnerText(data[i],totalValue),true);
			/*label outside the sector*/

			if(this._settings.label){
				this._drawSectorLabel(x0,y0,radius,alpha0,alpha1,ky,this._settings.label(data[i]),0,(this._labelMargins?this._labelMargins[i]:{}),ctx);
			}

			/*drawing lower part for 3D pie*/
			if(ky!=1){
				this._createLowerSector(ctx,x0,y0,alpha0,alpha1,radius,true);
				ctx.fillStyle = "#000000";
				ctx.globalAlpha = 0.2;
				this._createLowerSector(ctx,x0,y0,alpha0,alpha1,radius,false);
				ctx.globalAlpha = 1;
				ctx.fillStyle = color;
			}
			/*creats map area (needed for events)*/
			map.addSector(data[i].id,alpha0,alpha1,x0-point0.x,y0-point0.y/ky,radius,ky,sIndex);

			alpha0 = alpha1;
		}
		/*renders radius lines and labels*/
		ctx.globalAlpha = 0.8;
		var p;
		if(angles.length>1)
			for(i=0;i< angles.length;i++){
				p = this._getPositionByAngle(angles[i],x0,y0,radius);
				this._drawLine(ctx,x0,y0,p.x,p.y,this._settings.lineColor.call(this,data[i]),2);
			}

		if(ky==1){
			ctx.lineWidth = 2;
			ctx.strokeStyle = "#ffffff";
			ctx.beginPath();
			ctx.arc(x0,y0,radius+1,0,2*Math.PI,false);
			ctx.stroke();
		}
		ctx.globalAlpha =1;

		ctx.scale(1,1/ky);
	},
	_getLabelMargins: function(ratios,R){
		var alpha1, alpha2, i, j,
			margins = [],
			r = [];
		var dists = {1:[0]};


		for(i = 1; i < ratios.length; i++ ){
			alpha1 = -Math.PI/2  + (i>1?(ratios[i-1]- (ratios[i-1]-ratios[i-2])/2):ratios[i-1]/2);
			alpha2 = -Math.PI/2 + ratios[i]- (ratios[i]-ratios[i-1])/2;
			var cos2 = Math.cos(alpha2);
			var sin2 = Math.sin(alpha2);
			var cos1 = Math.cos(alpha1);
			var sin1 = Math.sin(alpha1);
			var dist = Math.round((R+8)*Math.abs(Math.sin(alpha2)-Math.sin(alpha1)));

			var quarter2 = (cos2<0?(sin2<0?4:3) :(sin2<0?1:2));
			var quarter1 = (cos1<0?(sin1<0?4:3) :(sin1<0?1:2));
			if(!dists[quarter2])
				dists[quarter2] = [];
			dists[quarter2].push(quarter1==quarter2?dist:0);
		}
		var distIncrease = [];
		var c = 0;

		for(var q in dists){
			var start = 0;
			var end = dists[q].length;
			var inc = 0;
			var incX = 0;
			if(q == 1 || q == 3){
				j = q-1;
				var len = 0;
				while(j>0){
					if(dists[j])
						len += dists[j].length;
					j--;
				}
				distIncrease[len+ dists[q].length-1] = {y:0,x:0};

				var j = dists[q].length-2;

				while(j>=0){
					if((inc||j) && dists[q][j+1]-inc<18){
						inc += 18 -dists[q][j+1];
					}
					else{
						inc = 0;
					}

					distIncrease[len+j] = {y:inc*(q == 1?-1:1)};
					j --;
				}
				for(var k=distIncrease.length-dists[q].length; k < distIncrease.length; k++){
					if(distIncrease[k]["y"]!=0){
						incX += 6;
						distIncrease[k]["x"] = incX;

					}
					else{
						distIncrease[k]["x"] = 0;
						incX = 0;
					}
				}
			}
			else{
				var j = 1;
				distIncrease.push({y:0,x:0});
				while(j<dists[q].length){
					if(dists[q][j]-inc<18){
						inc += 18 - dists[q][j];
					}
					else{
						inc = 0;
					}
					distIncrease.push({y:inc*(q == 4?-1:1)});
					j ++;
				}
				for(var k=distIncrease.length-1; k >=  distIncrease.length-dists[q].length; k--){
					if(distIncrease[k]["y"]!=0){
						incX += 8;
						distIncrease[k]["x"] = incX;

					}
					else{
						incX = 0;
						distIncrease[k]["x"] = 0;
					}

				}
			}
		}

		return distIncrease;
	},
	/**
	 *   returns list of values
	 *   @param: data array
	 */
	_getValues:function(data){
		var v = [];
		for(var i = 0; i < data.length;i++)
			v.push(parseFloat(this._settings.value(data[i])||0));
		return v;
	},
	/**
	 *   returns total value
	 *   @param: the array of values
	 */
	_getTotalValue:function(values){
		var t=0;
		for(var i = 0; i < values.length;i++)
			t += values[i];
		return  t;
	},
	/**
	 *   gets angles for all values
	 *   @param: the array of values
	 *   @param: total value (optional)
	 */
	_getRatios:function(values,totalValue){
		var value;
		var ratios = [];
		var prevSum = 0;
		totalValue = totalValue||this._getTotalValue(values);
		for(var i = 0; i < values.length;i++){
			value = values[i];

			ratios[i] = Math.PI*2*(totalValue?((value+prevSum)/totalValue):(1/values.length));
			prevSum += value;
		}
		return ratios;
	},
	/**
	 *   returns calculated pie parameters: center position and radius
	 *   @param: x - the width of a container
	 *   @param: y - the height of a container
	 */
	_getPieParameters:function(point0,point1){
		/*var offsetX = 0;
		 var offsetY = 0;
		 if(this._settings.legend &&this._settings.legend.layout!="x")
		 offsetX = this._settings.legend.width*(this._settings.legend.align=="right"?-1:1);
		 var x0 = (x + offsetX)/2;
		 if(this._settings.legend &&this._settings.legend.layout=="x")
		 offsetY = this._settings.legend.height*(this._settings.legend.valign=="bottom"?-1:1);
		 var y0 = (y+offsetY)/2;*/
		var width = point1.x-point0.x;
		var height = point1.y-point0.y;
		var x0 = point0.x+width/2;
		var y0 = point0.y+height/2;
		var radius = Math.min(width/2,height/2);
		return {"x":x0,"y":y0,"radius":radius};
	},
	/**
	 *   creates lower part of sector in 3Dpie
	 *   @param: ctx - canvas object
	 *   @param: x0 - the horizontal position of the pie center
	 *   @param: y0 - the vertical position of the pie center
	 *   @param: a0 - the angle that defines the first edge of a sector
	 *   @param: a1 - the angle that defines the second edge of a sector
	 *   @param: R - pie radius
	 *   @param: line (boolean) - if the sector needs a border
	 */
	_createLowerSector:function(ctx,x0,y0,a1,a2,R,line){
		ctx.lineWidth = 1;
		/*checks if the lower sector needs being displayed*/
		if(!((a1<=0 && a2>=0)||(a1>=0 && a2<=Math.PI)||(Math.abs(a1-Math.PI)>0.003&&a1<=Math.PI && a2>=Math.PI))) return;

		if(a1<=0 && a2>=0){
			a1 = 0;
			line = false;
			this._drawSectorLine(ctx,x0,y0,R,a1,a2);
		}
		if(a1<=Math.PI && a2>=Math.PI){
			a2 = Math.PI;
			line = false;
			this._drawSectorLine(ctx,x0,y0,R,a1,a2);
		}
		/*the height of 3D pie*/
		var offset = (this._settings.height||Math.floor(R/4))/this._settings.cant;
		ctx.beginPath();
		ctx.arc(x0,y0,R,a1,a2,false);
		ctx.lineTo(x0+R*Math.cos(a2),y0+R*Math.sin(a2)+offset);
		ctx.arc(x0,y0+offset,R,a2,a1,true);
		ctx.lineTo(x0+R*Math.cos(a1),y0+R*Math.sin(a1));
		ctx.fill();
		if(line)
			ctx.stroke();
	},
	/**
	 *   draws a serctor arc
	 */
	_drawSectorLine:function(ctx,x0,y0,R,a1,a2){
		ctx.beginPath();
		ctx.arc(x0,y0,R,a1,a2,false);
		ctx.stroke();
	},
	/**
	 *   adds a shadow to pie
	 *   @param: ctx - canvas object
	 *   @param: x - the horizontal position of the pie center
	 *   @param: y - the vertical position of the pie center
	 *   @param: R - pie radius
	 */
	_addShadow:function(ctx,x,y,R){
		ctx.globalAlpha = 0.5;
		var shadows = ["#c4c4c4","#c6c6c6","#cacaca","#dcdcdc","#dddddd","#e0e0e0","#eeeeee","#f5f5f5","#f8f8f8"];
		for(var i = shadows.length-1;i>-1;i--){
			ctx.beginPath();
			ctx.fillStyle = shadows[i];
			ctx.arc(x+1,y+1,R+i,0,Math.PI*2,true);
			ctx.fill();
		}
		ctx.globalAlpha = 1
	},
	/**
	 *   returns a gray gradient
	 *   @param: gradient - gradient object
	 */
	_getGrayGradient:function(gradient){
		gradient.addColorStop(0.0,"#ffffff");
		gradient.addColorStop(0.7,"#7a7a7a");
		gradient.addColorStop(1.0,"#000000");
		return gradient;
	},
	/**
	 *   adds gray radial gradient
	 *   @param: ctx - canvas object
	 *   @param: x - the horizontal position of the pie center
	 *   @param: y - the vertical position of the pie center
	 *   @param: radius - pie radius
	 *   @param: x0 - the horizontal position of a gradient center
	 *   @param: y0 - the vertical position of a gradient center
	 */
	_showRadialGradient:function(ctx,x,y,radius,x0,y0){
		//ctx.globalAlpha = 0.3;
		ctx.beginPath();
		var gradient;
		if(typeof this._settings.gradient!= "function"){
			gradient = ctx.createRadialGradient(x0,y0,radius/4,x,y,radius);
			gradient = this._getGrayGradient(gradient);
		}
		else gradient = this._settings.gradient(gradient);
		ctx.fillStyle = gradient;
		ctx.arc(x,y,radius,0,Math.PI*2,true);
		ctx.fill();
		//ctx.globalAlpha = 1;
		ctx.globalAlpha = 0.7;
	},
	/**
	 *   returns the calculates pie parameters: center position and radius
	 *   @param: ctx - canvas object
	 *   @param: x0 - the horizontal position of the pie center
	 *   @param: y0 - the vertical position of the pie center
	 *   @param: R - pie radius
	 *   @param: alpha1 - the angle that defines the 1st edge of a sector
	 *   @param: alpha2 - the angle that defines the 2nd edge of a sector
	 *   @param: ky - the value that defines an angle of inclination
	 *   @param: text - label text
	 *   @param: in_width (boolean) - if label needs being displayed inside a pie
	 */
	_drawSectorLabel:function(x0,y0,R,alpha1,alpha2,ky,text,in_width, margin,ctx){
		var t = this.canvases[0].renderText(0,0,text,0,1);
		if (!t) return;
		//get existing width of text
		var labelWidth = t.scrollWidth;
		t.style.width = labelWidth+"px";	//adjust text label to fit all text
		if (labelWidth>x0) labelWidth = x0;	//the text can't be greater than half of view

		//calculate expected correction based on default font metrics
		var width = (alpha2-alpha1<0.2?4:8);
		if (in_width) width = labelWidth/1.8;
		var alpha = alpha1+(alpha2-alpha1)/2;

		//position and its correction
		var radius = R;
		R = (in_width?5*R/6:R+this._settings.labelOffset);
		R = R-(width-8)/2;
		var corr_x = - width;
		var corr_y = -8;
		var align = "right";

		//for items in left upper and lower sector
		if(alpha>=Math.PI/2 && alpha<Math.PI || alpha<=3*Math.PI/2 && alpha>=Math.PI){
			corr_x = -labelWidth-corr_x;/*correction for label width*/
			align = "left";
		}

		//calculate position of text
		//basically get point at center of pie sector
		var offset = 0;

		if(!in_width&&ky<1&&(alpha>0&&alpha<Math.PI))
			offset = (this._settings.height||Math.floor(R/4))/ky;


		var y = (y0+Math.floor(R+offset)*Math.sin(alpha))*ky+corr_y;
		var x = x0+Math.floor(R+width/2)*Math.cos(alpha)+corr_x;




		//if pie sector starts in left of right part pie, related text
		//must be placed to the left of to the right of pie as well
		var left_end = (alpha2 < Math.PI/2+0.01);
		var left_start = (alpha1 < Math.PI/2);

		if (left_start && left_end){
			x = Math.max(x,x0+3);	//right part of pie
			/*if(alpha2-alpha1<0.2)
			 x = x0;*/
		}

		else if (!left_start && !left_end){

			x = Math.min(x,x0-labelWidth);	//left part of pie
		}else if (!in_width&&!this._settings.labelLines&&(alpha>=Math.PI/2 && alpha<Math.PI || alpha<=3*Math.PI/2 && alpha>=Math.PI)){

			x += labelWidth/3;
		}


		if(this._settings.labelLines && !in_width){
			var r1 = Math.abs((Math.abs(margin||0) +Math.abs(radius*Math.sin(alpha)))/Math.sin(alpha));

			if(margin.y)
				y += margin.y;
			if(align=="left"){
				x -= margin.x;
			}
			else
				x +=margin.x;

			ctx.beginPath();
			ctx.strokeStyle = "#555";
			var x1 = x0+radius*Math.cos(alpha);
			var y1 = y0+radius*Math.sin(alpha);
			ctx.moveTo(x1,y1);

			var x2= x-(align=="left"?corr_x-8:2);
			var y2 = y;

			if(align=="left" && x2>x1){
				x2 = x1-Math.abs(y2-y1+16)/Math.tan(alpha-Math.PI);
				y2 = y2+16;
				if(alpha<Math.PI)
					y2 -= 8;
			}
			else
				y2 += 8;
			ctx.lineTo(x2,y2);

			ctx.lineTo(x2 + (align=="left"?-5:5),y2);
			ctx.stroke();

			y = y2 - 8;
			x = x2 + corr_x + (align=="left"?-15:15);
		}



		//we need to set position of text manually, based on above calculations
		t.style.top  = y+"px";
		t.style.left = x + "px";
		t.style.width = labelWidth+"px";
		t.style.textAlign = align;
		t.style.whiteSpace = "nowrap";
	}
};

dhtmlx.chart.pie3D = {
	pvt_render_pie3D:function(ctx,data,x,y,sIndex,map){
		this._renderPie(ctx,data,x,y,this._settings.cant,map);
	}
};
dhtmlx.chart.donut = {
	pvt_render_donut:function(ctx,data,point0,point1,sIndex,map){
		if(!data.length)
			return;
		this._renderPie(ctx,data,point0,point1,1,map);
		var config = this._settings;
		var coord = this._getPieParameters(point0,point1);
		var pieRadius = (config.radius?config.radius:coord.radius);
		var innerRadius = ((config.innerRadius&&(config.innerRadius<pieRadius))?config.innerRadius:pieRadius/3);
		var x0 = (config.x?config.x:coord.x);
		var y0 = (config.y?config.y:coord.y);
		ctx.fillStyle = "#ffffff";
		ctx.beginPath();
		ctx.arc(x0,y0,innerRadius,0,Math.PI*2,true);
		ctx.fill();
	}
};



/* DHX DEPEND FROM FILE 'compatibility_grid.js'*/


/*
	Compatibility hack for loading data from the grid.
	Provides new type of datasource - dhtmlxgrid
	
*/

/*DHX:Depend load.js*/

dhtmlx.DataDriver.dhtmlxgrid={
	_grid_getter:"_get_cell_value",
	toObject:function(data){
		this._grid = data;
		return data;
	},
	getRecords:function(data){
		return data.rowsBuffer;
	},
	getDetails:function(data){
		var result = {};
		for (var i=0; i < this._grid.getColumnsNum(); i++)
			result["data"+i]=this._grid[this._grid_getter](data,i);
      
		return result;
	},
	getInfo:function(data){
		return { 
			_size:0,
			_from:0
		};
	}
};


/* DHX DEPEND FROM FILE 'canvas.js'*/


/*DHX:Depend thirdparty/excanvas*/
/*DHX:Depend dhtmlx.js*/

dhtmlx.ui.Canvas = function(container,name,style) {
	this._canvas_labels = [];
	this._canvas_name =  name;
	this._obj = container;
	var width = container.offsetWidth*(window.devicePixelRatio||1);
	var height = container.offsetHeight*(window.devicePixelRatio||1);
	var style = style||"";
	style += ";width:"+container.offsetWidth+"px;height:"+container.offsetHeight+"px;";
	this._prepareCanvas(name, style ,width, height);
};
dhtmlx.ui.Canvas.prototype = {
	_prepareCanvas:function (name,style,width,height){
		//canvas has the same size as master object
		this._canvas = dhtmlx.html.create("canvas",{ width:width, height:height, canvas_id:name, style:(style||"") });
		this._obj.appendChild(this._canvas);
		//use excanvas in IE
		if (!this._canvas.getContext){
			if (dhtmlx._isIE){
				dhtmlx.require("thirdparty/excanvas/excanvas.js");	//sync loading
				G_vmlCanvasManager.init_(document);
				G_vmlCanvasManager.initElement(this._canvas);
			} else	//some other not supported browser
				dhtmlx.error("Canvas is not supported in the current browser");
		}
		return this._canvas;
	}, 
	getCanvas:function(context){
		var ctx = (this._canvas||this._prepareCanvas()).getContext(context||"2d");
		if(!this._dhtmlxDevicePixelRatio){
			this._dhtmlxDevicePixelRatio = true;
			ctx.scale(window.devicePixelRatio||1, window.devicePixelRatio||1);
		}
		return ctx;
	},
	_resizeCanvas:function(){
		if (this._canvas){
			var w = this._canvas.parentNode.offsetWidth;
			var h = this._canvas.parentNode.offsetHeight;
			this._canvas.setAttribute("width", w*(window.devicePixelRatio||1));
			this._canvas.setAttribute("height", h*(window.devicePixelRatio||1));
			this._canvas.style.width = w+"px";
			this._canvas.style.height = h+"px";
			this._dhtmlxDevicePixelRatio = false;
		}
	},
	renderText:function(x,y,text,css,w){
		if (!text) return; //ignore empty text
		
		var t = dhtmlx.html.create("DIV",{
			"class":"dhx_canvas_text"+(css?(" "+css):""),
			"style":"left:"+x+"px; top:"+y+"px;"
		},text);
		this._obj.appendChild(t);
		this._canvas_labels.push(t); //destructor?
		if (w)
			t.style.width = w+"px";
		return t;
	},
	renderTextAt:function(valign,align, x,y,t,c,w){
		var text=this.renderText.call(this,x,y,t,c,w);
		if (text){
			if (valign){
				if(valign == "middle")
					text.style.top = parseInt(y-text.offsetHeight/2,10) + "px";
				else
					text.style.top = y-text.offsetHeight + "px";
			}
			if (align){
			    if(align == "left")
					text.style.left = x-text.offsetWidth + "px";
				else
					text.style.left = parseInt(x-text.offsetWidth/2,10) + "px";
			}
		}
		return text;
	},
	clearCanvas:function(skipMap){
		var areas=[], i;

		for(i=0; i < this._canvas_labels.length;i++)
			this._obj.removeChild(this._canvas_labels[i]);
		this._canvas_labels = [];

		if (!skipMap&&this._obj._htmlmap){

			//areas that correspond this canvas layer
		    areas = this._getMapAreas();

			//removes areas of this canvas
			while(areas.length){
                areas[0].parentNode.removeChild(areas[0]);
				areas.splice(0,1);
			}
			areas = null;

			//removes _htmlmap object if all its child nodes are removed
			if(!this._obj._htmlmap.getElementsByTagName("AREA").length){
				this._obj._htmlmap.parentNode.removeChild(this._obj._htmlmap);
				this._obj._htmlmap = null;
			}

		}
		//FF breaks, when we are using clear canvas and call clearRect without parameters	
		this.getCanvas().clearRect(0,0,this._canvas.width, this._canvas.height);
	},
	toggleCanvas:function(){
		this._toggleCanvas(this._canvas.style.display=="none")

	},
	showCanvas:function(){
		this._toggleCanvas(true);
	},
	hideCanvas:function(){
		this._toggleCanvas(false);
	},
	_toggleCanvas:function(show){
		var areas, i;

		for(i=0; i < this._canvas_labels.length;i++)
			this._canvas_labels[i].style.display = (show?"":"none");

		if (this._obj._htmlmap){
			areas = this._getMapAreas();
			for( i = 0; i < areas.length; i++){
				if(show)
					areas[i].removeAttribute("disabled");
				else
					areas[i].setAttribute("disabled","true");
			}
		}
		//FF breaks, when we are using clear canvas and call clearRect without parameters
		this._canvas.style.display = (show?"":"none");
	},
	_getMapAreas:function(){
		var res = [], areas, i;

		areas = this._obj._htmlmap.getElementsByTagName("AREA");

		for(i = 0; i < areas.length; i++){
			if(areas[i].getAttribute("userdata") == this._canvas_name){
				res.push(areas[i]);
			}
		}

		return res;
	}
};

/* DHX INITIAL FILE 'C:\http\legacy/dhtmlxCore/sources//chart.js'*/


/*DHX:Depend chart.css*/
/*DHX:Depend canvas.js*/
/*DHX:Depend load.js*/

/*DHX:Depend compatibility_grid.js*/
/*DHX:Depend compatibility_layout.js*/

/*DHX:Depend config.js*/
/*DHX:Depend destructor.js*/
/*DHX:Depend mouse.js*/
/*DHX:Depend key.js*/
/*DHX:Depend group.js*/
/*DHX:Depend autotooltip.js*/

/*DHX:Depend ext/chart/chart_base.js*/
/*DHX:Depend ext/chart/chart_pie.js*/		//+pie3d
/*DHX:Depend ext/chart/chart_bar.js*/	
/*DHX:Depend ext/chart/chart_line.js*/
/*DHX:Depend ext/chart/chart_barh.js*/	
/*DHX:Depend ext/chart/chart_stackedbar.js*/	
/*DHX:Depend ext/chart/chart_stackedbarh.js*/
/*DHX:Depend ext/chart/chart_spline.js*/	
/*DHX:Depend ext/chart/chart_area.js*/	 	//+stackedArea
/*DHX:Depend ext/chart/chart_radar.js*/	 	
/*DHX:Depend ext/chart/chart_scatter.js*/
/*DHX:Depend ext/chart/presets.js*/
/*DHX:Depend math.js*/
/*DHX:Depend destructor.js*/
/*DHX:Depend dhtmlx.js*/
/*DHX:Depend date.js*/

dhtmlXChart = function(container){
	this.name = "Chart";	
	
	if (dhtmlx.assert_enabled()) this._assert();
	
	dhtmlx.extend(this, dhtmlx.Settings);
	
	this._parseContainer(container,"dhx_chart");
	
	dhtmlx.extend(this, dhtmlx.AtomDataLoader);
	dhtmlx.extend(this, dhtmlx.DataLoader);
	this.data.provideApi(this,true);
	
	dhtmlx.extend(this, dhtmlx.EventSystem);
	dhtmlx.extend(this, dhtmlx.MouseEvents);
	dhtmlx.destructors.push(this);
	//dhtmlx.extend(this, dhtmlx.Destruction);
	//dhtmlx.extend(this, dhtmlx.Canvas);
	dhtmlx.extend(this, dhtmlx.Group);
	dhtmlx.extend(this, dhtmlx.AutoTooltip);
	
	for (var key in dhtmlx.chart)
		dhtmlx.extend(this, dhtmlx.chart[key]);


    if(container.preset){
        this.definePreset(container);
    }
	this._parseSettings(container,this.defaults);
	this._series = [this._settings];
	this.data.attachEvent("onStoreUpdated",dhtmlx.bind(function(){
		this.render();  
	},this));
	this.attachEvent("onLocateData", this._switchSerie);
};
dhtmlXChart.prototype={
	_id:"dhx_area_id",
	on_click: {
		dhx_chart_legend_item: function(e,id,obj){
			var series = obj.getAttribute("series_id");
			if(this.callEvent("onLegendClick",[e,series,obj])){
				var config = this._settings;
				var values = config.legend.values;
				var toggle = (values&&(typeof values[series].toggle != "undefined"))?values[series].toggle:config.legend.toggle;
			    if((typeof series != "undefined")&&this._series.length>1){
				    // hide action
				    if(toggle){
					    if(obj.className.indexOf("hidden")!=-1){
						    this.showSeries(series);
					    }
					    else{
						    this.hideSeries(series);
					    }
				    }
			    }
			}
		}
	},
	on_dblclick:{
	},
	on_mouse_move:{
	},
	destructor: function(){
		dhtmlx.Destruction.destructor.apply(this, arguments);
		if(this.canvases){
			for(var i in this.canvases){
				this.canvases[i]._obj = null;
				this.canvases[i] = null;
			}
			this.canvases = null;
		}
		if(this.legendObj){
			this.legendObj.innerHTML = "";
			this.legendObj = null;
		}
		if (this.config.tooltip) {
			this.config.tooltip._obj = null;
			this.config.tooltip._dataobj = null;
		}
	},
	bind:function(){
		dhtmlx.BaseBind.legacyBind.apply(this, arguments);
	},
	sync:function(){
		dhtmlx.BaseBind.legacySync.apply(this, arguments);
	},
	resize:function(){
		for(var c in this.canvases){
			this.canvases[c]._resizeCanvas();
		}
		this.render();	
	},
	view_setter:function( val){
		if (!dhtmlx.chart[val])
			dhtmlx.error("Chart type extension is not loaded: "+val);
		//if you will need to add more such settings - move them ( and this one ) in a separate methods
		
		if (typeof this._settings.offset == "undefined"){
			this._settings.offset = !(val == "area" || val == "stackedArea");
		}
        if(val=="radar"&&!this._settings.yAxis)
		    this.define("yAxis",{});
        if(val=="scatter"){
            if(!this._settings.yAxis)
                this.define("yAxis",{});
            if(!this._settings.xAxis)
                this.define("xAxis",{});
        }

		return val;
	},
	clearCanvas:function(){
		if(this.canvases&&typeof this.canvases == "object")
			for(var c in this.canvases){
				this.canvases[c].clearCanvas();
			}
	},
	render:function(){
		var bounds, i, data, map, temp;

		if (!this.callEvent("onBeforeRender",[this.data]))
			return;
		
		if(this.canvases&&typeof this.canvases == "object"){
			for(i in this.canvases){
				this.canvases[i].clearCanvas();
			}
		}
		else
			this.canvases = {};

		if(this._settings.legend){
			if(!this.canvases["legend"])
				this.canvases["legend"] =  new dhtmlx.ui.Canvas(this._obj,"legend");
			this._drawLegend(
				this.data.getRange(),
				this._obj.offsetWidth
			);
		}
		bounds = this._getChartBounds(this._obj.offsetWidth,this._obj.offsetHeight);
		this._map = map = new dhtmlx.ui.Map(this._id);
		temp = this._settings;
		data = this._getChartData();
		
		for(i=0; i < this._series.length;i++){
		 	this._settings = this._series[i];
			if(!this.canvases[i]){
				this.canvases[i] = new dhtmlx.ui.Canvas(this._obj,i,"z-index:"+(2+i));
			}
			this["pvt_render_"+this._settings.view](
				this.canvases[i].getCanvas(),
				data,
				bounds.start,
				bounds.end,
				i,
				map
			);
		}

		map.render(this._obj);
		this._obj.lastChild.style.zIndex = 1000;
		this._applyBounds(this._obj.lastChild,bounds);
		this.callEvent("onAfterRender",[]);
		this._settings = temp;
	},
	_applyBounds: function(elem,bounds){
		var style = {};
		style.left = bounds.start.x;
		style.top = bounds.start.y;
		style.width = bounds.end.x-bounds.start.x;
		style.height = bounds.end.y - bounds.start.y;
		for(var prop in style){
			elem.style[prop] = style[prop]+"px";
		}
	},
	_getChartData: function(){
		var  axis, axisConfig ,config, data, i, newData, start, units, value, valuesHash;
		data = this.data.getRange();
		axis = (this._settings.view.toLowerCase().indexOf("barh")!=-1?"yAxis":"xAxis");
		axisConfig = this._settings[axis];
		if(axisConfig&&axisConfig.units&&(typeof axisConfig.units == "object")){
			config = axisConfig.units;
			units = [];
			if(typeof config.start != "undefined"&&typeof config.end != "undefined" && typeof config.next != "undefined"){
				start = config.start;
				while(start<=config.end){
					units.push(start);
					start = config.next.call(this,start);
				}
			}
			else if(Object.prototype.toString.call(config) === '[object Array]'){
				units = config;
			}
			newData = [];
			if(units.length){
				value = axisConfig.value;
				valuesHash = {};
				for(i=0;i < data.length;i++){
					valuesHash[value(data[i])] = i;
				}
				for(i=0;i< units.length;i++){
					if(typeof valuesHash[units[i]]!= "undefined"){
						data[valuesHash[units[i]]].$unit = units[i];
						newData.push(data[valuesHash[units[i]]]);
					}
					else{
						newData.push({$unit:units[i]});
					}
				}
			}
			return newData;
		}
		return data;
	},
	value_setter:dhtmlx.Template.obj_setter,
    xValue_setter:dhtmlx.Template.obj_setter,
    yValue_setter:function(config){
        this.define("value",config);
    },
	alpha_setter:dhtmlx.Template.obj_setter,	
	label_setter:dhtmlx.Template.obj_setter,
	lineColor_setter:dhtmlx.Template.obj_setter,
	borderColor_setter:dhtmlx.Template.obj_setter,
	pieInnerText_setter:dhtmlx.Template.obj_setter,
	gradient_setter:function(config){
		if((typeof(config)!="function")&&config&&(config === true))
			config = "light";
		return config;
	},
	colormap:{
		"RAINBOW":function(obj){
            var pos = Math.floor(this.indexById(obj.id)/this.dataCount()*1536);
			if (pos==1536) pos-=1;
			return this._rainbow[Math.floor(pos/256)](pos%256);
		}
	},
	color_setter:function(value){
		return this.colormap[value]||dhtmlx.Template.obj_setter( value);
	},
    fill_setter:function(value){
        return ((!value||value==0)?false:dhtmlx.Template.obj_setter( value));
    },
    definePreset:function(obj){
        this.define("preset",obj.preset);
        delete obj.preset;
    },
	preset_setter:function(value){
        var a, b, preset;
        this.defaults = dhtmlx.extend({},this.defaults);
        if(typeof dhtmlx.presets.chart[value]=="object"){

            preset =  dhtmlx.presets.chart[value];
            for(a in preset){

                if(typeof preset[a]=="object"){
                    if(!this.defaults[a]||typeof this.defaults[a]!="object"){
                         this.defaults[a] = dhtmlx.extend({},preset[a]);
                    }
                    else{
                        this.defaults[a] = dhtmlx.extend({},this.defaults[a]);
                        for(b in preset[a]){
                            this.defaults[a][b] = preset[a][b];
                        }
                    }
                }else{
                     this.defaults[a] = preset[a];
                }
            }
            return value;
        }
		return false;
	},
	legend_setter:function( config){
		if(!config){
			if(this.legendObj){
				this.legendObj.innerHTML = "";
				this.legendObj = null;
			}
			return false;
		}
		if(typeof(config)!="object")	//allow to use template string instead of object
			config={template:config};
			
		this._mergeSettings(config,{
			width:150,
			height:18,
			layout:"y",
			align:"left",
			valign:"bottom",
			template:"",
			toggle:(this._settings.view.toLowerCase().indexOf("stacked")!=-1?"":"hide"),
			marker:{
				type:"square",
				width:15,
				height:15,
                radius:3
			},
            margin: 4,
            padding: 3
		});
		
		config.template = dhtmlx.Template.setter(config.template);
		return config;
	},
    defaults:{
        color:"RAINBOW",
		alpha:"1",
		label:false,
		value:"{obj.value}",
		padding:{},
		view:"pie",
		lineColor:"#ffffff",
		cant:0.5,
		width: 30,
		labelWidth:100,
		line:{
            width:2,
			color:"#1293f8"
        },
	    seriesMargin: 1,
	    seriesPadding: 4,
		item:{
			radius:3,
			borderColor:"#636363",
            borderWidth:1,
            color: "#ffffff",
            alpha:1,
            type:"r",
            shadow:false
		},
		shadow:true,
		gradient:false,
		border:true,
		labelOffset: 20,
		origin:"auto"
    },
	item_setter:function( config){
		if(typeof(config)!="object")
			config={color:config, borderColor:config};
        this._mergeSettings(config,dhtmlx.extend({},this.defaults.item));
		var settings = ["alpha","borderColor","color","radius"];
		for(var i=0; i< settings.length; i++)
			config[settings[i]] = dhtmlx.Template.setter(config[settings[i]]);
		/*config.alpha = dhtmlx.Template.setter(config.alpha);
        config.borderColor = dhtmlx.Template.setter(config.borderColor);
		config.color = dhtmlx.Template.setter(config.color);
        config.radius = dhtmlx.Template.setter(config.radius);*/
		return config;
	},
	line_setter:function( config){
		if(typeof(config)!="object")
			config={color:config};
	    dhtmlx.extend(this.defaults.line,config);
        config = dhtmlx.extend({},this.defaults.line);
		config.color = dhtmlx.Template.setter(config.color);
		return config;
	},
	padding_setter:function( config){	
		if(typeof(config)!="object")
			config={left:config, right:config, top:config, bottom:config};
		this._mergeSettings(config,{
			left:50,
			right:20,
			top:35,
			bottom:40
		});
		return config;
	},
	xAxis_setter:function( config){
		if(!config) return false;
		if(typeof(config)!="object")
			config={ template:config };
		if(!config.value)
			config.value = config.template;
		this._mergeSettings(config,{
			title:"",
			color:"#000000",
			lineColor:"#cfcfcf",
			template:"{obj}",
			value:"{obj}",
			lines:true
		});
		var templates = ["lineColor","template","lines","value"];
        this._converToTemplate(templates,config);
		this._configXAxis = dhtmlx.extend({},config);
		return config;
	},
    yAxis_setter:function( config){
		if(!config) return false;
	    this._mergeSettings(config,{
			title:"",
			color:"#000000",
			lineColor:"#cfcfcf",
			template:"{obj}",
			lines:true,
            bg:"#ffffff"
		});
		var templates = ["lineColor","template","lines","bg"];
        this._converToTemplate(templates,config);
		this._configYAxis = dhtmlx.extend({},config);
		return config;
	},
    _converToTemplate:function(arr,config){
        for(var i=0;i< arr.length;i++){
            config[arr[i]] = dhtmlx.Template.setter(config[arr[i]]);
        }
    },
    _drawScales:function(data,point0,point1,start,end,cellWidth){
	    var y = 0;
	    if(this._settings.yAxis){
		    if(! this.canvases["y"])
		        this.canvases["y"] =  new dhtmlx.ui.Canvas(this._obj,"axis_y");
		    y = this._drawYAxis(this.canvases["y"].getCanvas(),data,point0,point1,start,end);
	    }
	    if (this._settings.xAxis){
		    if(! this.canvases["x"])
			    this.canvases["x"] =  new dhtmlx.ui.Canvas(this._obj,"axis_x");
		    this._drawXAxis(this.canvases["x"].getCanvas(),data,point0,point1,cellWidth,y);
	    }
		return y;
	},
	_drawXAxis:function(ctx,data,point0,point1,cellWidth,y){
		var x0 = point0.x-0.5;
		var y0 = parseInt((y?y:point1.y),10)+0.5;
		var x1 = point1.x;
		var unitPos;
		var center = true;
		var labelY = (this._settings.origin ===0 && this._settings.view=="stackedBar")?point1.y+0.5:y0;

		for(var i=0; i < data.length; i++){

			if(this._settings.offset === true)
				unitPos = x0+cellWidth/2+i*cellWidth;
			else{
				unitPos = (i==data.length-1)?point1.x:x0+i*cellWidth;
				center = !!i;
			}
			unitPos = Math.ceil(unitPos)-0.5;
			/*scale labels*/
			var top = ((this._settings.origin!="auto")&&(this._settings.view=="bar")&&(parseFloat(this._settings.value(data[i]))<this._settings.origin));
			this._drawXAxisLabel(unitPos,labelY,data[i],center,top);
			/*draws a vertical line for the horizontal scale*/

			if((this._settings.offset||i)&&this._settings.xAxis.lines.call(this,data[i]))
		    	this._drawXAxisLine(ctx,unitPos,point1.y,point0.y,data[i]);
		}
		
		this.canvases["x"].renderTextAt(true, false, x0,point1.y+this._settings.padding.bottom-3,
			this._settings.xAxis.title,
			"dhx_axis_title_x",
			point1.x - point0.x
		);
		this._drawLine(ctx,x0,y0,x1,y0,this._settings.xAxis.color,1);
		/*the right border in lines in scale are enabled*/
		if (!this._settings.xAxis.lines.call(this,{}) || !this._settings.offset) return;
		this._drawLine(ctx,x1+0.5,point1.y,x1+0.5,point0.y+0.5,this._settings.xAxis.color,0.2);
	},
	_drawYAxis:function(ctx,data,point0,point1,start,end){
		var step;
		var scaleParam= {};
		if (!this._settings.yAxis) return;
		
		var x0 = point0.x - 0.5;
		var y0 = point1.y;
		var y1 = point0.y;
		var lineX = point1.y;
		
		//this._drawLine(ctx,x0,y0,x0,y1,this._settings.yAxis.color,1);
		
		if(this._settings.yAxis.step)
		     step = parseFloat(this._settings.yAxis.step);

		if(typeof this._configYAxis.step =="undefined"||typeof this._configYAxis.start=="undefined"||typeof this._configYAxis.end =="undefined"){
			scaleParam = this._calculateScale(start,end);
			start = scaleParam.start;
			end = scaleParam.end;
			step = scaleParam.step;
			
			this._settings.yAxis.end = end;
			this._settings.yAxis.start = start;
		}
		this._setYAxisTitle(point0,point1);
		/*if(step===0) return;
		if(end==start){
			return y0;
		}
		var stepHeight = (y0-y1)*step/(end-start);*/
		if(step===0){
			end = start;
			step = 1;
		}
		var stepHeight = (end==start?y0-y1:(y0-y1)*step/(end-start));
		var c = 0;
		for(var i = start; i<=end; i += step){
			if(scaleParam.fixNum)  i = parseFloat((new Number(i)).toFixed(scaleParam.fixNum));
			var yi = Math.floor(y0-c*stepHeight)+ 0.5;/*canvas line fix*/
			if(!(i==start&&this._settings.origin=="auto") &&this._settings.yAxis.lines.call(this,i))
				this._drawLine(ctx,x0,yi,point1.x,yi,this._settings.yAxis.lineColor.call(this,i),1);
			if(i == this._settings.origin) lineX = yi;
			/*correction for JS float calculation*/
			var label = i;
			if(step<1){
				var power = Math.min(this._log10(step),(start<=0?0:this._log10(start)));
				var corr = Math.pow(10,-power);
				label = Math.round(i*corr)/corr;
				i = label;
			}
			this.canvases["y"].renderText(0,yi-5,
				this._settings.yAxis.template(label.toString()),
				"dhx_axis_item_y",
				point0.x-5
			);	
			c++;
		}
		this._drawLine(ctx,x0,y0+1,x0,y1,this._settings.yAxis.color,1);
		return lineX;
	},
	_setYAxisTitle:function(point0,point1){
        var className = "dhx_axis_title_y"+(dhtmlx._isIE&&dhtmlx._isIE !=9?" dhx_ie_filter":"");
		var text=this.canvases["y"].renderTextAt("middle",false,0,parseInt((point1.y-point0.y)/2+point0.y,10),this._settings.yAxis.title,className);
        if (text)
			text.style.left = (dhtmlx.env.transform?(text.offsetHeight-text.offsetWidth)/2:0)+"px";
		/*var ctx = this.canvases["y"].getCanvas();
		var metric = ctx.measureText(this._settings.yAxis.title);
		var tx = 5 + (metric.width/2);
		var ty = 5 +point0.y+ (point1.y-point0.y)/2+metric.width/2;
		ctx.font = "bold 12pt sans-serif";
		ctx.save();
		ctx.translate(tx,ty);
		ctx.rotate(Math.PI/2*3);
		//ctx.translate(-tx,-ty);

		ctx.fillText(this._settings.yAxis.title, 0,0)
		ctx.restore();*/

	},
	_calculateScale:function(nmin,nmax){
	    if(this._settings.origin!="auto"&&this._settings.origin<nmin)
			nmin = this._settings.origin;
		var step,start,end;
	   	step = ((nmax-nmin)/8)||1;
		var power = Math.floor(this._log10(step));
		var calculStep = Math.pow(10,power);
		var stepVal = step/calculStep;
		stepVal = (stepVal>5?10:5);
		step = parseInt(stepVal,10)*calculStep;
		
		if(step>Math.abs(nmin))
			start = (nmin<0?-step:0);
		else{
			var absNmin = Math.abs(nmin);
			var powerStart = Math.floor(this._log10(absNmin));
			var nminVal = absNmin/Math.pow(10,powerStart);
			start = Math.ceil(nminVal*10)/10*Math.pow(10,powerStart)-step;
			if(absNmin>1&&step>0.1){
				start = Math.ceil(start);
			}
			while(nmin<0?start<=nmin:start>=nmin)
				start -= step;
			if(nmin<0) start =-start-2*step;
			
		}
	     end = start;
		while(end<nmax){
			end += step;
			end = parseFloat((new Number(end)).toFixed(Math.abs(power)));
		}
		return { start:start,end:end,step:step,fixNum:Math.abs(power) };
	},
	_getLimits:function(orientation,value){
		var maxValue,minValue;
		var axis = ((arguments.length && orientation=="h")?this._configXAxis:this._configYAxis);
		value = value||"value";
		if(axis&&(typeof axis.end!="undefined")&&(typeof axis.start!="undefined")&&axis.step){
		    maxValue = parseFloat(axis.end);
			minValue = parseFloat(axis.start);      
		}
		else{
			maxValue = this.max(this._series[0][value]);
			minValue = (axis&&(typeof axis.start!="undefined"))?parseFloat(axis.start):this.min(this._series[0][value]);
			if(this._series.length>1)
			for(var i=1; i < this._series.length;i++){
				var maxI = this.max(this._series[i][value]);
				var minI = this.min(this._series[i][value]);
				if (maxI > maxValue) maxValue = maxI;
		    	if (minI < minValue) minValue = minI;
			}
		}
		return {max:maxValue,min:minValue};
	},
	_log10:function(n){
        var method_name="log";
        return Math.floor((Math[method_name](n)/Math.LN10));
    },
	_drawXAxisLabel:function(x,y,obj,center,top){
		if (!this._settings.xAxis) return;
		var elem = this.canvases["x"].renderTextAt(top, center, x,y-(top?2:0),this._settings.xAxis.template(obj));
		if (elem)
			elem.className += " dhx_axis_item_x";
	},
	_drawXAxisLine:function(ctx,x,y1,y2,obj){
		if (!this._settings.xAxis||!this._settings.xAxis.lines) return;
		this._drawLine(ctx,x,y1,x,y2,this._settings.xAxis.lineColor.call(this,obj),1);
	},
	_drawLine:function(ctx,x1,y1,x2,y2,color,width){
		ctx.strokeStyle = color;
		ctx.lineWidth = width;
		ctx.beginPath();
		ctx.moveTo(x1,y1);
		ctx.lineTo(x2,y2);
		ctx.stroke();
        ctx.lineWidth = 1;
	},
	_getRelativeValue:function(minValue,maxValue){
	    var relValue, origRelValue;
		var valueFactor = 1;
		if(maxValue != minValue){
			relValue = maxValue - minValue;
			/*if(Math.abs(relValue) < 1){
			    while(Math.abs(relValue)<1){
				    valueFactor *= 10;
				    relValue = origRelValue* valueFactor;
				}
			}
			*/
		}
		else relValue = minValue;
		return [relValue,valueFactor];
	},
	_rainbow : [
		function(pos){ return "#FF"+dhtmlx.math.toHex(pos/2,2)+"00";},
		function(pos){ return "#FF"+dhtmlx.math.toHex(pos/2+128,2)+"00";},
		function(pos){ return "#"+dhtmlx.math.toHex(255-pos,2)+"FF00";},
		function(pos){ return "#00FF"+dhtmlx.math.toHex(pos,2);},
		function(pos){ return "#00"+dhtmlx.math.toHex(255-pos,2)+"FF";},
		function(pos){ return "#"+dhtmlx.math.toHex(pos,2)+"00FF";}		
	],
	/**
	*   adds series to the chart (value and color properties)
	*   @param: obj - obj with configuration properties
	*/
	addSeries:function(obj){
		var temp = this._settings;
		this._settings = dhtmlx.extend({},temp);
		this._parseSettings(obj,{});
	    this._series.push(this._settings);
		this._settings = temp;
    },
    /*switch global settings to serit in question*/
    _switchSerie:function(id, tag, e){
        var tip;
    	this._active_serie = (this._series.length==1?tag.getAttribute("userdata"):this._getActiveSeries(e));

    	if (!this._series[this._active_serie]) return;
    	for (var i=0; i < this._series.length; i++) {
    		tip = this._series[i].tooltip;
    		if (tip)
    			tip.disable();
		}
	    if(!tag.getAttribute("disabled")){
		    tip = this._series[this._active_serie].tooltip;
		    if (tip)
			    tip.enable();
	    }
    },
	_getActiveSeries: function(e){
		var a, areas, i, offset, pos, selection,  x, y;

		areas = this._map._areas;
		offset = dhtmlx.html.offset(this._obj._htmlmap);
		pos = dhtmlx.html.pos(e);
		x = pos.x - offset.x;
		y = pos.y - offset.y;

		for( i = 0; i < areas.length; i++){
			a = areas[i].points;
			if(x <= a[2] && x >= a[0] && y <= a[3] && y >= a[1]){
				if(selection){
					if(areas[i].index > selection.index)
						selection = areas[i];
				}
				else
					selection = areas[i];
			}
		}

		return selection?selection.index:0;
	},
	hideSeries:function(series){
		this.canvases[series].hideCanvas();
		if(this._settings.legend.values&&this._settings.legend.values[series])
			this._settings.legend.values[series].$hidden = true;
		this._drawLegend();
	},
	showSeries:function(series){
		this.canvases[series].showCanvas();
		if(this._settings.legend.values&&this._settings.legend.values[series])
			delete this._settings.legend.values[series].$hidden;
		this._drawLegend();

	},
	_changeColorSV:function(color,s,v){
		var hsv,rgb;
		rgb = dhtmlx.math.toRgb(color);
		hsv = dhtmlx.math.rgbToHsv(rgb[0],rgb[1],rgb[2]);
		hsv[1] *= s;
		hsv[2] *= v;
		return "rgb("+dhtmlx.math.hsvToRgb(hsv[0],hsv[1],hsv[2])+")";

	},
	_setBorderStyles:function(ctx,color){
		var hsv,rgb;
		rgb = dhtmlx.math.toRgb(color);
		hsv = dhtmlx.math.rgbToHsv(rgb[0],rgb[1],rgb[2]);
		hsv[2] /= 2;
		color = "rgb("+dhtmlx.math.hsvToRgb(hsv[0],hsv[1],hsv[2])+")";
		ctx.strokeStyle = color;
		if(ctx.globalAlpha==1)
			ctx.globalAlpha = 0.9;
	},
	/**
	*   renders legend block
	*   @param: ctx - canvas object
	*   @param: data - object those need to be displayed
	*   @param: width - the width of the container
	*   @param: height - the height of the container
	*/
	_drawLegend:function(data,width){
        var i, legend, legendContainer, legendHeight, legendItems, legendWidth, style, x=0, y= 0, ctx, itemColor, disabled, item;

		data = data||[];
		width = width||this._obj.offsetWidth;
		ctx = this.canvases["legend"].getCanvas();
		/*legend config*/
		legend = this._settings.legend;
        
		style = (this._settings.legend.layout!="x"?"width:"+legend.width+"px":"");
		/*creation of legend container*/
		if(this.legendObj){
			this.legendObj.innerHTML = "";
			this.legendObj.parentNode.removeChild(this.legendObj);
		}

		this.canvases["legend"].clearCanvas(true);
		legendContainer = dhtmlx.html.create("DIV",{
			"class":"dhx_chart_legend",
			"style":"left:"+x+"px; top:"+y+"px;"+style
		},"");
        if(legend.padding){
            legendContainer.style.padding =  legend.padding+"px";
        }
		this.legendObj = legendContainer;
		this._obj.appendChild(legendContainer);
		/*rendering legend text items*/
		legendItems = [];
		if(!legend.values)
			for(i = 0; i < data.length; i++){
				legendItems.push(this._drawLegendText(legendContainer,legend.template(data[i])));
			}
		else
			for(i = 0; i < legend.values.length; i++){
				legendItems.push(this._drawLegendText(legendContainer,legend.values[i].text,(typeof legend.values[i].id!="undefined"?typeof legend.values[i].id:i),legend.values[i].$hidden));
			}
	   	legendWidth = legendContainer.offsetWidth;
	    legendHeight = legendContainer.offsetHeight;
		/*this._settings.legend.width = legendWidth;
		this._settings.legend.height = legendHeight;*/

		/*setting legend position*/
		if(legendWidth<this._obj.offsetWidth){
			if(legend.layout == "x"&&legend.align == "center"){
			    x = (this._obj.offsetWidth-legendWidth)/2;
            }
			if(legend.align == "right"){
				x = this._obj.offsetWidth-legendWidth;
			}
            if(legend.margin&&legend.align != "center"){
                x += (legend.align == "left"?1:-1)*legend.margin;
            }


        }
		if(legendHeight<this._obj.offsetHeight){
			if(legend.valign == "middle"&&legend.align != "center"&&legend.layout != "x")
				y = (this._obj.offsetHeight-legendHeight)/2;
			else if(legend.valign == "bottom")
				y = this._obj.offsetHeight-legendHeight;
            if(legend.margin&&legend.valign != "middle"){
                y += (legend.valign == "top"?1:-1)*legend.margin;
            }
		}
		legendContainer.style.left = x+"px";
		legendContainer.style.top = y+"px";

		/*drawing colorful markers*/
		ctx.save();

		for(i = 0; i < legendItems.length; i++){
			item = legendItems[i];
			if(legend.values&&legend.values[i].$hidden){
				disabled = true;
				itemColor = (legend.values[i].disableColor?legend.values[i].disableColor:"#d9d9d9");
			}
			else{
				disabled = false;
				itemColor = (legend.values?legend.values[i].color:this._settings.color.call(this,data[i]));
			}
			var offset = (legend.marker.position == "right"?item.offsetWidth - legend.marker.width:0);
			this._drawLegendMarker(ctx,item.offsetLeft + x + offset,item.offsetTop+y,itemColor,item.offsetHeight,disabled,i);
		}
		ctx.restore();
		legendItems = null;
	},
	/**
	*   appends legend item to legend block
	*   @param: ctx - canvas object
	*   @param: obj - data object that needs being represented
	*/
	_drawLegendText:function(cont,value,series,disabled){
		var style = "";
		var legend = this._settings.legend;
		if(legend.layout=="x")
			style = "float:left;";
		/*the text of the legend item*/
		var pos = legend.marker.position;
		var text = dhtmlx.html.create("DIV",{
			"style":style+"padding-"+(pos&&pos=="right"?"right":"left")+":"+(10+legend.marker.width)+"px",
			"class":"dhx_chart_legend_item"+(disabled?" hidden":"")
		},value);
		if(arguments.length>2)
			text.setAttribute("series_id",series);
		cont.appendChild(text);
		return text;
	},
	/**
	*   draw legend colorful marder
	*   @param: ctx - canvas object
	*   @param: x - the horizontal position of the marker
	*   @param: y - the vertical position of the marker
	*   @param: color - marker color
	*   @param: height - item height
	*   @param: disabled - disabled staet
	*   @param: i - index of legend item
	*/
	_drawLegendMarker:function(ctx,x,y,color,height,disabled,i){
		var p = [];
		var marker = this._settings.legend.marker;
		var values = this._settings.legend.values;
		var type = (values&&values[i].markerType?values[i].markerType:marker.type);

		if(color){
			ctx.fillStyle = color;
			ctx.strokeStyle = this._getDarkenColor(color,0.75);
		}
        ctx.beginPath();
		if(type=="round"||!marker.radius){
            ctx.lineWidth = marker.height;
		    ctx.lineCap = type;
		    /*start of marker*/
		    x += ctx.lineWidth/2+5;
		    y += height/2;
		    ctx.moveTo(x,y);
		    var x1 = x + marker.width-marker.height +1;
		    ctx.lineTo(x1,y);

        }else if(type=="item"){
			/*copy of line*/
			if(this._settings.line&&this._settings.view != "scatter" && !this._settings.disableLines){
				ctx.beginPath();
				ctx.lineWidth = this._series[i].line.width;
				ctx.strokeStyle = disabled?color:this._series[i].line.color.call(this,{});
				var x0 = x + 5;
				var y0 = y + height/2;
				ctx.moveTo(x0,y0);
				var x1 = x0 + marker.width;
				ctx.lineTo(x1,y0);
				ctx.stroke();
			}
			/*item copy*/


			var config = this._series[i].item;
			var radius = parseInt(config.radius.call(this,{}),10)||0;
			if(radius){
				if(config.type == "image" && config.src){
					this._drawImage(ctx,x+5,y+marker.height/2-5,config.src,radius*2, radius*2);
					return;
				}
				else{
					ctx.beginPath();
					if(disabled){
						ctx.lineWidth = config.borderWidth;
						ctx.strokeStyle = color;
						ctx.fillStyle = color;
					}
					else{
						ctx.lineWidth = config.borderWidth;
						ctx.fillStyle = config.color.call(this,{});
						ctx.strokeStyle = config.borderColor.call(this,{});
						ctx.globalAlpha = config.alpha.call(this,{});
					}
					ctx.beginPath();
					x += marker.width/2+5;
					y += height/2;
					this._strokeChartItem(ctx,x,y,radius+1,config.type);
					ctx.fill();
					ctx.stroke();
				}

			}
			ctx.globalAlpha = 1;
		}else{
            ctx.lineWidth = 1;
            x += 5;
            y += parseInt(height/2-marker.height/2,10);

			p = [
				[x+marker.radius,y+marker.radius,marker.radius,Math.PI,3*Math.PI/2,false],
				[x+marker.width-marker.radius,y],
				[x+marker.width-marker.radius,y+marker.radius,marker.radius,-Math.PI/2,0,false],
				[x+marker.width,y+marker.height-marker.radius],
				[x+marker.width-marker.radius,y+marker.height-marker.radius,marker.radius,0,Math.PI/2,false],
				[x+marker.radius,y+marker.height],
				[x+marker.radius,y+marker.height-marker.radius,marker.radius,Math.PI/2,Math.PI,false],
				[x,y+marker.radius]
			];
            this._path(ctx,p);
        }

		ctx.stroke();
        ctx.fill();

	},
	_getDarkenColor:function(color,darken){
		var hsv,rgb;
		rgb = dhtmlx.math.toRgb(color);
		hsv = dhtmlx.math.rgbToHsv(rgb[0],rgb[1],rgb[2]);
		hsv[2] = hsv[2]*darken;
		return "rgb("+dhtmlx.math.hsvToRgb(hsv[0],hsv[1],hsv[2])+")";
	},
	/**
	*   gets the points those represent chart left top and right bottom bounds
	*   @param: width - the width of the chart container
	*   @param: height - the height of the chart container
	*/
	_getChartBounds:function(width,height){
		var chartX0, chartY0, chartX1, chartY1;
		
		chartX0 = this._settings.padding.left;
		chartY0 = this._settings.padding.top;
		chartX1 = width - this._settings.padding.right;
		chartY1 = height - this._settings.padding.bottom;	
		
		if(this._settings.legend){
			var legend = this._settings.legend;
			/*legend size*/
			var legendWidth = this._settings.legend.width;
			var legendHeight = this._settings.legend.height;
		
			/*if legend is horizontal*/
			if(legend.layout == "x"){
				if(legend.valign == "center"){
					if(legend.align == "right")
						chartX1 -= legendWidth;
					else if(legend.align == "left")
				 		chartX0 += legendWidth;
			 	}
			 	else if(legend.valign == "bottom"){
			    	chartY1 -= legendHeight;
			 	}
			 	else{
			    	chartY0 += legendHeight;
			 	}
			}
			/*vertical scale*/
			else{
				if(legend.align == "right")
					chartX1 -= legendWidth;
			 	else if(legend.align == "left")
					chartX0 += legendWidth;
			}
		}
		return {start:{x:chartX0,y:chartY0},end:{x:chartX1,y:chartY1}};
	},
	/**
	*   gets the maximum and minimum values for the stacked chart
	*   @param: data - data set
	*/
	_getStackedLimits:function(data){
		var i, j, maxValue, minValue, value;
		if(this._settings.yAxis&&(typeof this._settings.yAxis.end!="undefined")&&(typeof this._settings.yAxis.start!="undefined")&&this._settings.yAxis.step){
		    maxValue = parseFloat(this._settings.yAxis.end);
			minValue = parseFloat(this._settings.yAxis.start);
		}
		else{
			for(i=0; i < data.length; i++){
				data[i].$sum = 0 ;
				data[i].$min = Infinity;
				for(j =0; j < this._series.length;j++){
					value = parseFloat(this._series[j].value(data[i])||0);
					if(isNaN(value)) continue;
					if(this._series[j].view.toLowerCase().indexOf("stacked")!=-1)
						data[i].$sum += value;
					if(value < data[i].$min) data[i].$min = value;
				}
			}
			maxValue = -Infinity;
			minValue = Infinity;
			for(i=0; i < data.length; i++){
				if (data[i].$sum > maxValue) maxValue = data[i].$sum ;
				if (data[i].$min < minValue) minValue = data[i].$min ;
			}
			if(minValue>0) minValue =0;
		}
		return {max: maxValue, min: minValue};
	},
	/*adds colors to the gradient object*/
	_setBarGradient:function(ctx,x1,y1,x2,y2,type,color,axis){
		var gradient, offset, rgb, hsv, color0, stops;
		if(type == "light"){
			if(axis == "x")
				gradient = ctx.createLinearGradient(x1,y1,x2,y1);
			else
				gradient = ctx.createLinearGradient(x1,y1,x1,y2);
			stops = [[0,"#FFFFFF"],[0.9,color],[1,color]];
			offset = 2;
		}
		else if(type == "falling"||type == "rising"){
			if(axis == "x")
				gradient = ctx.createLinearGradient(x1,y1,x2,y1);
			else
				gradient = ctx.createLinearGradient(x1,y1,x1,y2);
			rgb = dhtmlx.math.toRgb(color);
			hsv = dhtmlx.math.rgbToHsv(rgb[0],rgb[1],rgb[2]);
			hsv[1] *= 1/2;
			color0 = "rgb("+dhtmlx.math.hsvToRgb(hsv[0],hsv[1],hsv[2])+")";
			if(type == "falling"){
				stops = [[0,color0],[0.7,color],[1,color]];
			}
			else if(type == "rising"){
				stops = [[0,color],[0.3,color],[1,color0]];
			}
			offset = 0;
		}
		else{
			ctx.globalAlpha = 0.37;
			offset = 0;
			if(axis == "x")
				gradient = ctx.createLinearGradient(x1,y2,x1,y1);
			else
				gradient = ctx.createLinearGradient(x1,y1,x2,y1);
			stops = [[0,"#9d9d9d"],[0.3,"#e8e8e8"],[0.45,"#ffffff"],[0.55,"#ffffff"],[0.7,"#e8e8e8"],[1,"#9d9d9d"]];
		}
		this._gradient(gradient,stops);
		return {gradient:gradient,offset:offset};
	},
    /**
	*   returns the x and y position
    *   @param: a - angle
    *   @param: x - start x position
    *   @param: y - start y position
	*   @param: r - destination to the point
	*/
     _getPositionByAngle:function(a,x,y,r){
         a *= (-1);
         x = x+Math.cos(a)*r;
         y = y-Math.sin(a)*r;
         return {x:x,y:y};
    },
	_gradient:function(gradient,stops){
		for(var i=0; i< stops.length; i++){
			gradient.addColorStop(stops[i][0],stops[i][1]);
		}
	},
	_path: function(ctx,points){
		var i, method;
		for(i = 0; i< points.length; i++){
			method = (i?"lineTo":"moveTo");
			if(points[i].length>2)
				method = "arc";
			ctx[method].apply(ctx,points[i]);
		}
	},
	_circle: function(ctx,x,y,r){
		ctx.arc(x,y,r,Math.PI*2,true);
	},
	_addMapRect:function(map,id,points,bounds,sIndex){
		map.addRect(id,[points[0].x-bounds.x,points[0].y-bounds.y,points[1].x-bounds.x,points[1].y-bounds.y],sIndex);
	}
};

dhtmlx.compat("layout");

if (typeof(window.dhtmlXCellObject) != "undefined") {
	
	dhtmlXCellObject.prototype.attachChart = function(conf) {
		
		this.callEvent("_onBeforeContentAttach",["chart"]);
		
		var obj = document.createElement("DIV");
		obj.id = "dhxChartObj_"+window.dhx4.newId();
		obj.style.width = "100%";
		obj.style.height = "100%";
		document.body.appendChild(obj);
		this._attachObject(obj);
		
		conf.container = obj.id;
		
		this.dataType = "chart";
		this.dataObj = new dhtmlXChart(conf);
		
		if (!this.dataObj.setSizes) {
			this.dataObj.setSizes = function() {
				if (this.resize) this.resize(); else this.render();
			};
		}
		
		return this.dataObj;
	};
	
}


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/



/* DHX DEPEND FROM FILE 'pager.js'*/


/*
	UI:paging control
*/

/*DHX:Depend template.js*/

dhtmlx.ui.pager=function(container){
	this.name = "Pager";
	
	if (dhtmlx.assert_enabled()) this._assert();
	
	dhtmlx.extend(this, dhtmlx.Settings);
	this._parseContainer(container,"dhx_pager");
	
	dhtmlx.extend(this, dhtmlx.EventSystem);
	dhtmlx.extend(this, dhtmlx.SingleRender);
	dhtmlx.extend(this, dhtmlx.MouseEvents);
	
	this._parseSettings(container,{
		size:10,	//items on page
		page:-1,	//current page
		group:5,	//pages in group
		count:0,	//total count of items
		type:"default"
	});
	
	this.data = this._settings;
	this.refresh();
};

dhtmlx.ui.pager.prototype={
	_id:"dhx_p_id",
	on_click:{
		//on paging button click
		"dhx_pager_item":function(e,id){
			this.select(id);
		}
	},
	select:function(id){
		//id - id of button, number for page buttons
		switch(id){
			case "next":
				id = this._settings.page+1;
				break;
			case "prev":
				id = this._settings.page-1;
				break;
			case "first":
				id = 0;
				break;
			case "last":
				id = this._settings.limit-1;
				break;
			default:
				//use incoming id
				break;
		}
		if (id<0) id=0;
		if (id>=this.data.limit) id=this.data.limit-1;
		if (this.callEvent("onBeforePageChange",[this._settings.page,id])){
			this.data.page = id*1; //must be int
			this.refresh();
			this.callEvent("onAfterPageChange",[id]);	
		}
	},
	types:{
		"default":{ 
			template:dhtmlx.Template.fromHTML("{common.pages()}"),
			//list of page numbers
			pages:function(obj){
				var html="";
				//skip rendering if paging is not fully initialized
				if (obj.page == -1) return "";
				//current page taken as center of view, calculate bounds of group
				obj.min = obj.page-Math.round((obj.group-1)/2);
				obj.max = obj.min + obj.group-1;
				if (obj.min<0){
					obj.max+=obj.min*(-1);
					obj.min=0;
				}
				if (obj.max>=obj.limit){
					obj.min -= Math.min(obj.min,obj.max-obj.limit+1);
					obj.max = obj.limit-1;
				}
				//generate HTML code of buttons
				for (var i=(obj.min||0); i<=obj.max; i++)
					html+=this.button({id:i, index:(i+1), selected:(i == obj.page ?"_selected":"")});
				return html;
			},
			page:function(obj){
				return obj.page+1;
			},
			//go-to-first page button
			first:function(){
				return this.button({ id:"first", index:" &lt;&lt; ", selected:""});
			},
			//go-to-last page button
			last:function(){
				return this.button({ id:"last", index:" &gt;&gt; ", selected:""});
			},
			//go-to-prev page button
			prev:function(){
				return this.button({ id:"prev", index:"&lt;", selected:""});
			},
			//go-to-next page button
			next:function(){
				return this.button({ id:"next", index:"&gt;", selected:""});
			},
			button:dhtmlx.Template.fromHTML("<div dhx_p_id='{obj.id}' class='dhx_pager_item{obj.selected}'>{obj.index}</div>")
			
		}
	},
	//update settings and repaint self
	refresh:function(){
		var s = this._settings;
		//max page number
		s.limit = Math.ceil(s.count/s.size);
		
		//correct page if it is out of limits
		if (s.limit && s.limit != s.old_limit)
			s.page = Math.min(s.limit-1, s.page);
		
		var id = s.page;
		if (id!=-1 && (id!=s.old_page) || (s.limit != s.old_limit)){ 
			//refresh self only if current page or total limit was changed
			this.render();
			this.callEvent("onRefresh",[]);
			s.old_limit = s.limit;	//save for onchange check in next iteration
			s.old_page = s.page;
		}
	},
	template_item_start:dhtmlx.Template.fromHTML("<div>"),
	template_item_end:dhtmlx.Template.fromHTML("</div>")
};


/* DHX DEPEND FROM FILE 'dataprocessor_hook.js'*/


/*
	Behaviour:DataProcessor - translates inner events in dataprocessor calls
	
	@export
		changeId
		setItemStyle
		setUserData
		getUserData
*/

/*DHX:Depend compatibility.js*/
/*DHX:Depend dhtmlx.js*/

dhtmlx.DataProcessor={
	//called from DP as part of dp.init
	_dp_init:function(dp){
		//map methods
		var varname = "_methods";
		dp[varname]=["setItemStyle","","changeId","remove"];
		//after item adding - trigger DP
		this.attachEvent("onAfterAdd",function(id){
			dp.setUpdated(id,true,"inserted");
		});
		this.data.attachEvent("onStoreLoad",dhtmlx.bind(function(driver, data){
			if (driver.getUserData)
				driver.getUserData(data,this._userdata);
		},this));
		
		//after item deleting - trigger DP
		this.attachEvent("onBeforeDelete",function(id){
			if (dp._silent_mode) return true;
			
	        var z=dp.getState(id);
			if (z=="inserted") {  dp.setUpdated(id,false);		return true; }
			if (z=="deleted")  return false;
	    	if (z=="true_deleted")  return true;
	    	
			dp.setUpdated(id,true,"deleted");
	      	return false;
		});
		//after editing - trigger DP
		this.attachEvent("onAfterEditStop",function(id){
			dp.setUpdated(id,true,"updated");
		});
		this.attachEvent("onBindUpdate",function(data){
			window.setTimeout(function(){
				dp.setUpdated(data.id,true,"updated");	
			},1);
		});
		
		varname = "_getRowData";
		//serialize item's data in URL
		dp[varname]=function(id,pref){
			var ev=this.obj.data.get(id);
			var data = {};
			for (var a in ev){
				if (a.indexOf("_")===0) continue;
					data[a]=ev[a];
			}
			
			return data;
		};
		varname = "_clearUpdateFlag";
		dp[varname]=function(){};
		this._userdata = {};
		
		dp.attachEvent("insertCallback", this._dp_callback);
		dp.attachEvent("updateCallback", this._dp_callback);
		dp.attachEvent("deleteCallback", function(upd, id) {
			this.obj.setUserData(id, this.action_param, "true_deleted");
			this.obj.remove(id);
		});
				
		//enable compatibility layer - it will allow to use DP without dhtmlxcommon
		dhtmlx.compat("dataProcessor",dp);
	},
	_dp_callback:function(upd,id){
		this.obj.data.set(id,dhtmlx.DataDriver.xml.getDetails(upd.firstChild));
		this.obj.data.refresh(id);
	},
	//marks item in question with specific styles, not purposed for public usage
	setItemStyle:function(id,style){
		var node = this._locateHTML(id);
		if (node) node.style.cssText+=";"+style; //style is not persistent
	},
	//change ID of item
	changeId:function(oldid, newid){
		this.data.changeId(oldid, newid);
		this.refresh();
	},
	//sets property value, not purposed for public usage
	setUserData:function(id,name,value){
		if (id)
			this.data.get(id)[name]=value;
		else
			this._userdata[name]=value;
	},
	//gets property value, not purposed for public usage
	getUserData:function(id,name){
		return id?this.data.get(id)[name]:this._userdata[name];
	}
};
(function(){
	var temp = "_dp_init";
	dhtmlx.DataProcessor[temp]=dhtmlx.DataProcessor._dp_init;
})();



/* DHX DEPEND FROM FILE 'compatibility_drag.js'*/


/*
	Compatibility hack for DND
	Allows dnd between dhtmlx.dnd and dhtmlxcommon based dnd
	When dnd items - related events will be correctly triggered. 
	onDrag event must define final moving logic, if it is absent - item will NOT be moved automatically
	
	to activate this functionality , next command need to be called
		dhtmlx.compat("dnd");
*/

/*DHX:Depend compatibility.js*/

dhtmlx.compat.dnd = function(){
	//if dhtmlxcommon.js included on the page
	if (window.dhtmlDragAndDropObject){
		var _dragged = "_dragged"; //fake for code compression utility, do not change!
		
		//wrap methods of dhtmlxcommon to inform dhtmlx.dnd logic
		var old_ocl = dhtmlDragAndDropObject.prototype.checkLanding;
		dhtmlDragAndDropObject.prototype.checkLanding=function(node,e,skip){
			old_ocl.apply(this,arguments);
			if (!skip){ 
				var c = dhtmlx.DragControl._drag_context = dhtmlx.DragControl._drag_context||{};
				if (!c.from)
					c.from = this.dragStartObject;
				dhtmlx.DragControl._checkLand(node,e,true);
			}
		};
		
		var old_odp = dhtmlDragAndDropObject.prototype.stopDrag;
		dhtmlDragAndDropObject.prototype.stopDrag=function(e,dot,skip){
			if (!skip){
				if (dhtmlx.DragControl._last){
					dhtmlx.DragControl._active = dragger.dragStartNode;
					dhtmlx.DragControl._stopDrag(e,true);
				}
			}
			old_odp.apply(this,arguments);
		};
		
		
		//pre-create dnd object from dhtmlxcommon
		var dragger = new dhtmlDragAndDropObject();
		
		//wrap drag start process
		var old_start = dhtmlx.DragControl._startDrag;
		dhtmlx.DragControl._startDrag=function(){ 
			old_start.apply(this,arguments);	
			//build list of IDs and fake objects for dhtlmxcommon support
			var c = dhtmlx.DragControl._drag_context;
			if (!c) return;
			var source = [];
			var tsource = [];
			for (var i=0; i < c.source.length; i++){
				source[i]={idd:c.source[i]};
				tsource.push(c.source[i]);
			}
			
			dragger.dragStartNode = {	
				parentNode:{}, 
				parentObject:{ 
					idd:source, 
					id:(tsource.length == 1?tsource[0]:tsource),
					treeNod:{
						object:c.from
					}
				}
			};
			
			//prevent code compression of "_dragged"
			dragger.dragStartNode.parentObject.treeNod[_dragged]=source;
			dragger.dragStartObject = c.from;
		};
		//wrap drop landing checker
		var old_check = dhtmlx.DragControl._checkLand;
		dhtmlx.DragControl._checkLand = function(node,e,skip){
			old_check.apply(this,arguments);
			if (!this._last && !skip){
				//we are in middle of nowhere, check old drop landings
				node = dragger.checkLanding(node,e,true);
			}
		};
		
		//wrap drop routine
		var old_drop = dhtmlx.DragControl._stopDrag;
		dhtmlx.DragControl._stopDrag=function(e,skip){
			old_drop.apply(this,arguments);
			if (dragger.lastLanding && !skip)
				dragger.stopDrag(e,false,true);
		};
		//extend getMaster, so they will be able to recognize master objects from dhtmlxcommon.js
		var old_mst = 	dhtmlx.DragControl.getMaster;
		dhtmlx.DragControl.getMaster = function(t){
			var master = null;
			if (t)
				master = old_mst.apply(this,arguments);
			if (!master){
				master = dragger.dragStartObject;
				var src = [];
				var from = master[_dragged];
				for (var i=0; i < from.length; i++) {
					src.push(from[i].idd||from[i].id);
				}
				dhtmlx.DragControl._drag_context.source = src;
			}
			return master;
		};
		
	}
};


/* DHX DEPEND FROM FILE 'move.js'*/


/*
	Behavior:DataMove - allows to move and copy elements, heavily relays on DataStore.move
	@export
		copy
		move
*/
dhtmlx.DataMove={
	_init:function(){
		dhtmlx.assert(this.data, "DataMove :: Component doesn't have DataStore");
	},
	//creates a copy of the item
	copy:function(sid,tindex,tobj,tid){
		var data = this.get(sid);
		if (!data){
			dhtmlx.log("Warning","Incorrect ID in DataMove::copy");
			return;
		}
		
		//make data conversion between objects
		if (tobj){
			dhtmlx.assert(tobj.externalData,"DataMove :: External object doesn't support operation");	
			data = tobj.externalData(data);
		}
		tobj = tobj||this;
		//adds new element same as original
		return tobj.add(tobj.externalData(data,tid),tindex);
	},
	//move item to the new position
	move:function(sid,tindex,tobj,tid){
		//can process an arrya - it allows to use it from onDrag 
		if (sid instanceof Array){
			for (var i=0; i < sid.length; i++) {
				//increase index for each next item in the set, so order of insertion will be equal to order in the array
				var new_index = (tobj||this).indexById(this.move(sid[i], tindex, tobj, sid[i]));
				if (sid[i+1])
					tindex = new_index+(this.indexById(sid[i+1])<new_index?0:1);
				
			}
			return;
		}
		
		nid = sid; //id after moving
		if (tindex<0){
			dhtmlx.log("Info","DataMove::move - moving outside of bounds is ignored");
			return;
		}
		
		var data = this.get(sid);
		if (!data){
			dhtmlx.log("Warning","Incorrect ID in DataMove::move");
			return;
		}
		
		if (!tobj || tobj == this)
			this.data.move(this.indexById(sid),tindex);	//move inside the same object
		else {
			dhtmlx.assert(tobj.externalData, "DataMove :: External object doesn't support operation");
			//copy to the new object
			nid=tobj.add(tobj.externalData(data,tid),tindex);
			this.remove(sid);//delete in old object
		}
		return nid;	//return ID of item after moving
	},
	//move item on one position up
	moveUp:function(id,step){
		return this.move(id,this.indexById(id)-(step||1));
	},
	//move item on one position down
	moveDown:function(id,step){
		return this.moveUp(id, (step||1)*-1);
	},
	//move item to the first position
	moveTop:function(id){
		return this.move(id,0);
	},
	//move item to the last position
	moveBottom:function(id){
		return this.move(id,this.data.dataCount()-1);
	},
	/*
		this is a stub for future functionality
		currently it just makes a copy of data object, which is enough for current situation
	*/
	externalData:function(data,id){
		//FIXME - will not work for multi-level data
		var newdata = dhtmlx.extend({},data);
		newdata.id = id||dhtmlx.uid();
		
		newdata.$selected=newdata.$template=null;
		return newdata;
	}
};


/* DHX DEPEND FROM FILE 'dnd.js'*/


/*
	Behavior:DND - low-level dnd handling
	@export
		getContext
		addDrop
		addDrag
		
	DND master can define next handlers
		onCreateDrag
		onDragIng
		onDragOut
		onDrag
		onDrop
	all are optional
*/

/*DHX:Depend dhtmlx.js*/

dhtmlx.DragControl={
	//has of known dnd masters
	_drag_masters : dhtmlx.toArray(["dummy"]),
	/*
		register drop area
		@param node 			html node or ID
		@param ctrl 			options dnd master
		@param master_mode 		true if you have complex drag-area rules
	*/
	addDrop:function(node,ctrl,master_mode){
		node = dhtmlx.toNode(node);
		node.dhx_drop=this._getCtrl(ctrl);
		if (master_mode) node.dhx_master=true;
	},
	//return index of master in collection
	//it done in such way to prevent dnd master duplication
	//probably useless, used only by addDrop and addDrag methods
	_getCtrl:function(ctrl){
		ctrl = ctrl||dhtmlx.DragControl;
		var index = this._drag_masters.find(ctrl);
		if (index<0){
			index = this._drag_masters.length;
			this._drag_masters.push(ctrl);
		}
		return index;
	},
	/*
		register drag area
		@param node 	html node or ID
		@param ctrl 	options dnd master
	*/
	addDrag:function(node,ctrl){
	    node = dhtmlx.toNode(node);
	    node.dhx_drag=this._getCtrl(ctrl);
		dhtmlx.event(node,"mousedown",this._preStart,node);
	},
	//logic of drag - start, we are not creating drag immediately, instead of that we hears mouse moving
	_preStart:function(e){
		if (dhtmlx.DragControl._active){
			dhtmlx.DragControl._preStartFalse();
			dhtmlx.DragControl.destroyDrag();
		}
		dhtmlx.DragControl._active=this;
		dhtmlx.DragControl._start_pos={x:e.pageX, y:e.pageY};
		dhtmlx.DragControl._dhx_drag_mm = dhtmlx.event(document.body,"mousemove",dhtmlx.DragControl._startDrag);
		dhtmlx.DragControl._dhx_drag_mu = dhtmlx.event(document.body,"mouseup",dhtmlx.DragControl._preStartFalse);
		//http://code.google.com/p/chromium/issues/detail?id=14204
		dhtmlx.DragControl._dhx_drag_sc = dhtmlx.event(this,"scroll",dhtmlx.DragControl._preStartFalse);

		e.cancelBubble=true;
		return false;
	},
	//if mouse was released before moving - this is not a dnd, remove event handlers
	_preStartFalse:function(e){
		dhtmlx.DragControl._dhx_drag_mm = dhtmlx.eventRemove(dhtmlx.DragControl._dhx_drag_mm);
		dhtmlx.DragControl._dhx_drag_mu = dhtmlx.eventRemove(dhtmlx.DragControl._dhx_drag_mu);		
		dhtmlx.DragControl._dhx_drag_sc = dhtmlx.eventRemove(dhtmlx.DragControl._dhx_drag_sc);		
	},
	//mouse was moved without button released - dnd started, update event handlers
	_startDrag:function(e){
		//prevent unwanted dnd
		var pos = {x:e.pageX, y:e.pageY};
		if (Math.abs(pos.x-dhtmlx.DragControl._start_pos.x)<5 && Math.abs(pos.y-dhtmlx.DragControl._start_pos.y)<5)
			return;

		dhtmlx.DragControl._preStartFalse();
		if (!dhtmlx.DragControl.createDrag(e)) return;
		
		dhtmlx.DragControl.sendSignal("start"); //useless for now
		dhtmlx.DragControl._dhx_drag_mm = dhtmlx.event(document.body,"mousemove",dhtmlx.DragControl._moveDrag);
		dhtmlx.DragControl._dhx_drag_mu = dhtmlx.event(document.body,"mouseup",dhtmlx.DragControl._stopDrag);
		dhtmlx.DragControl._moveDrag(e);
	},
	//mouse was released while dnd is active - process target
	_stopDrag:function(e){
		dhtmlx.DragControl._dhx_drag_mm = dhtmlx.eventRemove(dhtmlx.DragControl._dhx_drag_mm);
		dhtmlx.DragControl._dhx_drag_mu = dhtmlx.eventRemove(dhtmlx.DragControl._dhx_drag_mu);
		if (dhtmlx.DragControl._last){	//if some drop target was confirmed
			dhtmlx.DragControl.onDrop(dhtmlx.DragControl._active,dhtmlx.DragControl._last,this._landing,e);
			dhtmlx.DragControl.onDragOut(dhtmlx.DragControl._active,dhtmlx.DragControl._last,null,e);
		}
		dhtmlx.DragControl.destroyDrag();
		dhtmlx.DragControl.sendSignal("stop");	//useless for now
	},
	//dnd is active and mouse position was changed
	_moveDrag:function(e){
		var pos = dhtmlx.html.pos(e);
		//adjust drag marker position
		dhtmlx.DragControl._html.style.top=pos.y+dhtmlx.DragControl.top +"px";
		dhtmlx.DragControl._html.style.left=pos.x+dhtmlx.DragControl.left+"px";
		
		if (dhtmlx.DragControl._skip)
			dhtmlx.DragControl._skip=false;
		else
			dhtmlx.DragControl._checkLand((e.srcElement||e.target),e);
		
		e.cancelBubble=true;
		return false;		
	},
	//check if item under mouse can be used as drop landing
	_checkLand:function(node,e){ 
		while (node && node.tagName!="BODY"){
			if (node.dhx_drop){	//if drop area registered
				if (this._last && (this._last!=node || node.dhx_master))	//if this area with complex dnd master
					this.onDragOut(this._active,this._last,node,e);			//inform master about possible mouse-out
				if (!this._last || this._last!=node || node.dhx_master){	//if this is new are or area with complex dnd master
				    this._last=null;										//inform master about possible mouse-in
					this._landing=this.onDragIn(dhtmlx.DragControl._active,node,e);
					if (this._landing)	//landing was rejected
						this._last=node;
					return;				
				} 
				return;
			}
			node=node.parentNode;
		}
		if (this._last)	//mouse was moved out of previous landing, and without finding new one 
			this._last = this._landing = this.onDragOut(this._active,this._last,null,e);
	},
	//mostly useless for now, can be used to add cross-frame dnd
	sendSignal:function(signal){
		dhtmlx.DragControl.active=(signal=="start");
	},
	
	//return master for html area
	getMaster:function(t){
		return this._drag_masters[t.dhx_drag||t.dhx_drop];
	},
	//return dhd-context object
	getContext:function(t){
		return this._drag_context;
	},
	//called when dnd is initiated, must create drag representation
	createDrag:function(e){ 
		var a=dhtmlx.DragControl._active;
		var master = this._drag_masters[a.dhx_drag];
		var drag_container;
		
		//if custom method is defined - use it
		if (master.onDragCreate){
			drag_container=master.onDragCreate(a,e);
			drag_container.style.position='absolute';
			drag_container.style.zIndex=dhtmlx.zIndex.drag;
			drag_container.onmousemove=dhtmlx.DragControl._skip_mark;
		} else {
		//overvise use default one
			var text = dhtmlx.DragControl.onDrag(a,e);
			if (!text) return false;
			var drag_container = document.createElement("DIV");
			drag_container.innerHTML=text;
			drag_container.className="dhx_drag_zone";
			drag_container.onmousemove=dhtmlx.DragControl._skip_mark;
			document.body.appendChild(drag_container);
		}
		dhtmlx.DragControl._html=drag_container;
		return true;
	},
	//helper, prevents unwanted mouse-out events
	_skip_mark:function(){
		dhtmlx.DragControl._skip=true;
	},
	//after dnd end, remove all traces and used html elements
	destroyDrag:function(){
		var a=dhtmlx.DragControl._active;
		var master = this._drag_masters[a.dhx_drag];
		
		if (master && master.onDragDestroy)
			master.onDragDestroy(a,dhtmlx.DragControl._html);
		else dhtmlx.html.remove(dhtmlx.DragControl._html);
		
		dhtmlx.DragControl._landing=dhtmlx.DragControl._active=dhtmlx.DragControl._last=dhtmlx.DragControl._html=null;
	},
	top:5,	 //relative position of drag marker to mouse cursor
	left:5,
	//called when mouse was moved in drop area
	onDragIn:function(s,t,e){
		var m=this._drag_masters[t.dhx_drop];
		if (m.onDragIn && m!=this) return m.onDragIn(s,t,e);
		t.className=t.className+" dhx_drop_zone";
		return t;
	},
	//called when mouse was moved out drop area
	onDragOut:function(s,t,n,e){
		var m=this._drag_masters[t.dhx_drop];
		if (m.onDragOut && m!=this) return m.onDragOut(s,t,n,e);
		t.className=t.className.replace("dhx_drop_zone","");
		return null;
	},
	//called when mouse was released over drop area
	onDrop:function(s,t,d,e){
		var m=this._drag_masters[t.dhx_drop];
		dhtmlx.DragControl._drag_context.from = dhtmlx.DragControl.getMaster(s);
		if (m.onDrop && m!=this) return m.onDrop(s,t,d,e);
		t.appendChild(s);
	},
	//called when dnd just started
	onDrag:function(s,e){
		var m=this._drag_masters[s.dhx_drag];
		if (m.onDrag && m!=this) return m.onDrag(s,e);
		dhtmlx.DragControl._drag_context = {source:s, from:s};
		return "<div style='"+s.style.cssText+"'>"+s.innerHTML+"</div>";
	}	
};


/* DHX DEPEND FROM FILE 'drag.js'*/


/*
	Behavior:DragItem - adds ability to move items by dnd
	
	dnd context can have next properties
		from - source object
		to - target object
		source - id of dragged item(s)
		target - id of drop target, null for drop on empty space
		start - id from which DND was started
*/

/*DHX:Depend dnd.js*/		/*DHX:Depend move.js*/		/*DHX:Depend compatibility_drag.js*/ 	
/*DHX:Depend dhtmlx.js*/



dhtmlx.DragItem={
	_init:function(){
		dhtmlx.assert(this.move,"DragItem :: Component doesn't have DataMove interface");
		dhtmlx.assert(this.locate,"DragItem :: Component doesn't have RenderStack interface");
		dhtmlx.assert(dhtmlx.DragControl,"DragItem :: DragControl is not included");
		
		if (!this._settings || this._settings.drag)
			dhtmlx.DragItem._initHandlers(this);
		else if (this._settings){
			//define setter, which may be triggered by config call
			this.drag_setter=function(value){
				if (value){
					this._initHandlers(this);
					delete this.drag_setter;	//prevent double initialization
				}
				return value;
			};
		}
		//if custom dnd marking logic is defined - attach extra handlers
		if (this.dragMarker){
			this.attachEvent("onBeforeDragIn",this.dragMarker);
			this.attachEvent("onDragOut",this.dragMarker);
		}
			
	},
	//helper - defines component's container as active zone for dragging and for dropping
	_initHandlers:function(obj){
		dhtmlx.DragControl.addDrop(obj._obj,obj,true);
		dhtmlx.DragControl.addDrag(obj._obj,obj);	
	},
	/*
		s - source html element
		t - target html element
		d - drop-on html element ( can be not equal to the target )
		e - native html event 
	*/
	//called when drag moved over possible target
	onDragIn:function(s,t,e){
		var id = this.locate(e) || null;
		var context = dhtmlx.DragControl._drag_context;
		var to = dhtmlx.DragControl.getMaster(s);
		//previous target
		var html = (this._locateHTML(id)||this._obj);
		//prevent double processing of same target
		if (html == dhtmlx.DragControl._landing) return html;
		context.target = id;
		context.to = to;
		
		if (!this.callEvent("onBeforeDragIn",[context,e])){
			context.id = null;
			return null;
		}
		
		dhtmlx.html.addCss(html,"dhx_drag_over"); //mark target
		return html;
	},
	//called when drag moved out from possible target
	onDragOut:function(s,t,n,e){ 
		var id = this.locate(e) || null;
        if (n != this._dataobj)
            id = null;
		//previous target
		var html = (this._locateHTML(id)||(n?dhtmlx.DragControl.getMaster(n)._obj:window.undefined));
		if (html == dhtmlx.DragControl._landing) return null;
		//unmark previous target
		var context = dhtmlx.DragControl._drag_context;
		dhtmlx.html.removeCss(dhtmlx.DragControl._landing,"dhx_drag_over");
		context.target = context.to = null;
		this.callEvent("onDragOut",[context,e]);
		return null;
	},
	//called when drag moved on target and button is released
	onDrop:function(s,t,d,e){ 
		var context = dhtmlx.DragControl._drag_context;
		
		//finalize context details
		context.to = this;
		context.index = context.target?this.indexById(context.target):this.dataCount();
		context.new_id = dhtmlx.uid();
		if (!this.callEvent("onBeforeDrop",[context,e])) return;
		//moving
		if (context.from==context.to){
			this.move(context.source,context.index);	//inside the same component
		} else {
			if (context.from)	//from different component
				context.from.move(context.source,context.index,context.to,context.new_id);
			else
				dhtmlx.error("Unsopported d-n-d combination");
		}
		this.callEvent("onAfterDrop",[context,e]);
	},
	//called when drag action started
	onDrag:function(s,e){
		var id = this.locate(e);
		var list = [id];
		if (id){
			if (this.getSelected){ //has selection model
				var selection = this.getSelected();	//if dragged item is one of selected - drag all selected
				if (dhtmlx.PowerArray.find.call(selection,id)!=-1)
					list = selection;
			}
			//save initial dnd params
			var context = dhtmlx.DragControl._drag_context= { source:list, start:id };
			context.from = this;
			
			if (this.callEvent("onBeforeDrag",[context,e]))
				return context.html||this._toHTML(this.get(id));	//set drag representation
		}
		return null;
	}
	//returns dnd context object
	/*getDragContext:function(){
		return dhtmlx.DragControl._drag_context;
	}*/
};


/* DHX DEPEND FROM FILE 'edit.js'*/


/*
	Behavior:EditAbility - enables item operation for the items
	
	@export
		edit
		stopEdit
*/
dhtmlx.EditAbility={
	_init: function(id){
		this._edit_id = null;		//id of active item 
		this._edit_bind = null;		//array of input-to-property bindings

		dhtmlx.assert(this.data,"EditAbility :: Component doesn't have DataStore");
		dhtmlx.assert(this._locateHTML,"EditAbility :: Component doesn't have RenderStack");
				
		this.attachEvent("onEditKeyPress",function(code, ctrl, shift){
			if (code == 13 && !shift)
				this.stopEdit();
			else if (code == 27) 
				this.stopEdit(true);
		});
		this.attachEvent("onBeforeRender", function(){
			this.stopEdit();
		});
    	
	},
	//returns id of item in edit state, or null if none
	isEdit:function(){
		return this._edit_id;
	},
	//switch item to the edit state
	edit:function(id){
		//edit operation can be blocked from editStop - when previously active editor can't be closed			
		if (this.stopEdit(false, id)){
			if (!this.callEvent("onBeforeEditStart",[id])) 
				return;			
			var data = this.data.get(id);			
			//object with custom templates is not editable
			if (data.$template) return;
			
			//item must have have "edit" template
 			data.$template="edit";	
			this.data.refresh(id);
			this._edit_id = id;
			
			//parse templates and save input-property mapping
			this._save_binding(id);
			this._edit_bind(true,data);	//fill inputs with data
			
			this.callEvent("onAfterEditStart",[id]);	
		}
	},
	//close currently active editor
	stopEdit:function(mode, if_not_id){
		if (!this._edit_id) return true;
		if (this._edit_id == if_not_id) return false;

		var values = {};
		if (!mode) this._edit_bind(false,values);
		else values = null;

		if (!this.callEvent("onBeforeEditStop",[this._edit_id, values]))
			return false;
			
		var data=this.data.get(this._edit_id);
		data.$template=null;	//set default template
		
		//load data from inputs
		//if mode is set - close editor without saving
		if (!mode) this._edit_bind(false,data);
		var id = this._edit_id;
		this._edit_bind=this._edit_id=null;
		
		this.data.refresh(id);
		
		this.callEvent("onAfterEditStop",[id, values]);
		return true;
	},
	//parse template and save inputs which need to be mapped to the properties
	_save_binding:function(id){
		var cont = this._locateHTML(id);
		var code = "";			//code of prop-to-inp method
		var back_code = "";		//code of inp-to-prop method
		var bind_elements = [];	//binded inputs
		if (cont){
			var elements = cont.getElementsByTagName("*");		//all sub-tags
			var bind = "";
			for (var i=0; i < elements.length; i++) {
				if(elements[i].nodeType==1 && (bind = elements[i].getAttribute("bind"))){	//if bind present
					//code for element accessing 
					code+="els["+bind_elements.length+"].value="+bind+";";
					back_code+=bind+"=els["+bind_elements.length+"].value;";
					bind_elements.push(elements[i]);
					//clear block-selection for the input
					elements[i].className+=" dhx_allow_selection";
					elements[i].onselectstart=this._block_native;
				}
			}
			elements = null;
		}
		//create accessing methods, for later usage
		code = Function("obj","els",code);
		back_code = Function("obj","els",back_code);
		this._edit_bind = function(mode,obj){
			if (mode){	//property to input
				code(obj,bind_elements);	
				if (bind_elements.length && bind_elements[0].select) //focust first html input, if possible
					bind_elements[0].select();						 
			}
			else 		//input to propery
				back_code(obj,bind_elements);
		};
	},
	//helper - blocks event bubbling, used to stop click event on editor level
	_block_native:function(e){ (e||event).cancelBubble=true; return true; }
};


/* DHX DEPEND FROM FILE 'selection.js'*/


/*
	Behavior:SelectionModel - manage selection states
	@export
		select
		unselect
		selectAll
		unselectAll
		isSelected
		getSelected
*/
dhtmlx.SelectionModel={
	_init:function(){
		//collection of selected IDs
		this._selected = dhtmlx.toArray();
		dhtmlx.assert(this.data, "SelectionModel :: Component doesn't have DataStore");
         	
		//remove selection from deleted items
		this.data.attachEvent("onStoreUpdated",dhtmlx.bind(this._data_updated,this));
		this.data.attachEvent("onStoreLoad", dhtmlx.bind(this._data_loaded,this));
		this.data.attachEvent("onAfterFilter", dhtmlx.bind(this._data_filtered,this));
		this.data.attachEvent("onIdChange", dhtmlx.bind(this._id_changed,this));
	},
	_id_changed:function(oldid, newid){
		for (var i = this._selected.length - 1; i >= 0; i--)
			if (this._selected[i]==oldid)
				this._selected[i]=newid;
	},
	_data_filtered:function(){
		for (var i = this._selected.length - 1; i >= 0; i--){
			if (this.data.indexById(this._selected[i]) < 0){
				var id = this._selected[i];
				var item = this.item(id);
				if (item)
					delete item.$selected;
				this._selected.splice(i,1);
				this.callEvent("onSelectChange",[id]);
			}
		}	
	},
	//helper - linked to onStoreUpdated
	_data_updated:function(id,obj,type){
		if (type == "delete")				//remove selection from deleted items
			this._selected.remove(id);
		else if (!this.data.dataCount() && !this.data._filter_order){	//remove selection for clearAll
			this._selected = dhtmlx.toArray();
		}
	},
	_data_loaded:function(){
		if (this._settings.select)
			this.data.each(function(obj){
				if (obj.$selected) this.select(obj.id);
			}, this);
	},
	//helper - changes state of selection for some item
	_select_mark:function(id,state,refresh){
		if (!refresh && !this.callEvent("onBeforeSelect",[id,state])) return false;
		
		this.data.item(id).$selected=state;	//set custom mark on item
		if (refresh)
			refresh.push(id);				//if we in the mass-select mode - collect all changed IDs
		else{
			if (state)
				this._selected.push(id);		//then add to list of selected items
		else
				this._selected.remove(id);
			this._refresh_selection(id);	//othervise trigger repainting
		}
			
		return true;
	},
	//select some item
	select:function(id,non_modal,continue_old){
		//if id not provide - works as selectAll
		if (!id) return this.selectAll();

		//allow an array of ids as parameter
		if (id instanceof Array){
			for (var i=0; i < id.length; i++)
				this.select(id[i], non_modal, continue_old);
			return;
		}

		if (!this.data.exists(id)){
			dhtmlx.error("Incorrect id in select command: "+id);
			return;
		}
		
		//block selection mode
		if (continue_old && this._selected.length)
			return this.selectAll(this._selected[this._selected.length-1],id);
		//single selection mode
		if (!non_modal && (this._selected.length!=1 || this._selected[0]!=id)){
			this._silent_selection = true; //prevent unnecessary onSelectChange event
			this.unselectAll();
			this._silent_selection = false;
		}
		if (this.isSelected(id)){
			if (non_modal) this.unselect(id);	//ctrl-selection of already selected item
			return;
		}
		
		if (this._select_mark(id,true)){	//if not blocked from event
			this.callEvent("onAfterSelect",[id]);
		}
	},
	//unselect some item
	unselect:function(id){
		//if id is not provided  - unselect all items
		if (!id) return this.unselectAll();
		if (!this.isSelected(id)) return;
		
		this._select_mark(id,false);
	},
	//select all items, or all in defined range
	selectAll:function(from,to){
		var range;
		var refresh=[];
		
		if (from||to)
			range = this.data.getRange(from||null,to||null);	//get limited set if bounds defined
		else
			range = this.data.getRange();			//get all items in other case
												//in case of paging - it will be current page only
		range.each(function(obj){ 
			var d = this.data.item(obj.id);
			if (!d.$selected){	
				this._selected.push(obj.id);	
				this._select_mark(obj.id,true,refresh);
			}
			return obj.id; 
		},this);
		//repaint self
		this._refresh_selection(refresh);
	},
	//remove selection from all items
	unselectAll:function(){
		var refresh=[];
		
		this._selected.each(function(id){
			this._select_mark(id,false,refresh);	//unmark selected only
		},this);
		
		this._selected=dhtmlx.toArray();
		this._refresh_selection(refresh);	//repaint self
	},
	//returns true if item is selected
	isSelected:function(id){
		return this._selected.find(id)!=-1;
	},
	/*
		returns ID of selected items or array of IDs
		to make result predictable - as_array can be used, 
			with such flag command will always return an array 
			empty array in case when no item was selected
	*/
	getSelected:function(as_array){	
		switch(this._selected.length){
			case 0: return as_array?[]:"";
			case 1: return as_array?[this._selected[0]]:this._selected[0];
			default: return ([].concat(this._selected)); //isolation
		}
	},
	//detects which repainting mode need to be used
	_is_mass_selection:function(obj){
		 // crappy heuristic, but will do the job
		return obj.length>100 || obj.length > this.data.dataCount/2;
	},
	_refresh_selection:function(refresh){
		if (typeof refresh != "object") refresh = [refresh];
		if (!refresh.length) return;	//nothing to repaint
		
		if (this._is_mass_selection(refresh))	
			this.data.refresh();	//many items was selected - repaint whole view
		else
			for (var i=0; i < refresh.length; i++)	//repaint only selected
				this.render(refresh[i],this.data.item(refresh[i]),"update");
			
		if (!this._silent_selection)	
		this.callEvent("onSelectChange",[refresh]);
	}
};




/* DHX DEPEND FROM FILE 'render.js'*/


/*
	Renders collection of items
	Behavior uses plain strategy which suits only for relative small datasets
	
	@export
		locate
		show
		render
*/
dhtmlx.RenderStack={
	_init:function(){
		dhtmlx.assert(this.data,"RenderStack :: Component doesn't have DataStore");
        dhtmlx.assert(dhtmlx.Template,"dhtmlx.Template :: dhtmlx.Template is not accessible");

		//used for temporary HTML elements
		//automatically nulified during destruction
		this._html = document.createElement("DIV");

	},
	//convert single item to HTML text (templating)
	_toHTML:function(obj){
			//check if related template exist
			dhtmlx.assert((!obj.$template || this.type["template_"+obj.$template]),"RenderStack :: Unknown template: "+obj.$template);
                        
			/*mm: fix allows to call the event for all objects (PropertySheet)*/	
			//if (obj.$template) //custom template
				this.callEvent("onItemRender",[obj]);
			/*
				$template property of item, can contain a name of custom template
			*/	
			return this.type._item_start(obj,this.type)+(obj.$template?this.type["template_"+obj.$template]:this.type.template)(obj,this.type)+this.type._item_end;
	},
	//convert item to HTML object (templating)
	_toHTMLObject:function(obj){
		this._html.innerHTML = this._toHTML(obj);
		return this._html.firstChild;
	},
	//return html container by its ID
	//can return undefined if container doesn't exists
	_locateHTML:function(search_id){
		if (this._htmlmap)
			return this._htmlmap[search_id];
			
		//fill map if it doesn't created yet
		this._htmlmap={};
		
		var t = this._dataobj.childNodes;
		for (var i=0; i < t.length; i++){
			var id = t[i].getAttribute(this._id); //get item's
			if (id) 
				this._htmlmap[id]=t[i];
		}
		//call locator again, when map is filled
		return this._locateHTML(search_id);
	},
	//return id of item from html event
	locate:function(e){ return dhtmlx.html.locate(e,this._id); },
	//change scrolling state of top level container, so related item will be in visible part
	show:function(id){
		var html = this._locateHTML(id);
		if (html)
			this._dataobj.scrollTop = html.offsetTop-this._dataobj.offsetTop;
	},
	//update view after data update
	//method calls low-level rendering for related items
	//when called without parameters - all view refreshed
	render:function(id,data,type,after){
		if (id){
			var cont = this._locateHTML(id); //get html element of updated item
			switch(type){
				case "update":
					//in case of update - replace existing html with updated one
					if (!cont) return;
					var t = this._htmlmap[id] = this._toHTMLObject(data);
					dhtmlx.html.insertBefore(t, cont); 
					dhtmlx.html.remove(cont);
					break;
				case "delete":
					//in case of delete - remove related html
					if (!cont) return;
					dhtmlx.html.remove(cont);
					delete this._htmlmap[id];
					break;
				case "add":
					//in case of add - put new html at necessary position
					var t = this._htmlmap[id] = this._toHTMLObject(data);
					dhtmlx.html.insertBefore(t, this._locateHTML(this.data.next(id)), this._dataobj);
					break;
				case "move":
					//in case of move , simulate add - delete sequence
					//it will affect only rendering 
					this.render(id,data,"delete");
					this.render(id,data,"add");
					break;
				default:
					dhtmlx.error("Unknown render command: "+type);
					break;
			}
		} else {
			//full reset
			if (this.callEvent("onBeforeRender",[this.data])){
				//getRange - returns all elements
				this._dataobj.innerHTML = this.data.getRange().map(this._toHTML,this).join("");
				this._htmlmap = null; //clear map, it will be filled at first _locateHTML
			}
		}
		this.callEvent("onAfterRender",[]);
	},
	//pager attachs handler to onBeforeRender, to limit visible set of data 
	//data.min and data.max affect result of data.getRange()
	pager_setter:function(value){ 
		this.attachEvent("onBeforeRender",function(){
			var s = this._settings.pager._settings;
			//initial value of pager = -1, waiting for real value
			if (s.page == -1) return false;	
			
			this.data.min = s.page*s.size;	//affect data.getRange
			this.data.max = (s.page+1)*s.size-1;
			return true;
		});
	
		var pager = new dhtmlx.ui.pager(value);
		//update functor
		var update = dhtmlx.bind(function(){
			this.data.refresh();
		},this);
		
		//when values of pager are changed - repaint view
		pager.attachEvent("onRefresh",update);
		//when something changed in DataStore - update configuration of pager
		//during refresh - pager can call onRefresh method which will cause repaint of view
		this.data.attachEvent("onStoreUpdated",function(data){
			var count = this.dataCount();
			if (count != pager._settings.count){
				pager._settings.count = count;
				//set first page
				//it is called first time after data loading
				//until this time pager is not rendered
				if (pager._settings.page == -1)
					pager._settings.page = 0;
					
				pager.refresh();
			}
		});
		return pager;
	},
	//can be used only to trigger auto-height
	height_setter:function(value){
		if (value=="auto"){
			//react on resize of window and self-repainting
			this.attachEvent("onAfterRender",this._correct_height);
			dhtmlx.event(window,"resize",dhtmlx.bind(this._correct_height,this));
		}
		return value;
	},
	//update height of container to remove inner scrolls
	_correct_height:function(){
		//disable scrolls - if we are using auto-height , they are not necessary
		this._dataobj.style.overflow="hidden";
		//set min. size, so we can fetch real scroll height
		this._dataobj.style.height = "1px";
		
		var t = this._dataobj.scrollHeight;
		this._dataobj.style.height = t+"px";
		// FF has strange issue with height caculation 
		// it incorrectly detects scroll height when only small part of item is invisible
		if (dhtmlx._isFF){ 
			var t2 = this._dataobj.scrollHeight;
			if (t2!=t)
				this._dataobj.style.height = t2+"px";
		}
		this._obj.style.height = this._dataobj.style.height;
	},
	//get size of single item
	_getDimension:function(){
		var t = this.type;
		var d = (t.border||0)+(t.padding||0)*2+(t.margin||0)*2;
		//obj.x  - widht, obj.y - height
		return {x : t.width+d, y: t.height+d };
	},
	//x_count propery sets width of container, so N items can be placed on single line
	x_count_setter:function(value){
		var dim = this._getDimension();
		var scrfix = dhtmlx.$customScroll ? 0 : 18;
		this._dataobj.style.width = dim.x*value+(this._settings.height != "auto" ? scrfix : 0)+"px";
		return value;
	},
	//x_count propery sets height of container, so N items a visible in one column
	//column will have scroll if real count of lines is greater than N
	y_count_setter:function(value){
		var dim = this._getDimension();
		this._dataobj.style.height = dim.y*value+"px";
		return value;
	}
};


/* DHX DEPEND FROM FILE 'virtual_render.js'*/


/*
	Renders collection of items
	Always shows y-scroll
	Can be used with huge datasets
	
	@export
		show
		render
*/

/*DHX:Depend render.js*/ 

dhtmlx.VirtualRenderStack={
	_init:function(){
		dhtmlx.assert(this.render,"VirtualRenderStack :: Object must use RenderStack first");
        	
        this._htmlmap={}; //init map of rendered elements
        //in this mode y-scroll is always visible
        //it simplifies calculations a lot
        this._dataobj.style.overflowY="scroll";
        
        //we need to repaint area each time when view resized or scrolling state is changed
        dhtmlx.event(this._dataobj,"scroll",dhtmlx.bind(this._render_visible_rows,this));
        dhtmlx.event(window,"resize",dhtmlx.bind(function(){ this.render(); },this));

		//here we store IDs of elemenst which doesn't loadede yet, but need to be rendered
		this.data._unrendered_area=[];
		this.data.getIndexRange=this._getIndexRange;
	},
	//return html object by item's ID. Can return null for not-rendering element
	_locateHTML:function(search_id){
		//collection was filled in _render_visible_rows
		return this._htmlmap[search_id];
	},
	//adjust scrolls to make item visible
	show:function(id){
		range = this._getVisibleRange();
		var ind = this.data.indexById(id);
		//we can't use DOM method for not-rendered-yet items, so fallback to pure math
		var dy = Math.floor(ind/range._dx)*range._y;
		this._dataobj.scrollTop = dy;
	},	
	_getIndexRange:function(from,to){
		if (to !== 0)
			to=Math.min((to||Infinity),this.dataCount()-1);
		
		var ret=dhtmlx.toArray(); //result of method is rich-array
		for (var i=(from||0); i <= to; i++){
			var item = this.item(this.order[i]);
			if(this.order.length>i){
                if (!item){
                    this.order[i]=dhtmlx.uid();
                    item = { id:this.order[i], $template:"loading" };
                    this._unrendered_area.push(this.order[i]);	//store item ID for later loading
                } else if (item.$template == "loading")
                    this._unrendered_area.push(this.order[i]);
                ret.push(item);
            }

		}
		return ret;
	},	
	//repain self after changes in DOM
	//for add, delete, move operations - render is delayed, to minify performance impact
	render:function(id,data,type,after){ 
		if (id){
			var cont = this._locateHTML(id);	//old html element
			switch(type){
				case "update":
					if (!cont) return;
					//replace old with new
					var t = this._htmlmap[id] = this._toHTMLObject(data);
					dhtmlx.html.insertBefore(t, cont); 
					dhtmlx.html.remove(cont);
					break;
				default: // "move", "add", "delete"
					/*
						for all above operations, full repainting is necessary
						but from practical point of view, we need only one repainting per thread
						code below initiates double-thread-rendering trick
					*/
					this._render_delayed();
					break;
			}
		} else {
			//full repainting
			if (this.callEvent("onBeforeRender",[this.data])){
				this._htmlmap = {}; 					//nulify links to already rendered elements
				this._render_visible_rows(null, true);	
				// clear delayed-rendering, because we already have repaint view
				this._wait_for_render = false;			
				this.callEvent("onAfterRender",[]);
			}
		}
	},
	//implement double-thread-rendering pattern
	_render_delayed:function(){
		//this flag can be reset from outside, to prevent actual rendering 
		if (this._wait_for_render) return;
		this._wait_for_render = true;	
		
		window.setTimeout(dhtmlx.bind(function(){
			this.render();
		},this),1);
	},
	//create empty placeholders, which will take space before rendering
	_create_placeholder:function(height){
		var node = document.createElement("DIV");
			node.className = "dhxdataview_placeholder";
			node.style.cssText = "height:"+height+"px; width:100%; overflow:hidden;";
		return node;
	},
	/*
		Methods get coordinatest of visible area and checks that all related items are rendered
		If, during rendering, some not-loaded items was detected - extra data loading is initiated.
		reset - flag, which forces clearing of previously rendered elements
	*/
	_render_visible_rows:function(e,reset){
		this.data._unrendered_area=[]; //clear results of previous calls
		
		var viewport = this._getVisibleRange();	//details of visible view
		if (!this._dataobj.firstChild || reset){	//create initial placeholder - for all view space
			this._dataobj.innerHTML="";
			this._dataobj.appendChild(this._create_placeholder(viewport._max));
			//register placeholder in collection
			this._htmlrows = [this._dataobj.firstChild];
		}
		
		/*
			virtual rendering breaks all view on rows, because we know widht of item
			we can calculate how much items can be placed on single row, and knowledge 
			of that, allows to calculate count of such rows
			
			each time after scrolling, code iterate through visible rows and render items 
			in them, if they are not rendered yet
			
			both rendered rows and placeholders are registered in _htmlrows collection
		*/

		//position of first visible row
		var t = Math.max(viewport._from, 0);
		//max can be 0, in case of 1 row per page
		var max_row = (this.data.max || this.data.max === 0)?this.data.max:Infinity;
		
		while(t<=viewport._height){	//loop for all visible rows
			//skip already rendered rows
			while(this._htmlrows[t] && this._htmlrows[t]._filled && t<=viewport._height){
				t++; 
			}
			//go out if all is rendered
			if (t>viewport._height) break;
			
			//locate nearest placeholder
			var holder = t;
			while (!this._htmlrows[holder]) holder--;
			var holder_row = this._htmlrows[holder];
			
			//render elements in the row			
			var base = t*viewport._dx+(this.data.min||0);	//index of rendered item
			if (base > max_row) break;	//check that row is in virtual bounds, defined by paging
			var nextpoint =  Math.min(base+viewport._dx-1,max_row);
			var node = this._create_placeholder(viewport._y);
			//all items in rendered row
			var range = this.data.getIndexRange(base, nextpoint);
			if (!range.length) break; 
			
			node.innerHTML=range.map(this._toHTML,this).join(""); 	//actual rendering
			for (var i=0; i < range.length; i++)					//register all new elements for later usage in _locateHTML
				this._htmlmap[this.data.idByIndex(base+i)]=node.childNodes[i];
			
			//correct placeholders
			var h = parseInt(holder_row.style.height,10);
			var delta = (t-holder)*viewport._y;
			var delta2 = (h-delta-viewport._y);
			
			//add new row to the DOOM
			dhtmlx.html.insertBefore(node,delta?holder_row.nextSibling:holder_row,this._dataobj);
			this._htmlrows[t]=node;
			node._filled = true;
			
			/*
				if new row is at start of placeholder - decrease placeholder's height
				else if new row takes whole placeholder - remove placeholder from DOM
				else 
					we are inserting row in the middle of existing placeholder
					decrease height of existing one, and add one more, 
					before the newly added row
			*/
			if (delta <= 0 && delta2>0){
				holder_row.style.height = delta2+"px";
				this._htmlrows[t+1] = holder_row;
			} else {
				if (delta<0)
					dhtmlx.html.remove(holder_row);
				else
					holder_row.style.height = delta+"px";
				if (delta2>0){ 
					var new_space = this._htmlrows[t+1] = this._create_placeholder(delta2);
					dhtmlx.html.insertBefore(new_space,node.nextSibling,this._dataobj);
				}
			}
			
			
			t++;
		}
		//when all done, check for non-loaded items
		if (this.data._unrendered_area.length){
			//we have some data to load
			//detect borders
			var from = this.indexById(this.data._unrendered_area[0]);
			var to = this.indexById(this.data._unrendered_area.pop())+1;
			if (to>from){
				//initiate data loading
				if (!this.callEvent("onDataRequest",[from, to-from])) return false;
				dhtmlx.assert(this.data.feed,"Data feed is missed");
				this.data.feed.call(this,from,to-from);
			}
		}
		if (dhtmlx._isIE){
				var viewport2 = this._getVisibleRange();
				if (viewport2._from != viewport._from)
					this._render_visible_rows();
		}
	},
	//calculates visible view
	_getVisibleRange:function(){
		var scrfix = dhtmlx.$customScroll ? 0 : 18;
		var top = this._dataobj.scrollTop;
		var width = this._dataobj.scrollWidth; 	// opera returns zero scrollwidth for the empty object
		var height = this._dataobj.offsetHeight;									// 18 - scroll
		//size of single item
		var t = this.type;
		var dim = this._getDimension();

		var dx = Math.floor(width/dim.x)||1; //at least single item per row
		
		var min = Math.floor(top/dim.y);				//index of first visible row
		var dy = Math.ceil((height+top)/dim.y)-1;		//index of last visible row
		//total count of items, paging can affect this math
		var count = this.data.max?(this.data.max-this.data.min):this.data.dataCount();
		var max = Math.ceil(count/dx)*dim.y;			//size of view in rows
		
		return { _from:min, _height:dy, _top:top, _max:max, _y:dim.y, _dx:dx};
	}
};



/* DHX INITIAL FILE 'C:\http\legacy/dhtmlxCore/sources//dataview.js'*/


/*
	UI:DataView
*/

/*DHX:Depend dataview.css*/
/*DHX:Depend types*/
/*DHX:Depend ../imgs/dataview*/

/*DHX:Depend compatibility_layout.js*/
/*DHX:Depend compatibility_drag.js*/

/*DHX:Depend datastore.js*/
/*DHX:Depend load.js*/ 		/*DHX:Depend virtual_render.js*/ 		/*DHX:Depend selection.js*/
/*DHX:Depend mouse.js*/ 	/*DHX:Depend key.js*/ 					/*DHX:Depend edit.js*/ 
/*DHX:Depend drag.js*/		/*DHX:Depend dataprocessor_hook.js*/ 	/*DHX:Depend autotooltip.js*/ 
/*DHX:Depend pager.js*/		/*DHX:Depend destructor.js*/			/*DHX:Depend dhtmlx.js*/
/*DHX:Depend config.js*/




//container - can be a HTML container or it's ID
dhtmlXDataView = function(container){
	//next data is only for debug purposes
	this.name = "DataView";	//name of component
	
	if (dhtmlx.assert_enabled()) this._assert();

	//enable configuration
	dhtmlx.extend(this, dhtmlx.Settings);
	this._parseContainer(container,"dhx_dataview");	//assigns parent container
	
	
	
	//behaviors
	dhtmlx.extend(this, dhtmlx.AtomDataLoader);
	dhtmlx.extend(this, dhtmlx.DataLoader);	//includes creation of DataStore
	dhtmlx.extend(this, dhtmlx.EventSystem);
	dhtmlx.extend(this, dhtmlx.RenderStack);
	dhtmlx.extend(this, dhtmlx.SelectionModel);
	dhtmlx.extend(this, dhtmlx.MouseEvents);
	dhtmlx.extend(this, dhtmlx.KeyEvents);
	dhtmlx.extend(this, dhtmlx.EditAbility);
	dhtmlx.extend(this, dhtmlx.DataMove);
	dhtmlx.extend(this, dhtmlx.DragItem);
	dhtmlx.extend(this, dhtmlx.DataProcessor);
	dhtmlx.extend(this, dhtmlx.AutoTooltip);
	dhtmlx.extend(this, dhtmlx.Destruction);
	
	
	//render self , each time when data is updated
	this.data.attachEvent("onStoreUpdated",dhtmlx.bind(function(){
		this.render.apply(this,arguments);
	},this));

	//default settings
	this._parseSettings(container,{
		drag:false,
		edit:false,
		select:"multiselect", //multiselection is enabled by default
		type:"default"
	});
	
	//in case of auto-height we use plain rendering
	if (this._settings.height!="auto"&&!this._settings.renderAll)
		dhtmlx.extend(this, dhtmlx.VirtualRenderStack);	//extends RenderStack behavior
	
	//map API of DataStore on self
	this.data.provideApi(this,true);

	if (this.config.autowidth){
		this.attachEvent("onBeforeRender", function(){
			this.type.width = Math.floor((this._dataobj.scrollWidth) / (this.config.autowidth*1 || 1))-this.type.padding*2 - this.type.margin*2 - this.type.border*2;
			this.type._item_start = dhtmlx.Template.fromHTML(this.template_item_start(this.type));
			this.type._item_end = this.template_item_end(this.type);
		});
		dhtmlx.event(window, "resize", function(){
			this.refresh();
		}, this)
	}

	if (dhtmlx.$customScroll)
		dhtmlx.CustomScroll.enable(this);
};
dhtmlXDataView.prototype={
	bind:function(){
		dhtmlx.BaseBind.legacyBind.apply(this, arguments);
	},
	sync:function(){
		dhtmlx.BaseBind.legacySync.apply(this, arguments);
	},
	/*
		Called each time when dragIn or dragOut situation occurs
		context - drag context object
		ev - native event
	*/
	dragMarker:function(context,ev){
		//get HTML element by item ID
		//can be null - when item is not rendered yet
		var el = this._locateHTML(context.target);
		
		//ficon and some other types share common bg marker
		if (this.type.drag_marker){
			if (this._drag_marker){
				//clear old drag marker position
				this._drag_marker.style.backgroundImage="";
				this._drag_marker.style.backgroundRepeat="";
			}
			
			// if item already rendered
			if (el) {
				//show drag marker
				el.style.backgroundImage="url("+(dhtmlx.image_path||"")+this.type.drag_marker+")";
				el.style.backgroundRepeat="no-repeat";
				this._drag_marker = el;
			}
		}
		
		//auto-scroll during d-n-d, only if related option is enabled
		if (el && this._settings.auto_scroll){
			//maybe it can be moved to the drag behavior
			var dy = el.offsetTop;
			var dh = el.offsetHeight;
			var py = this._obj.scrollTop;
			var ph = this._obj.offsetHeight;
			//scroll up or down is mouse already pointing on top|bottom visible item
			if (dy-dh >= 0 && dy-dh*0.75 < py)
				py = Math.max(dy-dh, 0);
			else if (dy+dh/0.75 > py+ph)
				py = py+dh;
			
			this._obj.scrollTop = py;
		}
		return true;
	},
	//attribute , which will be used for ID storing
	_id:"dhx_f_id",
	//css class to action map, for onclick event
	on_click:{
		dhx_dataview_item:function(e,id){ 
			//click on item
			if (this.stopEdit(false,id)){
				if (this._settings.select){
					if (this._settings.select=="multiselect")
						this.select(id, e.ctrlKey, e.shiftKey); 	//multiselection
					else
						this.select(id);
				}
			}
		}	
	},
	//css class to action map, for dblclick event
	on_dblclick:{
		dhx_dataview_item:function(e,id){ 
			//dblclick on item
			if (this._settings.edit)
				this.edit(id);	//edit it!
		}
	},
	//css class to action map, for mousemove event
	on_mouse_move:{
	},
	types:{
		"default":{
			css:"default",
			//normal state of item
			template:dhtmlx.Template.fromHTML("<div style='padding:10px; white-space:nowrap; overflow:hidden;'>{obj.text}</div>"),
			//template for edit state of item
			template_edit:dhtmlx.Template.fromHTML("<div style='padding:10px; white-space:nowrap; overflow:hidden;'><textarea style='width:100%; height:100%;' bind='obj.text'></textarea></div>"),
			//in case of dyn. loading - temporary spacer
			template_loading:dhtmlx.Template.fromHTML("<div style='padding:10px; white-space:nowrap; overflow:hidden;'>Loading...</div>"),
			width:210,
			height:115,
			margin:0,
			padding:10,
			border:1
		}
	},
	template_item_start:dhtmlx.Template.fromHTML("<div dhx_f_id='{-obj.id}' class='dhx_dataview_item dhx_dataview_{obj.css}_item{-obj.$selected?_selected:}' style='width:{obj.width}px; height:{obj.height}px; padding:{obj.padding}px; margin:{obj.margin}px; float:left; overflow:hidden;'>"),
	template_item_end:dhtmlx.Template.fromHTML("</div>")
};

dhtmlx.compat("layout");
if (typeof(window.dhtmlXCellObject) != "undefined") {
	
	dhtmlXCellObject.prototype.attachDataView = function(conf) {
		
		this.callEvent("_onBeforeContentAttach",["dataview"]);
		
		var obj = document.createElement("DIV");
		obj.style.width = "100%";
		obj.style.height = "100%";
		obj.style.position = "relative";
		obj.style.overflow = "hidden";
		this._attachObject(obj);
		
		if (typeof(conf) == "undefined") conf = {};
		obj.id = "DataViewObject_"+new Date().getTime();
		conf.container = obj.id;
		conf.skin = this.conf.skin;
		
		
		this.dataType = "dataview";
		this.dataObj = new dhtmlXDataView(conf);
		
		
		this.dataObj.setSizes = function(){
			this.render();
		}
		
		obj = null;
		
		this.callEvent("_onContentAttach",[]);
		
		return this.dataObj;
	};
	
}


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

//container - can be a HTML container or it's ID
dhtmlXList = function(container){
	this.name = "List";	//name of component
	
	//enable configuration
	dhtmlx.extend(this, dhtmlx.Settings);
	this._parseContainer(container,"dhx_list");	//assigns parent container
	
	
	
	//behaviors
	dhtmlx.extend(this, dhtmlx.AtomDataLoader);
	dhtmlx.extend(this, dhtmlx.DataLoader);
	dhtmlx.extend(this, dhtmlx.EventSystem);
	dhtmlx.extend(this, dhtmlx.RenderStack);
	dhtmlx.extend(this, dhtmlx.SelectionModel);
	dhtmlx.extend(this, dhtmlx.MouseEvents);
	dhtmlx.extend(this, dhtmlx.KeyEvents);
	dhtmlx.extend(this, dhtmlx.EditAbility);
	dhtmlx.extend(this, dhtmlx.DataMove);
	dhtmlx.extend(this, dhtmlx.DragItem);
	dhtmlx.extend(this, dhtmlx.DataProcessor);
	dhtmlx.extend(this, dhtmlx.AutoTooltip);
	dhtmlx.extend(this, dhtmlx.Destruction);
	
	this._getDimension = function(){
		var t = this.type;
		var d = (t.margin||0)*2;
		//obj.x  - widht, obj.y - height
		return {x : t.width+d, y: t.height+d };
	};
	
	//render self , each time when data is updated
	this.data.attachEvent("onStoreUpdated",dhtmlx.bind(function(){
		this.render.apply(this,arguments);
	},this));

	//default settings
	this._parseSettings(container,{
		drag:false,
		edit:false,
		select:"multiselect", //multiselection is enabled by default
		type:"default"
	});
	
	this.data.provideApi(this,true);

	if (dhtmlx.$customScroll)
		dhtmlx.CustomScroll.enable(this);
};


dhtmlXList.prototype={
	bind:function(){
		dhtmlx.BaseBind.legacyBind.apply(this, arguments);
	},
	sync:function(){
		dhtmlx.BaseBind.legacySync.apply(this, arguments);
	},	
	dragMarker:function(context,ev){
		var el = this._locateHTML(context.target);
		
		if (el && this._settings.auto_scroll){
			//maybe it can be moved to the drag behavior
			var dy = el.offsetTop;
			var dh = el.offsetHeight;
			var py = this._obj.scrollTop;
			var ph = this._obj.offsetHeight;
			//scroll up or down is mouse already pointing on top|bottom visible item
			if (dy-dh >= 0 && dy-dh*0.75 < py)
				py = Math.max(dy-dh, 0);
			else if (dy+dh/0.75 > py+ph)
				py = py+dh;
			
			this._obj.scrollTop = py;
		}
		return true;
	},
	//attribute , which will be used for ID storing
	_id:"dhx_f_id",
	//css class to action map, for onclick event
	on_click:{
		dhx_list_item:function(e,id){ 
			//click on item
			if (this.stopEdit(false,id)){
				if (this._settings.select){
					if (this._settings.select=="multiselect")
						this.select(id, e.ctrlKey, e.shiftKey); 	//multiselection
					else
						this.select(id);
				}
			}
		}	
	},
	//css class to action map, for dblclick event
	on_dblclick:{
		dhx_list_item:function(e,id){ 
			//dblclick on item
			if (this._settings.edit)
				this.edit(id);	//edit it!
		}
	},
	//css class to action map, for mousemove event
	on_mouse_move:{
	},
	types:{
		"default":{
			css:"default",
			//normal state of item
			template:dhtmlx.Template.fromHTML("<div style='padding:10px; white-space:nowrap; overflow:hidden;'>{obj.text}</div>"),
			//template for edit state of item
			template_edit:dhtmlx.Template.fromHTML("<div style='padding:10px; white-space:nowrap; overflow:hidden;'><textarea bind='obj.text'></textarea></div>"),
			//in case of dyn. loading - temporary spacer
			template_loading:dhtmlx.Template.fromHTML("<div style='padding:10px; white-space:nowrap; overflow:hidden;'>Loading...</div>"),
			height:50,
			margin:0,
			padding:10,
			border:1
		}
	},
	template_item_start:dhtmlx.Template.fromHTML("<div dhx_f_id='{-obj.id}' class='dhx_list_item dhx_list_{obj.css}_item{-obj.$selected?_selected:}' style='width:100%; height:{obj.height}px; padding:{obj.padding}px; margin:{obj.margin}px; overflow:hidden;'>"),
	template_item_end:dhtmlx.Template.fromHTML("</div>")
};

dhtmlx.compat("layout");
if (typeof(window.dhtmlXCellObject) != "undefined") {
	
	dhtmlXCellObject.prototype.attachList = function(conf) {
		
		this.callEvent("_onBeforeContentAttach",["list"]);
		
		var obj = document.createElement("DIV");
		obj.style.width = "100%";
		obj.style.height = "100%";
		obj.style.position = "relative";
		obj.style.overflowX = "hidden";
		this._attachObject(obj);
		
		if (typeof(conf) == "undefined") conf = {};
		obj.id = "ListObject_"+new Date().getTime();
		conf.container = obj.id;
		conf.skin = this.conf.skin;
		
		
		this.dataType = "list";
		this.dataObj = new dhtmlXList(conf);
		
		
		this.dataObj.setSizes = function(){
			this.render();
		}
		
		obj = null;
		
		this.callEvent("_onContentAttach",[]);
		
		return this.dataObj;
	};
	
}


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*_TOPICS_
@0:Initialization
@1:Selection control
@2:Add/delete
@3:Private
@4:Node/level control
@5:Checkboxes/user data manipulation
@6:Appearence control
@7: Handlers
*/

function xmlPointer(data){
	this.d=data;
}
xmlPointer.prototype={
	text:function(){ if (!_isFF) return this.d.xml; var x = new XMLSerializer();   return x.serializeToString(this.d); },
	get:function(name){return this.d.getAttribute(name); },
	exists:function(){return !!this.d },
	content:function(){return this.d.firstChild?(this.d.firstChild.wholeText||this.d.firstChild.data):""; }, // <4k in FF
	each:function(name,f,t,i){  var a=this.d.childNodes; var c=new xmlPointer(); if (a.length) for (i=i||0; i<a.length; i++) if (a[i].tagName==name) { c.d=a[i]; if(f.apply(t,[c,i])==-1) return; } },
	get_all:function(){ var a={}; var b=this.d.attributes; for (var i=0; i<b.length; i++) a[b[i].name]=b[i].value; return a; },
	sub:function(name){ var a=this.d.childNodes; var c=new xmlPointer(); if (a.length) for (var i=0; i<a.length; i++) if (a[i].tagName==name) { c.d=a[i]; return c; } },
	up:function(name){ return new xmlPointer(this.d.parentNode);  },
	set:function(name,val){ this.d.setAttribute(name,val);  },
	clone:function(name){ return new xmlPointer(this.d); },
	sub_exists:function(name){ var a=this.d.childNodes; if (a.length) for (var i=0; i<a.length; i++) if (a[i].tagName==name) return true;  return false;  },
	through:function(name,rule,v,f,t){  var a=this.d.childNodes; if (a.length) for (var i=0; i<a.length; i++) { if (a[i].tagName==name && a[i].getAttribute(rule)!=null && a[i].getAttribute(rule)!="" &&  (!v || a[i].getAttribute(rule)==v )) { var c=new xmlPointer(a[i]);  f.apply(t,[c,i]); } var w=this.d; this.d=a[i]; this.through(name,rule,v,f,t); this.d=w;  } }
}



/**
*     @desc: tree constructor
*     @param: htmlObject - parent html object or id of parent html object
*     @param: width - tree width
*     @param: height - tree height
*     @param: rootId - id of virtual root node (same as tree node id attribute in xml)
*     @type: public
*     @topic: 0
*/
function dhtmlXTreeObject(htmlObject, width, height, rootId){
  if (dhtmlxEvent.initTouch)
    dhtmlxEvent.initTouch();

	if (_isIE) try { document.execCommand("BackgroundImageCache", false, true); } catch (e){}
	if (typeof(htmlObject)!="object")
      this.parentObject=document.getElementById(htmlObject);
	else
      this.parentObject=htmlObject;

	this.parentObject.style.overflow="hidden";
   	this._itim_dg=true;
    this.dlmtr=",";
    this.dropLower=false;
	  this.enableIEImageFix(true);

   this.xmlstate=0;
   this.mytype="tree";
   this.smcheck=true;   //smart checkboxes
   this.width=width;
   this.height=height;
   this.rootId=rootId;
   this.childCalc=null;
      this.def_img_x="18px";
      this.def_img_y="18px";
      this.def_line_img_x="18px";
      this.def_line_img_y="24px";

    this._dragged=new Array();
   this._selected=new Array();

   this.style_pointer="pointer";
   
   this._aimgs=true;
   this.htmlcA=" [";
   this.htmlcB="]";
   this.lWin=window;
   this.cMenu=0;
   this.mlitems=0;
   this.iconURL="";
   this.dadmode=0;
   this.slowParse=false;
   this.autoScroll=true;
   this.hfMode=0;
   this.nodeCut=new Array();
   this.XMLsource=0;
   this.XMLloadingWarning=0;
   this._idpull={};
   this._pullSize=0;
   this.treeLinesOn=true;
   this.tscheck=false;
   this.timgen=true;
   this.dpcpy=false;
   this._ld_id=null;
   this._dynDeleteBranches={};
	this._oie_onXLE=[];
   this.imPath=window.dhx_globalImgPath||""; 
   this.checkArray=new Array("iconUncheckAll.gif","iconCheckAll.gif","iconCheckGray.gif","iconUncheckDis.gif","iconCheckDis.gif","iconCheckDis.gif");
   this.radioArray=new Array("radio_off.gif","radio_on.gif","radio_on.gif","radio_off.gif","radio_on.gif","radio_on.gif");

   this.lineArray=new Array("line2.gif","line3.gif","line4.gif","blank.gif","blank.gif","line1.gif");
   this.minusArray=new Array("minus2.gif","minus3.gif","minus4.gif","minus.gif","minus5.gif");
   this.plusArray=new Array("plus2.gif","plus3.gif","plus4.gif","plus.gif","plus5.gif");
   this.imageArray=new Array("leaf.gif","folderOpen.gif","folderClosed.gif");
   this.cutImg= new Array(0,0,0);
   this.cutImage="but_cut.gif";
   
   dhx4._eventable(this);

   this.dragger= new dhtmlDragAndDropObject();
//create root
   this.htmlNode=new dhtmlXTreeItemObject(this.rootId,"",0,this);
   this.htmlNode.htmlNode.childNodes[0].childNodes[0].style.display="none";
   this.htmlNode.htmlNode.childNodes[0].childNodes[0].childNodes[0].className="hiddenRow";
//init tree structures
   this.allTree=this._createSelf();
   this.allTree.appendChild(this.htmlNode.htmlNode);

   if (dhtmlx.$customScroll)
      dhtmlx.CustomScroll.enable(this);

    if(_isFF){
         this.allTree.childNodes[0].width="100%";
         this.allTree.childNodes[0].style.overflow="hidden";
    }

   var self=this;
   this.allTree.onselectstart=new Function("return false;");
   if (_isMacOS)
		this.allTree.oncontextmenu = function(e){ 
			return self._doContClick(e||window.event, true); 
		};   
   this.allTree.onmousedown = function(e){ return self._doContClick(e||window.event); };  
   
   this.XMLLoader=this._parseXMLTree;
   if (_isIE) this.preventIECashing(true);

//#__pro_feature:01112006{
//#complex_move:01112006{
   this.selectionBar=document.createElement("DIV");
   this.selectionBar.className="selectionBar";
   this.selectionBar.innerHTML="&nbsp;";
   this.selectionBar.style.display="none";
   this.allTree.appendChild(this.selectionBar);
//#}
//#}

    
    if (window.addEventListener) window.addEventListener("unload",function(){try{  self.destructor(); } catch(e){}},false);
    if (window.attachEvent) window.attachEvent("onunload",function(){ try{ self.destructor(); } catch(e){}});

	this.setImagesPath=this.setImagePath;
	this.setIconsPath=this.setIconPath;

	this.setSkin(window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxtree")||"material");
	if (dhtmlx.image_path) {
		var path = dhtmlx.image_path;
		var sk = this.parentObject.className.match(/dhxtree_dhx_([a-z_]*)/i);
		if (sk != null && sk[1] != null) path += "dhxtree_"+sk[1]+"/";
		this.setImagePath(path);
	}

   return this;
};


/**
*     @desc: set default data transfer mode 
*     @param: mode - data mode (json,xml,csv)
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.setDataMode=function(mode){
		this._datamode=mode;
}


	
dhtmlXTreeObject.prototype._doContClick=function(ev, force){
	if (!force && ev.button!=2) {
		if(this._acMenu){
			if (this._acMenu.hideContextMenu)
				this._acMenu.hideContextMenu()
			else
				this.cMenu._contextEnd();
		}
		return true;
	}
	
 	

	
	var el=(_isIE?ev.srcElement:ev.target);
	while ((el)&&(el.tagName!="BODY")) {
		if (el.parentObject) break;
    	 el=el.parentNode;
	 }
    	
    if ((!el)||(!el.parentObject)) return true;
    
    var obj=el.parentObject;
    
    if (!this.callEvent("onRightClick",[obj.id,ev]))
        (ev.srcElement||ev.target).oncontextmenu = function(e){ (e||event).cancelBubble=true; return false; };
        
    	this._acMenu=(obj.cMenu||this.cMenu);
        if (this._acMenu){
       		if (!(this.callEvent("onBeforeContextMenu", [
					obj.id
				]))) return true; 	
				if(!_isMacOS)
	        (ev.srcElement||ev.target).oncontextmenu = function(e){ (e||event).cancelBubble=true; return false; };
	               
			if (this._acMenu.showContextMenu){

var dEl0=window.document.documentElement;
var dEl1=window.document.body;
var corrector = new Array((dEl0.scrollLeft||dEl1.scrollLeft),(dEl0.scrollTop||dEl1.scrollTop));
if (_isIE){
	var x= ev.clientX+corrector[0];
	var y = ev.clientY+corrector[1];
} else {
	var x= ev.pageX;
	var y = ev.pageY;
}
				
				this._acMenu.showContextMenu(x-1,y-1)
				this.contextID=obj.id;
				ev.cancelBubble=true;
				this._acMenu._skip_hide=true;
			} else {
				el.contextMenuId=obj.id;
				el.contextMenu=this._acMenu;
				el.a=this._acMenu._contextStart;
				el.a(el, ev);
				el.a=null;
			}
	        	
			return false;           
    	}
    return true;
}


/**
*     @desc: replace IMG tag with background images - solve problem with IE image caching , not works for IE6 SP1
*     @param: mode - true/false - enable/disable fix
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.enableIEImageFix=function(mode){
	if (!mode){

	this._getImg=function(id){ return document.createElement((id==this.rootId)?"div":"img"); }
	//this._setSrc=function(a,b){ a.src=b; }
	this._setSrc=function(a,b){ a.src=b; }
	this._getSrc=function(a){ return a.src; }
	}	else	{

	this._getImg=function(){ var z=document.createElement("DIV"); z.innerHTML="&nbsp;"; z.className="dhx_bg_img_fix"; return z; }
	this._setSrc=function(a,b){ a.style.backgroundImage="url("+b+")"; }
	this._getSrc=function(a){ var z=a.style.backgroundImage;  return z.substr(4,z.length-5).replace(/(^")|("$)/g,""); }
	}
}

/**
*	@desc: deletes tree and clears memory
*	@type: public
*/
dhtmlXTreeObject.prototype.destructor=function(){
    for (var a in this._idpull){
        var z=this._idpull[a];
		if (!z) continue;
        z.parentObject=null;z.treeNod=null;z.childNodes=null;z.span=null;z.tr.nodem=null;z.tr=null;z.htmlNode.objBelong=null;z.htmlNode=null;
        this._idpull[a]=null;
        }
    this.parentObject.innerHTML="";
    
    this.allTree.onselectstart = null;
    this.allTree.oncontextmenu = null;
    this.allTree.onmousedown = null;
        
    for(var a in this){
        this[a]=null;
        }
}

function cObject(){
    return this;
}
cObject.prototype= new Object;
cObject.prototype.clone = function () {
       function _dummy(){};
       _dummy.prototype=this;
       return new _dummy();
    }

/**
*   @desc: tree node constructor
*   @param: itemId - node id
*   @param: itemText - node label
*   @param: parentObject - parent item object
*   @param: treeObject - tree object
*   @param: actionHandler - onclick event handler(optional)
*   @param: mode - do not show images
*   @type: private
*   @topic: 0
*/
function dhtmlXTreeItemObject(itemId,itemText,parentObject,treeObject,actionHandler,mode){
   this.htmlNode="";
   this.acolor="";
   this.scolor="";
   this.tr=0;
   this.childsCount=0;
   this.tempDOMM=0;
   this.tempDOMU=0;
   this.dragSpan=0;
   this.dragMove=0;
   this.span=0;
   this.closeble=1;
   this.childNodes=new Array();
   this.userData=new cObject();


   this.checkstate=0;
   this.treeNod=treeObject;
   this.label=itemText;
   this.parentObject=parentObject;
   this.actionHandler=actionHandler;
   this.images=new Array(treeObject.imageArray[0],treeObject.imageArray[1],treeObject.imageArray[2]);


   this.id=treeObject._globalIdStorageAdd(itemId,this);
   if (this.treeNod.checkBoxOff ) this.htmlNode=this.treeNod._createItem(1,this,mode);
   else  this.htmlNode=this.treeNod._createItem(0,this,mode);

   this.htmlNode.objBelong=this;
   return this;
   };   


/**
*     @desc: register node
*     @type: private
*     @param: itemId - node id
*     @param: itemObject - node object
*     @topic: 3  
*/
   dhtmlXTreeObject.prototype._globalIdStorageAdd=function(itemId,itemObject){
      if (this._globalIdStorageFind(itemId,1,1)) {   itemId=itemId +"_"+(new Date()).valueOf(); return this._globalIdStorageAdd(itemId,itemObject); }
	  	 this._idpull[itemId]=itemObject;
         this._pullSize++;
      return itemId;
   };

/**
*     @desc: unregister node
*     @type: private
*     @param: itemId - node id
*     @topic: 3
*/
   dhtmlXTreeObject.prototype._globalIdStorageSub=function(itemId){
        if (this._idpull[itemId]){
		    this._unselectItem(this._idpull[itemId]);
			this._idpull[itemId]=null;
			this._pullSize--;
        }
		if ((this._locker)&&(this._locker[itemId])) this._locker[itemId]=false;
   };
   
/**
*     @desc: return node object
*     @param: itemId - node id
*     @type: private
*     @topic: 3
*/
   dhtmlXTreeObject.prototype._globalIdStorageFind=function(itemId,skipXMLSearch,skipParsing,isreparse){
		var z=this._idpull[itemId];
        if (z){
//#__pro_feature:01112006{
//#smart_parsing:01112006{
            if ((z.unParsed)&&(!skipParsing))
                    {
                    this.reParse(z,0);
                    }
            if (this._srnd && !z.htmlNode) this._buildSRND(z,skipParsing);
                if ((isreparse)&&(this._edsbpsA)){
                    for (var j=0; j<this._edsbpsA.length; j++)
                        if (this._edsbpsA[j][2]==itemId){
                            dhx4.callEvent("ongetItemError",["Requested item still in parsing process.",itemId]);
                            return null;
                        }
                    }
//#}
//#}
            return z;
            }
//#__pro_feature:01112006{
//#smart_parsing:01112006{
      if ((this.slowParse)&&(itemId!=0)&&(!skipXMLSearch)) return this.preParse(itemId);
      else
//#}
//#}
	  	return null;
   };
//#__pro_feature:01112006{
//#smart_parsing:01112006{
dhtmlXTreeObject.prototype._getSubItemsXML=function(p){
      var z=[];
      p.each("item",function(c){
      	z.push(c.get("id"));
      },this)
      return z.join(this.dlmtr);
    }

/**
*     @desc: enable/disable smart XML parsing mode (usefull for big, well structured XML)
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableSmartXMLParsing=function(mode) { this.slowParse=dhx4.s2b(mode); };
   dhtmlXTreeObject.prototype.findXML=function(node,par,val){  }

dhtmlXTreeObject.prototype._getAllCheckedXML=function(p,list,mode){
	var z=[];
	
	if (mode==2)
		p.through("item","checked",-1,function(c){
			z.push(c.get("id"));
  		},this);
  	
  	if (mode==1)
  		p.through("item","id",null,function(c){
  			if (c.get("checked") && (c.get("checked") !=-1))
			z.push(c.get("id"));
  		},this);
  		
	if (mode==0)
  		p.through("item","id",null,function(c){
			if (!c.get("checked") || c.get("checked")==0 )
			z.push(c.get("id"));
  		},this);  		
    if(z.length)
  		return list+(list?this.dlmtr:"")+z.join(this.dlmtr);
      if (list) return list; else return "";
   };


/**
*     @desc: change state of node's checkbox and all childnodes checkboxes
*     @type: private
*     @param: itemId - target node id
*     @param: state - checkbox state
*     @param: sNode - target node object (optional, used by private methods)
*     @topic: 5
*/
   dhtmlXTreeObject.prototype._setSubCheckedXML=function(state,p){
	   	var val= state?"1":"";
	   	p.through("item","id",null,function(c){
			if (!c.get("disabled") || c.get("disabled")==0 )
	   		    c.set("checked",val);
	   	},this);
}

       dhtmlXTreeObject.prototype._getAllScraggyItemsXML=function(p,x){
        var z=[];
        var fff=function(c){
	   		if (!c.sub_exists("item"))
	   			z.push(c.get("id"));
	   		else
	   			c.each("item",fff,this);
		   	}
	    fff(p);
        return z.join(",");
    }
    
   dhtmlXTreeObject.prototype._getAllFatItemsXML=function(p,x){
        var z=[];
        var fff=function(c){
	   		if (!c.sub_exists("item"))
	   			return;
   			z.push(c.get("id"));
   			c.each("item",fff,this);
		   	}
	    fff(p);
        return z.join(",");
    }

dhtmlXTreeObject.prototype._getAllSubItemsXML=function(itemId,z,p){
      var z=[];
      p.through("item","id",null,function(c){
      	z.push(c.get("id"));
      },this)
      return z.join(",");
    }

/**
*     @desc: parse stored xml
*     @param: node - XML node
*     @type: private
*     @edition: Professional
*     @topic: 3  
*/
 dhtmlXTreeObject.prototype.reParse=function(node){
        var that=this;
      if (!this.parsCount) that.callEvent("onXLS",[that,node.id]);
      this.xmlstate=1;

      var tmp=node.unParsed;
      node.unParsed=0;
//               if (confirm("reParse "+node.id)) { window.asdasd.asdasd(); }
      this.XMLloadingWarning=1;
        var oldpid=this.parsingOn;
		var oldmd=this.waitUpdateXML;
		var oldpa=this.parsedArray;

		this.parsedArray=new Array();
	  	this.waitUpdateXML=false;
      this.parsingOn=node.id;
      this.parsedArray=new Array();

         this.setCheckList="";
         this._parse(tmp,node.id,2);
         var chArr=this.setCheckList.split(this.dlmtr);

      for (var i=0; i<this.parsedArray.length; i++)
         node.htmlNode.childNodes[0].appendChild(this.parsedArray[i]);
      
	  if (tmp.get("order") && tmp.get("order")!="none")
	  	 	this._reorderBranch(node,tmp.get("order"),true);
	  	 	
            this.oldsmcheck=this.smcheck;
            this.smcheck=false;

         for (var n=0; n<chArr.length; n++)
            if (chArr[n])  this.setCheck(chArr[n],1);
            this.smcheck=this.oldsmcheck;

      this.parsingOn=oldpid;
	  this.waitUpdateXML=oldmd;
	  this.parsedArray=oldpa;  	  
      this.XMLloadingWarning=0;
      this._redrawFrom(this,node);
      if (this._srnd && !node._sready)
      	this.prepareSR(node.id);
      this.xmlstate=0;
      return true;
   }

/**
*     @desc: search for item in unparsed chunks
*     @param: itemId - item ID
*     @type: private
*     @edition: Professional
*     @topic: 3
*/
dhtmlXTreeObject.prototype.preParse=function(itemId){
   if (!itemId || !this._p) return null; 
   var result=false;
   this._p.clone().through("item","id",itemId,function(c){
   		this._globalIdStorageFind(c.up().get("id"));
   		return result=true;
   	},this);
   	if (result){
   		var n=this._globalIdStorageFind(itemId,true,false);
   		if (!n)
   			dhx4.callEvent("ongetItemError",["The item "+itemId+" not operable. Seems you have non-unique|incorrect IDs in tree's XML.",itemId]);
   	}
   	return n;
}

//#}
//#}

/**
*     @desc: escape string
*     @param: itemId - item ID
*     @type: private
*     @topic: 3
*/
   dhtmlXTreeObject.prototype._escape=function(str){
        switch(this.utfesc){
        case "none":
            return str;
            break;
        case "utf8":
         return encodeURIComponent(str);
            break;
        default:
         return escape(str);
            break;
        }
   }



/**
*     @desc: create and return  new line in tree
*     @type: private
*     @param: htmlObject - parent Node object
*     @param: node - item object
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype._drawNewTr=function(htmlObject,node)
   {
      var tr =document.createElement('tr');
      var td1=document.createElement('td');
      var td2=document.createElement('td');
      td1.appendChild(document.createTextNode(" "));
      td2.colSpan=3;
      td2.appendChild(htmlObject);
      tr.appendChild(td1);  tr.appendChild(td2);
      return tr;
   };
/**
*     @desc: load tree from xml string
*     @type: public
*     @param: xmlString - XML string
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.parse=function(xmlString,afterCall,type){
      if (typeof afterCall == "string"){
        type = afterCall;
        afterCall = null;
      }

      if (type === "json")
        return this._loadJSONObject(xmlString, afterCall)
      else if (type === "csv")
        return this._loadCSVString(xmlString, afterCall);
      else if (type === "jsarray")
        return this._loadJSArray(xmlString, afterCall);

      var that=this;
      if (!this.parsCount) this.callEvent("onXLS",[that,null]);
      this.xmlstate=1;
      this.XMLLoader({ responseXML:dhx4.ajax.parse(xmlString)}, afterCall);
    };

    dhtmlXTreeObject.prototype.loadXMLString = function(){
      if (window.console && window.console.info)
        window.console.info("loadXMLString was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");
      return this.parse.apply(this, arguments);
    }

/**
*     @desc: load tree from xml file
*     @type: public
*     @param: file - link to XML file
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
	dhtmlXTreeObject.prototype.load=function(file,afterCall,type){ 
    if (typeof afterCall == "string"){
      type = afterCall;
      afterCall = null;
    }

    type = type || this._datamode;
    if (type === "json")
      return this._loadJSON(file, afterCall)
    else if (type === "csv")
      return this._loadCSV(file, afterCall);
    else if (type === "jsarray")
      return this._loadJSArrayFile(xmlString, afterCall);

      var that=this;
      if (!this.parsCount) this.callEvent("onXLS",[that,this._ld_id]);
      this._ld_id=null;
      this.xmlstate=1;
      this.XMLLoader=this._parseXMLTree;

      var self = this;
      dhx4.ajax.get(file, function(data){
        self.XMLLoader(data.xmlDoc, afterCall);
        self = null;
      });
   };
   dhtmlXTreeObject.prototype.loadXML = function(){
      if (window.console && window.console.info)
        window.console.info("loadXML was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");
      return this.load.apply(this, arguments);
   }
/**
*     @desc: create new child node
*     @type: private
*     @param: parentObject - parent node object
*     @param: itemId - new node id
*     @param: itemText - new node text
*     @param: itemActionHandler - function fired on node select event
*     @param: image1 - image for node without children;
*     @param: image2 - image for closed node;
*     @param: image3 - image for opened node
*     @param: optionStr - string of otions
*     @param: childs - node childs flag (for dynamical trees) (optional)
*     @param: beforeNode - node, after which new node will be inserted (optional)
*     @topic: 2
*/
   dhtmlXTreeObject.prototype._attachChildNode=function(parentObject,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,childs,beforeNode,afterNode){

         if (beforeNode && beforeNode.parentObject) parentObject=beforeNode.parentObject;
         if (((parentObject.XMLload==0)&&(this.XMLsource))&&(!this.XMLloadingWarning))
         {
            parentObject.XMLload=1;
                this._loadDynXML(parentObject.id);

         }

         var Count=parentObject.childsCount;
         var Nodes=parentObject.childNodes;


            if (afterNode && afterNode.tr.previousSibling){
            if (afterNode.tr.previousSibling.previousSibling){
               beforeNode=afterNode.tr.previousSibling.nodem;
               }
            else
               optionStr=optionStr.replace("TOP","")+",TOP";
               }

         if (beforeNode)
            {
            var ik,jk;
            for (ik=0; ik<Count; ik++)
               if (Nodes[ik]==beforeNode)
               {
               for (jk=Count; jk!=ik; jk--)
                  Nodes[1+jk]=Nodes[jk];
               break;
               }
            ik++;
            Count=ik;
            }


         if (optionStr) {
             var tempStr=optionStr.split(",");
            for (var i=0; i<tempStr.length; i++)
            {
               switch(tempStr[i])
               {
                  case "TOP": if (parentObject.childsCount>0) { beforeNode=new Object; beforeNode.tr=parentObject.childNodes[0].tr.previousSibling; }
				  	 parentObject._has_top=true;
                     for  (ik=Count; ik>0; ik--)
                        Nodes[ik]=Nodes[ik-1];
                        Count=0;
                     break;
               }
            };
          };

        	var n;
		if (!(n=this._idpull[itemId]) || n.span!=-1){
         	n=Nodes[Count]=new dhtmlXTreeItemObject(itemId,itemText,parentObject,this,itemActionHandler,1);
         	itemId = Nodes[Count].id;
         	parentObject.childsCount++;
     	}
        
        if(!n.htmlNode) {
           n.label=itemText;
		   n.htmlNode=this._createItem((this.checkBoxOff?1:0),n);
   		   n.htmlNode.objBelong=n;
   		  }

         if(image1) n.images[0]=image1;
         if(image2) n.images[1]=image2;
         if(image3) n.images[2]=image3;

		
         var tr=this._drawNewTr(n.htmlNode);
         if ((this.XMLloadingWarning)||(this._hAdI))
            n.htmlNode.parentNode.parentNode.style.display="none";

           
            if ((beforeNode)&&beforeNode.tr&&(beforeNode.tr.nextSibling))
               parentObject.htmlNode.childNodes[0].insertBefore(tr,beforeNode.tr.nextSibling);
            else
               if (this.parsingOn==parentObject.id){
                  this.parsedArray[this.parsedArray.length]=tr;
                        }
               else
                   parentObject.htmlNode.childNodes[0].appendChild(tr);


               if ((beforeNode)&&(!beforeNode.span)) beforeNode=null;

            if (this.XMLsource) if ((childs)&&(childs!=0)) n.XMLload=0; else n.XMLload=1;
            n.tr=tr;
            tr.nodem=n;

            if (parentObject.itemId==0)
                tr.childNodes[0].className="hiddenRow";

            if ((parentObject._r_logic)||(this._frbtr))
                this._setSrc(n.htmlNode.childNodes[0].childNodes[0].childNodes[1].childNodes[0],this.imPath+this.radioArray[0]);


          if (optionStr) {
             var tempStr=optionStr.split(",");

            for (var i=0; i<tempStr.length; i++)
            {
               switch(tempStr[i])
               {
                     case "SELECT": this.selectItem(itemId,false); break;
                  case "CALL": this.selectItem(itemId,true);   break;
                  case "CHILD":  n.XMLload=0;  break;
                  case "CHECKED":
                     if (this.XMLloadingWarning)
                        this.setCheckList+=this.dlmtr+itemId;
                     else
                        this.setCheck(itemId,1);
                        break;
                  case "HCHECKED":
                        this._setCheck(n,"unsure");
                        break;                        
                  case "OPEN": n.openMe=1;  break;
               }
            };
          };

      if (!this.XMLloadingWarning)
      {
             if ((this._getOpenState(parentObject)<0)&&(!this._hAdI)) this.openItem(parentObject.id);

             if (beforeNode)
                {
             this._correctPlus(beforeNode);
             this._correctLine(beforeNode);
                }
             this._correctPlus(parentObject);
             this._correctLine(parentObject);
             this._correctPlus(n);
             if (parentObject.childsCount>=2)
             {
                   this._correctPlus(Nodes[parentObject.childsCount-2]);
                   this._correctLine(Nodes[parentObject.childsCount-2]);
             }
             if (parentObject.childsCount!=2) this._correctPlus(Nodes[0]);

         if (this.tscheck) this._correctCheckStates(parentObject);

            if (this._onradh){
				if (this.xmlstate==1){
					var old=this.onXLE;
					this.onXLE=function(id){ this._onradh(itemId); if (old) old(id); }
					}
				else
					this._onradh(itemId);
			}

      }
   return n;
};


//#__pro_feature:01112006{
//#context_menu:01112006{

/**
*     @desc: enable context menu
*     @param: menu - dhtmlXMenu object
*     @edition: Professional
*     @type: public
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableContextMenu=function(menu){  if (menu) this.cMenu=menu; };

/**
*     @desc: set context menu to individual nodes
*     @type: public
*     @param: itemId - node id
*     @param: cMenu - context menu object
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.setItemContextMenu=function(itemId,cMenu){
   var l=itemId.toString().split(this.dlmtr);
   for (var i=0; i<l.length; i++)
      {
      var temp=this._globalIdStorageFind(l[i]);
      if (!temp) continue;
      temp.cMenu=cMenu;
      }
}

//#}
//#}

/**
*     @desc: create new node as a child to specified with parentId
*     @type: deprecated
*     @param: parentId - parent node id
*     @param: itemId - new node id
*     @param: itemText - new node text
*     @param: itemActionHandler - function fired on node select event (optional)
*     @param: image1 - image for node without children; (optional)
*     @param: image2 - image for closed node; (optional)
*     @param: image3 - image for opened node (optional)
*     @param: optionStr - options string (optional)            
*     @param: children - node children flag (for dynamical trees) (optional)
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype.insertNewItem=function(parentId,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children){
      var parentObject=this._globalIdStorageFind(parentId);
      if (!parentObject) return (-1);
      var nodez=this._attachChildNode(parentObject,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children);
      if(!this._idpull[this.rootId].XMLload)
         this._idpull[this.rootId].XMLload = 1;
//#__pro_feature:01112006{
//#child_calc:01112006{
      if ((!this.XMLloadingWarning)&&(this.childCalc))  this._fixChildCountLabel(parentObject);
//#}
//#}
        return nodez;
   };
/**
*     @desc: create new node as a child to specified with parentId
*     @type: public
*     @param: parentId - parent node id
*     @param: itemId - new node id
*     @param: itemText - new node label
*     @param: itemActionHandler - function fired on node select event (optional)
*     @param: image1 - image for node without children; (optional)
*     @param: image2 - image for closed node; (optional)
*     @param: image3 - image for opened node (optional)
*     @param: optionStr - options string (optional)            
*     @param: children - node children flag (for dynamical trees) (optional)
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype.insertNewChild=function(parentId,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children){
      return this.insertNewItem(parentId,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children);
   }   
/**  
*     @desc: parse xml
*     @type: private
*     @param: dhtmlObject - jsTree object
*     @param: node - top XML node
*     @param: parentId - parent node id
*     @param: level - level of tree
*     @topic: 2
*/
	dhtmlXTreeObject.prototype._parseXMLTree=function(xml, callback){
		var p=new xmlPointer(dhx4.ajax.xmltop("tree", xml));
		this._parse(p);
		this._p=p;
    if (callback) callback.call(this, xml);
	}
	
	dhtmlXTreeObject.prototype._parseItem=function(c,temp,preNode,befNode){ 
		var id;
		if (this._srnd && (!this._idpull[id=c.get("id")] || !this._idpull[id].span))
		{
			this._addItemSRND(temp.id,id,c);
			return; 
		}
		
  var a=c.get_all();
        
        if ((typeof(this.waitUpdateXML)=="object")&&(!this.waitUpdateXML[a.id])){
			this._parse(c,a.id,1);
			return;
		}    

//#__pro_feature:01112006{
			if ((a.text===null)||(typeof(a.text)=="undefined")){
				a.text=c.sub("itemtext");
				if (a.text) a.text=a.text.content();
			}
//#}
              



                  var zST=[];
                  if (a.select) zST.push("SELECT");
                  if (a.top) zST.push("TOP");
                  if (a.call) this.nodeAskingCall=a.id;
                  if (a.checked==-1) zST.push("HCHECKED");
                     else if (a.checked) zST.push("CHECKED");
                  if (a.open) zST.push("OPEN");
	
    	          if (this.waitUpdateXML){
				  		if (this._globalIdStorageFind(a.id))
	    	            	var newNode=this.updateItem(a.id,a.text,a.im0,a.im1,a.im2,a.checked,a.child);
						else{
							if (this.npl==0) zST.push("TOP");
							else preNode=temp.childNodes[this.npl];

		                    var newNode=this._attachChildNode(temp,a.id,a.text,0,a.im0,a.im1,a.im2,zST.join(","),a.child,0,preNode);
                        a.id = newNode.id;
							preNode=null;
						}
					 }
                  else
                     var newNode=this._attachChildNode(temp,a.id,a.text,0,a.im0,a.im1,a.im2,zST.join(","),a.child,(befNode||0),preNode);
                  if (a.tooltip)
					newNode.span.parentNode.parentNode.title=a.tooltip;

                  if (a.style)
                            if (newNode.span.style.cssText)
                                newNode.span.style.cssText+=(";"+a.style);
                            else
                                newNode.span.setAttribute("style",newNode.span.getAttribute("style")+"; "+a.style);

                        if (a.radio) newNode._r_logic=true;

                  if (a.nocheckbox){
                  	 var check_node=newNode.span.parentNode.previousSibling.previousSibling;
                     check_node.style.display="none";
                     newNode.nocheckbox=true;
                  }
                        if (a.disabled){
                            if (a.checked!=null) this._setCheck(newNode,a.checked);
                            this.disableCheckbox(newNode,1);
                            }

				
                  newNode._acc=a.child||0;

                  if (this.parserExtension) this.parserExtension._parseExtension.call(this,c,a,(temp?temp.id:0));

                  this.setItemColor(newNode,a.aCol,a.sCol);
                  if (a.locked=="1")    this.lockItem(newNode.id,true,true);

                  if ((a.imwidth)||(a.imheight))   this.setIconSize(a.imwidth,a.imheight,newNode);
                  if ((a.closeable=="0")||(a.closeable=="1"))  this.setItemCloseable(newNode,a.closeable);
                  var zcall="";
                  if (a.topoffset) this.setItemTopOffset(newNode,a.topoffset);
                  if ((!this.slowParse)||(typeof(this.waitUpdateXML)=="object")){ 
                  	if (c.sub_exists("item"))
                    	zcall=this._parse(c,a.id,1);
                  }
//#__pro_feature:01112006{
//#smart_parsing:01112006{
                  else {
                  	if ((!newNode.childsCount) && c.sub_exists("item"))
                      newNode.unParsed=c.clone();
                     
						c.each("userdata",function(u){
							this.setUserData(a.id,u.get("name"),u.content());
						},this);
     	  	      }
//#}                     
//#}
                  if (zcall!="") this.nodeAskingCall=zcall;

   
        c.each("userdata",function(u){
    	  		this.setUserData(c.get("id"),u.get("name"),u.content());
 	  	  },this)
		
		
	}
   	dhtmlXTreeObject.prototype._parse=function(p,parentId,level,start){ 
   		if (this._srnd && !this.parentObject.offsetHeight) {
   			var self=this;
   			return window.setTimeout(function(){
   				self._parse(p,parentId,level,start);
   			},100);
   		}
		if (!p.exists()) return;
		
		this.skipLock=true; //disable item locking
		//loading flags
		
		
		if (!parentId) {          //top level  
			parentId=p.get("id");
			
	  // deleting child items for refreshed branches
	  if(this._dynDeleteBranches[parentId]){
		 this.deleteChildItems(parentId);
		 this._dynDeleteBranches[parentId]--;
		 if(!this._dynDeleteBranches[parentId]){
			delete this._dynDeleteBranches[parentId];
		 }	
	  }
	  
      var skey = p.get("dhx_security");
      if (skey)
          dhtmlx.security_key = skey;

			if (p.get("radio"))
				this.htmlNode._r_logic=true;
			this.parsingOn=parentId;                 
			this.parsedArray=new Array();
			this.setCheckList="";
			this.nodeAskingCall="";
		}
		
		var temp=this._globalIdStorageFind(parentId);
		if (!temp) return dhx4.callEvent("onDataStructureError",["XML refers to not existing parent"]);

		this.parsCount=this.parsCount?(this.parsCount+1):1;
		this.XMLloadingWarning=1;

		if ((temp.childsCount)&&(!start)&&(!this._edsbps)&&(!temp._has_top))
            var preNode=0;//temp.childNodes[temp.childsCount-1];
        else
            var preNode=0;

        this.npl=0;

		p.each("item",function(c,i){
				
		temp.XMLload=1;
				
          this._parseItem(c,temp,0,preNode); 
 	  	  
//#__pro_feature:01112006{
//#distributed_load:01112006{
              if ((this._edsbps)&&(this.npl==this._edsbpsC)){
                this._distributedStart(p,i+1,parentId,level,temp.childsCount);
                return -1;
              }
//#}
//#}
              this.npl++;
         

 	  	  
      },this,start);


      if (!level) {
      	  p.each("userdata",function(u){
    	  		this.setUserData(p.get("id"),u.get("name"),u.content());
 	  	  },this);
 	  	  
	  	 temp.XMLload=1;
         if (this.waitUpdateXML){
            this.waitUpdateXML=false;
			for (var i=temp.childsCount-1; i>=0; i--)
				if (temp.childNodes[i]._dmark)
					this.deleteItem(temp.childNodes[i].id);
			}

         var parsedNodeTop=this._globalIdStorageFind(this.parsingOn);

         for (var i=0; i<this.parsedArray.length; i++)
               temp.htmlNode.childNodes[0].appendChild(this.parsedArray[i]);
		this.parsedArray = [];
		
         this.lastLoadedXMLId=parentId;
         this.XMLloadingWarning=0;

         var chArr=this.setCheckList.split(this.dlmtr);
         for (var n=0; n<chArr.length; n++)
            if (chArr[n]) this.setCheck(chArr[n],1);

               if ((this.XMLsource)&&(this.tscheck)&&(this.smcheck)&&(temp.id!=this.rootId)){
                if (temp.checkstate===0)
                    this._setSubChecked(0,temp);
                else if (temp.checkstate===1)
                    this._setSubChecked(1,temp);
            }

         this._redrawFrom(this,null,start)
		 if (p.get("order") && p.get("order")!="none")
	  	 	this._reorderBranch(temp,p.get("order"),true);
	  	 	
	  	 if (this.nodeAskingCall!="") this.callEvent("onClick",[this.nodeAskingCall,this.getSelectedItemId()]); 
         if (this._branchUpdate) this._branchUpdateNext(p);
	     }


      if (this.parsCount==1) {
      	 this.parsingOn=null;
//#__pro_feature:01112006{
//#smart_parsing:01112006{
          //if ((this.slowParse)&&(this.parsingOn==this.rootId))
         if (this._srnd && temp.id!=this.rootId){
 	  	 	this.prepareSR(temp.id);
 	  	 	if (this.XMLsource) this.openItem(temp.id)
 	  	 }
 	  	 
            p.through("item","open",null,function(c){
            	this.openItem(c.get("id"));
            	},this);
//#}
//#}

         
         if ((!this._edsbps)||(!this._edsbpsA.length)){
         		var that=this;
               	window.setTimeout( function(){  that.callEvent("onXLE",[that,parentId]); },1);
                this.xmlstate=0;
                }
             this.skipLock=false;
         }
      this.parsCount--;

//#__pro_feature:01112006{
//#distributed_load:01112006{
		var that=this;
        if (this._edsbps) window.setTimeout(function(){ that._distributedStep(parentId); },this._edsbpsD);
//#}
//#}

        
		
		if (!level && this.onXLE) this.onXLE(this,parentId);
      return this.nodeAskingCall;
  };
  

dhtmlXTreeObject.prototype._branchUpdateNext=function(p){
	p.each("item",function(c){
		var nid=c.get("id");
		if (this._idpull[nid] && (!this._idpull[nid].XMLload))  return;
		this._branchUpdate++;
		this.smartRefreshItem(c.get("id"),c);
	},this)
	this._branchUpdate--;
} 

  dhtmlXTreeObject.prototype.checkUserData=function(node,parentId){
      if ((node.nodeType==1)&&(node.tagName == "userdata"))
      {
         var name=node.getAttribute("name");
            if ((name)&&(node.childNodes[0]))
               this.setUserData(parentId,name,node.childNodes[0].data);
      }
  }




/**  
*     @desc: reset tree images from selected level
*     @type: private
*     @param: dhtmlObject - tree
*     @param: itemObject - current item
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._redrawFrom=function(dhtmlObject,itemObject,start,visMode){
      if (!itemObject) {
      var tempx=dhtmlObject._globalIdStorageFind(dhtmlObject.lastLoadedXMLId);
      dhtmlObject.lastLoadedXMLId=-1;
      if (!tempx) return 0;
      }
      else tempx=itemObject;
      var acc=0;
      for (var i=(start?start-1:0); i<tempx.childsCount; i++)
      {
	  	 if ((!this._branchUpdate)||(this._getOpenState(tempx)==1))
	         if ((!itemObject)||(visMode==1)) tempx.childNodes[i].htmlNode.parentNode.parentNode.style.display="";
         if (tempx.childNodes[i].openMe==1)
            {
            this._openItem(tempx.childNodes[i]);
            tempx.childNodes[i].openMe=0;
            }

         dhtmlObject._redrawFrom(dhtmlObject,tempx.childNodes[i]);
//#__pro_feature:01112006{
//#child_calc:01112006{
      if (this.childCalc!=null){

      if ((tempx.childNodes[i].unParsed)||((!tempx.childNodes[i].XMLload)&&(this.XMLsource)))
      {

         if (tempx.childNodes[i]._acc)
         tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+tempx.childNodes[i]._acc+this.htmlcB;
         else
         tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label;
      }
         if ((tempx.childNodes[i].childNodes.length)&&(this.childCalc))
         {
            if (this.childCalc==1)
               {
               tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+tempx.childNodes[i].childsCount+this.htmlcB;
               }
            if (this.childCalc==2)
               {
               var zCount=tempx.childNodes[i].childsCount-(tempx.childNodes[i].pureChilds||0);
               if (zCount)
                  tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+zCount+this.htmlcB;
               if (tempx.pureChilds) tempx.pureChilds++; else tempx.pureChilds=1;
               }
            if (this.childCalc==3)
               {
               tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+tempx.childNodes[i]._acc+this.htmlcB;
               }
            if (this.childCalc==4)
               {
               var zCount=tempx.childNodes[i]._acc;
               if (zCount)
                  tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+zCount+this.htmlcB;
               }               
         }
            else if (this.childCalc==4)   {
               acc++;
               }   
            
         acc+=tempx.childNodes[i]._acc;
         
         if (this.childCalc==3){
            acc++;
         }

         }
//#}
//#}

      };

      if ((!tempx.unParsed)&&((tempx.XMLload)||(!this.XMLsource)))
      tempx._acc=acc;
      dhtmlObject._correctLine(tempx);
      dhtmlObject._correctPlus(tempx);
//#__pro_feature:01112006{
//#child_calc:01112006{
      if ((this.childCalc)&&(!itemObject)) dhtmlObject._fixChildCountLabel(tempx);
//#}
//#}
   };

/**
*     @desc: create and return main html element of tree
*     @type: private
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype._createSelf=function(){
      var div=document.createElement('div');
      div.className="containerTableStyle";
      div.style.width=this.width;
      div.style.height=this.height;
      this.parentObject.appendChild(div);
      return div;
   };

/**
*     @desc: collapse target node
*     @type: private
*     @param: itemObject - item object
*     @topic: 4  
*/
   dhtmlXTreeObject.prototype._xcloseAll=function(itemObject)
   {
        if (itemObject.unParsed) return;
      if (this.rootId!=itemObject.id) {
      		if (!itemObject.htmlNode) return;//srnd
          var Nodes=itemObject.htmlNode.childNodes[0].childNodes;
            var Count=Nodes.length;

          for (var i=1; i<Count; i++)
             Nodes[i].style.display="none";

          this._correctPlus(itemObject);
      }

       for (var i=0; i<itemObject.childsCount; i++)
            if (itemObject.childNodes[i].childsCount)
             this._xcloseAll(itemObject.childNodes[i]);
   };
/**
*     @desc: expand target node
*     @type: private
*     @param: itemObject - item object
*     @topic: 4
*/      
   dhtmlXTreeObject.prototype._xopenAll=function(itemObject)
   {
      this._HideShow(itemObject,2);
      for (var i=0; i<itemObject.childsCount; i++)
         this._xopenAll(itemObject.childNodes[i]);
   };      
/**  
*     @desc: set correct tree-line and node images
*     @type: private
*     @param: itemObject - item object
*     @topic: 6  
*/
dhtmlXTreeObject.prototype._correctPlus=function(itemObject){
	if (!itemObject.htmlNode) return;
        var imsrc=itemObject.htmlNode.childNodes[0].childNodes[0].childNodes[0].lastChild;
        var imsrc2=itemObject.htmlNode.childNodes[0].childNodes[0].childNodes[2].childNodes[0];
        
        var workArray=this.lineArray;
        if ((this.XMLsource)&&(!itemObject.XMLload)) {
        	var workArray=this.plusArray;
        	this._setSrc(imsrc2,this.iconURL+itemObject.images[2]);
                if (this._txtimg) return (imsrc.innerHTML="[+]");
        } else if ((itemObject.childsCount)||(itemObject.unParsed)) {
        	if ((itemObject.htmlNode.childNodes[0].childNodes[1])&&( itemObject.htmlNode.childNodes[0].childNodes[1].style.display!="none" )) {
        		if (!itemObject.wsign) var workArray=this.minusArray;
        		this._setSrc(imsrc2,this.iconURL+itemObject.images[1]);
        		if (this._txtimg) return (imsrc.innerHTML="[-]");
        	} else {
        		if (!itemObject.wsign) var workArray=this.plusArray;
        		this._setSrc(imsrc2,this.iconURL+itemObject.images[2]);
        		if (this._txtimg) return (imsrc.innerHTML="[+]");
        	}
        } else {
        	this._setSrc(imsrc2,this.iconURL+itemObject.images[0]);
        }
        
        
        var tempNum=2;
        if (!itemObject.treeNod.treeLinesOn) {
        	this._setSrc(imsrc,this.imPath+workArray[3]);
        } else {
        	if (itemObject.parentObject) tempNum=this._getCountStatus(itemObject.id,itemObject.parentObject);
        	this._setSrc(imsrc,this.imPath+workArray[tempNum]);
        }
};

/**
*     @desc: set correct tree-line images
*     @type: private
*     @param: itemObject - item object
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._correctLine=function(itemObject){
   	  if (!itemObject.htmlNode) return;
      var sNode=itemObject.parentObject;
      if (sNode)
         if ((this._getLineStatus(itemObject.id,sNode)==0)||(!this.treeLinesOn))
               for(var i=1; i<=itemObject.childsCount; i++){
                  if (!itemObject.htmlNode.childNodes[0].childNodes[i]) break;
                  itemObject.htmlNode.childNodes[0].childNodes[i].childNodes[0].style.backgroundImage="";
                  itemObject.htmlNode.childNodes[0].childNodes[i].childNodes[0].style.backgroundRepeat="";
                }
            else
               for(var i=1; i<=itemObject.childsCount; i++){
               	 if (!itemObject.htmlNode.childNodes[0].childNodes[i]) break;
               	 itemObject.htmlNode.childNodes[0].childNodes[i].childNodes[0].style.backgroundImage="url("+this.imPath+this.lineArray[5]+")";
               	 itemObject.htmlNode.childNodes[0].childNodes[i].childNodes[0].style.backgroundRepeat="repeat-y";
	     }
   };
/**
*     @desc: return type of node
*     @type: private
*     @param: itemId - item id
*     @param: itemObject - parent node object
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getCountStatus=function(itemId,itemObject){
      if (itemObject.childsCount<=1) { if (itemObject.id==this.rootId) return 4; else  return 0; }

      if (itemObject.childNodes[0].id==itemId) if (itemObject.id==this.rootId) return 2; else return 1;
      if (itemObject.childNodes[itemObject.childsCount-1].id==itemId) return 0;

      return 1;
   };
/**
*     @desc: return type of node
*     @type: private
*     @param: itemId - node id        
*     @param: itemObject - parent node object
*     @topic: 6
*/      
   dhtmlXTreeObject.prototype._getLineStatus =function(itemId,itemObject){
         if (itemObject.childNodes[itemObject.childsCount-1].id==itemId) return 0;
         return 1;
      }

/**  
*     @desc: open/close node 
*     @type: private
*     @param: itemObject - node object        
*     @param: mode - open/close mode [1-close 2-open](optional)
*     @topic: 6
*/      
   dhtmlXTreeObject.prototype._HideShow=function(itemObject,mode){
      if (this._locker && !this.skipLock && this._locker[itemObject.id]) return;
      if ((this.XMLsource)&&(!itemObject.XMLload)) {
            if (mode==1) return; //close for not loaded node - ignore it
            itemObject.XMLload=1;
            this._loadDynXML(itemObject.id);
            return; };
//#__pro_feature:01112006{
//#smart_parsing:01112006{
        if (itemObject.unParsed) this.reParse(itemObject);
//#}
//#}
      var Nodes=itemObject.htmlNode.childNodes[0].childNodes; var Count=Nodes.length;
      if (Count>1){
         if ( ( (Nodes[1].style.display!="none") || (mode==1) ) && (mode!=2) ) {
//nb:solves standard doctype prb in IE
          this.allTree.childNodes[0].border = "1";
          this.allTree.childNodes[0].border = "0";
         nodestyle="none";
         }
         else  nodestyle="";

      for (var i=1; i<Count; i++)
         Nodes[i].style.display=nodestyle;
      }
      this._correctPlus(itemObject);
   }

/**
*     @desc: return node state
*     @type: private
*     @param: itemObject - node object        
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getOpenState=function(itemObject){
   	  if (!itemObject.htmlNode) return 0; //srnd
   	  var z=itemObject.htmlNode.childNodes[0].childNodes;
      if (z.length<=1) return 0;
      if    (z[1].style.display!="none") return 1;
      else return -1;
   }

   

/**  
*     @desc: ondblclick item  event handler
*     @type: private
*     @topic: 0  
*/      
   dhtmlXTreeObject.prototype.onRowClick2=function(){
   	  var that=this.parentObject.treeNod;
      if (!that.callEvent("onDblClick",[this.parentObject.id,that])) return false;
      if ((this.parentObject.closeble)&&(this.parentObject.closeble!="0"))
         that._HideShow(this.parentObject);
      else
         that._HideShow(this.parentObject,2);

   	if    (that.checkEvent("onOpenEnd"))
           if (!that.xmlstate)
				that.callEvent("onOpenEnd",[this.parentObject.id,that._getOpenState(this.parentObject)]);
            else{
                that._oie_onXLE.push(that.onXLE);
                that.onXLE=that._epnFHe;
                }
    	return false;
   };
/**
*     @desc: onclick item event handler
*     @type: private
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.onRowClick=function(){ 
    var that=this.parentObject.treeNod;
	  if (!that.callEvent("onOpenStart",[this.parentObject.id,that._getOpenState(this.parentObject)])) return 0;
      if ((this.parentObject.closeble)&&(this.parentObject.closeble!="0"))
         that._HideShow(this.parentObject);
      else
         that._HideShow(this.parentObject,2);

	
   if    (that.checkEvent("onOpenEnd"))
           if (!that.xmlstate)
				that.callEvent("onOpenEnd",[this.parentObject.id,that._getOpenState(this.parentObject)]);
            else{
                that._oie_onXLE.push(that.onXLE);
                that.onXLE=that._epnFHe;
                }

   };

      dhtmlXTreeObject.prototype._epnFHe=function(that,id,flag){
      	if (id!=this.rootId)
	  		this.callEvent("onOpenEnd",[id,that.getOpenState(id)]);
        that.onXLE=that._oie_onXLE.pop();
        
        if (!flag && !that._oie_onXLE.length)
			if (that.onXLE) that.onXLE(that,id);
    }



/**
*     @desc: onclick item image event handler
*     @type: private
*     @edition: Professional
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype.onRowClickDown=function(e){
            e=e||window.event;
         var that=this.parentObject.treeNod;
         that._selectItem(this.parentObject,e);
      };


/*****
SELECTION
*****/

/**
*     @desc: retun selected item id
*     @type: public
*     @return: id of selected item
*     @topic: 1
*/
   dhtmlXTreeObject.prototype.getSelectedItemId=function()
   {
        var str=new Array();
        for (var i=0; i<this._selected.length; i++) str[i]=this._selected[i].id;
      return (str.join(this.dlmtr));
   };

/**
*     @desc: visual select item in tree
*     @type: private
*     @param: node - tree item object
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype._selectItem=function(node,e){
   		if (this.checkEvent("onSelect")) this._onSSCFold=this.getSelectedItemId();
//#__pro_feature:01112006{
//#multiselect:01112006{
        if ((!this._amsel)||(!e)||((!e.ctrlKey)&&(!e.metaKey)&&(!e.shiftKey)))
//#}
//#}
            this._unselectItems();
//#__pro_feature:01112006{
//#multiselect:01112006{
            if ((node.i_sel)&&(this._amsel)&&(e)&&(e.ctrlKey || e.metaKey))
                this._unselectItem(node);
            else
            if ((!node.i_sel)&&((!this._amselS)||(this._selected.length==0)||(this._selected[0].parentObject==node.parentObject)))
                if ((this._amsel)&&(e)&&(e.shiftKey)&&(this._selected.length!=0)&&(this._selected[this._selected.length-1].parentObject==node.parentObject)){
                    var a=this._getIndex(this._selected[this._selected.length-1]);
                    var b=this._getIndex(node);
                    if (b<a) { var c=a; a=b; b=c; }
                    for (var i=a; i<=b; i++)
                        if (!node.parentObject.childNodes[i].i_sel)
                            this._markItem(node.parentObject.childNodes[i]);
                    }
                else
//#}
//#}
					this._markItem(node);
		if (this.checkEvent("onSelect")) {
		   	var z=this.getSelectedItemId();
			if (z!=this._onSSCFold)
				this.callEvent("onSelect",[z]);
		}
    }
    dhtmlXTreeObject.prototype._markItem=function(node){
              if (node.scolor)  node.span.style.color=node.scolor;
              node.span.className = "selectedTreeRow";
              node.span.parentNode.parentNode.className = "selectedTreeRowFull";
             node.i_sel=true;
             this._selected[this._selected.length]=node;
    }

/**
*     @desc: retun node index in children collection by Id
*     @type: public
*     @param: itemId - node id
*     @return: node index
*     @topic: 2
*/
   dhtmlXTreeObject.prototype.getIndexById=function(itemId){
         var z=this._globalIdStorageFind(itemId);
         if (!z) return null;
         return this._getIndex(z);
   };
   dhtmlXTreeObject.prototype._getIndex=function(w){
        var z=w.parentObject;
        for (var i=0; i<z.childsCount; i++)
            if (z.childNodes[i]==w) return i;
   };





/**
*     @desc: visual unselect item in tree
*     @type: private
*     @param: node - tree item object
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype._unselectItem=function(node){
        if ((node)&&(node.i_sel))
            {

          node.span.className="standartTreeRow";
          node.span.parentNode.parentNode.className = "";
          if (node.acolor)  node.span.style.color=node.acolor;
            node.i_sel=false;
            for (var i=0; i<this._selected.length; i++)
                    if (!this._selected[i].i_sel) {
                        this._selected.splice(i,1);
                        break;
                 }
            }
       }

/**
*     @desc: visual unselect items in tree
*     @type: private
*     @param: node - tree item object
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype._unselectItems=function(){
      for (var i=0; i<this._selected.length; i++){
            var node=this._selected[i];
         node.span.className="standartTreeRow";
         node.span.parentNode.parentNode.className = "";
          if (node.acolor)  node.span.style.color=node.acolor;
         node.i_sel=false;
         }
         this._selected=new Array();
       }


/**  
*     @desc: select node text event handler
*     @type: private
*     @param: e - event object
*     @param: htmlObject - node object     
*     @param: mode - if false - call onSelect event
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype.onRowSelect=function(e,htmlObject,mode){
      e=e||window.event;

        var obj=this.parentObject;
      if (htmlObject) obj=htmlObject.parentObject;
        var that=obj.treeNod;

        var lastId=that.getSelectedItemId();
		if ((!e)||(!e.skipUnSel))
	        that._selectItem(obj,e);

      if (!mode) {	 	
         if (obj.actionHandler) obj.actionHandler(obj.id,lastId);
		 else that.callEvent("onClick",[obj.id,lastId]);
         }
   };




   
/**
*     @desc: fix checkbox state
*     @type: private
*     @topic: 0
*/
dhtmlXTreeObject.prototype._correctCheckStates=function(dhtmlObject){
	
   if (!this.tscheck) return;
   if (!dhtmlObject) return;
   if (dhtmlObject.id==this.rootId) return;
   //calculate state
   var act=dhtmlObject.childNodes;
   var flag1=0; var flag2=0;
   if (dhtmlObject.childsCount==0) return;
   for (var i=0; i<dhtmlObject.childsCount; i++){
   	  if (act[i].dscheck) continue;
      if (act[i].checkstate==0) flag1=1;
      else if (act[i].checkstate==1) flag2=1;
         else { flag1=1; flag2=1; break; }
		 }

   if ((flag1)&&(flag2)) this._setCheck(dhtmlObject,"unsure");
   else if (flag1)  this._setCheck(dhtmlObject,false);
      else  this._setCheck(dhtmlObject,true);

      this._correctCheckStates(dhtmlObject.parentObject);
}

/**
*     @desc: checbox select action
*     @type: private
*     @topic: 0
*/   
   dhtmlXTreeObject.prototype.onCheckBoxClick=function(e){
	   	  if (!this.treeNod.callEvent("onBeforeCheck",[this.parentObject.id,this.parentObject.checkstate]))
	   	  	return;
   	  
      if (this.parentObject.dscheck) return true;
      if (this.treeNod.tscheck)
         if (this.parentObject.checkstate==1) this.treeNod._setSubChecked(false,this.parentObject);
         else this.treeNod._setSubChecked(true,this.parentObject);
      else
         if (this.parentObject.checkstate==1) this.treeNod._setCheck(this.parentObject,false);
         else this.treeNod._setCheck(this.parentObject,true);
      this.treeNod._correctCheckStates(this.parentObject.parentObject);

      return this.treeNod.callEvent("onCheck",[this.parentObject.id,this.parentObject.checkstate]);
   };
/**
*     @desc: create HTML elements for tree node
*     @type: private
*     @param: acheck - enable/disable checkbox
*     @param: itemObject - item object
*     @param: mode - mode
*     @topic: 0
*/
dhtmlXTreeObject.prototype._createItem=function(acheck,itemObject,mode){
	
	var table=document.createElement('table');
	table.cellSpacing = 0;
	table.cellPadding = 0;
	table.border = 0;
	
	if (this.hfMode) table.style.tableLayout="fixed";
	table.style.margin = 0;
	table.style.padding = 0;
	
	var tbody=document.createElement('tbody');
	var tr=document.createElement('tr');
	
	var td1=document.createElement('td');
	td1.className="standartTreeImage";
	
	if(this._txtimg){
		var img0=document.createElement("div");
		td1.appendChild(img0);
		img0.className="dhx_tree_textSign";
	} else {
		var img0 = this._getImg(itemObject.id);
		img0.border = "0";
		if (img0.tagName == "IMG") {
			img0.align="absmiddle";
		}
		td1.appendChild(img0);
		img0.style.padding = 0;
		img0.style.margin = 0;
    img0.style.width = this.def_line_img_x;
    //img0.style.height = this.def_line_img_y;
	}
	
	var td11=document.createElement('td');
	//         var inp=document.createElement("input");            inp.type="checkbox"; inp.style.width="12px"; inp.style.height="12px";
	var inp=this._getImg(this.cBROf?this.rootId:itemObject.id);
	inp.checked=0; this._setSrc(inp,this.imPath+this.checkArray[0]); inp.style.width="18px"; inp.style.height="18px";
	//can cause problems with hide/show check
	
	if (!acheck) td11.style.display="none";
	
	// td11.className="standartTreeImage";
	//if (acheck)
	td11.appendChild(inp);
	if ((!this.cBROf)&&(inp.tagName=="IMG")) inp.align="absmiddle";
	inp.onclick=this.onCheckBoxClick;
	inp.treeNod=this;
	inp.parentObject=itemObject;
	if (!window._KHTMLrv) td11.width="20px";
	else td11.width="16px";
	
	var td12=document.createElement('td');
	td12.className="standartTreeImage";
	var img=this._getImg(this.timgen?itemObject.id:this.rootId);
	img.onmousedown=this._preventNsDrag; img.ondragstart=this._preventNsDrag;
	img.border="0";
	if (this._aimgs){
		img.parentObject=itemObject;
		if (img.tagName=="IMG") img.align="absmiddle";
	img.onclick=this.onRowSelect; }
	if (!mode) this._setSrc(img,this.iconURL+this.imageArray[0]);
	td12.appendChild(img); img.style.padding=0; img.style.margin=0;
	if (this.timgen)
	{  
	td12.style.width=img.style.width=this.def_img_x; img.style.height=this.def_img_y; }
	else
	{
                img.style.width="0px"; img.style.height="0px";
                if (_isOpera || window._KHTMLrv )    td12.style.display="none";
        }
        
        
        var td2=document.createElement('td');
        td2.className="dhxTextCell standartTreeRow";
        
        itemObject.span=document.createElement('span');
        itemObject.span.className="standartTreeRow";
        if (this.mlitems) {
        	itemObject.span.style.width=this.mlitems;
        	//	if (!_isIE)
        	itemObject.span.style.display="block";
        }
        else td2.noWrap=true;
        if (dhx4.isIE8) td2.style.width="99999px";
        else if (!window._KHTMLrv) td2.style.width="100%";
        
        //      itemObject.span.appendChild(document.createTextNode(itemObject.label));
        itemObject.span.innerHTML=itemObject.label;
        td2.appendChild(itemObject.span);
        td2.parentObject=itemObject;        td1.parentObject=itemObject;
        td2.onclick=this.onRowSelect; td1.onclick=this.onRowClick; td2.ondblclick=this.onRowClick2;
        if (this.ettip)
        	tr.title=itemObject.label;
        
        if (this.dragAndDropOff) {
        	if (this._aimgs) { this.dragger.addDraggableItem(td12,this); td12.parentObject=itemObject; }
        	this.dragger.addDraggableItem(td2,this);
        }
        
        itemObject.span.style.paddingLeft="5px";      itemObject.span.style.paddingRight="5px";   td2.style.verticalAlign="";
        td2.style.fontSize="10pt";       td2.style.cursor=this.style_pointer;
        tr.appendChild(td1);            tr.appendChild(td11);            tr.appendChild(td12);
        tr.appendChild(td2);
        tbody.appendChild(tr);
        table.appendChild(tbody);
        
        if (this.ehlt || this.checkEvent("onMouseIn") || this.checkEvent("onMouseOut")){//highlighting
		tr.onmousemove=this._itemMouseIn;
		tr[(_isIE)?"onmouseleave":"onmouseout"]=this._itemMouseOut;
	}
	return table;
};
   

/**  
*     @desc: set path to images directory
*     @param: newPath - path to images directory (related to the page with tree or absolute http url)
*     @type: public
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.setImagePath=function( newPath ){ this.imPath=newPath; this.iconURL=newPath; };
    /**
	*   @desc: set path to external images used as tree icons
	*   @type: public
	*   @param: path - url (or relative path) of images folder with closing "/"
	*   @topic: 0,7
	*/
	dhtmlXTreeObject.prototype.setIconPath=function(path){
		this.iconURL=path;
	}	   

//#__pro_feature:01112006{
//#child_calc:01112006{

/**
*     @desc: return count of leafs
*     @param: itemNode -  node object
*     @type: private
*     @edition: Professional
*     @topic: 4
*/
   dhtmlXTreeObject.prototype._getLeafCount=function(itemNode){
      var a=0;
      for (var b=0; b<itemNode.childsCount; b++)
         if (itemNode.childNodes[b].childsCount==0) a++;
      return a;
   }

/**
*     @desc: get value of child counter (child counter must be enabled)
*     @type: private
*     @param: itemId - id of selected item
*     @edition: Professional
*     @return: counter value (related to counter mode)
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getChildCounterValue=function(itemId){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      if ((temp.unParsed)||((!temp.XMLload)&&(this.XMLsource)))
      return temp._acc
      switch(this.childCalc)
      {
         case 1: return temp.childsCount; break;
         case 2: return this._getLeafCount(temp); break;
         case 3: return temp._acc; break;
         case 4: return temp._acc; break;
      }
   }

  /**
*     @desc: fix node child counter
*     @param: itemNode -  node object
*     @type: private
*     @edition: Professional
*     @topic: 4
*/
   dhtmlXTreeObject.prototype._fixChildCountLabel=function(itemNode,index){
      if (this.childCalc==null) return;
      if ((itemNode.unParsed)||((!itemNode.XMLload)&&(this.XMLsource)))
      {
         if (itemNode._acc)
         itemNode.span.innerHTML=itemNode.label+this.htmlcA+itemNode._acc+this.htmlcB;
         else
         itemNode.span.innerHTML=itemNode.label;

      return;
      }

      switch(this.childCalc){
         case 1:
            if (itemNode.childsCount!=0)
               itemNode.span.innerHTML=itemNode.label+this.htmlcA+itemNode.childsCount+this.htmlcB;
            else itemNode.span.innerHTML=itemNode.label;
            break;
         case 2:
            var z=this._getLeafCount(itemNode);
            if (z!=0)
               itemNode.span.innerHTML=itemNode.label+this.htmlcA+z+this.htmlcB;
            else itemNode.span.innerHTML=itemNode.label;
            break;
         case 3:
            if (itemNode.childsCount!=0)
               {
               var bcc=0;
               for (var a=0; a<itemNode.childsCount; a++)   {
                  if (!itemNode.childNodes[a]._acc) itemNode.childNodes[a]._acc=0;
                  bcc+=itemNode.childNodes[a]._acc*1;      }
                  bcc+=itemNode.childsCount*1;

               itemNode.span.innerHTML=itemNode.label+this.htmlcA+bcc+this.htmlcB;
               itemNode._acc=bcc;
               }
            else { itemNode.span.innerHTML=itemNode.label;   itemNode._acc=0; }
            if ((itemNode.parentObject)&&(itemNode.parentObject!=this.htmlNode))
               this._fixChildCountLabel(itemNode.parentObject);
            break;
         case 4:
            if (itemNode.childsCount!=0)
               {
               var bcc=0;
               for (var a=0; a<itemNode.childsCount; a++)   {
                  if (!itemNode.childNodes[a]._acc) itemNode.childNodes[a]._acc=1;
                  bcc+=itemNode.childNodes[a]._acc*1;      }

               itemNode.span.innerHTML=itemNode.label+this.htmlcA+bcc+this.htmlcB;
               itemNode._acc=bcc;
               }
            else { itemNode.span.innerHTML=itemNode.label;   itemNode._acc=1; }
            if ((itemNode.parentObject)&&(itemNode.parentObject!=this.htmlNode))
               this._fixChildCountLabel(itemNode.parentObject);
            break;
      }
   }

/**
*     @desc: set children calculation mode
*     @param: mode - mode name as string . Possible values: child - children, no recursive; leafs - children without subchildren, no recursive;  ,childrec - children, recursive; leafsrec - children without subchildren, recursive; disabled (disabled by default)
*     @type: public
*     @edition: Professional
*     @topic: 0
*/ 
   dhtmlXTreeObject.prototype.setChildCalcMode=function( mode ){
      switch(mode){
         case "child": this.childCalc=1; break;
         case "leafs": this.childCalc=2; break;
         case "childrec": this.childCalc=3; break;
         case "leafsrec": this.childCalc=4; break;
         case "disabled": this.childCalc=null; break;
         default: this.childCalc=4;
      }
    }
/**
*     @desc: set children calculation prefix and postfix
*     @param: htmlA - postfix ([ - by default)
*     @param: htmlB - postfix (] - by default)
*     @type: public
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.setChildCalcHTML=function( htmlA,htmlB ){
      this.htmlcA=htmlA;      this.htmlcB=htmlB;
    }
//#}
//#}

/**
*     @desc: set function called when tree node selected
*     @param: (function) func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event: onRightClick
*     @depricated: use grid.attachEvent("onRightClick",func); instead
*     @eventdesc:  Event occurs after right mouse button was clicked.
         Assigning this handler can disable default context menu, and incompattible with dhtmlXMenu integration.
*     @eventparam: (string) ID of clicked item
*     @eventparam: (object) event object
*/
   dhtmlXTreeObject.prototype.setOnRightClickHandler=function(func){  this.attachEvent("onRightClick",func);   };

/**
*     @desc: set function called when tree node clicked, also can be forced to call from API
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event: onClick
*     @depricated: use grid.attachEvent("onClick",func); instead
*     @eventdesc: Event raises immideatly after text part of item in tree was clicked, but after default onClick functionality was processed.
              Richt mouse button click can be catched by onRightClick event handler.
*     @eventparam:  ID of clicked item
*     @eventparam:  ID of previously selected item
*/
   dhtmlXTreeObject.prototype.setOnClickHandler=function(func){  this.attachEvent("onClick",func);  };

/**
*     @desc: set function called when tree node selected or unselected, include any select change caused by any functionality
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event: onSelect
*     @depricated: use grid.attachEvent("onSelect",func); instead
*     @eventdesc: Event raises immideatly after selection in tree was changed
*     @eventparam:  selected item ID ( list of IDs in case of multiselection)
*/
   dhtmlXTreeObject.prototype.setOnSelectStateChange=function(func){  this.attachEvent("onSelect",func); };


/**
*     @desc: enables dynamic loading from XML
*     @type: public
*     @param: filePath - name of script returning XML; in case of virtual loading - user defined function
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype.setXMLAutoLoading=function(filePath){  this.XMLsource=filePath; };

   /**
*     @desc: set function called before checkbox checked/unchecked
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event: onCheck
*     @depricated: use tree.attachEvent("onCheck",func); instead
*     @eventdesc: Event raises right before item in tree was checked/unchecked. can be canceled (return false from event handler)
*     @eventparam: ID of item which will be checked/unchecked
*     @eventparam: Current checkbox state. 1 - item checked, 0 - item unchecked.
*		@eventreturn: true - confirm changing checked state; false - deny chaning checked state;
*/
   dhtmlXTreeObject.prototype.setOnCheckHandler=function(func){ this.attachEvent("onCheck",func);  };


/**
*     @desc: set function called before tree node opened/closed
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event:  onOpen
*     @depricated: use grid.attachEvent("onOpenStart",func); instead
*     @eventdesc: Event raises immideatly after item in tree got command to open/close , and before item was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
            Event does not occur if node was opened by dhtmlXtree API.
*     @eventparam: ID of node which will be opened/closed
*     @eventparam: Current open state of tree item. 0 - item has not children, -1 - item closed, 1 - item opened.
*     @eventreturn: true - confirm opening/closing; false - deny opening/closing;
*/
   dhtmlXTreeObject.prototype.setOnOpenHandler=function(func){  this.attachEvent("onOpenStart",func);   };
/**
*     @desc: set function called before tree node opened/closed
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event:  onOpenStart
*     @depricated: use grid.attachEvent("onOpenStart",func); instead
*     @eventdesc: Event raises immideatly after item in tree got command to open/close , and before item was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
            Event not raised if node opened by dhtmlXtree API.
*     @eventparam: ID of node which will be opened/closed
*     @eventparam: Current open state of tree item. 0 - item has not children, -1 - item closed, 1 - item opened.
*     @eventreturn: true - confirm opening/closing; false - deny opening/closing;
*/
   dhtmlXTreeObject.prototype.setOnOpenStartHandler=function(func){  this.attachEvent("onOpenStart",func);    };

/**
*     @desc: set function called after tree node opened/closed
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event:  onOpenEnd
*     @depricated: use grid.attachEvent("onOpenEnd",func); instead
*     @eventdesc: Event raises immideatly after item in tree was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
            Event not raised if node opened by dhtmlXtree API.
*     @eventparam: ID of node which will be opened/closed
*     @eventparam: Current open state of tree item. 0 - item has not children, -1 - item closed, 1 - item opened.
*/
   dhtmlXTreeObject.prototype.setOnOpenEndHandler=function(func){  this.attachEvent("onOpenEnd",func);  };

   /**
*     @desc: set function called when tree node double clicked
*     @param: func - event handling function
*     @type: public
*     @topic: 0,7
*     @event: onDblClick
*     @depricated: use grid.attachEvent("onDblClick",func); instead
*     @eventdesc: Event raised immideatly after item in tree was doubleclicked, before default onDblClick functionality was processed.
         Beware using both onClick and onDblClick events, because component can  generate onClick event before onDblClick event while doubleclicking item in tree.
         ( that behavior depend on used browser )
*     @eventparam:  ID of item which was doubleclicked
*     @eventreturn:  true - confirm opening/closing; false - deny opening/closing;
*/
   dhtmlXTreeObject.prototype.setOnDblClickHandler=function(func){ this.attachEvent("onDblClick",func);   };









   /**
*     @desc: expand target node and all sub nodes
*     @type: public
*     @param: itemId - node id
*     @topic: 4
*/
   dhtmlXTreeObject.prototype.openAllItems=function(itemId)
   {
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      this._xopenAll(temp);
   };
   
/**
*     @desc: return open/close state
*     @type: public
*     @param: itemId - node id
*     @return: -1 - close, 1 - opened, 0 - node doesn't have children
*     @topic: 4
*/   
   dhtmlXTreeObject.prototype.getOpenState=function(itemId){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return "";
      return this._getOpenState(temp);
   };

/**  
*     @desc: collapse target node and all sub nodes
*     @type: public
*     @param: itemId - node id
*     @topic: 4  
*/
   dhtmlXTreeObject.prototype.closeAllItems=function(itemId)
   {
        if (itemId===window.undefined) itemId=this.rootId;
        
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      this._xcloseAll(temp);

//nb:solves standard doctype prb in IE
         this.allTree.childNodes[0].border = "1";
       this.allTree.childNodes[0].border = "0";

   };
   
   
/**
*     @desc: set user data for target node
*     @type: public
*     @param: itemId - target node id
*     @param: name - key for user data
*     @param: value - user data value
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.setUserData=function(itemId,name,value){
      var sNode=this._globalIdStorageFind(itemId,0,true);
         if (!sNode) return;
         if(name=="hint")
			 sNode.htmlNode.childNodes[0].childNodes[0].title=value;
            if (typeof(sNode.userData["t_"+name])=="undefined"){
                 if (!sNode._userdatalist) sNode._userdatalist=name;
                else sNode._userdatalist+=","+name;
            }
            sNode.userData["t_"+name]=value;
   };
   
/**  
*     @desc: get user data from target node
*     @type: public
*     @param: itemId - target node id
*     @param: name - key for user data
*     @return: value of user data
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.getUserData=function(itemId,name){
      var sNode=this._globalIdStorageFind(itemId,0,true);
      if (!sNode) return;
      return sNode.userData["t_"+name];
   };




/**
*     @desc: get node color (text color)
*     @param: itemId - id of node
*     @type: public
*     @return: color of node (empty string for default color);
*     @topic: 6  
*/   
   dhtmlXTreeObject.prototype.getItemColor=function(itemId)
   {
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;

      var res= new Object();
      if (temp.acolor) res.acolor=temp.acolor;
      if (temp.scolor) res.scolor=temp.scolor;      
      return res;
   };
/**  
*     @desc: set node text color
*     @param: itemId - id of node
*     @param: defaultColor - node color
*     @param: selectedColor - selected node color
*     @type: public
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.setItemColor=function(itemId,defaultColor,selectedColor)
   {
      if ((itemId)&&(itemId.span))
         var temp=itemId;
      else
         var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
         else {
         if (temp.i_sel)
            {  if (selectedColor || defaultColor) temp.span.style.color=selectedColor || defaultColor; }
         else
            {  if (defaultColor) temp.span.style.color=defaultColor;  }

         if (selectedColor) temp.scolor=selectedColor;
         if (defaultColor) temp.acolor=defaultColor;
         }
   };

/**
*     @desc: return node text
*     @param: itemId - id of node
*     @type: public
*     @return: text of item (with HTML formatting, if any)
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.getItemText=function(itemId)
   {
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      return(temp.htmlNode.childNodes[0].childNodes[0].childNodes[3].childNodes[0].innerHTML);
   };
/**  
*     @desc: return parent item id
*     @param: itemId - id of node
*     @type: public
*     @return: id of parent item
*     @topic: 4
*/         
   dhtmlXTreeObject.prototype.getParentId=function(itemId)
   {
      var temp=this._globalIdStorageFind(itemId);
      if ((!temp)||(!temp.parentObject)) return "";
      return temp.parentObject.id;
   };



/**  
*     @desc: change item id
*     @type: public
*     @param: itemId - old node id
*     @param: newItemId - new node id        
*     @topic: 4
*/    
   dhtmlXTreeObject.prototype.changeItemId=function(itemId,newItemId)
   {
   	if (itemId==newItemId) return;
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
        temp.id=newItemId;
        temp.span.contextMenuId=newItemId;
        this._idpull[newItemId]=this._idpull[itemId];
        delete this._idpull[itemId];
   };


/**
*     @desc: mark selected item as cut
*     @type: public
*     @topic: 2  
*/    
   dhtmlXTreeObject.prototype.doCut=function(){
      if (this.nodeCut) this.clearCut();
      this.nodeCut=(new Array()).concat(this._selected);
        for (var i=0; i<this.nodeCut.length; i++){
          var tempa=this.nodeCut[i];
            tempa._cimgs=new Array();
          tempa._cimgs[0]=tempa.images[0];
          tempa._cimgs[1]=tempa.images[1];
          tempa._cimgs[2]=tempa.images[2];
          tempa.images[0]=tempa.images[1]=tempa.images[2]=this.cutImage;
          this._correctPlus(tempa);
        }
   };

/**
*     @desc: insert previously cut branch
*     @param: itemId - id of new parent node
*     @type: public
*     @topic: 2  
*/    
   dhtmlXTreeObject.prototype.doPaste=function(itemId){
      var tobj=this._globalIdStorageFind(itemId);
      if (!tobj) return 0;
        for (var i=0; i<this.nodeCut.length; i++){
               if (this._checkPNodes(tobj,this.nodeCut[i])) continue;
                this._moveNode(this.nodeCut[i],tobj);
               }
      this.clearCut();
   };

/**  
*     @desc: clear cut
*     @type: public
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype.clearCut=function(){
      for (var i=0; i<this.nodeCut.length; i++)
         {
          var tempa=this.nodeCut[i];
          tempa.images[0]=tempa._cimgs[0];
          tempa.images[1]=tempa._cimgs[1];
          tempa.images[2]=tempa._cimgs[2];
          this._correctPlus(tempa);
         }
          this.nodeCut=new Array();
   };
   


   /**  
*     @desc: move node with subnodes
*     @type: private
*     @param: itemObject - moved node object
*     @param: targetObject - new parent node
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype._moveNode=function(itemObject,targetObject){
//#__pro_feature:01112006{
//#complex_move:01112006{
      var mode=this.dadmodec;
      if (mode==1)
        {
            var z=targetObject;
         if (this.dadmodefix<0)
         {

                while (true){
            z=this._getPrevNode(z);
            if ((z==-1)) { z=this.htmlNode; break; }
                if ((z.tr==0)||(z.tr.style.display=="")||(!z.parentObject)) break;
                }

                var nodeA=z;
                var nodeB=targetObject;

            }
            else
            {
				if ((z.tr)&&(z.tr.nextSibling)&&(z.tr.nextSibling.nodem)&&(this._getOpenState(z)<1)){
  				 	z = z.tr.nextSibling.nodem;
				}
           		else{
					if(this._getOpenState(z)<1)
						z=this.htmlNode;
					else{
						z=this._getNextNode(z);
						if ((z==-1)) z=this.htmlNode;
					}

				}
				
                var nodeB=z;
                var nodeA=targetObject;
            }


            if (this._getNodeLevel(nodeA,0)>this._getNodeLevel(nodeB,0))
                {
                if (!this.dropLower)
                    return this._moveNodeTo(itemObject,nodeA.parentObject);
                else
                    if  (nodeB.id!=this.rootId)
                        return this._moveNodeTo(itemObject,nodeB.parentObject,nodeB);
                    else
                        return this._moveNodeTo(itemObject,this.htmlNode,null);
                }
            else
                {
                return this._moveNodeTo(itemObject,nodeB.parentObject,nodeB);
                }


      }
      else
//#}
//#}
	  return this._moveNodeTo(itemObject,targetObject);

   }

   /**
*     @desc: fix order of nodes in collection
*     @type: private
*     @param: target - parent item node
*     @param: zParent - before node
*     @edition: Professional
*     @topic: 2
*/

dhtmlXTreeObject.prototype._fixNodesCollection=function(target,zParent){
      var flag=0; var icount=0;
      var Nodes=target.childNodes;
      var Count=target.childsCount-1;

      if (zParent==Nodes[Count]) return;
      for (var i=0; i<Count; i++)
         if (Nodes[i]==Nodes[Count]) {  Nodes[i]=Nodes[i+1]; Nodes[i+1]=Nodes[Count]; }

//         Count=target.childsCount;
      for (var i=0; i<Count+1; i++)      
         {
         if (flag) { 
            var temp=Nodes[i];
            Nodes[i]=flag; 
            flag=temp; 
               }
         else 
         if (Nodes[i]==zParent) {   flag=Nodes[i]; Nodes[i]=Nodes[Count];  }
         }
   };
   
/**  
*     @desc: recreate branch
*     @type: private
*     @param: itemObject - moved node object
*     @param: targetObject - new parent node
*     @param: level - top level flag
*     @param: beforeNode - node for sibling mode
*     @mode: mode - DragAndDrop mode (0 - as child, 1 as sibling)
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype._recreateBranch=function(itemObject,targetObject,beforeNode,level){
    var i; var st="";
    if (beforeNode){
    for (i=0; i<targetObject.childsCount; i++)
        if (targetObject.childNodes[i]==beforeNode) break;

    if (i!=0)
        beforeNode=targetObject.childNodes[i-1];
    else{
        st="TOP";
        beforeNode="";
        }
    }

   var t2=this._onradh; this._onradh=null;
   var newNode=this._attachChildNode(targetObject,itemObject.id,itemObject.label,0,itemObject.images[0],itemObject.images[1],itemObject.images[2],st,0,beforeNode);

   //copy user data
   newNode._userdatalist=itemObject._userdatalist;
   newNode.userData=itemObject.userData.clone();
   if(itemObject._attrs){
	   newNode._attrs={};
	   for(var attr in itemObject._attrs)
		   newNode._attrs[attr] = itemObject._attrs[attr];
	}

   newNode.XMLload=itemObject.XMLload;
   if (t2){
   	this._onradh=t2; this._onradh(newNode.id); }

//#__pro_feature:01112006{
//#smart_parsing:01112006{
   //copy unparsed chunk
      if (itemObject.treeNod.dpcpy) itemObject.treeNod._globalIdStorageFind(itemObject.id);
      else newNode.unParsed=itemObject.unParsed;
      this._correctPlus(newNode);
      //this._correctLine(newNode);
   
//#}
//#}
   for (var i=0; i<itemObject.childsCount; i++)
      this._recreateBranch(itemObject.childNodes[i],newNode,0,1);

//#__pro_feature:01112006{
//#child_calc:01112006{
      if ((!level)&&(this.childCalc)) { this._redrawFrom(this,targetObject);  }
//#}
//#}
   return newNode;
}

/**
*     @desc: move single node
*     @type: private
*     @param: itemObject - moved node object
*     @param: targetObject - new parent node
*     @mode: mode - DragAndDrop mode (0 - as child, 1 as sibling)
*     @topic: 2
*/
   dhtmlXTreeObject.prototype._moveNodeTo=function(itemObject,targetObject,beforeNode){
    //return;
    if   (itemObject.treeNod._nonTrivialNode)
        return itemObject.treeNod._nonTrivialNode(this,targetObject,beforeNode,itemObject);

	if (this._checkPNodes(targetObject,itemObject))
   		return false;
                           		
    if    (targetObject.mytype)
       var framesMove=(itemObject.treeNod.lWin!=targetObject.lWin);
    else
          var framesMove=(itemObject.treeNod.lWin!=targetObject.treeNod.lWin);

   if (!this.callEvent("onDrag",[itemObject.id,targetObject.id,(beforeNode?beforeNode.id:null),itemObject.treeNod,targetObject.treeNod])) return false;
      if ((targetObject.XMLload==0)&&(this.XMLsource))
         {
         targetObject.XMLload=1;
            this._loadDynXML(targetObject.id);
         }
	this.openItem(targetObject.id);

   var oldTree=itemObject.treeNod;
   var c=itemObject.parentObject.childsCount;
   var z=itemObject.parentObject;
   

   if ((framesMove)||(oldTree.dpcpy)) {//interframe drag flag
        var _otiid=itemObject.id;
      itemObject=this._recreateBranch(itemObject,targetObject,beforeNode);
        if (!oldTree.dpcpy) oldTree.deleteItem(_otiid);
        }
   else
      {
	
      var Count=targetObject.childsCount; var Nodes=targetObject.childNodes;
      	   	if (Count==0) targetObject._open=true;
      		oldTree._unselectItem(itemObject);
           Nodes[Count]=itemObject;
            itemObject.treeNod=targetObject.treeNod;
            targetObject.childsCount++;         
			
            var tr=this._drawNewTr(Nodes[Count].htmlNode);

            if (!beforeNode)
               {
                  targetObject.htmlNode.childNodes[0].appendChild(tr);
               if (this.dadmode==1) this._fixNodesCollection(targetObject,beforeNode);
               }
            else
               {
               targetObject.htmlNode.childNodes[0].insertBefore(tr,beforeNode.tr);
               this._fixNodesCollection(targetObject,beforeNode);
               Nodes=targetObject.childNodes;
               }

			
         }

            if ((!oldTree.dpcpy)&&(!framesMove))   {
                var zir=itemObject.tr;

                if ((document.all)&&(navigator.appVersion.search(/MSIE\ 5\.0/gi)!=-1))
                    {
                    window.setTimeout(function() { zir.parentNode.removeChild(zir); } , 250 );
                    }
                else   //if (zir.parentNode) zir.parentNode.removeChild(zir,true);

                itemObject.parentObject.htmlNode.childNodes[0].removeChild(itemObject.tr);

                //itemObject.tr.removeNode(true);
            if ((!beforeNode)||(targetObject!=itemObject.parentObject)){
               for (var i=0; i<z.childsCount; i++){
                  if (z.childNodes[i].id==itemObject.id) {
                  z.childNodes[i]=0;
                  break;            }}}
               else z.childNodes[z.childsCount-1]=0;

            oldTree._compressChildList(z.childsCount,z.childNodes);
            z.childsCount--;
            }


      if ((!framesMove)&&(!oldTree.dpcpy)) {
       itemObject.tr=tr;
      tr.nodem=itemObject;
      itemObject.parentObject=targetObject;

      if (oldTree!=targetObject.treeNod) {
	    if(itemObject.treeNod._registerBranch(itemObject,oldTree)) return;      this._clearStyles(itemObject);  this._redrawFrom(this,itemObject.parentObject);
		if(this._onradh) this._onradh(itemObject.id);
		   };

      this._correctPlus(targetObject);
      this._correctLine(targetObject);

      this._correctLine(itemObject);
      this._correctPlus(itemObject);

         //fix target siblings
      if (beforeNode)
      {

         this._correctPlus(beforeNode);
         //this._correctLine(beforeNode);
      }
      else 
      if (targetObject.childsCount>=2)
      {

         this._correctPlus(Nodes[targetObject.childsCount-2]);
         this._correctLine(Nodes[targetObject.childsCount-2]);
      }
      
      this._correctPlus(Nodes[targetObject.childsCount-1]);
      //this._correctLine(Nodes[targetObject.childsCount-1]);


      if (this.tscheck) this._correctCheckStates(targetObject);
      if (oldTree.tscheck) oldTree._correctCheckStates(z);

      }

      //fix source parent

      if (c>1) { oldTree._correctPlus(z.childNodes[c-2]);
               oldTree._correctLine(z.childNodes[c-2]);
               }


//      if (z.childsCount==0)
          oldTree._correctPlus(z);
            oldTree._correctLine(z);

//#__pro_feature:01112006{
//#child_calc:01112006{
      this._fixChildCountLabel(targetObject);
      oldTree._fixChildCountLabel(z);
//#}
//#}
      this.callEvent("onDrop",[itemObject.id,targetObject.id,(beforeNode?beforeNode.id:null),oldTree,targetObject.treeNod]);
      return itemObject.id;
   };

   

/**
*     @desc: recursive set default styles for node
*     @type: private
*     @param: itemObject - target node object
*     @topic: 6  
*/   
   dhtmlXTreeObject.prototype._clearStyles=function(itemObject){
   		if (!itemObject.htmlNode) return; //some weird case in SRND mode
         var td1=itemObject.htmlNode.childNodes[0].childNodes[0].childNodes[1];
         var td3=td1.nextSibling.nextSibling;

         itemObject.span.innerHTML=itemObject.label;
		 itemObject.i_sel=false;

   		 if (itemObject._aimgs)
	         this.dragger.removeDraggableItem(td1.nextSibling);

         if (this.checkBoxOff) {
		 	td1.childNodes[0].style.display="";
			td1.childNodes[0].onclick=this.onCheckBoxClick;
			this._setSrc(td1.childNodes[0],this.imPath+this.checkArray[itemObject.checkstate]);
			}
         else td1.style.display="none";
         td1.childNodes[0].treeNod=this;

         this.dragger.removeDraggableItem(td3);
         if (this.dragAndDropOff) this.dragger.addDraggableItem(td3,this);
		 if (this._aimgs) this.dragger.addDraggableItem(td1.nextSibling,this);
		 		 
         td3.childNodes[0].className="standartTreeRow";
         td3.parentNode.className = "";
         td3.onclick=this.onRowSelect; td3.ondblclick=this.onRowClick2;
         td1.previousSibling.onclick=this.onRowClick;

         this._correctLine(itemObject);
         this._correctPlus(itemObject);
         for (var i=0; i<itemObject.childsCount; i++) this._clearStyles(itemObject.childNodes[i]); 

   };
/**
*     @desc: register node and all children nodes
*     @type: private
*     @param: itemObject - node object
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype._registerBranch=function(itemObject,oldTree){
      if (oldTree) oldTree._globalIdStorageSub(itemObject.id);
      itemObject.id=this._globalIdStorageAdd(itemObject.id,itemObject);
      itemObject.treeNod=this;
         for (var i=0; i<itemObject.childsCount; i++)
            this._registerBranch(itemObject.childNodes[i],oldTree);
      return 0;
   };

   
/**  
*     @desc: enable three state checkboxes
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype.enableThreeStateCheckboxes=function(mode) { this.tscheck=dhx4.s2b(mode); };


/**
*     @desc: set function called when mouse is over tree node
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event: onMouseIn
*     @depricated: use grid.attachEvent("onMouseIn",func); instead
*     @eventdesc: Event raised immideatly after mouse started moving over item
*     @eventparam:  ID of item
*/
   dhtmlXTreeObject.prototype.setOnMouseInHandler=function(func){
    	this.ehlt=true;
   		this.attachEvent("onMouseIn",func);
	};

/**
*     @desc: set function called when mouse is out of tree node
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event: onMouseOut
*     @depricated: use grid.attachEvent("onMouseOut",func); instead
*     @eventdesc: Event raised immideatly after mouse moved out of item
*     @eventparam:  ID of clicked item
*/
   dhtmlXTreeObject.prototype.setOnMouseOutHandler=function(func){
		this.ehlt=true;
   		this.attachEvent("onMouseOut",func);
	};





//#__pro_feature:01112006{
/**
*     @desc: enable drag without removing (copy instead of move)
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @edition:Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableMercyDrag=function(mode){ this.dpcpy=dhx4.s2b(mode); };
//#}



/**
*     @desc: enable tree images
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @topic: 0  
*/         
   dhtmlXTreeObject.prototype.enableTreeImages=function(mode) { this.timgen=dhx4.s2b(mode); };
   

   
/**
*     @desc: enable mode with fixed tables (looks better, but has no horisontal scrollbar)
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: private
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype.enableFixedMode=function(mode) { this.hfMode=dhx4.s2b(mode); };
   
/**  
*     @desc: show/hide checkboxes (all checkboxes in tree)
*     @type: public
*     @param: mode - true/false
*     @param: hidden - if set to true, checkboxes not rendered but can be shown by showItemCheckbox
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype.enableCheckBoxes=function(mode, hidden){ this.checkBoxOff=dhx4.s2b(mode); this.cBROf=(!(this.checkBoxOff||dhx4.s2b(hidden))); 
   	};
/**
*     @desc: set default images for nodes (must be called before XML loading)
*     @type: public
*     @param: a0 - image for node without children;
*     @param: a1 - image for closed node;
*     @param: a2 - image for opened node                  
*     @topic: 6  
*/
   dhtmlXTreeObject.prototype.setStdImages=function(image1,image2,image3){
                  this.imageArray[0]=image1; this.imageArray[1]=image2; this.imageArray[2]=image3;};

/**
*     @desc: enable/disable tree lines (parent-child threads)
*     @type: public
*     @param: mode - enable/disable tree lines
*     @topic: 6
*/                  
   dhtmlXTreeObject.prototype.enableTreeLines=function(mode){
      this.treeLinesOn=dhx4.s2b(mode);
   }

/**
*     @desc: set images used for parent-child threads drawing (lines, plus, minus)
*     @type: public
*     @param: arrayName - name of array: plus, minus
*     @param: image1 - line crossed image
*     @param: image2 - image with top line
*     @param: image3 - image with bottom line
*     @param: image4 - image without line
*     @param: image5 - single root image
*     @topic: 6
*/      
   dhtmlXTreeObject.prototype.setImageArrays=function(arrayName,image1,image2,image3,image4,image5){
      switch(arrayName){
      case "plus": this.plusArray[0]=image1; this.plusArray[1]=image2; this.plusArray[2]=image3; this.plusArray[3]=image4; this.plusArray[4]=image5; break;
      case "minus": this.minusArray[0]=image1; this.minusArray[1]=image2; this.minusArray[2]=image3; this.minusArray[3]=image4;  this.minusArray[4]=image5; break;
      }
   };

/**  
*     @desc: expand node
*     @param: itemId - id of node
*     @type: public
*     @topic: 4
*/ 
   dhtmlXTreeObject.prototype.openItem=function(itemId){
     this.skipLock = true;
	   var temp=this._globalIdStorageFind(itemId);
	   if (!temp) return 0;
	   else return this._openItem(temp);
	   this.skipLock = false;
   };

/**  
*     @desc: expand node
*     @param: item - tree node object
*     @type: private
*     @editing: pro
*     @topic: 4  
*/ 
   dhtmlXTreeObject.prototype._openItem=function(item){
   		   var state=this._getOpenState(item);
		   if ((state<0)||(((this.XMLsource)&&(!item.XMLload)))){
	           if    (!this.callEvent("onOpenStart",[item.id,state])) return 0;
	           this._HideShow(item,2);
				   if    (this.checkEvent("onOpenEnd")){ 
						   if (this.onXLE==this._epnFHe) this._epnFHe(this,item.id,true);
	                       if (!this.xmlstate || !this.XMLsource)
	                       		this.callEvent("onOpenEnd",[item.id,this._getOpenState(item)]);
	                        else{
	                            this._oie_onXLE.push(this.onXLE);
	                            this.onXLE=this._epnFHe;
	                            }
							}
			   } else if (this._srnd) this._HideShow(item,2);
           if (item.parentObject && !this._skip_open_parent) this._openItem(item.parentObject);
   };
   
/**  
*     @desc: collapse node
*     @param: itemId - id of node
*     @type: public
*     @topic: 4  
*/
   dhtmlXTreeObject.prototype.closeItem=function(itemId){
	   if (this.rootId==itemId) return 0;
	   this.skipLock = true;
	   var temp=this._globalIdStorageFind(itemId);
	   if (!temp) return 0;
	   if (temp.closeble)
		   this._HideShow(temp,1);
	   this.skipLock = false;
   };
   
   

   
   
   
   
   

   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
      
/**
*     @desc: get node level (position in hierarchy)
*     @param: itemId - id of node
*     @type: public
*     @return: node level (0 if no such item in hierarchy - probably super root)
*     @topic: 4
*/
   dhtmlXTreeObject.prototype.getLevel=function(itemId){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      return this._getNodeLevel(temp,0);
   };
   
      

/**  
*     @desc: prevent node from closing
*     @param: itemId - id of node
*     @param: flag -  if 0 - node can't be closed, else node can be closed
*     @type: public
*     @topic: 4  
*/ 
   dhtmlXTreeObject.prototype.setItemCloseable=function(itemId,flag)
   {
      flag=dhx4.s2b(flag);
      if ((itemId)&&(itemId.span)) 
         var temp=itemId;
      else      
         var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
         temp.closeble=flag;
   };

   /**  
*     @desc: recursive function used for node level calculation
*     @param: itemObject - pointer to node object
*     @param: count - counter of levels        
*     @type: private
*     @topic: 4  
*/   
   dhtmlXTreeObject.prototype._getNodeLevel=function(itemObject,count){
      if (itemObject.parentObject) return this._getNodeLevel(itemObject.parentObject,count+1);
      return(count);
   };
   
   /**  
*     @desc: return number of children
*     @param: itemId - id of node
*     @type: public
*     @return: number of child items for loaded branches; true - for not loaded branches
*     @topic: 4
*/
   dhtmlXTreeObject.prototype.hasChildren=function(itemId){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      else 
         {
            if ( (this.XMLsource)&&(!temp.XMLload) ) return true;
            else 
               return temp.childsCount;
         };
   };
   

   /**
*     @desc: get number of leafs (nodes without children)
*     @param: itemNode -  node object
*     @type: private
*     @edition: Professional
*     @topic: 4
*/
   dhtmlXTreeObject.prototype._getLeafCount=function(itemNode){
      var a=0;
      for (var b=0; b<itemNode.childsCount; b++)
         if (itemNode.childNodes[b].childsCount==0) a++;
      return a;
   }

   
/**
*     @desc: set new node text (HTML allowed)
*     @param: itemId - id of node
*     @param: newLabel - node text
*     @param: newTooltip - (optional)tooltip for the node
*     @type: public
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.setItemText=function(itemId,newLabel,newTooltip)
   {
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      temp.label=newLabel;
      temp.span.innerHTML=newLabel;
//#__pro_feature:01112006{
//#child_calc:01112006{
        if (this.childCalc) this._fixChildCountLabel(temp);
//#}
//#}
	      temp.span.parentNode.parentNode.title=newTooltip||"";
   };

/**
*     @desc: get item's tooltip
*     @param: itemId - id of node
*     @type: public
*     @topic: 6
*/
    dhtmlXTreeObject.prototype.getItemTooltip=function(itemId){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return "";
	  return (temp.span.parentNode.parentNode._dhx_title||temp.span.parentNode.parentNode.title||"");
   };

/**  
*     @desc: refresh tree branch from xml (XML with child nodes rerequested from server)
*     @param: itemId - id of node, if not defined tree super root used.
*     @type: public
*     @topic: 6  
*/
   dhtmlXTreeObject.prototype.refreshItem=function(itemId){
      if (!itemId) itemId=this.rootId;
      var temp=this._globalIdStorageFind(itemId);
	  this._dynDeleteBranches[itemId] = (this._dynDeleteBranches[itemId]||0) + 1;
      this._loadDynXML(itemId);
   };

   /**  
*     @desc: set item images
*     @param: itemId - id of node
*     @param: image1 - node without children icon
*     @param: image2 - closed node icon          
*     @param: image3 - open node icon         
*     @type: public
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.setItemImage2=function(itemId, image1,image2,image3){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
            temp.images[1]=image2;
            temp.images[2]=image3;
            temp.images[0]=image1;
      this._correctPlus(temp);
   };
/**
*     @desc: set item icons (mostly usefull for childless nodes)
*     @param: itemId - id of node
*     @param: image1 - node without children icon or closed node icon (if image2 specified)
*     @param: image2 - open node icon (optional)        
*     @type: public
*     @topic: 6  
*/   
   dhtmlXTreeObject.prototype.setItemImage=function(itemId,image1,image2)
   {
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
         if (image2)
         {
            temp.images[1]=image1;
            temp.images[2]=image2;
         }
         else temp.images[0]=image1;
      this._correctPlus(temp);
   };


/**
*     @desc: Returns the list of all subitems Ids from the next level of tree, separated by commas.
*     @param: itemId - id of node
*     @type: public
*     @return: list of all subitems from the next level of tree, separated by commas.
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.getSubItems =function(itemId)
   {
      var temp=this._globalIdStorageFind(itemId,0,1);
      if (!temp) return 0;
//#__pro_feature:01112006{
//#smart_parsing:01112006{
        if(temp.unParsed)
            return (this._getSubItemsXML(temp.unParsed));
//#}
//#}
      var z="";
      for (i=0; i<temp.childsCount; i++){
         if (!z) z= ""+temp.childNodes[i].id;
            else z+=this.dlmtr+temp.childNodes[i].id;

                                                         }

      return z;
   };




/**
*     @desc: Returns the list of all sub items from all next levels of tree, separated by commas.
*     @param: itemId - id of node
*     @edition: Professional
*     @type: private
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getAllScraggyItems =function(node)
   {
      var z="";
      for (var i=0; i<node.childsCount; i++)
        {
            if ((node.childNodes[i].unParsed)||(node.childNodes[i].childsCount>0))
            {
                    if (node.childNodes[i].unParsed)
                        var zb=this._getAllScraggyItemsXML(node.childNodes[i].unParsed,1);
                    else
                       var zb=this._getAllScraggyItems(node.childNodes[i])

                 if (zb)
                        if (z) z+=this.dlmtr+zb;
                        else z=zb;
         }
            else
               if (!z) z=""+node.childNodes[i].id;
             else z+=this.dlmtr+node.childNodes[i].id;
         }
          return z;
   };





/**
*     @desc: Returns the list of all children items from all next levels of tree, separated by commas.
*     @param: itemId - id of node
*     @type: private
*     @edition: Professional
*     @topic: 6
*/

   dhtmlXTreeObject.prototype._getAllFatItems =function(node)
   {
      var z="";
      for (var i=0; i<node.childsCount; i++)
        {
            if ((node.childNodes[i].unParsed)||(node.childNodes[i].childsCount>0))
            {
             if (!z) z=""+node.childNodes[i].id;
                else z+=this.dlmtr+node.childNodes[i].id;

                    if (node.childNodes[i].unParsed)
                        var zb=this._getAllFatItemsXML(node.childNodes[i].unParsed,1);
                    else
                       var zb=this._getAllFatItems(node.childNodes[i])

                 if (zb) z+=this.dlmtr+zb;
         }
         }
          return z;
   };


/**
*     @desc: Returns the list of all children items from all next levels of tree, separated by commas.
*     @param: itemId - id of node
*     @type: private
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getAllSubItems =function(itemId,z,node)
   {
      if (node) temp=node;
      else {
      var temp=this._globalIdStorageFind(itemId);
         };
      if (!temp) return 0;

      z="";
      for (var i=0; i<temp.childsCount; i++)
         {
         if (!z) z=""+temp.childNodes[i].id;
            else z+=this.dlmtr+temp.childNodes[i].id;
         var zb=this._getAllSubItems(0,z,temp.childNodes[i])

         if (zb) z+=this.dlmtr+zb;
         }

//#__pro_feature:01112006{
//#smart_parsing:01112006{
        if (temp.unParsed)
            z=this._getAllSubItemsXML(itemId,z,temp.unParsed);
//#}
//#}
          return z;
   };




   
/**  
*     @desc: select node ( and optionaly fire onselect event)
*     @type: public
*     @param: itemId - node id
*     @param: mode - If true, script function for selected node will be called.
*     @param: preserve - preserve earlier selected nodes
*     @topic: 1
*/
   dhtmlXTreeObject.prototype.selectItem=function(itemId,mode,preserve){
      mode=dhx4.s2b(mode);
         var temp=this._globalIdStorageFind(itemId);
      if ((!temp)||(!temp.parentObject)) return 0;

            if (this.XMLloadingWarning)
                temp.parentObject.openMe=1;
            else
             	this._openItem(temp.parentObject);

      //temp.onRowSelect(0,temp.htmlNode.childNodes[0].childNodes[0].childNodes[3],mode);
        var ze=null;
        if (preserve)  {
			ze=new Object; ze.ctrlKey=true;
			if (temp.i_sel) ze.skipUnSel=true;
		}
      if (mode)
         this.onRowSelect(ze,temp.htmlNode.childNodes[0].childNodes[0].childNodes[3],false);
      else
         this.onRowSelect(ze,temp.htmlNode.childNodes[0].childNodes[0].childNodes[3],true);
   };
   
/**
*     @desc: retun selected node text
*     @type: public
*     @return: text of selected node (or list of all selected nodes text if more than one selected)
*     @topic: 1
*/
   dhtmlXTreeObject.prototype.getSelectedItemText=function()
   {
        var str=new Array();
        for (var i=0; i<this._selected.length; i++) str[i]=this._selected[i].span.innerHTML;
      return (str.join(this.dlmtr));
   };




/**  
*     @desc: correct childNode list after node deleting
*     @type: private
*     @param: Count - childNodes collection length        
*     @param: Nodes - childNodes collection
*     @topic: 4  
*/   
   dhtmlXTreeObject.prototype._compressChildList=function(Count,Nodes)
   {
      Count--;
      for (var i=0; i<Count; i++)
      {
         if (Nodes[i]==0) { Nodes[i]=Nodes[i+1]; Nodes[i+1]=0;}
      };
   };
/**  
*     @desc: delete node
*     @type: private
*     @param: itemId - target node id
*     @param: htmlObject - target node object        
*     @param: skip - node unregistration mode (optional, used by private methods)
*     @topic: 2
*/      
   dhtmlXTreeObject.prototype._deleteNode=function(itemId,htmlObject,skip){
   if ((!htmlObject)||(!htmlObject.parentObject)) return 0;
   var tempos=0; var tempos2=0;
   if (htmlObject.tr.nextSibling)  tempos=htmlObject.tr.nextSibling.nodem;
   if (htmlObject.tr.previousSibling)  tempos2=htmlObject.tr.previousSibling.nodem;
   
      var sN=htmlObject.parentObject;
      var Count=sN.childsCount;
      var Nodes=sN.childNodes;
            for (var i=0; i<Count; i++)
            {
               if (Nodes[i].id==itemId) { 
               if (!skip) sN.htmlNode.childNodes[0].removeChild(Nodes[i].tr);
               Nodes[i]=0;
               break;
               }
            }
      this._compressChildList(Count,Nodes);
      if (!skip) {
        sN.childsCount--;
                 }

      if (tempos) {
      this._correctPlus(tempos);
      this._correctLine(tempos);
               }
      if (tempos2) {
      this._correctPlus(tempos2);
      this._correctLine(tempos2);
               }
      if (this.tscheck) this._correctCheckStates(sN);

      if (!skip) {
        this._globalIdStorageRecSub(htmlObject);
                 }
   };
/**
*     @desc: set state of node's checkbox
*     @type: public
*     @param: itemId - target node id
*     @param: state - checkbox state (0/1/"unsure")
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.setCheck=function(itemId,state){
      var sNode=this._globalIdStorageFind(itemId,0,1);
      if (!sNode) return;

        if (state==="unsure")
            this._setCheck(sNode,state);
        else
        {
      state=dhx4.s2b(state);
        if ((this.tscheck)&&(this.smcheck)) this._setSubChecked(state,sNode);
      else this._setCheck(sNode,state);
        }
      if (this.smcheck)
         this._correctCheckStates(sNode.parentObject);
   };

   dhtmlXTreeObject.prototype._setCheck=function(sNode,state){
   		if (!sNode) return;
        if (((sNode.parentObject._r_logic)||(this._frbtr))&&(state))
			if (this._frbtrs){
				if (this._frbtrL)   this.setCheck(this._frbtrL.id,0);
				this._frbtrL=sNode;
			} else
    	        for (var i=0; i<sNode.parentObject.childsCount; i++)
	                this._setCheck(sNode.parentObject.childNodes[i],0);

      var z=sNode.htmlNode.childNodes[0].childNodes[0].childNodes[1].childNodes[0];

      if (state=="unsure") sNode.checkstate=2;
      else if (state) sNode.checkstate=1; else sNode.checkstate=0;
      if (sNode.dscheck) sNode.checkstate=sNode.dscheck;
      this._setSrc(z,this.imPath+((sNode.parentObject._r_logic||this._frbtr)?this.radioArray:this.checkArray)[sNode.checkstate]);
   };

/**
*     @desc: change state of node's checkbox and all children checkboxes
*     @type: public
*     @param: itemId - target node id
*     @param: state - checkbox state
*     @topic: 5
*/
dhtmlXTreeObject.prototype.setSubChecked=function(itemId,state){
   var sNode=this._globalIdStorageFind(itemId);
   this._setSubChecked(state,sNode);
   this._correctCheckStates(sNode.parentObject);
}



/**  
*     @desc: change state of node's checkbox and all childnodes checkboxes
*     @type: private
*     @param: itemId - target node id
*     @param: state - checkbox state
*     @param: sNode - target node object (optional, used by private methods)
*     @topic: 5  
*/
   dhtmlXTreeObject.prototype._setSubChecked=function(state,sNode){
      state=dhx4.s2b(state);
      if (!sNode) return;
        if (((sNode.parentObject._r_logic)||(this._frbtr))&&(state))
            for (var i=0; i<sNode.parentObject.childsCount; i++)
                this._setSubChecked(0,sNode.parentObject.childNodes[i]);

//#__pro_feature:01112006{
//#smart_parsing:01112006{
      if (sNode.unParsed)
         this._setSubCheckedXML(state,sNode.unParsed)
//#}
//#}
        if (sNode._r_logic||this._frbtr)
           this._setSubChecked(state,sNode.childNodes[0]);
        else
      for (var i=0; i<sNode.childsCount; i++)
         {
             this._setSubChecked(state,sNode.childNodes[i]);
         };
      var z=sNode.htmlNode.childNodes[0].childNodes[0].childNodes[1].childNodes[0];

      if (state) sNode.checkstate=1;
      else    sNode.checkstate=0;
      if (sNode.dscheck)  sNode.checkstate=sNode.dscheck;



      this._setSrc(z,this.imPath+((sNode.parentObject._r_logic||this._frbtr)?this.radioArray:this.checkArray)[sNode.checkstate]);
   };

/**
*     @desc: get state of nodes's checkbox
*     @type: public
*     @param: itemId - target node id
*     @return: node state (0 - unchecked,1 - checked, 2 - third state)
*     @topic: 5  
*/      
   dhtmlXTreeObject.prototype.isItemChecked=function(itemId){
      var sNode=this._globalIdStorageFind(itemId);
      if (!sNode) return;      
      return   sNode.checkstate;
   };







/**
*     @desc: delete all children of node
*     @type: public
*     @param: itemId - node id
*     @topic: 2
*/
    dhtmlXTreeObject.prototype.deleteChildItems=function(itemId)
   {
      var sNode=this._globalIdStorageFind(itemId);
      if (!sNode) return;
      var j=sNode.childsCount;
      for (var i=0; i<j; i++)
      {
         this._deleteNode(sNode.childNodes[0].id,sNode.childNodes[0]);
      };
   };

/**
*     @desc: delete node
*     @type: public
*     @param: itemId - node id
*     @param: selectParent - If true parent of deleted item get selection, else no selected items leaving in tree.
*     @topic: 2  
*/      
dhtmlXTreeObject.prototype.deleteItem=function(itemId,selectParent){
    if ((!this._onrdlh)||(this._onrdlh(itemId))){
		var z=this._deleteItem(itemId,selectParent);
//#__pro_feature:01112006{
//#child_calc:01112006{
    if (z)
        this._fixChildCountLabel(z);
//#}
//#}
	}

    //nb:solves standard doctype prb in IE
      this.allTree.childNodes[0].border = "1";
      this.allTree.childNodes[0].border = "0";
}
/**
*     @desc: delete node
*     @type: private
*     @param: id - node id
*     @param: selectParent - If true parent of deleted item get selection, else no selected items leaving in tree.
*     @param: skip - unregistering mode (optional, used by private methods)        
*     @topic: 2  
*/
dhtmlXTreeObject.prototype._deleteItem=function(itemId,selectParent,skip){
      selectParent=dhx4.s2b(selectParent);
      var sNode=this._globalIdStorageFind(itemId);
      if (!sNode) return;
        var pid=this.getParentId(itemId);

      var zTemp=sNode.parentObject;
      this._deleteNode(itemId,sNode,skip);
      if(this._editCell&&this._editCell.id==itemId)
     	this._editCell = null;
      this._correctPlus(zTemp);
      this._correctLine(zTemp);

      if  ((selectParent)&&(pid!=this.rootId)) this.selectItem(pid,1);
      return    zTemp;
   };

/**
*     @desc: uregister all child nodes of target node
*     @type: private
*     @param: itemObject - node object
*     @topic: 3  
*/      
   dhtmlXTreeObject.prototype._globalIdStorageRecSub=function(itemObject){
      for(var i=0; i<itemObject.childsCount; i++)
      {
         this._globalIdStorageRecSub(itemObject.childNodes[i]);
         this._globalIdStorageSub(itemObject.childNodes[i].id);
      };
      this._globalIdStorageSub(itemObject.id);

      	  /*anti memory leaking*/
	  	var z=itemObject;
//		var par=z.span.parentNode.parentNode.childNodes;
//		par[0].parentObject=null;
//		par[1].childNodes[0].parentObject=null;
//		par[2].childNodes[0].parentObject=null;
//		par[2].childNodes[0].treeNod=null;
//		par[2].parentObject=null;
//		par[3].parentObject=null;
		z.span=null;
		z.tr.nodem=null;
		z.tr=null;
		z.htmlNode=null;
   };

/**  
*     @desc: create new node next to specified
*     @type: public
*     @param: itemId - node id
*     @param: newItemId - new node id
*     @param: itemText - new node text
*     @param: itemActionHandler - function fired on node select event (optional)
*     @param: image1 - image for node without children; (optional)
*     @param: image2 - image for closed node; (optional)
*     @param: image3 - image for opened node (optional)
*     @param: optionStr - options string (optional)            
*     @param: children - node children flag (for dynamical trees) (optional)
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype.insertNewNext=function(itemId,newItemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children){
      var sNode=this._globalIdStorageFind(itemId);
      if ((!sNode)||(!sNode.parentObject)) return (0);

      var nodez=this._attachChildNode(0,newItemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children,sNode);
//#__pro_feature:01112006{
//#child_calc:01112006{
      if ((!this.XMLloadingWarning)&&(this.childCalc))  this._fixChildCountLabel(sNode.parentObject);
//#}
//#}
        return nodez;
   };


   
/**
*     @desc: retun node id by index
*     @type: public
*     @param: itemId - parent node id
*     @param: index - index of node, 0 based
*     @return: node id
*     @topic: 1
*/
   dhtmlXTreeObject.prototype.getItemIdByIndex=function(itemId,index){
       var z=this._globalIdStorageFind(itemId);
       if ((!z)||(index>=z.childsCount)) return null;
          return z.childNodes[index].id;
   };

/**
*     @desc: retun child node id by index
*     @type: public
*     @param: itemId - parent node id        
*     @param: index - index of child node
*     @return: node id
*     @topic: 1
*/      
   dhtmlXTreeObject.prototype.getChildItemIdByIndex=function(itemId,index){
       var z=this._globalIdStorageFind(itemId);
       if ((!z)||(index>=z.childsCount)) return null;
          return z.childNodes[index].id;
   };



   

/**
*     @desc: set function called when drag-and-drop event occured
*     @param: aFunc - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event:    onDrag
*     @depricated: use grid.attachEvent("onDrag",func); instead
*     @eventdesc: Event occured after item was dragged and droped on another item, but before item moving processed.
      Event also raised while programmatic moving nodes.
*     @eventparam:  ID of source item
*     @eventparam:  ID of target item
*     @eventparam:  if node droped as sibling then contain id of item before whitch source node will be inserted
*     @eventparam:  source Tree object
*     @eventparam:  target Tree object
*     @eventreturn:  true - confirm drag-and-drop; false - deny drag-and-drop;
*/
   dhtmlXTreeObject.prototype.setDragHandler=function(func){ this.attachEvent("onDrag",func); };
   
   /**
*     @desc: clear selection from node
*     @param: htmlNode - pointer to node object
*     @type: private
*     @topic: 1
*/
    dhtmlXTreeObject.prototype._clearMove=function(){
		if (this._lastMark){
	   		this._lastMark.className=this._lastMark.className.replace(/dragAndDropRow/g,"");
	   		this._lastMark=null;
		}
//#__pro_feature:01112006{
//#complex_move:01112006{
		this.selectionBar.style.display="none";
//#}
//#}
		this.allTree.className=this.allTree.className.replace(" selectionBox","");
   };

   /**  
*     @desc: enable/disable drag-and-drop
*     @type: public
*     @param: mode - enabled/disabled [ can be true/false/temporary_disabled - last value mean that tree can be D-n-D can be switched to true later ]
*     @param: rmode - enabled/disabled drag and drop on super root
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableDragAndDrop=function(mode,rmode){
        if  (mode=="temporary_disabled"){
            this.dADTempOff=false;
            mode=true;                  }
        else
            this.dADTempOff=true;

      this.dragAndDropOff=dhx4.s2b(mode);
         if (this.dragAndDropOff) this.dragger.addDragLanding(this.allTree,this);
        if (arguments.length>1)
            this._ddronr=(!dhx4.s2b(rmode));
       };   

/**
*     @desc: set selection on node
*     @param: node - pointer to node object
*     @type: private
*     @topic: 1
*/    
   dhtmlXTreeObject.prototype._setMove=function(htmlNode,x,y){
      if (htmlNode.parentObject.span) {
      //window.status=x;
      var a1=dhx4.absTop(htmlNode);
      var a2=dhx4.absTop(this.allTree)-this.allTree.scrollTop;

      this.dadmodec=this.dadmode;//this.dadmode;
      this.dadmodefix=0;
//#__pro_feature:01112006{
//#complex_move:01112006{
      if (this.dadmode==2)
      {

      var z=y-a1+(document.body.scrollTop||document.documentElement.scrollTop)-2-htmlNode.offsetHeight/2;
      if ((Math.abs(z)-htmlNode.offsetHeight/6)>0)
      {
         this.dadmodec=1;
         //sibbling zone
         if (z<0)
            this.dadmodefix=0-htmlNode.offsetHeight;
      }
      else this.dadmodec=0;

      }
      if (this.dadmodec==0)
         {
//#}
//#} 

			var zN=htmlNode.parentObject.span;
			zN.className+=" dragAndDropRow";
			this._lastMark=zN;
//#__pro_feature:01112006{
//#complex_move:01112006{
         }
      else{
 	  	 this._clearMove();
         this.selectionBar.style.top=(a1-a2+((parseInt(htmlNode.parentObject.span.parentNode.parentNode.offsetHeight)||18)-1)+this.dadmodefix)+"px";
         this.selectionBar.style.left="5px";
           if (this.allTree.offsetWidth>20)
                this.selectionBar.style.width=(this.allTree.offsetWidth-(_isFF?30:25))+"px";
         this.selectionBar.style.display="";
         }
//#}
//#}
         this._autoScroll(null,a1,a2);

      }
   };

dhtmlXTreeObject.prototype._autoScroll=function(node,a1,a2){
         if (this.autoScroll)
         {
		 	if (node){
				a1=dhx4.absTop(node);
	      		a2=dhx4.absTop(this.allTree)-this.allTree.scrollTop;
			}
            //scroll down
            if ( (a1-a2-parseInt(this.allTree.scrollTop))>(parseInt(this.allTree.offsetHeight)-50) )
               this.allTree.scrollTop=parseInt(this.allTree.scrollTop)+20;
            //scroll top
            if ( (a1-a2)<(parseInt(this.allTree.scrollTop)+30) )
               this.allTree.scrollTop=parseInt(this.allTree.scrollTop)-20;
         }
}

/**
*     @desc: create html element for dragging
*     @type: private
*     @param: htmlObject - html node object
*     @topic: 1
*/
dhtmlXTreeObject.prototype._createDragNode=function(htmlObject,e){
      if (!this.dADTempOff) return null;

     var obj=htmlObject.parentObject;
     if (!this.callEvent("onBeforeDrag",[obj.id, e])) return null;
    if (!obj.i_sel){

         this._selectItem(obj,e);
}
//#__pro_feature:01112006{
//#multiselect:01112006{
      this._checkMSelectionLogic();
//#}
//#}
      var dragSpan=document.createElement('div');

            var text=new Array();
            if (this._itim_dg)
                    for (var i=0; i<this._selected.length; i++)
                        text[i]="<table cellspacing='0' cellpadding='0'><tr><td><img width='18px' height='18px' src='"+this._getSrc(this._selected[i].span.parentNode.previousSibling.childNodes[0])+"'></td><td>"+this._selected[i].span.innerHTML+"</td></tr></table>";
            else
                text=this.getSelectedItemText().split(this.dlmtr);

            dragSpan.innerHTML=text.join("");
         dragSpan.style.position="absolute";
         dragSpan.className="dragSpanDiv";
      this._dragged=(new Array()).concat(this._selected);
     return dragSpan;
}



/**  
*     @desc: focus item in tree
*     @type: private
*     @param: item - node object
*     @edition: Professional
*     @topic: 0  
*/
dhtmlXTreeObject.prototype._focusNode=function(item){
	var z=dhx4.absTop(item.htmlNode)-dhx4.absTop(this.allTree);
	if ((z>(this.allTree.offsetHeight-30)) || (z<0))
		this.allTree.scrollTop=z+this.allTree.scrollTop;
};




              








///DragAndDrop

dhtmlXTreeObject.prototype._preventNsDrag=function(e){
   if ((e)&&(e.preventDefault)) { e.preventDefault(); return false; }
   return false;
}

dhtmlXTreeObject.prototype._drag=function(sourceHtmlObject,dhtmlObject,targetHtmlObject){
      if (this._autoOpenTimer) clearTimeout(this._autoOpenTimer);

      if (!targetHtmlObject.parentObject){
            targetHtmlObject=this.htmlNode.htmlNode.childNodes[0].childNodes[0].childNodes[1].childNodes[0];
            this.dadmodec=0;
            }

      this._clearMove();
      var z=sourceHtmlObject.parentObject.treeNod;
        if ((z)&&(z._clearMove))   z._clearMove("");

       if ((!this.dragMove)||(this.dragMove()))
          {
              if ((!z)||(!z._clearMove)||(!z._dragged)) var col=new Array(sourceHtmlObject.parentObject);
              else var col=z._dragged;
				var trg=targetHtmlObject.parentObject;

                for (var i=0; i<col.length; i++){
                   var newID=this._moveNode(col[i],trg);
				   if ((this.dadmodec)&&(newID!==false)) trg=this._globalIdStorageFind(newID,true,true);
                   if ((newID)&&(!this._sADnD)) this.selectItem(newID,0,1);
                }

         }
        if (z) z._dragged=new Array();


}

dhtmlXTreeObject.prototype._dragIn=function(htmlObject,shtmlObject,x,y){

                    if (!this.dADTempOff) return 0;
                    var fobj=shtmlObject.parentObject;
                    var tobj=htmlObject.parentObject;
	                if ((!tobj)&&(this._ddronr)) return;
                    if (!this.callEvent("onDragIn",[fobj.id,tobj?tobj.id:null,fobj.treeNod,this])){
                    	if (tobj) this._autoScroll(htmlObject);
                    	return 0;
                    }
						

					if (!tobj) 
		            	this.allTree.className+=" selectionBox";
					else
					{
	                    if (fobj.childNodes==null){
		                	this._setMove(htmlObject,x,y);
        	             	return htmlObject;
                    	}

	                    var stree=fobj.treeNod;
    	                for (var i=0; i<stree._dragged.length; i++)
                        	if (this._checkPNodes(tobj,stree._dragged[i])){
						   		this._autoScroll(htmlObject);
                           		return 0;
							}
//#__pro_feature:01112006{
//#complex_move:01112006{	 
				this.selectionBar.parentNode.removeChild(this.selectionBar);
				tobj.span.parentNode.appendChild(this.selectionBar);
//#}
//#}
                       this._setMove(htmlObject,x,y);
                       if (this._getOpenState(tobj)<=0){
                           var self = this;
                           this._autoOpenId=tobj.id;
                           this._autoOpenTimer=window.setTimeout(function(){
                             self._autoOpenItem(null, self);
                             self = null;
                           }, 1000);
                       }
					}
					
				return htmlObject;

}
dhtmlXTreeObject.prototype._autoOpenItem=function(e,treeObject){
   treeObject.openItem(treeObject._autoOpenId);
};
dhtmlXTreeObject.prototype._dragOut=function(htmlObject){
this._clearMove();
if (this._autoOpenTimer) clearTimeout(this._autoOpenTimer);
 }


//#__pro_feature:01112006{

/**  
*     @desc: return next node
*     @type: private
*     @param: item - node object
*     @param: mode - inner flag
*     @return: next node or -1
*     @topic: 2
*/
dhtmlXTreeObject.prototype._getNextNode=function(item,mode){
   if ((!mode)&&(item.childsCount)) return item.childNodes[0];
   if (item==this.htmlNode)
      return -1;
   if ((item.tr)&&(item.tr.nextSibling)&&(item.tr.nextSibling.nodem))
   return item.tr.nextSibling.nodem;

   return this._getNextNode(item.parentObject,true);
};

/**  
*     @desc: return last child of item (include all sub-child collections)
*     @type: private
*     @param: item - node object
*     @topic: 2  
*/
dhtmlXTreeObject.prototype._lastChild=function(item){
   if (item.childsCount)
      return this._lastChild(item.childNodes[item.childsCount-1]);
   else return item;
};

/**  
*     @desc: return previous node
*     @type: private
*     @param: item - node object
*     @param: mode - inner flag
*     @return: previous node or -1
*     @topic: 2  
*/
dhtmlXTreeObject.prototype._getPrevNode=function(node,mode){
   if ((node.tr)&&(node.tr.previousSibling)&&(node.tr.previousSibling.nodem))
   return this._lastChild(node.tr.previousSibling.nodem);

   if (node.parentObject)
      return node.parentObject;
   else return -1;
};



//#find_item:01112006{

/**
*     @desc: find tree item by text, select and focus it
*     @type: public
*     @param: searchStr - search text
*     @param: direction - 0: top -> bottom; 1: bottom -> top
*     @param: top - 1: start searching from top
*     @return: node id
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.findItem=function(searchStr,direction,top){
   var z=this._findNodeByLabel(searchStr,direction,(top?this.htmlNode:null));
   if (z){
      this.selectItem(z.id,true);
      this._focusNode(z);
      return z.id;
      }
      else return null;
}

/**  
*     @desc: find tree item by text
*     @type: public
*     @param: searchStr - search text
*     @param: direction - 0: top -> bottom; 1: bottom -> top
*     @param: top - 1: start searching from top
*     @return: node id
*     @edition: Professional
*     @topic: 2  
*/
dhtmlXTreeObject.prototype.findItemIdByLabel=function(searchStr,direction,top){
   var z=this._findNodeByLabel(searchStr,direction,(top?this.htmlNode:null));
   if (z)
      return z.id
   else return null;
}

//#smart_parsing:01112006{
/**  
*     @desc: find tree item by text in unParsed XML
*     @type: private
*     @param: node - start xml node
*     @param: field - name of xml attribute
*     @param: cvalue - search text
*     @return: true/false
*     @topic: 2  
*/
dhtmlXTreeObject.prototype.findStrInXML=function(node,field,cvalue){ 
   if (!node.childNodes && node.item) return this.findStrInJSON(node,field,cvalue);
   if(!node.childNodes)
       return false;
   for (var i=0; i<node.childNodes.length; i++)
   {
   if (node.childNodes[i].nodeType==1)
      {
      	
        var z=node.childNodes[i].getAttribute(field);
        if (!z && node.childNodes[i].tagName=="itemtext")  z=node.childNodes[i].firstChild.data; 
      if ((z)&&(z.toLowerCase().search(cvalue)!=-1))
         return true;
      if (this.findStrInXML(node.childNodes[i],field,cvalue)) return true;
      }
   }
   return false;
}
dhtmlXTreeObject.prototype.findStrInJSON=function(node,field,cvalue){ 
   for (var i=0; i<node.item.length; i++)
   {
	    var z=node.item[i].text;
        if ((z)&&(z.toLowerCase().search(cvalue)!=-1))
         return true;
      if (node.item[i].item && this.findStrInJSON(node.item[i],field,cvalue)) return true;
   }
   return false;
}
//#}

/**  
*     @desc: find tree item by text
*     @type: private
*     @param: searchStr - search text
*     @param: direction - 0: top -> bottom; 1: bottom -> top
*     @param: fromNode - node from which search begin
*     @return: node id
*     @topic: 2  
*/
dhtmlXTreeObject.prototype._findNodeByLabel=function(searchStr,direction,fromNode){
   //trim
   var searchStr=searchStr.replace(new RegExp("^( )+"),"").replace(new RegExp("( )+$"),"");
   searchStr =  new RegExp(searchStr.replace(/([\^\.\?\*\+\\\[\]\(\)]{1})/gi,"\\$1").replace(/ /gi,".*"),"gi");

   //get start node
   if (!fromNode)
      {
      fromNode=this._selected[0];
      if (!fromNode) fromNode=this.htmlNode;
      }

   var startNode=fromNode;

   //first step
   if (!direction){
      if ((fromNode.unParsed)&&(this.findStrInXML(fromNode.unParsed.d,"text",searchStr)))
      this.reParse(fromNode);
   fromNode=this._getNextNode(startNode);
   if (fromNode==-1) fromNode=this.htmlNode.childNodes[0];
   }
   else
   {
      var z2=this._getPrevNode(startNode);
      if (z2==-1) z2=this._lastChild(this.htmlNode);
      if ((z2.unParsed)&&(this.findStrInXML(z2.unParsed.d,"text",searchStr)))
      {   this.reParse(z2); fromNode=this._getPrevNode(startNode); }
      else fromNode=z2;
      if (fromNode==-1) fromNode=this._lastChild(this.htmlNode);
   }



   while ((fromNode)&&(fromNode!=startNode)){
      if ((fromNode.label)&&(fromNode.label.search(searchStr)!=-1))
            return (fromNode);

      if (!direction){
      if (fromNode==-1) { if (startNode==this.htmlNode) break; fromNode=this.htmlNode.childNodes[0]; }
      if ((fromNode.unParsed)&&(this.findStrInXML(fromNode.unParsed.d,"text",searchStr)))
         this.reParse(fromNode);
      fromNode=this._getNextNode(fromNode);
      if (fromNode==-1) fromNode=this.htmlNode;
      }
      else
      {
      var z2=this._getPrevNode(fromNode);
      if (z2==-1) z2=this._lastChild(this.htmlNode);
      if ((z2.unParsed)&&(this.findStrInXML(z2.unParsed.d,"text",searchStr)))
         {   this.reParse(z2); fromNode=this._getPrevNode(fromNode); }
      else fromNode=z2;
      if (fromNode==-1) fromNode=this._lastChild(this.htmlNode);
      }
   }
   return null;
};

//#}
//#}


//#complex_move:01112006{

/**
*     @desc: move item (inside of tree)
*     @type:  public
*     @param: itemId - item Id
*     @param: mode - moving mode (left,up,down,item_child,item_sibling,item_sibling_next,up_strict,down_strict)
*     @param: targetId - target Node in item_child and item_sibling mode
*     @param: targetTree - used for moving between trees (optional)
*     @return: node id
*     @topic: 2
*/
dhtmlXTreeObject.prototype.moveItem=function(itemId,mode,targetId,targetTree)
{
	var sNode=this._globalIdStorageFind(itemId);
	if (!sNode) return (0);
	var resultId = null;
	switch(mode){
		case "right":
			alert('Not supported yet');
			break;
		case "item_child":
			var tNode=(targetTree||this)._globalIdStorageFind(targetId);
			if (!tNode) return (0);
			resultId = (targetTree||this)._moveNodeTo(sNode,tNode,0);
			break;
		case "item_sibling":
			var tNode=(targetTree||this)._globalIdStorageFind(targetId);
			if (!tNode) return (0);
			resultId = (targetTree||this)._moveNodeTo(sNode,tNode.parentObject,tNode);
			break;
		case "item_sibling_next":
			var tNode=(targetTree||this)._globalIdStorageFind(targetId);
			if (!tNode) return (0);
			if ((tNode.tr)&&(tNode.tr.nextSibling)&&(tNode.tr.nextSibling.nodem))
				resultId = (targetTree||this)._moveNodeTo(sNode,tNode.parentObject,tNode.tr.nextSibling.nodem);
			else
				resultId = (targetTree||this)._moveNodeTo(sNode,tNode.parentObject);
			break;
		case "left":
			if (sNode.parentObject.parentObject)
				resultId = this._moveNodeTo(sNode,sNode.parentObject.parentObject,sNode.parentObject);
			break;
		case "up":
			var z=this._getPrevNode(sNode);
			if ((z==-1)||(!z.parentObject)) return null;
			resultId = this._moveNodeTo(sNode,z.parentObject,z);
			break;
		case "up_strict":
			var z=this._getIndex(sNode);
			if (z!=0)
				resultId = this._moveNodeTo(sNode,sNode.parentObject,sNode.parentObject.childNodes[z-1]);
			break;
		case "down_strict":
			var z=this._getIndex(sNode);
			var count=sNode.parentObject.childsCount-2;
			if (z==count)
				resultId = this._moveNodeTo(sNode,sNode.parentObject);
			else if (z<count)
				resultId = this._moveNodeTo(sNode,sNode.parentObject,sNode.parentObject.childNodes[z+2]);
			break;
		case "down":
			var z=this._getNextNode(this._lastChild(sNode));
			if ((z==-1)||(!z.parentObject)) return;
			if (z.parentObject==sNode.parentObject)
				var z=this._getNextNode(z);
			if (z==-1){
				resultId = this._moveNodeTo(sNode,sNode.parentObject);
			}
			else{
				if ((z==-1)||(!z.parentObject)) return;
				resultId = this._moveNodeTo(sNode,z.parentObject,z);
			}
			break;
	}
	if (_isIE && _isIE<8){
		this.allTree.childNodes[0].border = "1";
		this.allTree.childNodes[0].border = "0";
	}
	return resultId;
}

//#__pro_feature:01112006{

/**
*     @desc: set Drag-And-Drop behavior (child - drop as chils, sibling - drop as sibling, complex - complex drop behaviour )
*     @type: public
*     @edition: Professional
*     @param: mode - behavior name (child,sibling,complex)
*     @param: select - select droped node after drag-n-drop, true by default
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.setDragBehavior=function(mode,select){
		this._sADnD=(!dhx4.s2b(select));
		switch (mode) {
			case "child": this.dadmode=0; break;
			case "sibling": this.dadmode=1; break;
			case "complex": this.dadmode=2; break;
		}    };




//#}
//#}







/**
*     @desc: load xml for tree branch
*     @param: id - id of parent node
*     @param: src - path to xml, optional
*     @type: private
*     @topic: 1
*/
   dhtmlXTreeObject.prototype._loadDynXML=function(id,src) {
   		src=src||this.XMLsource;
        var sn=(new Date()).valueOf();
        this._ld_id=id;
//#__pro_feature:01112006{
        if (this.xmlalb=="function"){
            if (src) src(this._escape(id));
            }
        else
        if (this.xmlalb=="name")
            this.load(src+this._escape(id));
        else
        if (this.xmlalb=="xmlname")
            this.load(src+this._escape(id)+".xml?uid="+sn);
        else
//#}
            this.load(src+dhtmlx.url(src)+"uid="+sn+"&id="+this._escape(id));
        };


//#__pro_feature:01112006{
//#multiselect:01112006{
/**
*     @desc: enable multiselection
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @param: strict - 1 - on, 0 - off; in strict mode only items on the same level can be selected
*     @type: public
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableMultiselection=function(mode,strict) {
        this._amsel=dhx4.s2b(mode);
        this._amselS=dhx4.s2b(strict);
        };

/**
*     @desc: check logic of selection
*     @type: private
*     @edition: Professional
*     @topic: 0
*/
dhtmlXTreeObject.prototype._checkMSelectionLogic=function() {
            var usl=new Array();
         for (var i=0; i<this._selected.length; i++)
            for (var j=0; j<this._selected.length; j++)
                  if ((i!=j)&&(this._checkPNodes(this._selected[j],this._selected[i])))
                            usl[usl.length]=this._selected[j];

         for (var i=0; i<usl.length; i++)
             this._unselectItem(usl[i]);

         };
//#}
//#}




/**
*     @desc: check possibility of drag-and-drop
*     @type: private
*     @param: itemId - draged node id
*     @param: htmlObject - droped node object
*     @param: shtmlObject - sourse node object
*     @topic: 6
*/
    dhtmlXTreeObject.prototype._checkPNodes=function(item1,item2){
      if (this._dcheckf) return false;
      if (item2==item1) return 1
      if (item1.parentObject) return this._checkPNodes(item1.parentObject,item2); else return 0;
   };
   dhtmlXTreeObject.prototype.disableDropCheck = function(mode){
      this._dcheckf = dhx4.s2b(mode);
   };


//#__pro_feature:01112006{
//#distributed_load:01112006{

/**
*     @desc: enable distributed parsing of big tree (items loaded portion by portion with some timeouts)
*     @type: public
*     @edition: Professional
*     @param: mode - true/false
*     @param: count - critical count to start distibuting (optional)
*     @param: delay - delay between distributed calls, ms (optional)
*     @topic: 2
*/
dhtmlXTreeObject.prototype.enableDistributedParsing=function(mode,count,delay){
    this._edsbps=dhx4.s2b(mode);
    this._edsbpsA=new Array();
    this._edsbpsC=count||10;
    this._edsbpsD=delay||250;
}
/**
*     @desc: get current state of distributed parsing
*     @type: public
*     @edition: Professional
*     @returns: true - still parsing; false - parsing finished
*     @topic: 2
*/
dhtmlXTreeObject.prototype.getDistributedParsingState=function(){
    return (!((!this._edsbpsA)||(!this._edsbpsA.length)));
}
/**
*     @desc: get current parsing state of item
*     @type: public
*     @edition: Professional
*     @returns: 1 - item already parsed; 0 - item not parsed yet; -1 - item in parsing process
*     @topic: 2
*/
dhtmlXTreeObject.prototype.getItemParsingState=function(itemId){
    var z=this._globalIdStorageFind(itemId,true,true)
    if (!z) return 0;
    if (this._edsbpsA)
        for (var i=0; i<this._edsbpsA.length; i++)
            if (this._edsbpsA[i][2]==itemId) return -1;

    return 1;
}

dhtmlXTreeObject.prototype._distributedStart=function(node,start,parentId,level,start2){
    if (!this._edsbpsA)
        this._edsbpsA=new Array();
    this._edsbpsA[this._edsbpsA.length]=[node,start,parentId,level,start2];
}

dhtmlXTreeObject.prototype._distributedStep=function(pId){
    var self=this;
    if ((!this._edsbpsA)||(!this._edsbpsA.length)) {
         self.XMLloadingWarning=0;
         return;
         }
    var z=this._edsbpsA[0];
    this.parsedArray=new Array();
    this._parse(z[0],z[2],z[3],z[1]);
    var zkx=this._globalIdStorageFind(z[2]);
    this._redrawFrom(this,zkx,z[4],this._getOpenState(zkx));
    var chArr=this.setCheckList.split(this.dlmtr);
   for (var n=0; n<chArr.length; n++)
      if (chArr[n]) this.setCheck(chArr[n],1);

    this._edsbpsA=(new Array()).concat(this._edsbpsA.slice(1));


    if ((!this._edsbpsA.length)){
         window.setTimeout( function(){ if (self.onXLE) self.onXLE(self,pId); self.callEvent("onXLE",[self,pId]); },1);
            self.xmlstate=0;
            }
}

//#}
//#}




//#__pro_feature:01112006{

/**
*     @desc: replace images with text signs
*     @type: public
*     @param: mode - true/false
*     @edition: Professional
*     @topic: 1
*/
dhtmlXTreeObject.prototype.enableTextSigns=function(mode){
    this._txtimg=dhx4.s2b(mode);
}

//#}

/**
*   @desc:  prevent caching in IE  by adding random value to URL string
*   @param: mode - enable/disable random value ( disabled by default )
*   @type: public
*   @topic: 0
*/
dhtmlXTreeObject.prototype.preventIECaching=function(mode){
      dhx4.ajax.cache = !mode;
}
dhtmlXTreeObject.prototype.preventIECashing=dhtmlXTreeObject.prototype.preventIECaching;





/**
*     @desc: disable checkbox
*     @param: itemId - Id of tree item
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.disableCheckbox=function(itemId,mode) {
            if (typeof(itemId)!="object")
             var sNode=this._globalIdStorageFind(itemId,0,1);
            else
                var sNode=itemId;
         if (!sNode) return;
            sNode.dscheck=dhx4.s2b(mode)?(((sNode.checkstate||0)%3)+3):((sNode.checkstate>2)?(sNode.checkstate-3):sNode.checkstate);
            this._setCheck(sNode);
                if (sNode.dscheck<3) sNode.dscheck=false;
         };

//#__pro_feature:01112006{


/**
*     @desc: refresh specified tree branch (get XML from server, add new nodes, remove not used nodes)
*     @param: itemId -  top node in branch
*     @param: source - server side script , optional
*     @type: public
*     @edition: Professional
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.smartRefreshBranch=function(itemId,source){
   		this._branchUpdate=1;
		this.smartRefreshItem(itemId,source);
   }

/**
*     @desc: refresh specified tree item (get XML from server, add new nodes, remove not used nodes)
*     @param: itemId -  top node in branch
*     @param: source - server side script , optional
*     @type: public
*     @edition: Professional
*     @topic: 6
*/
dhtmlXTreeObject.prototype.smartRefreshItem=function(itemId,source){
		var sNode=this._globalIdStorageFind(itemId);
		for (var i=0; i<sNode.childsCount; i++)
			sNode.childNodes[i]._dmark=true;

		this.waitUpdateXML=true;
		if (source && source.exists)
			this._parse(source,itemId);
		else
			this._loadDynXML(itemId,source);
};


/**
*     @desc: refresh specified tree nodes (get XML from server and updat only nodes included in itemIdList)
*     @param: itemIdList - list of node identificators
*     @param: source - server side script
*     @type: public
*     @edition: Professional
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.refreshItems=function(itemIdList,source){
   		var z=itemIdList.toString().split(this.dlmtr);
		this.waitUpdateXML=new Array();
		for (var i=0; i<z.length; i++)
			this.waitUpdateXML[z[i]]=true;
        this.load((source||this.XMLsource)+dhtmlx.url(source||this.XMLsource)+"ids="+this._escape(itemIdList));
   };


/**
*     @desc: update item properties
*     @param: itemId - list of node identificators
*     @param: name - list of node identificators, optional
*     @param: im0 - list of node identificators, optional
*     @param: im1 - list of node identificators, optional
*     @param: im2 - list of node identificators, optional
*     @param: achecked - list of node identificators, optional
*     @param: child - child attribute for dynamic loading
*     @type: public
*     @edition: Professional
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.updateItem=function(itemId,name,im0,im1,im2,achecked,child){
      var sNode=this._globalIdStorageFind(itemId);
	  sNode.userData=new cObject(); 
      if (name) sNode.label=name;
      sNode.images=new Array(im0||this.imageArray[0],im1||this.imageArray[1],im2||this.imageArray[2]);
	  this.setItemText(itemId,name);
      if (achecked) this._setCheck(sNode,true);
	  if(child=="1" && !this.hasChildren(itemId)) sNode.XMLload = 0;
      this._correctPlus(sNode);
	  sNode._dmark=false;
      return sNode;
   };

/**
*     @desc: set function called after drag-and-drap event occured
*     @param: func - event handling function
*     @type: deprecated
*     @edition: Professional
*     @topic: 0,7
*     @event:  onDrop
*     @depricated: use grid.attachEvent("onDrop",func); instead
*     @eventdesc:  Event raised after drag-and-drop processed. Event also raised while programmatic moving nodes.
*     @eventparam:  ID of source item (ID after inserting in tree, my be not equal to initial ID)
*     @eventparam:  ID of target item
*     @eventparam:  if node droped as sibling then contain id of item before whitch source node will be inserted
*     @eventparam:  source Tree object
*     @eventparam:  target Tree object
*/
   dhtmlXTreeObject.prototype.setDropHandler=function(func){  this.attachEvent("onDrop",func);  };

/**
*     @desc: set function called before xml loading/parsing started
*     @param: func - event handling function
*     @type: deprecated
*     @edition: Professional
*     @topic: 0,7
*     @event:  onXLS
*     @depricated: use grid.attachEvent("onXLS",func); instead
*     @eventdesc: event fired simultaneously with starting XML parsing
*     @eventparam: tree object
*     @eventparam: item id, for which xml loaded
*/
   dhtmlXTreeObject.prototype.setOnLoadingStart=function(func){    this.attachEvent("onXLS",func);  };
      /**
*     @desc: set function called after xml loading/parsing ended
*     @param: func - event handling function
*     @type: deprecated
*     @edition: Professional
*     @topic: 0,7
*     @event:  onXLE
*     @depricated: use grid.attachEvent("onXLE",func); instead
*     @eventdesc: event fired simultaneously with ending XML parsing, new items already available in tree
*     @eventparam: tree object
*     @eventparam: last parsed parent id
*/
     dhtmlXTreeObject.prototype.setOnLoadingEnd=function(func){  this.attachEvent("onXLE",func); };



/**
*     @desc: define which script be called on dynamic loading
*     @param: mode - id for some_script?id=item_id ;  name for  some_scriptitem_id, xmlname for  some_scriptitem_id.xml ; function for calling user defined handler
*     @type: public
*     @edition: Professional
*     @topic: 1
*/
   dhtmlXTreeObject.prototype.setXMLAutoLoadingBehaviour=function(mode) {
            this.xmlalb=mode;
         };


/**
*     @desc: enable smart checkboxes ,true by default (auto checking children and parents for 3-state checkboxes)
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableSmartCheckboxes=function(mode) { this.smcheck=dhx4.s2b(mode); };

/**
*     @desc: return current state of XML loading
*     @type: public
*     @edition: Professional
*     @return: current state, true - xml loading now
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.getXMLState=function(){ return (this.xmlstate==1); };

/**
*     @desc: set top offset for item
*     @type: public
*     @param: itemId - id of item
*     @param: value - value of top offset in px
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.setItemTopOffset=function(itemId,value){
    var node;
    if (typeof(itemId)!="object")
        node=this._globalIdStorageFind(itemId);
    else
        node=itemId;
    var z=node.span.parentNode.parentNode;
    node.span.style.paddingBottom="1px";
  
    for (var i=0; i<z.childNodes.length; i++){
        if (i!=0){
      
            if (_isIE){
                z.childNodes[i].style.height="18px";
                z.childNodes[i].style.paddingTop=parseInt(value)+"px";
            }else
                z.childNodes[i].style.height=18+parseInt(value)+"px";
        }
        else{
            var w=z.childNodes[i].firstChild;
            if (z.childNodes[i].firstChild.tagName!='DIV'){
              w=document.createElement("DIV");
              z.childNodes[i].insertBefore(w,z.childNodes[i].firstChild);
            }
            
            if ((node.parentObject.id!=this.rootId || node.parentObject.childNodes[0]!=node) && this.treeLinesOn){
                z.childNodes[i].style.backgroundImage="url("+this.imPath+this.lineArray[5]+")";
            }
            w.innerHTML="&nbsp;";
            w.style.overflow='hidden';
            
        }
        
        w.style.verticalAlign = z.childNodes[i].style.verticalAlign="bottom";
        if (_isIE){
            this.allTree.childNodes[0].border = "1";
            this.allTree.childNodes[0].border = "0";
        }
    }
}

/**
*     @desc: set size of icons
*     @type:  public
*     @param: newWidth - new icon width
*     @param: newHeight - new icon height
*     @param: itemId - item Id, if skipped set default value for all new icons, optional
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.setIconSize=function(newWidth,newHeight,itemId)
{
      if (itemId){
         if ((itemId)&&(itemId.span))
            var sNode=itemId;
         else
            var sNode=this._globalIdStorageFind(itemId);

         if (!sNode) return (0);
         var img=sNode.span.parentNode.previousSibling.childNodes[0];
            if (newWidth) {
            	img.style.width=newWidth+"px";
            	if (window._KHTMLrv) img.parentNode.style.width=newWidth+"px";
        	}
            if (newHeight) {
            	img.style.height=newHeight+"px";
            	if (window._KHTMLrv) img.parentNode.style.height=newHeight+"px";
        	}
         }
      else{
         this.def_img_x=newWidth+"px";
         this.def_img_y=newHeight+"px";
      }
}

/**
*     @desc: get url of item image
*     @type: public
*     @param: itemId - id of item
*     @param: imageInd - index of image ( 0 - leaf, 1 - closed folder, 2 - opened folder)
*     @param: value - value of top offset
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.getItemImage=function(itemId,imageInd,fullPath){
    var node=this._globalIdStorageFind(itemId);
    if (!node) return "";
    var img=node.images[imageInd||0];
    if (fullPath) img=this.iconURL+img;
    return img;
}

/**
*     @desc: replace checkboxes with radio buttons
*     @type: public
*     @param: mode - true/false
*     @param: itemId - node for which replacement called (optional)
*     @edition: Professional
*     @topic: 1
*/
dhtmlXTreeObject.prototype.enableRadioButtons=function(itemId,mode){
    if (arguments.length==1){
        this._frbtr=dhx4.s2b(itemId);
        this.checkBoxOff=this.checkBoxOff||this._frbtr;
        return;
        }


    var node=this._globalIdStorageFind(itemId);
    if (!node) return "";
    mode=dhx4.s2b(mode);
    if ((mode)&&(!node._r_logic)){
            node._r_logic=true;
            for (var i=0; i<node.childsCount; i++)
                this._setCheck(node.childNodes[i],node.childNodes[i].checkstate);
        }

    if ((!mode)&&(node._r_logic)){
            node._r_logic=false;
            for (var i=0; i<node.childsCount; i++)
                this._setCheck(node.childNodes[i],node.childNodes[i].checkstate);
        }
}
/**
*     @desc: replace checkboxes with radio buttons
*     @type: public
*     @param: mode - true/false
*     @param: itemId - node for which replacement called (optional)
*     @edition: Professional
*     @topic: 1
*/
dhtmlXTreeObject.prototype.enableSingleRadioMode=function(mode){
     this._frbtrs=dhx4.s2b(mode);
}


/**
*     @desc: configure if parent node will be expanded immideatly after child item added
*     @type: public
*     @param: mode - true/false
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.openOnItemAdded=function(mode){
    this._hAdI=!dhx4.s2b(mode);
}
dhtmlXTreeObject.prototype.openOnItemAdding=function(mode){
    this._hAdI=!dhx4.s2b(mode);
}

/**
*     @desc: enable multi line items
*     @beforeInit: 1
*     @param: width - text width, if equls zero then use single lines items;
*     @type: public
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableMultiLineItems=function(width) { if (width===true) this.mlitems="100%"; else this.mlitems=width; }

/**
*     @desc: enable auto tooltips (node text as tooltip)
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @edition:Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableAutoTooltips=function(mode) { this.ettip=dhx4.s2b(mode); };


/**
*     @desc: unselect item in tree
*     @type: public
*     @param: itemId - used in multi selection tree (optional)
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.clearSelection=function(itemId){
       if (itemId)
            this._unselectItem(this._globalIdStorageFind(itemId));
            else
            this._unselectItems();
            }

/**
*     @desc: show/hide (+/-) icon (works only for individual items, not for entire tree )
*     @type: public
*     @param: itemId - id of selected item
*     @param: state - show state : 0/1
*     @edition: Professional
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.showItemSign=function(itemId,state){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;

      var z=temp.span.parentNode.previousSibling.previousSibling.previousSibling;
      if (!dhx4.s2b(state)){
         this._openItem(temp)
         temp.closeble=false;
         temp.wsign=true;
      }
      else
      {
         temp.closeble=true;
         temp.wsign=false;
      }
      this._correctPlus(temp);
   }
/**
*     @desc: show/hide checkbox for tree item (works only for individual items, not for entire tree )
*     @type: public
*     @param: itemId - id of selected item, optional, set null to change states of all items
*     @param: state - checkbox show state : 0/1
*     @edition: Professional
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.showItemCheckbox=function(itemId,state){
      if (!itemId)
		for (var a in this._idpull)
			this.showItemCheckbox(this._idpull[a],state);

      if (typeof(itemId)!="object")
	      itemId=this._globalIdStorageFind(itemId,0,0);

      if (!itemId) return 0;
   	  itemId.nocheckbox=!dhx4.s2b(state);
      var t=itemId.span.parentNode.previousSibling.previousSibling.childNodes[0];
      t.parentNode.style.display=(!itemId.nocheckbox)?"":"none";
   }

/**
*     @desc: set list separator ("," by default)
*     @type: public
*     @param: separator - char or string to use for separating items in lists
*     @edition: Professional
*     @topic: 0
*/
dhtmlXTreeObject.prototype.setListDelimeter=function(separator){
    this.dlmtr=separator;
}

//#}


/**
*     @desc: set escaping mode (used for escaping ID in requests)
*     @param: mode - escaping mode ("utf8" for UTF escaping)
*     @type: public
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.setEscapingMode=function(mode){
        this.utfesc=mode;
        }


/**
*     @desc: enable item highlighting (item text highlited on mouseover)
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableHighlighting=function(mode) { this.ehlt=true; this.ehlta=dhx4.s2b(mode); };

/**
*     @desc: called on mouse out
*     @type: private
*     @topic: 0
*/
   dhtmlXTreeObject.prototype._itemMouseOut=function(){
   		var that=this.childNodes[3].parentObject;
		var tree=that.treeNod;
 		tree.callEvent("onMouseOut",[that.id]);
		if (that.id==tree._l_onMSI) tree._l_onMSI=null;
        if (!tree.ehlta) return;
 	    that.span.className=that.span.className.replace("_lor","");
   }
/**
*     @desc: called on mouse in
*     @type: private
*     @topic: 0
*/
   dhtmlXTreeObject.prototype._itemMouseIn=function(){
   		var that=this.childNodes[3].parentObject;
		var tree=that.treeNod;

		if (tree._l_onMSI!=that.id) tree.callEvent("onMouseIn",[that.id]);
		tree._l_onMSI=that.id;
        if (!tree.ehlta) return;
 	    that.span.className=that.span.className.replace("_lor","");
 	    that.span.className=that.span.className.replace(/((standart|selected)TreeRow)/,"$1_lor");
   }

/**
*     @desc: enable active images (clickable and dragable). By default only text part of the node is active
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableActiveImages=function(mode){this._aimgs=dhx4.s2b(mode); };

/**
*     @desc: focus item in tree (scroll to it if necessary)
*     @type: public
*     @param: itemId - item Id
*     @topic: 0
*/
dhtmlXTreeObject.prototype.focusItem=function(itemId){
      var sNode=this._globalIdStorageFind(itemId);
      if (!sNode) return (0);
      this._focusNode(sNode);
   };


/**
*     @desc: Returns the list of all children from all next levels of tree, separated by default delimiter.
*     @param: itemId - id of node
*     @type: public
*     @return: list of all children items from all next levels of tree, separated by default delimiter
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.getAllSubItems =function(itemId){
      return this._getAllSubItems(itemId);
   }

/**
*     @desc: Returns the list of all items which doesn't have child nodes.
*     @type: public
*     @return: list of all items which doesn't have child nodes.
*     @topic: 6
*/
	dhtmlXTreeObject.prototype.getAllChildless =function(){
		return this._getAllScraggyItems(this.htmlNode);
	}
	dhtmlXTreeObject.prototype.getAllLeafs=dhtmlXTreeObject.prototype.getAllChildless;


/**
*     @desc: Returns the list of all children from all next levels of tree, separated by default delimiter.
*     @param: itemId - id of node
*     @edition: Professional
*     @type: private
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getAllScraggyItems =function(node)
   {
      var z="";
      for (var i=0; i<node.childsCount; i++)
        {
            if ((node.childNodes[i].unParsed)||(node.childNodes[i].childsCount>0))
            {
                    if (node.childNodes[i].unParsed)
                        var zb=this._getAllScraggyItemsXML(node.childNodes[i].unParsed,1);
                    else
                       var zb=this._getAllScraggyItems(node.childNodes[i])

                 if (zb)
                        if (z) z+=this.dlmtr+zb;
                        else z=zb;
         }
            else
               if (!z) z=""+node.childNodes[i].id;
             else z+=this.dlmtr+node.childNodes[i].id;
         }
          return z;
   };





/**
*     @desc: Returns the list of all children from all next levels of tree, separated by default delimiter.
*     @param: itemId - id of node
*     @type: private
*     @edition: Professional
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getAllFatItems =function(node)
   {
      var z="";
      for (var i=0; i<node.childsCount; i++)
        {
            if ((node.childNodes[i].unParsed)||(node.childNodes[i].childsCount>0))
            {
             if (!z) z=""+node.childNodes[i].id;
                else z+=this.dlmtr+node.childNodes[i].id;

                    if (node.childNodes[i].unParsed)
                        var zb=this._getAllFatItemsXML(node.childNodes[i].unParsed,1);
                    else
                       var zb=this._getAllFatItems(node.childNodes[i])

                 if (zb) z+=this.dlmtr+zb;
         }
         }
          return z;
   };

/**
*     @desc: Returns the list of all items which have child nodes, separated by default delimiter.
*     @type: public
*     @return: list of all items which has child nodes, separated by default delimiter.
*     @topic: 6
*/
	dhtmlXTreeObject.prototype.getAllItemsWithKids =function(){
		return this._getAllFatItems(this.htmlNode);
	}
	dhtmlXTreeObject.prototype.getAllFatItems=dhtmlXTreeObject.prototype.getAllItemsWithKids;



/**
*     @desc: return list of identificators of nodes with checked checkboxes, separated by default delimiter
*     @type: public
*     @return: list of ID of items with checked checkboxes, separated by default delimiter
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.getAllChecked=function(){
      return this._getAllChecked("","",1);
   }
/**
*     @desc: return list of identificators of nodes with unchecked checkboxes, separated by default delimiter
*     @type: public
*     @return: list of ID of items with unchecked checkboxes, separated by default delimiter
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.getAllUnchecked=function(itemId){
        if (itemId)
            itemId=this._globalIdStorageFind(itemId);
      return this._getAllChecked(itemId,"",0);
    }


/**
*     @desc: return list of identificators of nodes with third state checkboxes, separated by default delimiter
*     @type: public
*     @return: list of ID of items with third state checkboxes, separated by default delimiter
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.getAllPartiallyChecked=function(){
      return this._getAllChecked("","",2);
   }


/**
*     @desc: return list of identificators of nodes with checked and third state checkboxes, separated by default delimiter
*     @type: public
*     @return: list of ID of items with checked and third state checkboxes, separated by default delimiter
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.getAllCheckedBranches=function(){
        var temp = [this._getAllChecked("","",1)];
        var second = this._getAllChecked("","",2);
        if (second) temp.push(second);
        return temp.join(this.dlmtr);
   }

/**
*     @desc: return list of identificators of nodes with checked checkboxes
*     @type: private
*     @param: node - node object (optional, used by private methods)
*     @param: list - initial identificators list (optional, used by private methods)
*     @topic: 5
*/
   dhtmlXTreeObject.prototype._getAllChecked=function(htmlNode,list,mode){
      if (!htmlNode) htmlNode=this.htmlNode;

      if (htmlNode.checkstate==mode)
         if (!htmlNode.nocheckbox)  { if (list) list+=this.dlmtr+htmlNode.id; else list=""+htmlNode.id;  }
      var j=htmlNode.childsCount;
      for (var i=0; i<j; i++)
      {
         list=this._getAllChecked(htmlNode.childNodes[i],list,mode);
      };
//#__pro_feature:01112006{
//#smart_parsing:01112006{
        if  (htmlNode.unParsed)
            list=this._getAllCheckedXML(htmlNode.unParsed,list,mode);
//#}
//#}

      if (list) return list; else return "";
   };

/**
*     @desc: set individual item style
*     @type: public
*     @param: itemId - node id
*     @param: styleString - valid CSS string
*     @param: resetCss - reset current style : 0/1
*     @topic: 2
*/
dhtmlXTreeObject.prototype.setItemStyle=function(itemId,style_string,resetCss){ 
	var resetCss= resetCss|| false; 
	var temp=this._globalIdStorageFind(itemId); 
	if (!temp) return 0; 
	if (!temp.span.style.cssText) 
		temp.span.setAttribute("style",temp.span.getAttribute("style")+"; "+style_string); 
	else 
		temp.span.style.cssText = resetCss? style_string : temp.span.style.cssText+";"+style_string; 
}

/**
*     @desc: enable draging item image with item text
*     @type: public
*     @param: mode - true/false
*     @topic: 1
*/
dhtmlXTreeObject.prototype.enableImageDrag=function(mode){
    this._itim_dg=dhx4.s2b(mode);
}

/**
*     @desc: set function called when tree item draged over another item
*     @param: func - event handling function
*     @type: depricated
*     @edition: Professional
*     @topic: 4
*     @event: onDragIn
*     @depricated: use grid.attachEvent("onDragIn",func); instead
*     @eventdesc: Event raised when item draged other other dropable target
*     @eventparam:  ID draged item
*     @eventparam:  ID potencial drop landing
*     @eventparam:  source object
*     @eventparam:  target object
*     @eventreturn: true - allow drop; false - deny drop;
*/
	dhtmlXTreeObject.prototype.setOnDragIn=function(func){
		this.attachEvent("onDragIn",func);
        };

/**
*     @desc: enable/disable auto scrolling while drag-and-drop
*     @type: public
*     @param: mode - enabled/disabled
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableDragAndDropScrolling=function(mode){ this.autoScroll=dhx4.s2b(mode); };


dhtmlXTreeObject.prototype.setSkin=function(name){
	var tmp = this.parentObject.className.replace(/dhxtree_[^ ]*/gi,"");
  this.parentObject.className= tmp+" dhxtree_"+name;
  if (name == "dhx_terrace" || name == "dhx_web" || name == "material"){
    this.enableTreeLines(false);
  }
  if (name == "material")
    this.setIconSize("25", "25");
};

//tree
(function(){
	
	dhtmlx.extend_api("dhtmlXTreeObject",{
		_init:function(obj){
			return [obj.parent,(obj.width||"100%"),(obj.height||"100%"),(obj.root_id||0)];
		},
		auto_save_selection:"enableAutoSavingSelected",
		auto_tooltip:"enableAutoTooltips",
		checkbox:"enableCheckBoxes",
		checkbox_3_state:"enableThreeStateCheckboxes",
		checkbox_smart:"enableSmartCheckboxes",
		context_menu:"enableContextMenu",
		distributed_parsing:"enableDistributedParsing",
		drag:"enableDragAndDrop",
		drag_copy:"enableMercyDrag",
		drag_image:"enableImageDrag",
		drag_scroll:"enableDragAndDropScrolling",
		editor:"enableItemEditor",
		hover:"enableHighlighting",
		images:"enableTreeImages",
		image_fix:"enableIEImageFix",
		image_path:"setImagePath",
		lines:"enableTreeLines",
		loading_item:"enableLoadingItem",
		multiline:"enableMultiLineItems",
		multiselect:"enableMultiselection",
		navigation:"enableKeyboardNavigation",
		radio:"enableRadioButtons",
		radio_single:"enableSingleRadioMode",
		rtl:"enableRTL",
		search:"enableKeySearch",
		smart_parsing:"enableSmartXMLParsing",
		smart_rendering:"enableSmartRendering",
		text_icons:"enableTextSigns",
		xml:"loadXML",
		skin:"setSkin"
	},{});
	
})();

dhtmlXTreeObject.prototype._dp_init=function(dp){
	dp.attachEvent("insertCallback", function(upd, id, parent) {
		var data = dhx4.ajax.xpath(".//item",upd);
		var text = data[0].getAttribute('text');
		this.obj.insertNewItem(parent, id, text, 0, 0, 0, 0, "CHILD");
	});

	dp.attachEvent("updateCallback", function(upd, id, parent) {
		var data = dhx4.ajax.xpath(".//item",upd);
		var text = data[0].getAttribute('text');
		this.obj.setItemText(id, text);
		if (this.obj.getParentId(id) != parent) {
			this.obj.moveItem(id, 'item_child', parent);
		}
		this.setUpdated(id, true, 'updated');
	});

	dp.attachEvent("deleteCallback", function(upd, id, parent) {
		this.obj.setUserData(id, this.action_param, "true_deleted");
		this.obj.deleteItem(id, false);
	});
	
	dp._methods=["setItemStyle","","changeItemId","deleteItem"];
    this.attachEvent("onEdit",function(state,id){
        if (state==3)
            dp.setUpdated(id,true)
		return true;
	});
    this.attachEvent("onDrop",function(id,id_2,id_3,tree_1,tree_2){
    	if (tree_1==tree_2)
        	dp.setUpdated(id,true);
    });
    this._onrdlh=function(rowId){
		var z=dp.getState(rowId);
		if (z=="inserted") {  dp.set_invalid(rowId,false); dp.setUpdated(rowId,false);	return true; }
		if (z=="true_deleted")  { dp.setUpdated(rowId,false); return true; }

		dp.setUpdated(rowId,true,"deleted")
		return false;
	};
	this._onradh=function(rowId){
		dp.setUpdated(rowId,true,"inserted")
	};
	dp._getRowData=function(rowId){
		var data = {};
		var z=this.obj._globalIdStorageFind(rowId);
		var z2=z.parentObject;
			
		var i=0;
		for (i=0; i<z2.childsCount; i++)
			if (z2.childNodes[i]==z) break;
		
		data["tr_id"] = z.id;
		data["tr_pid"] = z2.id;
		data["tr_order"] = i;
		data["tr_text"] = z.span.innerHTML;
		
		z2=(z._userdatalist||"").split(",");
		for (i=0; i<z2.length; i++)
			data[z2[i]]=z.userData["t_"+z2[i]];
			
    	return data;
	};	
};

//(c)dhtmlx ltd. www.dhtmlx.com
if (typeof(window.dhtmlXCellObject) != "undefined") {
	
	dhtmlXCellObject.prototype.attachTree = function(rootId) {
		
		this.callEvent("_onBeforeContentAttach",["tree"]);
		
		var obj = document.createElement("DIV");
		obj.style.width = "100%";
		obj.style.height = "100%";
		obj.style.position = "relative";
		obj.style.overflow = "hidden";
		
		this._attachObject(obj);
		
		this.dataType = "tree";
		this.dataObj = new dhtmlXTreeObject(obj, "100%", "100%", (rootId||0));
		this.dataObj.setSkin(this.conf.skin);
		
		// cosmetic fix
		this.dataObj.allTree.childNodes[0].style.marginTop = "2px";
		this.dataObj.allTree.childNodes[0].style.marginBottom = "2px";
		
		//obj.style.overflow = "auto";
		obj = null;
		
		this.callEvent("_onContentAttach",[]);
		
		return this.dataObj;
		
	};
	
}


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*     @desc: adds drag-n-drop capabilities (with possibility to drop into dhtmlxTree) to HTML object. 
*     @param: obj - HTML object, or HTML object ID
*     @param: func - custom drag processor function, optional
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.makeDraggable=function(obj,func){
	if (typeof(obj)!="object")
		obj=document.getElementById(obj);

    dragger=new dhtmlDragAndDropObject();
	dropper=new dhx_dragSomethingInTree();

    dragger.addDraggableItem(obj,dropper);
    obj.dragLanding=null;
    obj.ondragstart=dropper._preventNsDrag;
    obj.onselectstart=new Function("return false;");

    obj.parentObject=new Object;
    obj.parentObject.img=obj;
    obj.parentObject.treeNod=dropper;
	dropper._customDrop=func;
}
dhtmlXTreeObject.prototype.makeDragable=dhtmlXTreeObject.prototype.makeDraggable;
/**
*     @desc: adds drag-n-drop capabilities (with possibility to drop into dhtmlxTree) to all HTML items with dragInDhtmlXTree attribute
*     @param: func - custom drag processor function, optional
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.makeAllDraggable=function(func){
	var z=document.getElementsByTagName("div");
	for (var i=0; i<z.length; i++)
		if (z[i].getAttribute("dragInDhtmlXTree"))
			this.makeDragable(z[i],func);
}

function dhx_dragSomethingInTree(){
	this.lWin=window;
	//this function creates a HTML object which will be used while drag-n-drop
    this._createDragNode=function(node){
    	var dragSpan=document.createElement('div');
        dragSpan.style.position="absolute";
        dragSpan.innerHTML=(node.innerHTML||node.value);
        dragSpan.className="dragSpanDiv";
        return dragSpan;
    };
	//this function necessary for correct browser support
	//doesn't change anything in it
    this._preventNsDrag=function(e){
    	(e||window.event).cancelBubble=true;
        if ((e)&&(e.preventDefault)) { e.preventDefault(); return false; }
        return false;
    }
	//this function contains a reaction on drop operation
	//the tree don't know what to do with custom item
	//so you must define this reaction
    this._nonTrivialNode=function(tree,item,bitem,source){
		if (this._customDrop) return this._customDrop(tree,source.img.id,item.id,bitem?bitem.id:null);

        var image=(source.img.getAttribute("image")||"");
		var id=source.img.id||"new";
		var text=(source.img.getAttribute("text")||(_isIE?source.img.innerText:source.img.textContent));
        tree[bitem?"insertNewNext":"insertNewItem"](bitem?bitem.id:item.id,id,text,"",image,image,image);
     }
}
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*
Purpose: item edit extension
*/


/**
*     @desc: enable editing of item text
*     @param:  mode - true/false
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.enableItemEditor=function(mode){
        this._eItEd=dhx4.s2b(mode);
        if (!this._eItEdFlag){

            this._edn_click_IE=true;
            this._edn_dblclick=true;
            this._ie_aFunc=this.aFunc;
            this._ie_dblclickFuncHandler=this.dblclickFuncHandler;

            this.setOnDblClickHandler(function (a,b) {
                if (this._edn_dblclick) this._editItem(a,b);
                return true;
				});

            this.setOnClickHandler(function (a,b) {
                this._stopEditItem(a,b);
                    if ((this.ed_hist_clcik==a)&&(this._edn_click_IE))
                        this._editItem(a,b);
                this.ed_hist_clcik=a;
                return true;
                });

            this._eItEdFlag=true;

            }
        };

/**
*     @desc: set onEdit handler ( multi handler event)
*     @param:  func - function which will be called on edit related events
*     @type: depricated
*     @event:  onEdit
*     @depricated: use grid.attachEvent("onEdit",func); instead
*     @eventdesc: Event occurs on 4 different stages of edit process: before editing started (cancelable), after editing started, before closing (cancelable), after closed
*     @eventparam: state - 0 before editing started , 1 after editing started, 2 before closing, 3 after closed
*     @eventparam: id - id of edited items
*     @eventparam: tree - tree object
*     @eventparam: value - for stage 0 and 2, value of editor
*     @eventreturn: for stages 0 and 2; true - confirm opening/closing, false - deny opening/closing;  text - edit value
*     @topic: 0
*/
dhtmlXTreeObject.prototype.setOnEditHandler=function(func){
		this.attachEvent("onEdit",func);
        };



/**
*     @desc: define which events must start editing
*     @param:  click_IE - click on already selected item - true/false [true by default]
*     @param:  dblclick - on double click
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.setEditStartAction=function(click_IE, dblclick){
        this._edn_click_IE=dhx4.s2b(click_IE);
        this._edn_dblclick=dhx4.s2b(dblclick);
        };

dhtmlXTreeObject.prototype._stopEdit=function(a,mode){
    if  (this._editCell){
        this.dADTempOff=this.dADTempOffEd;
        if (this._editCell.id!=a){
			
			var editText=true;
			if(!mode){
	            editText=this.callEvent("onEdit",[2,this._editCell.id,this,this._editCell.span.childNodes[0].value]);
			}
			else{
				editText = false;
				this.callEvent("onEditCancel",[this._editCell.id,this._editCell._oldValue]);
			}
	        if (editText===true)
	           	editText=this._editCell.span.childNodes[0].value;
	        else if (editText===false) editText=this._editCell._oldValue;
	        
			var changed = (editText!=this._editCell._oldValue);
	        this._editCell.span.innerHTML=editText;
	        this._editCell.label=this._editCell.span.innerHTML;
			var cSS=this._editCell.i_sel?"selectedTreeRow":"standartTreeRow";
	        this._editCell.span.className=cSS;
	        this._editCell.span.parentNode.className="standartTreeRow";
	        this._editCell.span.style.paddingRight=this._editCell.span.style.paddingLeft='5px';
	        this._editCell.span.onclick=this._editCell.span.ondblclick=function(){};
	        
	        var id=this._editCell.id; 
	        if (this.childCalc)  this._fixChildCountLabel(this._editCell);
	        this._editCell=null;
	        
			if(!mode)
	        	this.callEvent("onEdit",[3,id,this,changed]);
	        
			if (this._enblkbrd){
				this.parentObject.lastChild.focus();
				this.parentObject.lastChild.focus();
			}
        }
    }
}

dhtmlXTreeObject.prototype._stopEditItem=function(id,tree){
    this._stopEdit(id);
};

/**
*     @desc:  switch currently edited item back to normal view
*     @type: public
*     @topic: 0
*/

dhtmlXTreeObject.prototype.stopEdit=function(mode){
    if (this._editCell)
        this._stopEdit(this._editCell.id+"_non",mode);
}

/**
*     @desc: open editor for specified item
*     @param:  id - item ID
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.editItem=function(id){
    this._editItem(id,this);
}

dhtmlXTreeObject.prototype._editItem=function(id,tree){
    if (this._eItEd){
        this._stopEdit();
        var temp=this._globalIdStorageFind(id);
		if (!temp) return;
				
	    var editText = this.callEvent("onEdit",[0,id,this,temp.span.innerHTML]);
        if (editText===true)
            editText = (typeof temp.span.innerText!="undefined"?temp.span.innerText:temp.span.textContent);
        else if (editText===false) return;
        this.dADTempOffEd=this.dADTempOff;
        this.dADTempOff=false;


        this._editCell=temp;
        temp._oldValue=editText;
        temp.span.innerHTML="<input type='text' class='intreeeditRow' />";
        temp.span.style.paddingRight=temp.span.style.paddingLeft='0px';
        temp.span.onclick = temp.span.ondblclick= function(e){
			(e||event).cancelBubble = true;
		}

        temp.span.childNodes[0].value=editText;

        temp.span.childNodes[0].onselectstart=function(e){
            (e||event).cancelBubble=true;
            return true;
        }
        temp.span.childNodes[0].onmousedown=function(e){
            (e||event).cancelBubble=true;
            return true;
        }

        temp.span.childNodes[0].focus();
        temp.span.childNodes[0].focus();
//		temp.span.childNodes[0].select();
        temp.span.onclick=function (e){ (e||event).cancelBubble=true; return false; };
        temp.span.className="";
        temp.span.parentNode.className="";

        var self=this;

        temp.span.childNodes[0].onkeydown=function(e){
            if (!e) e=window.event;
            if (e.keyCode==13){
				 e.cancelBubble=true;
				 self._stopEdit(window.undefined);	
			}
			else if (e.keyCode==27){
				self._stopEdit(window.undefined, true);
			}
			(e||event).cancelBubble=true;
        }
        this.callEvent("onEdit",[1,id,this]);
    }
};
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function jsonPointer(data,parent){
	this.d=data;
	this.dp=parent;
}
jsonPointer.prototype={
	text:function(){ var afff=function(n){ var p=[]; for(var i=0; i<n.length; i++) p.push("{"+sfff(n[i])+"}"); return p.join(","); }; var sfff=function(n){ var p=[]; for (var a in n) if (typeof(n[a])=="object"){ if (a.length) p.push('"'+a+'":['+afff(n[a])+"]");  else p.push('"'+a+'":{'+sfff(n[a])+"}"); }else p.push('"'+a+'":"'+n[a]+'"'); return p.join(","); }; return "{"+sfff(this.d)+"}"; },
	get:function(name){return this.d[name]; },
	exists:function(){return !!this.d },
	content:function(){return this.d.content; },
	each:function(name,f,t){  var a=this.d[name]; var c=new jsonPointer(); if (a) for (var i=0; i<a.length; i++) { c.d=a[i]; f.apply(t,[c,i]); } },
	get_all:function(){ return this.d; },
	sub:function(name){ return new jsonPointer(this.d[name],this.d) },
	sub_exists:function(name){ return !!this.d[name]; },
	each_x:function(name,rule,f,t,i){  var a=this.d[name]; var c=new jsonPointer(0,this.d); if (a) for (i=i||0; i<a.length; i++) if (a[i][rule]) { c.d=a[i]; if(f.apply(t,[c,i])==-1) return; } },
	up:function(name){ return new jsonPointer(this.dp,this.d);  },
	set:function(name,val){ this.d[name]=val;  },
	clone:function(name){ return new jsonPointer(this.d,this.dp); },
	through:function(name,rule,v,f,t){  var a=this.d[name]; if (a.length) for (var i=0; i<a.length; i++) { if (a[i][rule]!=null && a[i][rule]!="" &&  (!v || a[i][rule]==v )) { 
		var c=new jsonPointer(a[i],this.d);  f.apply(t,[c,i]); }  var w=this.d; this.d=a[i]; 
		if (this.sub_exists(name)) this.through(name,rule,v,f,t); this.d=w;   } }
}

/**
*     @desc: load tree from js array file|stream
*     @type: public
*     @param: file - link to JSArray file
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
dhtmlXTreeObject.prototype.loadJSArrayFile=function(file,callback){
  if (window.console && window.console.info)
    window.console.info("loadJSArrayFile was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");
	return this._loadJSArrayFile(file, callback);
};
   dhtmlXTreeObject.prototype._loadJSArrayFile=function(file,callback){
      if (!this.parsCount) this.callEvent("onXLS",[this,this._ld_id]); this._ld_id=null; this.xmlstate=1;
      var that=this;
      
      this.XMLLoader=function(xml, callback){
      	eval("var z="+xml.responseText);
      	this._loadJSArray(z);
      	if (callback) callback.call(this, xml);
      };

      dhx4.ajax.get(file, function(obj){
      	that.XMLLoader(obj.xmlDoc, callback);
      });
   };
   
/**
*     @desc: load tree from csv file|stream
*     @type: public
*     @param: file - link to CSV file
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
dhtmlXTreeObject.prototype.loadCSV=function(file,callback){
  if (window.console && window.console.info)
    window.console.info("loadCSV was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");
	return this._loadCSV(file, callback);
};
   dhtmlXTreeObject.prototype._loadCSV=function(file,callback){
      if (!this.parsCount) this.callEvent("onXLS",[this,this._ld_id]); this._ld_id=null; this.xmlstate=1;
      var that=this;
	  this.XMLLoader=function(xml, callback){
      	this._loadCSVString(xml.responseText);
      	if (callback) callback.call(this, xml);
      };

      dhx4.ajax.get(file, function(obj){
      	that.XMLLoader(obj.xmlDoc, callback);
      });
   };
   
/**
*     @desc: load tree from js array object
*     @type: public
*     @param: ar - js array
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/  
dhtmlXTreeObject.prototype.loadJSArray=function(file,callback){
  if (window.console && window.console.info)
    window.console.info("loadJSArray was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");
	return this._loadJSArray(file, callback);
};
dhtmlXTreeObject.prototype._loadJSArray=function(ar,afterCall){

	//array id,parentid,text
	var z=[];
	for (var i=0; i<ar.length; i++){
		if (!z[ar[i][1]]) z[ar[i][1]]=[];
		z[ar[i][1]].push({id:ar[i][0],text:ar[i][2]});
	}
	
	var top={id: this.rootId};
	var f=function(top,f){
		if (z[top.id]){
			top.item=z[top.id];
			for (var j=0; j<top.item.length; j++)
				f(top.item[j],f);
		}
	}
	f(top,f);
	this._loadJSONObject(top,afterCall);
}


/**
*     @desc: load tree from csv string
*     @type: public
*     @param: csv - csv string 
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
dhtmlXTreeObject.prototype.loadCSVString=function(file,callback){
  if (window.console && window.console.info)
    window.console.info("loadCSVString was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");
	return this._loadCSVString(file, callback);
};
dhtmlXTreeObject.prototype._loadCSVString=function(csv,afterCall){
	//array id,parentid,text
	var z=[];
	var ar=csv.split("\n");
	for (var i=0; i<ar.length; i++){
		var t=ar[i].split(",");
		if (!z[t[1]]) z[t[1]]=[];
		z[t[1]].push({id:t[0],text:t[2]});
	}
	
	var top={id: this.rootId};
	var f=function(top,f){
		if (z[top.id]){
			top.item=z[top.id];
			for (var j=0; j<top.item.length; j++)
				f(top.item[j],f);
		}
	}
	f(top,f);
	this._loadJSONObject(top,afterCall);
}


/**
*     @desc: load tree from json object
*     @type: public
*     @param: json - json object
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.loadJSONObject=function(file,callback){
	  if (window.console && window.console.info)
        window.console.info("loadJSONObject was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");
    	return this._loadJSONObject(file, callback);
   };
   dhtmlXTreeObject.prototype._loadJSONObject=function(json,afterCall){
      if (!this.parsCount) this.callEvent("onXLS",[this,null]);this.xmlstate=1;
      var p=new jsonPointer(json);
	  this._parse(p);
	  this._p=p;
      if (afterCall) afterCall();
   };
   

/**   
*     @desc: load tree from json file
*     @type: public
*     @param: file - link to JSON file
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.loadJSON=function(file,callback){
	  if (window.console && window.console.info)
        window.console.info("loadJSON was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");
    	return this._loadJSON(file, callback);
   };
   dhtmlXTreeObject.prototype._loadJSON=function(file,callback){
	  if (!this.parsCount) this.callEvent("onXLS",[this,this._ld_id]); this._ld_id=null; this.xmlstate=1;
      var that=this;
      
      this.XMLLoader=function(xml, callback){
      	try {
			eval("var t="+xml.responseText);
		} catch(e){
				dhx4.callEvent("onLoadXMLerror",["Incorrect JSON",
					(xml),
					this
				]);
				return;
		}
      	var p=new jsonPointer(t);
      	this._parse(p);
      	this._p=p;
      	if (callback) callback.call(this, xml);
      };
      
      dhx4.ajax.get(file, function(obj){
      	that.XMLLoader(obj.xmlDoc, callback);
      });
   };   
   
   
/**   
*     @desc: return tree as json string
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.serializeTreeToJSON=function(){
	var out=['{"id":"'+this.rootId+'", "item":['];
	var p=[];
		for (var i=0; i<this.htmlNode.childsCount; i++)
			p.push(this._serializeItemJSON(this.htmlNode.childNodes[i]));
	out.push(p.join(","));
	out.push("]}");	
	return out.join("");
};
dhtmlXTreeObject.prototype._serializeItemJSON=function(itemNode){
	var out=[];
	if (itemNode.unParsed)
			return (itemNode.unParsed.text());
  
	if (this._selected.length)
		var lid=this._selected[0].id;
	else lid="";
    var text=itemNode.span.innerHTML;

	text=text.replace(/\"/g, "\\\"", text);

	if (!this._xfullXML)
		out.push('{ "id":"'+itemNode.id+'", '+(this._getOpenState(itemNode)==1?' "open":"1", ':'')+(lid==itemNode.id?' "select":"1",':'')+' "text":"'+text+'"'+( ((this.XMLsource)&&(itemNode.XMLload==0))?', "child":"1" ':''));
	else
		out.push('{ "id":"'+itemNode.id+'", '+(this._getOpenState(itemNode)==1?' "open":"1", ':'')+(lid==itemNode.id?' "select":"1",':'')+' "text":"'+text+'", "im0":"'+itemNode.images[0]+'", "im1":"'+itemNode.images[1]+'", "im2":"'+itemNode.images[2]+'" '+(itemNode.acolor?(', "aCol":"'+itemNode.acolor+'" '):'')+(itemNode.scolor?(', "sCol":"'+itemNode.scolor+'" '):'')+(itemNode.checkstate==1?', "checked":"1" ':(itemNode.checkstate==2?', "checked":"-1"':''))+(itemNode.closeable?', "closeable":"1" ':'')+( ((this.XMLsource)&&(itemNode.XMLload==0))?', "child":"1" ':''));

	if ((this._xuserData)&&(itemNode._userdatalist))
		{
			out.push(', "userdata":[');
			var names=itemNode._userdatalist.split(",");
			var p=[];
			for  (var i=0; i<names.length; i++)
				p.push('{ "name":"'+names[i]+'" , "content":"'+itemNode.userData["t_"+names[i]]+'" }');
			out.push(p.join(",")); out.push("]");
		}
		
		if (itemNode.childsCount){
			out.push(', "item":[');
			var p=[];
		for (var i=0; i<itemNode.childsCount; i++)
			p.push(this._serializeItemJSON(itemNode.childNodes[i]));
			out.push(p.join(","));
			out.push("]\n");
		}
			
		out.push("}\n")
	return out.join("");
}   
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXTreeFromHTML(obj){
			if (typeof(obj)!="object")
				obj=document.getElementById(obj);

            var n=obj;
			var id=n.id;
			var cont="";

			for (var j=0; j<obj.childNodes.length; j++)
				if (obj.childNodes[j].nodeType=="1"){
					if (obj.childNodes[j].tagName=="XMP"){
						var cHead=obj.childNodes[j];
						for (var m=0; m<cHead.childNodes.length; m++)
							cont+=cHead.childNodes[m].data;

						}
					else if (obj.childNodes[j].tagName.toLowerCase()=="ul")
						cont=dhx_li2trees(obj.childNodes[j],new Array(),0);
					break;
					}
			obj.innerHTML="";


			var t=new dhtmlXTreeObject(obj,"100%","100%",0);
			var z_all=new Array();
			for ( b in t )
				z_all[b.toLowerCase()]=b;

			var atr=obj.attributes;
			for (var a=0; a<atr.length; a++)
				if ((atr[a].name.indexOf("set")==0)||(atr[a].name.indexOf("enable")==0)){
					var an=atr[a].name;
                    if (!t[an])
						an=z_all[atr[a].name];
					t[an].apply(t,atr[a].value.split(","));
					}

			if (typeof(cont)=="object"){
			    t.XMLloadingWarning=1;
				for (var i=0; i<cont.length; i++){
					var n=t.insertNewItem(cont[i][0],cont[i][3],cont[i][1]);
					if (cont[i][2]) t._setCheck(n,cont[i][2]);
					}
				t.XMLloadingWarning=0;
				t.lastLoadedXMLId=0;
				t._redrawFrom(t);
			}
			else
			t.parse("<tree id='0'>"+cont+"</tree>");
            window[id]=t;
            
            var oninit = obj.getAttribute("oninit");
            if (oninit) eval(oninit);
			return t;
}

function dhx_init_trees(){
    var z=document.getElementsByTagName("div");
    for (var i=0; i<z.length; i++)
        if (z[i].className=="dhtmlxTree")
			dhtmlXTreeFromHTML(z[i])
}

function dhx_li2trees(tag,data,ind){
	for (var i=0; i<tag.childNodes.length; i++){
        var z=tag.childNodes[i];
		if ((z.nodeType==1)&&(z.tagName.toLowerCase()=="li")){
			var c=""; var ul=null;
				var check=z.getAttribute("checked");
				for (var j=0; j<z.childNodes.length; j++){
				var zc=z.childNodes[j];
				if (zc.nodeType==3) c+=zc.data;
				else if (zc.tagName.toLowerCase()!="ul")  c+=dhx_outer_html(zc);
					 else ul=zc;
			}

			data[data.length]=[ind,c,check,(z.id||(data.length+1))];
			if (ul)
				data=dhx_li2trees(ul,data,(z.id||data.length));
		}
	}
	return data;
}

function dhx_outer_html(node){
		if (node.outerHTML) return node.outerHTML;
		var temp=document.createElement("DIV");
		temp.appendChild(node.cloneNode(true));
		temp=temp.innerHTML;
		return temp;
}

if (window.addEventListener) window.addEventListener("load",dhx_init_trees,false);
else    if (window.attachEvent) window.attachEvent("onload",dhx_init_trees);
//(c)dhtmlx ltd. www.dhtmlx.com




/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXTreeObject.prototype.parserExtension={
	_parseExtension:function(p,a,pid) {
		this._idpull[a.id]._attrs=a;
	}
};

dhtmlXTreeObject.prototype.getAttribute=function(id,name){
	this._globalIdStorageFind(id)
	var t=this._idpull[id]._attrs;
	return t?t[name]:window.undefined;
}
dhtmlXTreeObject.prototype.setAttribute=function(id,name,value){
	this._globalIdStorageFind(id)
	var t=(this._idpull[id]._attrs)||{};
	t[name]=value;
	this._idpull[id]._attrs=t;
}


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*
Purpose: keyboard navigation extension
*/

/**
*     @desc: enable keyboard navigation in tree
*     @param: mode - true/false
*     @edition: Professional
*     @type: public
*     @topic: 4
*/
dhtmlXTreeObject.prototype.enableKeyboardNavigation=function(mode){
        this._enblkbrd=dhx4.s2b(mode);
        if (this._enblkbrd){
            if (_isFF){
                var z=window.getComputedStyle(this.parentObject,null)["position"];
                if ((z!="absolute")&&(z!="relative"))
                    this.parentObject.style.position="relative";
                }
            this._navKeys=[["up",38],["down",40],["open",39],["close",37],["call",13],["edit",113]];
            var self=this;
            var z=document.createElement("INPUT");
                z.className="a_dhx_hidden_input";
                z.autocomplete="off";
                if (window._KHTMLrv) z.style.color="white";
            this.parentObject.appendChild(z);
            this.parentObject[_isOpera?"onkeypress":"onkeydown"]=function(e){
            	if (self.callEvent("onKeyPress",[(e||window.event).keyCode,(e||window.event)]))
                	return self._onKeyDown(e||window.event)
                
            }
            this.parentObject.onclick=function(e){
                    if (_isFF || _isIE)
                    	z.select();
                    if (window._KHTMLrv || _isOpera) 
                    	z.focus();
            }
        }
        else
            this.parentObject.onkeydown=null;
}


dhtmlXTreeObject.prototype._onKeyDown=function(e){
    if (window.globalActiveDHTMLGridObject && globalActiveDHTMLGridObject.isActive) 
        return true;
    var self=this;
    for (var i=0; i<this._navKeys.length; i++)
        if (this._navKeys[i][1]==e.keyCode){
        	
            this["_onkey_"+this._navKeys[i][0]].apply(this,[this.getSelectedItemId()]);
            if (e.preventDefault) e.preventDefault();
			(e||event).cancelBubble=true;
            return false;
            }
    if (this._textSearch) {
    	return this._searchItemByKey(e);
    }
    return true;
}

dhtmlXTreeObject.prototype._onkey_up=function(id){
   	var temp=this._globalIdStorageFind(id);
    if (!temp) return;
    var next=this._getPrevVisibleNode(temp);
    if (next.id==this.rootId) return;
    this.focusItem(next.id);
    this.selectItem(next.id,false);
}
dhtmlXTreeObject.prototype._onkey_down=function(id){
   	var temp=this._globalIdStorageFind(id);
    if (!temp) return;
    var next=this._getNextVisibleNode(temp);
    if (next.id==this.rootId) return;
    this.focusItem(next.id);
    this.selectItem(next.id,false);
}
dhtmlXTreeObject.prototype._onkey_open=function(id){
    this.openItem(id);
}
dhtmlXTreeObject.prototype._onkey_close=function(id){
    this.closeItem(id);
}
dhtmlXTreeObject.prototype._onkey_call=function(id){
	if (this.stopEdit){
		this.stopEdit();
		this.parentObject.lastChild.focus();
		this.parentObject.lastChild.focus();
	    this.selectItem(id,true);
		}
	else
	    this.selectItem(this.getSelectedItemId(),true);
}
dhtmlXTreeObject.prototype._onkey_edit=function(id){
	if (this.editItem)
   		this.editItem(id);
}


dhtmlXTreeObject.prototype._getNextVisibleNode=function(item,mode){
	if ((!mode)&&(this._getOpenState(item)>0)) return item.childNodes[0];
	if ((item.tr)&&(item.tr.nextSibling)&&(item.tr.nextSibling.nodem))
    	return item.tr.nextSibling.nodem;

    if (item.parentObject) return  this._getNextVisibleNode(item.parentObject,1);
	return item;
};

dhtmlXTreeObject.prototype._getPrevVisibleNode=function(item){
	if ((item.tr)&&(item.tr.previousSibling)&&(item.tr.previousSibling.nodem))
    	return this._lastVisibleChild(item.tr.previousSibling.nodem);

	if (item.parentObject)
		return item.parentObject;
	else return item;
};

dhtmlXTreeObject.prototype._lastVisibleChild=function(item){
	if (this._getOpenState(item)>0)
		return this._lastVisibleChild(item.childNodes[item.childsCount-1]);
	else return item;
};


dhtmlXTreeObject.prototype._searchItemByKey=function(e){
	if (e.keyCode==8) {
		this._textSearchString='';
		return true;
	}
    var key = String.fromCharCode(e.keyCode).toUpperCase();
    if (key.match(/[A-Z,a-z,0-9\ ]/)) {
	    this._textSearchString += key;
	    this._textSearchInProgress = true;
		if (!(this.getSelectedItemText()||"").match(RegExp('^'+this._textSearchString,"i"))){
		    this.findItem(this._textSearchString, 0);
		}
		this._textSearchInProgress = false;
	    if (e.preventDefault) e.preventDefault();
	    (e||event).cancelBubble=true;
	    return false;
    }
    return true;
}



/**
*     @desc: configure keys used for keyboard navigation
*     @param: keys - configuration array, please check pro_key_nav.html in samples for more details
*     @edition: Professional
*     @type: public
*     @topic: 4
*/
dhtmlXTreeObject.prototype.assignKeys=function(keys){
      this._navKeys=keys;
}

/**
*     @desc: enable search items by pressing keys (any item in tree should be focused/selected to make search work)
*     @param: mode - true/false
*     @edition: Professional
*     @type: public
*     @topic: 4
*/
dhtmlXTreeObject.prototype.enableKeySearch=function(mode){
	this._textSearch = dhx4.s2b(mode);
	if (!this._textSearch) return;
	this._textSearchString = '';
	var self = this;
	this._markItem2 = this._markItem;
	this._markItem = function(node)
				     { 
				     	if (!self._textSearchInProgress)
	                    	self._textSearchString = '';
						self._markItem2(node);
				     }

}
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*
Purpose: temporary loading XML item
Warining - this extension is an experimental and not fully compatible
*/


/**
*     @desc: enable/disable "Loading..." item
*     @param: text - text of temporary item (default is "Loading...")
*     @edition: Professional
*     @type: public
*     @topic: 0
*/
 	dhtmlXTreeObject.prototype.enableLoadingItem=function(text) {
            this.attachEvent("onXLS",this._showFakeItem);
            this.attachEvent("onXLE",this._hideFakeItem);

            this._tfi_text=text||"Loading...";
    };


 	dhtmlXTreeObject.prototype._showFakeItem=function(tree,id) {
        if ((id===null)||(this._globalIdStorageFind("fake_load_xml_"+id))) return;
        var temp = this.XMLsource; this.XMLsource=null;
        this.insertNewItem(id,"fake_load_xml_"+id,this._tfi_text);
        this.XMLsource=temp;
    }
 	dhtmlXTreeObject.prototype._hideFakeItem=function(tree,id) {
        if (id===null) return;
        this.deleteItem("fake_load_xml_"+id);
    }
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/


/*
Purpose: locked item extension for dhtmlxTree
Last updated: 11.01.2006
*/


/**
*     @desc: get locked state of item
*     @param: itemId - id of item
*     @returns: true/false  - locked/unlocked
*     @edition: Professional
*     @type: public
*     @topic: 4
*/
dhtmlXTreeObject.prototype.isLocked=function(itemId)
	{
        if (!this._locker) this._init_lock();
        return  (this._locker[itemId]==true);
	};

dhtmlXTreeObject.prototype._lockItem=function(sNode,state,skipdraw){
	if (!this._locker) this._init_lock();
    if (state){

            if (this._locker[sNode.id]==true) return;
            this._locker[sNode.id]=true;

            sNode.bIm0=sNode.images[0];
            sNode.bIm1=sNode.images[1];
            sNode.bIm2=sNode.images[2];

            sNode.images[0]=this.lico0;
            sNode.images[1]=this.lico1;
            sNode.images[2]=this.lico2;

            var z1=sNode.span.parentNode;
            var z2=z1.previousSibling;

            this.dragger.removeDraggableItem(z1);
            this.dragger.removeDraggableItem(z2);
        }
        else{
            if (this._locker[sNode.id]!=true) return;
            this._locker[sNode.id]=false;

            sNode.images[0]=sNode.bIm0;
            sNode.images[1]=sNode.bIm1;
            sNode.images[2]=sNode.bIm2;

            var z1=sNode.span.parentNode;
            var z2=z1.previousSibling;

            this.dragger.addDraggableItem(z1,this);
            this.dragger.addDraggableItem(z2,this);
        }

       if (!skipdraw) this._correctPlus(sNode);
}
/**
*     @desc: lock/unlock item
*     @param: itemId - id of item
*     @param: state - true/false  - lock/unlock item
*     @edition: Professional
*     @type: public
*     @topic: 4
*/
dhtmlXTreeObject.prototype.lockItem=function(itemId,state)
	{
        if (!this._locker) this._init_lock();
        this._lockOn=false;
		var sNode=this._globalIdStorageFind(itemId);
        this._lockOn=true;
        this._lockItem(sNode,dhx4.s2b(state));
	}
/**
*     @desc: set icon for locked items
*     @param: im0 - icon for locked leaf
*     @param: im1 - icon for closed branch
*     @param: im2 - icon for opened branch
*     @edition: Professional
*     @type: public
*     @topic: 4
*/
dhtmlXTreeObject.prototype.setLockedIcons=function(im0,im1,im2)
	{
        if (!this._locker) this._init_lock();
        this.lico0=im0;
        this.lico1=im1;
        this.lico2=im2;
    };


dhtmlXTreeObject.prototype._init_lock=function()
	{
        this._locker=new Array();
        this._locker_count="0";
        this._lockOn=true;
        this._globalIdStorageFindA=this._globalIdStorageFind;
        this._globalIdStorageFind=this._lockIdFind;

        if (this._serializeItem){
            this._serializeItemA=this._serializeItem;
            this._serializeItem=this._serializeLockItem;


            this._serializeTreeA=this.serializeTree;
            this.serializeTree=this._serializeLockTree;

            }

        this.setLockedIcons(this.imageArray[0],this.imageArray[1],this.imageArray[2]);
    };


dhtmlXTreeObject.prototype._lockIdFind=function(itemId,skipXMLSearch,skipParsing)
	{
        if (!this.skipLock)
            if ((!skipParsing)&&(this._lockOn==true)&&(this._locker[itemId]==true)) {  return null; }
        return this._globalIdStorageFindA(itemId,skipXMLSearch,skipParsing);
    };
dhtmlXTreeObject.prototype._serializeLockItem=function(node)
	{
        if (this._locker[node.id]==true) return "";
        return this._serializeItemA(node);
    };
dhtmlXTreeObject.prototype._serializeLockTree=function()
	{
        var out=this._serializeTreeA();
        return out.replace(/<item[^>]+locked\=\"1\"[^>]+\/>/g,"");
    };


dhtmlXTreeObject.prototype._moveNodeToA=dhtmlXTreeObject.prototype._moveNodeTo;
dhtmlXTreeObject.prototype._moveNodeTo=function(itemObject,targetObject,beforeNode){
	   	if ((targetObject.treeNod.isLocked)&&(targetObject.treeNod.isLocked(targetObject.id))) {
			return false;
		}
		return this._moveNodeToA(itemObject,targetObject,beforeNode);
		}



/**
*     @desc: lock tree
*     @param: isLock - bool value. True - lock, false - unlock
*     @edition: Professional
*     @type: public
*     @topic: 4
*/
dhtmlXTreeObject.prototype.lockTree=function(isLock)
{
	if (dhx4.s2b(isLock))
		this._initTreeLocker();
	else
		if (this._TreeLocker) {
			this._TreeLocker.parentNode.removeChild(this._TreeLocker);
			this._TreeLocker=null;
		}
};


dhtmlXTreeObject.prototype._initTreeLocker=function(isLock)
{
	if (this._TreeLocker) return;
	this.parentObject.style.overflow="hidden";
   	if (this.parentObject.style.position != 'absolute')
		this.parentObject.style.position = 'relative';


	var div = document.createElement('div');
	div.style.position = 'absolute';
	div.style.left = '0px';
	div.style.top = '0px';
	div.className = 'dhx_tree_opacity';

	div.style.width = this.allTree.offsetWidth+'px';
	div.style.backgroundColor = '#FFFFFF';

	div.style.height = this.allTree.offsetHeight+'px';
	//div.style.display = 'none';
	this._TreeLocker = div;
   	this.parentObject.appendChild(this._TreeLocker);
};
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*
Purpose: right-to-left extension for dhtmlxTree
Last updated: 17.02.2006
*/

/**
*     @desc: enables Right-to-Left mode in tree
*     @type: public
*     @param: mode - true/false
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.enableRTL=function(mode){
        var z=dhx4.s2b(mode);
        if (((z)&&(!this.rtlMode))||((!z)&&(this.rtlMode)))
        {
        this.rtlMode=z;
        this._switchToRTL(this.rtlMode);
        }
};



dhtmlXTreeObject.prototype._switchToRTL=function(mode) {
        if (mode){
            this.allTree.className=
            this._ltr_line=this.lineArray;
            this._ltr_min=this.minusArray;
            this._ltr_plus=this.plusArray;
        	this.lineArray=new Array("line2_rtl.gif","line3_rtl.gif","line4_rtl.gif","blank.gif","blank.gif","line1_rtl.gif");
        	this.minusArray=new Array("minus2_rtl.gif","minus3_rtl.gif","minus4_rtl.gif","minus.gif","minus5_rtl.gif");
    	    this.plusArray=new Array("plus2_rtl.gif","plus3_rtl.gif","plus4_rtl.gif","plus.gif","plus5_rtl.gif");
            this.allTree.className="containerTableStyleRTL";
                }
            else
                {
            this.allTree.className="containerTableStyle";
            this.lineArray=this._ltr_line;
            this.minusArray=this._ltr_min;
            this.plusArray=this._ltr_plus;
                }
           if (this.htmlNode.childsCount)
                this._redrawFrom(this,this.htmlNode);
};

//(c)dhtmlx ltd. www.dhtmlx.com



/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*
Purpose: sorting extension for dhtmlxTree
Last updated: 03.05.2005
*/


/**
*     @desc: reorder items in tree according to their text
*     @type: public
*     @param: nodeId - id of node to start sorting from
*     @param: all_levels - sorting all levels or only current level
*     @param: order - sorting order - ASC or DES
*     @edition: Professional
*     @topic: 0
*/

dhtmlXTreeObject.prototype.sortTree=function(nodeId,order,all_levels)
	{
		var sNode=this._globalIdStorageFind(nodeId);
		if (!sNode) return false;

		this._reorderBranch(sNode,(order.toString().toLowerCase()=="asc"),dhx4.s2b(all_levels))
	};

/**
*     @desc: set custom sort functions, which has two parametrs - id_of_item1,id_of_item2
*     @type: public
*     @param: func - sorting function
*     @edition: Professional
*     @topic: 0
*/
dhtmlXTreeObject.prototype.setCustomSortFunction=function(func)
	{
        this._csfunca=func;
	};
	
	
dhtmlXTreeObject.prototype._reorderBranch=function(node,order,all_levels){ 
	var m=[];
	var count=node.childsCount;
	if (!count) return;

	var parent = node.childNodes[0].tr.parentNode;
	for (var i=0; i<count; i++){
			m[i]=node.childNodes[i];
			parent.removeChild(m[i].tr);
			}

var self=this;
if (order==1)
    if(this._csfunca)
    	m.sort( function(a,b){ return self._csfunca(a.id,b.id); } );
    else
    	m.sort( function(a,b){ return ((a.span.innerHTML.toUpperCase()>b.span.innerHTML.toUpperCase())?1:((a.span.innerHTML.toUpperCase()==b.span.innerHTML.toUpperCase())?0:-1)) } );
else
    if(this._csfunca)
    	m.sort( function(a,b){ return self._csfunca(b.id,a.id); } );
    else
    	m.sort( function(a,b){ return ((a.span.innerHTML.toUpperCase()<b.span.innerHTML.toUpperCase())?1:((a.span.innerHTML.toUpperCase()==b.span.innerHTML.toUpperCase())?0:-1)) } );

	for (var i=0; i<count; i++){
		parent.appendChild(m[i].tr);
		node.childNodes[i]=m[i];
		
		if ((all_levels)&&(m[i].unParsed))
			m[i].unParsed.set("order",order?1:-1);
		else
		if ((all_levels)&&(m[i].childsCount))
			this._reorderBranch(m[i],order,all_levels);
		
		}
	
	for (var i=0; i<count; i++){
		this._correctPlus(m[i]);
		this._correctLine(m[i]);
		}
}

dhtmlXTreeObject.prototype._reorderXMLBranch=function(node){
	var orderold=node.getAttribute("order");
    if (orderold=="none") return;
	var order=(orderold==1);
	var count=node.childNodes.length;
	if (!count) return;

	var m=new Array();
    var j=0;

	for (var i=0; i<count; i++)
        if (node.childNodes[i].nodeType==1)
    		{ m[j]=node.childNodes[i]; j++ }

	for (var i=count-1; i!=0; i--)
		node.removeChild(node.childNodes[i]);


	if (order)
		m.sort( function(a,b){ return ((a.getAttribute("text")>b.getAttribute("text"))?1:((a.getAttribute("text")==b.getAttribute("text"))?0:-1)) } );
	else
		m.sort( function(a,b){ return ((a.getAttribute("text")<b.getAttribute("text"))?1:((a.getAttribute("text")==b.getAttribute("text"))?0:-1)) } );

	for (var i=0; i<j; i++){
		m[i].setAttribute("order",orderold);
		node.appendChild(m[i]);
		}

    node.setAttribute("order","none");
}
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*
Purpose: saving state extension for dhtmlxTree
Inner Version: 1.3
Last updated: 05.07.2005
*/

dhtmlXTreeObject.prototype._serEnts=[["&","&amp;"],["<","&lt;"],[">","&gt;"]];

/**
*     @desc: register XML entity for replacement while initialization (default are: ampersand, lessthen and greaterthen symbols)
*     @type: public
*     @edition: Professional
*	  @param: rChar - source char
*	  @param: rEntity - target entity
*     @topic: 2
*/
dhtmlXTreeObject.prototype.registerXMLEntity=function(rChar,rEntity){
    this._serEnts[this._serEnts.length]=[rChar,rEntity,new RegExp(rChar,"g")];
}

/**
*     @desc: configure XML serialization
*     @type: public
*     @edition: Professional
*	  @param: userData - enable/disable user data serialization
*	  @param: fullXML - enable/disable full XML serialization
*	  @param: escapeEntities - convert tag brackets to related html entitites
*	  @param: userDataAsCData - output user data in CDATA sections
*	  @param: DTD - if specified, then set as XML's DTD
*     @topic: 2
*/
dhtmlXTreeObject.prototype.setSerializationLevel=function(userData,fullXML,escapeEntities,userDataAsCData,DTD){
	this._xuserData=dhx4.s2b(userData);
	this._xfullXML=dhx4.s2b(fullXML);
    this._dtd=DTD;
    this._xescapeEntities=dhx4.s2b(escapeEntities);
    if (dhx4.s2b(userDataAsCData)){
        this._apreUC="<![CDATA[";
        this._apstUC="]]>";
    }
    else{
    }

    for (var i=0; i< this._serEnts.length; i++)
        this._serEnts[i][2]=new RegExp(this._serEnts[i][0],"g");
}

/**
*     @desc: get xml representation (as string) of tree
*     @type: public
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.serializeTree=function(){
    if (this.stopEdit) this.stopEdit();
    this._apreUC=this._apreUC||"";
    this._apstUC=this._apstUC||"";
	var out='<?xml version="1.0"?>';
    if (this._dtd)
        out+="<!DOCTYPE tree SYSTEM \""+this._dtd+"\">";
    out+='<tree id="'+this.rootId+'">';

		if ((this._xuserData)&&(this._idpull[this.rootId]._userdatalist))
		{
		var names=this._idpull[this.rootId]._userdatalist.split(",");
		for  (var i=0; i<names.length; i++)
			out+="<userdata name=\""+names[i]+"\">"+this._apreUC+this._idpull[this.rootId].userData["t_"+names[i]]+this._apstUC+"</userdata>";
		}


		for (var i=0; i<this.htmlNode.childsCount; i++)
		out+=this._serializeItem(this.htmlNode.childNodes[i]);
		
	out+="</tree>";
	return out;
};
/**  
*     @desc: return xml description of tree item
*     @type: private
*     @param: itemNode - tree item object
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype._serializeItem=function(itemNode){
	if (itemNode.unParsed)
		if (dhx4.isIE){
			return itemNode.unParsed.d.xml;
		}
		else{
  var xmlSerializer = new XMLSerializer();
  return xmlSerializer.serializeToString(itemNode.unParsed.d);
		}

		
	var out="";
	if (this._selected.length)
		var lid=this._selected[0].id;
	else lid="\"";


    var text=itemNode.span.innerHTML;

    if (this._xescapeEntities)
        for (var i=0; i<this._serEnts.length; i++)
            text=text.replace(this._serEnts[i][2],this._serEnts[i][1]);

	if (!this._xfullXML)
		out='<item id="'+itemNode.id+'" '+(this._getOpenState(itemNode)==1?' open="1" ':'')+(lid==itemNode.id?' select="1"':'')+' text="'+text+'"'+( ((this.XMLsource)&&(itemNode.XMLload==0))?" child=\"1\" ":"")+'>';
	else
		out='<item id="'+itemNode.id+'" '+(this._getOpenState(itemNode)==1?' open="1" ':'')+(lid==itemNode.id?' select="1"':'')+' text="'+text+'" im0="'+itemNode.images[0]+'" im1="'+itemNode.images[1]+'" im2="'+itemNode.images[2]+'" '+(itemNode.acolor?('aCol="'+itemNode.acolor+'" '):'')+(itemNode.scolor?('sCol="'+itemNode.scolor+'" '):'')+(itemNode.checkstate==1?'checked="1" ':(itemNode.checkstate==2?'checked="-1"':''))+(itemNode.closeable?'closeable="1" ':'')+( ((this.XMLsource)&&(itemNode.XMLload==0))?" child=\"1\" ":"")+'>';

	if ((this._xuserData)&&(itemNode._userdatalist))
		{
		var names=itemNode._userdatalist.split(",");
		for  (var i=0; i<names.length; i++)
			out+="<userdata name=\""+names[i]+"\">"+this._apreUC+itemNode.userData["t_"+names[i]]+this._apstUC+"</userdata>";
		}

		for (var i=0; i<itemNode.childsCount; i++)
			out+=this._serializeItem(itemNode.childNodes[i]);
			


	out+="</item>";
	return out;
}
/**  
*     @desc: save selected item to cookie
*     @type: public
*     @param: name - optional, cookie name
*     @param: cookie_param - additional parametrs added to cookie
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.saveSelectedItem=function(name,cookie_param){
	name=name||"";
	this.setCookie("treeStateSelected"+name,this.getSelectedItemId(),cookie_param);
}
/**     @desc: restore selected item from cookie
*     @type: public
*     @param: name - optional, cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.restoreSelectedItem=function(name){
	name=name||"";
	var z=this.getCookie("treeStateSelected"+name);
	this.selectItem(z,false);
}


/**   @desc: enable/disable autosaving selected node in cookie
*     @type: public
*     @param: mode - true/false
*     @edition: Professional
*     @topic: 2
*/	
dhtmlXTreeObject.prototype.enableAutoSavingSelected=function(mode,cookieName){
 this.assMode=dhx4.s2b(mode);
 if ((this.assMode)&&(!this.oldOnSelect)){
		 this.oldOnSelect=this.onRowSelect;
		 this.onRowSelect=function(e,htmlObject,mode){
 			if (!htmlObject) htmlObject=this;
			htmlObject.parentObject.treeNod.oldOnSelect(e,htmlObject,mode);
			if (htmlObject.parentObject.treeNod.assMode)
				htmlObject.parentObject.treeNod.saveSelectedItem(htmlObject.parentObject.treeNod.assCookieName);
		}
 }

 this.assCookieName=cookieName;
}


/**   @desc: save tree to cookie
*     @type: public
*     @param: name - optional, cookie name
*     @param: cookie_param - additional parametrs added to cookie
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.saveState=function(name,cookie_param){
	var z=this._escape(this.serializeTree());
	var kusok = 4000;
	if (z.length>kusok)
	{
		if(navigator.appName.indexOf("Microsoft")!=-1)
			return false;//IE max cookie length is ~4100
	this.setCookie("treeStatex"+name,Math.ceil(z.length/kusok));
		for (var i=0; i<Math.ceil(z.length/kusok); i++)
		{
			this.setCookie("treeStatex"+name+"x"+i,z.substr(i*kusok,kusok),cookie_param);
		}
	}
	else
		this.setCookie("treeStatex"+name,z,cookie_param);
	var z=this.getCookie("treeStatex"+name);
    if (!z) {
		this.setCookie("treeStatex"+name,"",cookie_param);
		return false;
	}
    return true;
}
/**   @desc: load tree from cookie
*     @type: public
*     @param: name - optional,cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.loadState=function(name){
	var z=this.getCookie("treeStatex"+name);
//    alert("treeStatex"+name);
    if (!z) return false;

	if (z.length)
	{
		if (z.toString().length<4)
		{

			var z2="";
			for (var i=0; i<z; i++){
				z2+=this.getCookie("treeStatex"+name+"x"+i);
                }
			z=z2;
		}
		this.parse((this.utfesc=="utf8")?decodeURI(z):unescape(z));
	}

    return true;
}
/**   @desc: save cookie
*     @type: private
*     @param: name - cookie name
*     @param: value - cookie value
*     @param: cookie_param - additional parametrs added to cookie
*     @edition: Professional
*     @topic: 0
*/

dhtmlXTreeObject.prototype.setCookie=function(name,value,cookie_param) {
	var str = name + "=" + value +  (cookie_param?("; "+cookie_param):"");
  /*  ((expires) ? "; expires=" + expires.toGMTString() : "") +
    ((path) ? "; path=" + path : "; path=/") +
    ((domain) ? "; domain=" + domain : "") +
    ((secure) ? "; secure" : "");*/
	document.cookie = str;
}

/**   @desc: get cookie
*     @type: private
*     @param: name - cookie name
*     @edition: Professional
*     @topic: 0
*/	
dhtmlXTreeObject.prototype.getCookie=function(name) {
	var search = name + "=";
	if (document.cookie.length > 0) {
		var offset = document.cookie.indexOf(search);
		if (offset != -1) {
			offset += search.length;
			var end = document.cookie.indexOf(";", offset);
			if (end == -1)
				end = document.cookie.length;
			return document.cookie.substring(offset, end);
						}		}
};



/**   @desc: save open nodes to cookie
*     @type: public
*     @edition: Professional
*     @param: name - optional,cookie name
*     @param: cookie_param - additional parametrs added to cookie
*     @topic: 2
*/
dhtmlXTreeObject.prototype.saveOpenStates=function(name,cookie_param){
    var z=[];
    for (var i=0; i<this.htmlNode.childsCount; i++)
    	z=z.concat(this._collectOpenStates(this.htmlNode.childNodes[i]));
    z=z.join(this.dlmtr);

	this.setCookie("treeOpenStatex"+name,z,cookie_param);
};

/**   @desc: restore open nodes from cookie
*     @type: public
*     @edition: Professional
*     @param: name - optional,cookie name
*     @topic: 2
*/
dhtmlXTreeObject.prototype.loadOpenStates=function(name){
	for (var i=0; i<this.htmlNode.childsCount; i++)
    	this._xcloseAll(this.htmlNode.childNodes[i]);

 this.allTree.childNodes[0].border = "1";
 this.allTree.childNodes[0].border = "0";

	var z=getCookie("treeOpenStatex"+name);
	if (z) {
		var arr=z.split(this.dlmtr);
		for (var i=0; i<arr.length; i++)
			{
            var zNode=this._globalIdStorageFind(arr[i]);
            if (zNode){
                if  ((this.XMLsource)&&(!zNode.XMLload)&&(zNode.id!=this.rootId)){
                     this._delayedLoad(zNode,"loadOpenStates('"+name+"')");
                     return;
                    }
                else
           			this.openItem(arr[i]);
                }
			}
		}
	this.callEvent("onAllOpenDynamic",[]);
};

dhtmlXTreeObject.prototype._delayedLoad=function(node,name){
    this.afterLoadMethod=name;
	this.onLoadReserve = this.onXLE; //save loading end handler
	this.onXLE=this._delayedLoadStep2; //set on XML data loading end handler
	this._loadDynXML(node.id);
}
dhtmlXTreeObject.prototype._delayedLoadStep2=function(tree){
	tree.onXLE=tree.onLoadReserve; //save loading end handler
//    if (tree.onXLE) tree.onXLE(tree);
    window.setTimeout( function() { dhtmlx.temp = tree; eval("dhtmlx.temp."+tree.afterLoadMethod);  } ,100);
	if (tree.onXLE) tree.onXLE(tree);
	tree.callEvent("onXLE",[tree]);

}

/**   @desc: build list of opened nodes
*     @type: private
*     @edition: Professional
*     @param: node - start tree item
*     @param: list - start list value
*     @topic: 2
*/
dhtmlXTreeObject.prototype._collectOpenStates=function(node){
	var list=[];
	if (this._getOpenState(node)==1)
    {
    list.push(node.id);
	for (var i=0; i<node.childsCount; i++)
		list=list.concat(this._collectOpenStates(node.childNodes[i]));
    }
	return list;
};

/**   @desc: save cookie
*     @type: private
*     @edition: Professional
*     @param: name - cookie name
*     @param: value - cookie value
*     @topic: 0
*/
function setCookie(name,value) {
	document.cookie = name+'='+value;
}

/**   @desc: get cookie
*     @type: private
*     @edition: Professional
*     @param: name - cookie name
*     @topic: 0
*/
function getCookie(name) {
	var search = name + "=";
	if (document.cookie.length > 0) {
		var offset = document.cookie.indexOf(search);
		if (offset != -1) {
			offset += search.length;
			var end = document.cookie.indexOf(";", offset);
			if (end == -1)
				end = document.cookie.length;
			return (document.cookie.substring(offset, end));
						}		}
};

/**
*     @desc: expand target node and all child nodes (same as openAllItems, but works in dynamic trees)
*     @type: public
*     @edition: Professional
*     @param: itemId - node id, optional
*     @topic: 4
*/
	dhtmlXTreeObject.prototype.openAllItemsDynamic = function(itemId)
	{
        this.ClosedElem=new Array();
        this.G_node=null;
		var itemNode = this._globalIdStorageFind(itemId||this.rootId); //get node object by id of tree sart node
		if (itemNode.id != this.rootId &&this.getOpenState(itemNode.id) != 0) this.openItem(itemId);
		this._openAllNodeChilds(itemNode, 0); //open closed nodes that have data, or find nodes that have no data yet


		if(this.ClosedElem.length>0){
			this.onLoadReserve = this.onXLE; //save loading end handler
			this.onXLE=this._loadAndOpen; //set on XML data loading end handler
			this._loadAndOpen(this); //if there are not loaded items -> run load&open routine
		}
	};

	dhtmlXTreeObject.prototype._openAllNodeChilds = function(itemNode)
	{
			//for dynamic loading
    	if ((itemNode.XMLload==0)||(itemNode.unParsed))  this.ClosedElem.push(itemNode);  //if not loaded put in array
		for (var i=0; i<itemNode.childsCount; i++) //for all childnodes
		{
			//no dynamic loading
			if(this._getOpenState(itemNode.childNodes[i])<0) this._HideShow(itemNode.childNodes[i],2); //if closed -> open
			if(itemNode.childNodes[i].childsCount>0) this._openAllNodeChilds(itemNode.childNodes[i]); //if has childs -> run same routine for that node

			//for dynamic loading
			if ((itemNode.childNodes[i].XMLload==0)||(itemNode.childNodes[i].unParsed)) this.ClosedElem.push(itemNode.childNodes[i]); //if not loaded put in array
		}
	}

	dhtmlXTreeObject.prototype._loadAndOpen = function(that)
	{
		if(that.G_node) //if there was loaded one node
		{
			that._openItem(that.G_node); //open it
			that._openAllNodeChilds(that.G_node); //run open/find closed nodes for childs of this node
			that.G_node = null; //erase "just loaded node" pointer
		}

		if(that.ClosedElem.length>0) that.G_node = that.ClosedElem.shift(); //get not loaded node if any left in array

		if(that.G_node)
            if (that.G_node.unParsed)
                that.reParse(that.G_node);
            else
                window.setTimeout( function(){  that._loadDynXML(that.G_node.id); },100);
        else
			{
            that.onXLE = that.onLoadReserve; //restore loading end handler if finished opening
            if (that.onXLE) that.onXLE(that);
			that.callEvent("onAllOpenDynamic",[that]);
			}
	}


/**
*     @desc: expand list of nodes in dynamic tree (wait of loading of node before expanding next)
*     @type: public
*     @edition: Professional
*     @param: list - list of nodes which will be expanded
*     @param: flag - true/false - select last node in the list
*     @topic: 4
*/
    dhtmlXTreeObject.prototype.openItemsDynamic=function(list,flag){
    	if (this.onXLE==this._stepOpen) return;
        this._opnItmsDnmcFlg=dhx4.s2b(flag);
        this.onLoadReserve = this.onXLE;
        this.onXLE=this._stepOpen;
        this.ClosedElem=list.split(",").reverse();
        this._stepOpen(this);
        }

	dhtmlXTreeObject.prototype._stepOpen=function(that){
		if(!that.ClosedElem.length){
			that.onXLE = that.onLoadReserve;
			if (that._opnItmsDnmcFlg)
				that.selectItem(that.G_node,true);
			if ((that.onXLE)&&(arguments[1]))
				that.onXLE.apply(that,arguments);
			that.callEvent("onOpenDynamicEnd",[]);
			return;
		}
		that.G_node=that.ClosedElem.pop();
		that.skipLock = true;
		var temp=that._globalIdStorageFind(that.G_node);

		if(temp){
			if (temp.XMLload===0)
				that.openItem(that.G_node);
			else{
				that.openItem(that.G_node);
				that._stepOpen(that);
			}
		}
		that.skipLock = false;
	}

//(c)dhtmlx ltd. www.dhtmlx.com



/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXTreeView(conf) {
	
	// console.log("add cache for kids for removeItem");
	// console.log("add unload");
	
	var that = this;
	
	if (typeof(conf) == "object" && conf.tagName == null) {
		// api-init
	} else {
		conf = {parent: conf, clear: true};
	}
	
	this.base = (typeof(conf.parent)=="string"?document.getElementById(conf.parent):conf.parent);
	
	if (this.base != document.body) {
		while (this.base.childNodes.length > 0) this.base.removeChild(this.base.lastChild);
	}
	
	this.conf = {
		skin: (conf.skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxtreeview")||"material"),
	        tree_id: window.dhx4.newId(), // register tree in common pull
	        ofs: {w: 1, h: 0}, // skyblue only
		adjust_base: false,
		icons: this.icons[(typeof(conf.iconset) == "string" && this.icons[conf.iconset] != null && this.icons[conf.iconset].r == true ? conf.iconset : "tree_native")],
		autoload: {
			url: null, // will set automaticaly from 1st loadStruct
			mode: "id" // user function allowed here
		},
		selected: {},
		ud: {}, // usersdata
		idx: {sign:0,icon:1,text:2}, // icons index
		silent: false, // do not callEvent if true
		// macos related for selection
		is_mac: (navigator.platform.match(/^mac/i) != null && typeof(window.addEventListener) == "function"),
		mac_cmd_key: false
	};
	
	this.setSkin(this.conf.skin);
	
	this.cont = document.createElement("DIV");
	this.cont.className = "dhxtreeview_cont";
	this.base.appendChild(this.cont);
	
	this.area = document.createElement("DIV");
	this.area.className = "dhxtreeview_area";
	this.cont.appendChild(this.area);
	
	this.cont.onclick = function(e) {
		e = e||event;
		that.callEvent("_onTreeClick", [e, {stop:false}]);
	}
	
	this.cont.ondblclick = function(e) {
		e = e||event;
		var t = (e.target||e.srcElement);
		if (t.className.match(/dhxtreeview_item_label/) != null) {
			that._openCloseItem(t.parentNode.parentNode._itemId, true);
		}
	}
	
	
	this.items = {};
	
	this._addItem = function(id, pId, data, index) {
		
		var level = (pId!=null?this.items[pId].level+1:1);
		
		var t = document.createElement("DIV");
		t.className = "dhxtreeview_item";
		t.innerHTML = "<div class='dhxtreeview_item_text'></div>";
		
		if (index != null && index < 0) data.index = 0;
		
		if (pId == null) {
			var node = this.area;
		} else {
			var k = this.items[pId].kids;
			if (k == false) this._initKidsNode(pId);
			this.items[pId].kids_request = false; // do not use dyn load if at least 1 child is present
			var node = this.items[pId].item.lastChild.firstChild;
		}
		
		if (index != null && node.childNodes[index] != null) {
			node.insertBefore(t, node.childNodes[index]);
		} else {
			node.appendChild(t);
		}
		node = null;
		
		t._itemId = id;
		t._treeId = this.conf.tree_id;
		
		if (window.dhx4.isIE == true) {
			t.onselectstart = function(e){
				e = e||event;
				if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			}
		}
		
		this.items[id] = {
			id: id,
			pId: pId,
			treeId: this.conf.tree_id,
			text: data.text,
			item: t,
			level: level,
			kids: false, // true/false if any kid
			opened: window.dhx4.s2b(data.open),
			userdata: window.dhx4._copyObj(data.userdata||{}),
			half_opened: false // true/false to change sign only, used for dyn.load
		};
		
		this.callEvent("_onItemRendered", [id, data]);
		
		t.firstChild.innerHTML = this._getItemHtml(id);
		t = null;
		
		// pre-select
		if (window.dhx4.s2b(data.select) == true) this._setSelected(id, true);
		
		this.callEvent("_onItemInited", [id, data]);
		
	}
	
	this.addItem = function(id, text, parentId, index) {
		if (this.items[id] != null) return;
		if (parentId != null && this.items[parentId] == null) parentId = null;
		this._addItem(id, parentId, {text: text}, index);
		this._callPublicEvent("onAddItem", [id, text, parentId, index]);
	}
	
	this._removeSingleItem = function(id) {
		if (window.dhx4.isIE == true) this.items[id].item.onselectstart = null;
		this.items[id].item.parentNode.removeChild(this.items[id].item);
		
		for (var a in this.items[id]) {
			this.items[id][a] = null;
			delete this.items[id][a];
		}
		
		delete this.items[id];
		
		// clear selection if any
		if (this.conf.selected[id] == true) delete this.conf.selected[id];
	}
	
	this._removeItem = function(id) {
		
		// remove nested
		for (var a in this.items) {
			if (this.items[a].pId == id) this._removeItem(a);
		}
		
		if (id != null) this._removeSingleItem(id);
	}
	
	this.deleteItem = function(id) {
		if (this.items[id] == null) return;
		if (!this._callPublicEvent("onBeforeDeleteItem", [id])) return;
		this._removeItem(id);
		this._callPublicEvent("onDeleteItem", [id]);
	}
	
	this.clearAll = function() {
		this._removeItem(null);
		if (this.conf.unloading != true) this._fixAreaWidth();
	}
	
	this._initKidsNode = function(id) {
		
		var p;
		
		if (this.items[id].item.lastChild.className.match(/dhxtreeview_kids_cont/) == null) {
		
			p = document.createElement("DIV");
			p.className = "dhxtreeview_kids_cont";
			p.innerHTML = "<div style='position:relative;'></div>";
			
			p.style.opacity = "1";
			
			if (this.items[id].opened != true) {
				if (this.conf.transProp != false) {
					p.style.height = "0px";
					p.style.opacity = "0";
					p.firstChild.style.display = "none";
				} else {
					p.style.display = "none";
				}
			}
			
			this.items[id].item.appendChild(p);
			
		}
		
		this.items[id].kids = true;
		this._iconUpdate(id);
		this._signUpdate(id);
		
		p = null;
	}
	
	this._clearKidsNode = function(id) {
		
		if (this.items[id].item.lastChild.className.match(/dhxtreeview_kids_cont/) != null) {
			this.items[id].item.removeChild(this.items[id].item.lastChild);
		}
		
		this.items[id].kids = false;
		this._iconUpdate(id);
		this._signUpdate(id);
		
	}
	
	// open/colse
	this.openItem = function(id, anim) {
		if (this.items[id].opened != true) {
			if (typeof(anim) == "undefined") anim = true;
			this._openCloseItem(id, anim);
		}
	}
	this.closeItem = function(id, anim) {
		if (this.items[id].opened == true) {
			if (typeof(anim) == "undefined") anim = true;
			this._openCloseItem(id, anim);
		}
	}
	
	this._openCloseItem = function(id, anim) {
		
		if (this.callEvent("_onBeforeOpen", [id]) !== true) return;
		
		if (!(this.items[id].kids == true || this.items[id].kids_request == true)) return false;
		
		if (this.items[id].half_opened == true) {
			this.items[id].half_opened = false;
			this._signUpdate(id);
			return;
		}
		
		if (anim && this.conf.transProp != false) {
			
			if (!this.items[id].transEv) {
				this.items[id].item.lastChild.addEventListener(this.conf.transEv, this._doOnTrEnd);
				this.items[id].transEv = true;
			}
			
			if (this.items[id].opened == true) {
				
				// close
				
				this.items[id].transMode = "close";
				
				this.items[id].item.lastChild.style.overflow = "hidden";
				this.items[id].item.lastChild.style.height = this.items[id].item.lastChild.childNodes[0].offsetHeight+"px";
				
				window.setTimeout(function(){
						
					that.items[id].item.lastChild.style[that.conf.transProp] = that.conf.transValueHeight;
					that.items[id].item.lastChild.style.height = "0px";
					that.items[id].item.lastChild.style.opacity = "0";
					
					that.items[id].opened = false;
					that._iconUpdate(id);
					that._signUpdate(id);
					
				},50);
				
			} else {
				
				// open
				
				this.items[id].transMode = "open";
				
				this.items[id].item.lastChild.style[this.conf.transProp] = this.conf.transValueHeight;
				
				this.items[id].item.lastChild.childNodes[0].style.display = "";
				this.items[id].item.lastChild.style.overflow = "hidden";
				
				this.items[id].item.lastChild.style.height = this.items[id].item.lastChild.childNodes[0].offsetHeight+"px";
				this.items[id].item.lastChild.style.opacity = "1";
				
				this.items[id].opened = true;
				this._iconUpdate(id);
				this._signUpdate(id);
			}
			
			
		} else {
			
			// open/close
			this.items[id].opened = !this.items[id].opened;
			this.items[id].item.lastChild.style.display = (this.items[id].opened==true ? "" : "none");
			
			// add for dnd
			this.items[id].item.lastChild.childNodes[0].style.display = this.items[id].item.lastChild.style.display;
			this.items[id].item.lastChild.style.height = (this.items[id].opened==true?"":"0px");
			this.items[id].item.lastChild.style.opacity = (this.items[id].opened==true?1:0);
			// end for dnd
			
			this._iconUpdate(id);
			this._signUpdate(id);
			this._fixAreaWidth();
		}
	}
	
	this._doOnTrEnd = function() {
		
		var id = this.parentNode._itemId;
		that.items[id].item.lastChild.style[that.conf.transProp] = "";
		
		if (that.items[id].transMode == "close") {
			that.items[id].item.lastChild.childNodes[0].style.display = "none";
			//that._iconUpdate(id);
		} else {
			that.items[id].item.lastChild.style.height = "";
			that.items[id].item.lastChild.style.overflow = "";
		}
		that._fixAreaWidth();
	}
	
	// dimension
	this.setSizes = function() {
		// adjust top-parent, used in window when tree has border
		if (this.conf.adjust_base == true) {
			this.base.style.width = this.base.parentNode.clientWidth-2+"px";
			this.base.style.height = this.base.parentNode.clientHeight-2+"px";
		}
		//
		this.cont.style.left = this.conf.ofs.w+"px";
		this.cont.style.top = this.conf.ofs.h+"px";
		this.cont.style.width = this.base.clientWidth-this.conf.ofs.w*2+"px";
		this.cont.style.height = this.base.clientHeight-this.conf.ofs.h*2+"px";
		//
		this._fixAreaWidth();
	}
	
	this._fixAreaWidth = function(r) {
		this.area.style.width = "100%";
		if (this.cont.scrollWidth != this.cont.clientWidth) {
			this.area.style.width = this.cont.scrollWidth+1+"px";
		}
		if (window.dhx4.isIE7 == true && r !== false) { // extra loop for ie7 to fix scroll artefacts
			window.setTimeout(function(){that._fixAreaWidth(false);},1);
		}
	}
	
	
	this.setSizes();
	
	dhx4._eventable(this);
	
	// transition
	var k = window.dhx4.transDetect();
	this.conf.transProp = k.transProp;
	this.conf.transEv = k.transEv;
	this.conf.transValueHeight = "height 0.15s";
	k = null;
	
	// macos multiselect
	if (this.conf.is_mac == true) {
		this._macOnKey = function(e) {
			if (((window.dhx4.isKHTML || window.dhx4.isChrome || window.dhx4.isOpera) && (e.keyCode == 91 || e.keyCode == 93)) || (window.dhx4.isFF && e.keyCode == 224)) {
				that.conf.mac_cmd_key = (e.type == "keydown");
			}
		}
		window.addEventListener("keydown", this._macOnKey, false);
		window.addEventListener("keyup", this._macOnKey, false);
	}
	
	// extra modules to init if any
	for (var a in this.modules) {
		if (this.modules[a].init != null) this[this.modules[a].init](conf);
	}
	
	this.unload = function() {
		
		this.conf.unloading = true;
		
		this.cont.onclick = null;
		this.cont.ondblclick = null;
		
		this.clearAll();
		
		if (this.conf.is_mac == true) {
			window.removeEventListener("keydown", this._macOnKey, false);
			window.removeEventListener("keyup", this._macOnKey, false);
		}
		
		// extra modules to unload if any
		for (var a in this.modules) {
			if (this.modules[a].unload != null) this[this.modules[a].unload]();
		}
		
		this.area.parentNode.removeChild(this.area);
		this.area = null;
		
		this.cont.parentNode.removeChild(this.cont);
		this.cont = null;
		
		this.base.className = String(this.base.className).replace(new RegExp("\s{0,}dhxtreeview_"+(this.conf.skin||"")), "");
		
		window.dhx4._eventable(this, "clear");
		
		for (var a in this) this[a] = null;
		
		that = null;
		
	}
	
	// autoload/etc
	if (conf.items != null || conf.json != null || conf.xml != null) {
		this.loadStruct(conf.items||conf.json||conf.xml, conf.onload);
	}
	
	return this;
	
};

dhtmlXTreeView.prototype.modules = {};

// misc
dhtmlXTreeView.prototype.setSkin = function(skin) {
	this.base.className = String(this.base.className).replace(new RegExp("\s{0,}dhxtreeview_"+(this.conf.skin||"")), "") + " dhxtreeview_"+skin;
	this.conf.skin = skin;
	this.conf.icon_width = dhx4.readFromCss("dhxtreeview_"+this.conf.skin+" dhxtreeview_icon_width");
	this.conf.ofs = (this.conf.skin == "dhx_skyblue" ? {w:1, h:0} : {w:0, h:0});
};

dhtmlXTreeView.prototype.setItemText = function(id, text) {
	if (this.items[id] != null) {
		this.items[id].text = text;
		this.items[id].item.firstChild.childNodes[this.conf.idx.text].innerHTML = text;
		this._callPublicEvent("onTextChange", [id, text]);
	}
};
dhtmlXTreeView.prototype.getItemText = function(id) {
	return this.items[id].text;
};

//

dhtmlXTreeView.prototype.getParentId = function(id) {
	return this.items[id].pId;
};
dhtmlXTreeView.prototype.getSubItems = function(parentId) {
	var t = [];
	for (var a in this.items) {
		if (this.items[a].pId == parentId) t.push(a);
	}
	return t;
};

// render item html
dhtmlXTreeView.prototype._refreshItemHtml = function(id, updSign, updIcon) {
	this.items[id].item.firstChild.innerHTML = this._getItemHtml(id);
	if (updSign == true) this._signUpdate(id);
	if (updIcon == true) this._iconUpdate(id);
};
dhtmlXTreeView.prototype._getItemHtml = function(id) {
	var html = [];
	var nodeIndex = 0;
	for (var a in this.conf.idx) {
		var data = this["_itemHtml_"+a](id, nodeIndex);
		if (data.nodeText !== false) {
			html.push(data.nodeText);
			nodeIndex += data.nodeIndex;
		}
	}
	return html.join("");
};
dhtmlXTreeView.prototype._getIconOfs = function(id, index) {
	return ((this.items[id].level-1+index)*this.conf.icon_width);
};
dhtmlXTreeView.prototype._itemHtml_text = function(id, nodeIndex) {
	return {
		nodeIndex: 1,
		nodeText: "<div class='dhxtreeview_item_label' style='left:"+this._getIconOfs(id, nodeIndex)+"px;'>"+this.items[id].text+"</div>"
	};
};

// userdata
dhtmlXTreeView.prototype.setUserData = function(id, name, value) {
	var item = this.items[id];
	if (item) item.userdata[name] = value;
};
dhtmlXTreeView.prototype.getUserData = function(id, name) {
	var item = this.items[id];
	if (item && !name) return item.userdata;
	return item ? (item.userdata[name]||null) : null;
};

// events extension
dhtmlXTreeView.prototype.silent = function(f) {
	this.conf.silent = true;
	if (typeof(f) == "function") f.apply(window, [this]);
	this.conf.silent = false;
};
dhtmlXTreeView.prototype._callPublicEvent = function() {
	return (this.conf.silent == false ? this.callEvent.apply(this, arguments) : true);
};
if (typeof(window.dhtmlXCellObject) == "function") {
	
	dhtmlXCellObject.prototype.attachTreeView = function(conf) {
		
		this.callEvent("_onBeforeContentAttach", ["treeview"]);
		
		var obj = document.createElement("DIV");
		obj.style.position = "relative";
		obj.style.overflow = "hidden";
		obj.style.width = "100%";
		obj.style.height = "100%";
		
		this._attachObject(obj);
		
		var treeConf = {parent: obj, skin: this.conf.skin};
		if (conf != null && typeof(conf) == "object") {
			for (var a in conf) { if (typeof(treeConf[a]) == "undefined") treeConf[a] = conf[a]; }
		}
		
		this.dataType = "treeview";
		this.dataObj = new dhtmlXTreeView(treeConf);
		
		// draw border if attached to window
		if (typeof(window.dhtmlXWindowsCell) == "function" && this instanceof window.dhtmlXWindowsCell) {
			obj.className += " dhxtreeview_with_border";
			this.dataObj.conf.adjust_base = true;
			this.dataObj.setSizes();
		}
		
		treeConf.parent = null;
		treeConf = obj = conf = null;
		
		this.callEvent("_onContentAttach", []);
		
		return this.dataObj;
		
	};
	
}
// register checkboxes module
dhtmlXTreeView.prototype.modules.chbx = {
	init: "_chbxInit"
};

// public
dhtmlXTreeView.prototype.enableCheckboxes = function(mode) {
	mode = (mode==true);
	if (this.conf.enable_chbx != mode) {
		this.conf.enable_chbx = mode;
		this._chbxUpdIndex();
		for (var a in this.items) this._refreshItemHtml(a, true, true);
	}
};

dhtmlXTreeView.prototype.getAllChecked = function(parentId) {
	return this._chbxGetCheckedBranch(parentId, true);
};
dhtmlXTreeView.prototype.getAllUnchecked = function(parentId) {
	return this._chbxGetCheckedBranch(parentId, false);
};

dhtmlXTreeView.prototype.checkItem = function(id) {
	this._chbxSetChecked(id, true, true);
};
dhtmlXTreeView.prototype.uncheckItem = function(id) {
	this._chbxSetChecked(id, false, true);
};
dhtmlXTreeView.prototype.isItemChecked = function(id) {
	if (this.items[id] == null) return null;
	return (this.items[id].checked == true);
};

dhtmlXTreeView.prototype.enableCheckbox = function(id) {
	this._chbxSetEnabled(id, true);
};
dhtmlXTreeView.prototype.disableCheckbox = function(id) {
	this._chbxSetEnabled(id, false);
};
dhtmlXTreeView.prototype.isCheckboxEnabled = function(id) {
	return (this.items[id].chbx_enabled == true);
};

dhtmlXTreeView.prototype.showCheckbox = function(id) {
	this._chbxSetVisible(id, true);
};
dhtmlXTreeView.prototype.hideCheckbox = function(id) {
	this._chbxSetVisible(id, false);
};
dhtmlXTreeView.prototype.isCheckboxVisible = function(id) {
	return (this.items[id].chbx_visible == true);
};

// private
dhtmlXTreeView.prototype._chbxInit = function(conf) { // init
	
	this.enableCheckboxes(conf.checkboxes);
	
	this.attachEvent("_onItemRendered", function(id, data){
		
		this.items[id].checked = window.dhx4.s2b(data.checked);
		
		var conf = (data.checkbox||"enabled,visible");
		this.items[id].chbx_enabled = (conf.match(/disabled/)==null);
		this.items[id].chbx_visible = (conf.match(/hidden/)==null);
		
	});
	
	this.attachEvent("_onTreeClick", function(e, flow){
			
		if (this.conf.enable_chbx != true) return;
		
		var t = (e.target||e.srcElement);
		if (t.tagName.toLowerCase() == "i") t = t.parentNode; // check if icon
		
		if ((t.parentNode.className||"").match(/dhxtreeview_item_text/) != null && t == t.parentNode.childNodes[this.conf.idx.chbx]) { // check if checkbox
			var id = t.parentNode.parentNode._itemId;
			if (this.items[id].chbx_enabled == true) this._chbxSetChecked(id, !this.items[id].checked, true);
			flow.stop = true;
		}
	});
	
	conf = null;
	
};

dhtmlXTreeView.prototype._itemHtml_chbx = function(id, nodeIndex) {
	var r = {nodeIndex: 0, nodeText: false};
	if (this.conf.enable_chbx == true) {
		if (this.items[id].chbx_visible == true) r.nodeIndex = 1;
		r.nodeText = "<div class='dhxtreeview_item_icon' style='left:"+this._getIconOfs(id, nodeIndex)+"px;"+(r.nodeIndex>0?"":"display:none;")+"'>"+this._chbxGenIcon(id)+"</div>";
	}
	return r;
};

dhtmlXTreeView.prototype._chbxSetChecked = function(id, state) {
	if (this.conf.enable_chbx != true) return;
	state = (state==true);
	if (this.items[id].checked != state) {
		if (this._callPublicEvent("onBeforeCheck", [id, (this.items[id].checked==true)]) !== true) return;
		this.items[id].checked = state;
		this.items[id].item.childNodes[0].childNodes[this.conf.idx.chbx].innerHTML = this._chbxGenIcon(id);
		this._callPublicEvent("onCheck", [id, state]);
	}
};

dhtmlXTreeView.prototype._chbxSetEnabled = function(id, mode) {
	if (this.items[id].chbx_enabled != mode) {
		this.items[id].chbx_enabled = mode;
		this.items[id].item.firstChild.childNodes[this.conf.idx.chbx].innerHTML = this._chbxGenIcon(id);
	}
};

dhtmlXTreeView.prototype._chbxSetVisible = function(id, mode) {
	if (this.items[id].chbx_visible != mode) {
		this.items[id].chbx_visible = mode;
		this._refreshItemHtml(id, true, true);
	}
};

dhtmlXTreeView.prototype._chbxGenIcon = function(id) {
	var icon = this.conf.icons["chbx_"+(this.items[id].chbx_enabled?"":"dis_")+(this.items[id].checked?"1":"0")];
	return '<i class="'+this.conf.icons.prefix+' '+icon+'"></i>';
};

dhtmlXTreeView.prototype._chbxUpdIndex = function() {
	if (this.conf.enable_chbx == true) {
		this.conf.idx = {sign: 0, chbx: 1, icon: 2, text: 3};
	} else {
		this.conf.idx = {sign: 0, icon: 1, text: 2};
	}
};

dhtmlXTreeView.prototype._chbxGetCheckedBranch = function(pId, mode) {
	var k = [];
	for (var a in this.items) {
		if (this.items[a].pId == pId) {
			if (this.items[a].checked == mode) k.push(a);
			if (this.items[a].kids == true) k = k.concat(this._chbxGetCheckedBranch(a, mode));
		}
	}
	return k;
};
// register selection module
dhtmlXTreeView.prototype.modules.sign = {
	init: "_signInit"
};

// private
dhtmlXTreeView.prototype._signInit = function() {
	this.attachEvent("_onTreeClick", function(e, flow){
		if (flow.stop == true) return; // check if cancelled by prev attached function
		var t = (e.target||e.srcElement);
		if (t.tagName.toLowerCase() == "i") t = t.parentNode; // check if icon
		if ((t.parentNode.className||"").match(/dhxtreeview_item_text/) != null && t == t.parentNode.childNodes[this.conf.idx.sign]) {
			this._openCloseItem(t.parentNode.parentNode._itemId, true);
			flow.stop = true;
		}
	});
};

dhtmlXTreeView.prototype._signUpdate = function(id) {
	var t = this.items[id];
	var img = t.item.childNodes[0].childNodes[this.conf.idx.sign];
	if (t.kids == true || t.kids_request == true) {
		img.innerHTML = '<i class="'+this.conf.icons.prefix+" "+this.conf.icons[(t.opened||t.half_opened?"minus":"plus")]+'"></i>';
	} else {
		img.innerHTML = "";
	}
	t = img = null;
}

dhtmlXTreeView.prototype._itemHtml_sign = function(id, nodeIndex) { // item html renderer
	return {
		nodeIndex: 1,
		nodeText: "<div class='dhxtreeview_item_icon' style='left:"+this._getIconOfs(id, nodeIndex)+"px;'></div>"
	};
};
// register selection module
dhtmlXTreeView.prototype.modules.selection = {
	init: "_selectionInit"
};

// public
dhtmlXTreeView.prototype.selectItem = function(id) {
	if (this.conf.msel == true) {
		var t = {};
		if (!(id instanceof Array)) id = [id];
		for (var q=0; q<id.length; q++) t[id[q]] = true;
		for (var a in this.conf.selected) {
			if (t[a] == true) {
				delete t[a]; // already selected
			} else {
				this._setSelected(a, false); // clear selection if not preserve
			}
		}
		for (var a in t) this._setSelected(a, true); // select the rest
	} else if (id != null && this.conf.selected[id] != true && !(id instanceof Array)) {
		if (this._clearSelection(id) == false) this._setSelected(id, true);
	}
};

dhtmlXTreeView.prototype.unselectItem = function(id) {
	if (this.conf.msel == true) {
		if (!(id instanceof Array)) id = [id];
		for (var q=0; q<id.length; q++) {
			if (this.conf.selected[id[q]] == true) this._setSelected(id[q], false);
		}
	} else if (id != null) {
		this._setSelected(id, false);
	}
};

dhtmlXTreeView.prototype.getSelectedId = function() {
	var ids = [];
	for (var a in this.conf.selected) ids.push(a);
	return (this.conf.msel?ids:(ids[0]||null));
};

dhtmlXTreeView.prototype.enableMultiselect = function(mode) {
	mode = (mode==true);
	if (this.conf.msel != mode) {
		this._clearSelection();
		this.conf.msel = mode;
	}
};

// private
dhtmlXTreeView.prototype._selectionInit = function(conf) { // init
	
	this.conf.msel = window.dhx4.s2b(conf.multiselect);
	
	this.attachEvent("_onTreeClick", function(e, flow){
		
		if (flow.stop == true) return; // check if cancelled by prev attached function
		
		var t = (e.target||e.srcElement);
		if (t.tagName.toLowerCase() == "i") t = t.parentNode; // check if icon
		
		var selectId = null;
		
		if (t.className.match(/dhxtreeview_item_label/) != null) {
			selectId = t.parentNode.parentNode._itemId;
		} else if (t.className.match(/^dhxtreeview_item_text/) != null) {
			selectId = t.parentNode._itemId;
		} else if (t.className.match(/^dhxtreeview_item_icon/) != null) {
			selectId = t.parentNode.parentNode._itemId;
		}
		
		if (selectId != null)  {
			if (this.conf.msel == true) {
				if ((e.ctrlKey == true || this.conf.mac_cmd_key == true) && e.shiftKey == false && e.altKey == false) { // ctrl pressed
					this._setSelected(selectId, !this._isSelected(selectId));
				} else if (e.ctrlKey == false && e.shiftKey == false && e.altKey == false && this.conf.mac_cmd_key == false) { // nothing pressed
					if (this._clearSelection(selectId) == false) this._setSelected(selectId, true);
				}
			} else {
				if (this._clearSelection(selectId) == false) this._setSelected(selectId, true);
			}
		}
	});
};

dhtmlXTreeView.prototype._setSelected = function(id, mode) {
	if (mode == true) {
		if (this.conf.selected[id] != true) {
			this.items[id].item.childNodes[0].className += " dhxtreeview_item_text_selected";
			this.conf.selected[id] = true;
			this._callPublicEvent("onSelect", [id, true]);
		}
	} else {
		if (this.conf.selected[id] == true) {
			this.items[id].item.childNodes[0].className = String(this.items[id].item.childNodes[0].className).replace(/\s*dhxtreeview_item_text_selected/gi, "");
			delete this.conf.selected[id];
			this._callPublicEvent("onSelect", [id, false]);
		}
	}
};

dhtmlXTreeView.prototype._clearSelection = function(exceptId) {
	var r = false;
	for (var a in this.conf.selected) {
		if (exceptId != null && a == exceptId) r = true; else this._setSelected(a, false);
	}
	return r; // true if item stay selected
};

dhtmlXTreeView.prototype._isSelected = function(id) {
	return (this.conf.selected[id]==true);
};

// register icons module
dhtmlXTreeView.prototype.modules.icons = {
	init: "_iconModuleInit"
};

// public
dhtmlXTreeView.prototype.setItemIcons = function(id, icons) {
	if (icons == null && this.items[id].icons != null) {
		delete this.items[id].icons; // clear all custom for certain item
	} else if (icons != null) {
		if (this.items[id].icons == null) this.items[id].icons = {};
		for (var a in icons) {
			if (icons[a] != null) {
				this.items[id].icons[a] = icons[a];
			} else if (icons[a] == null && this.items[id].icons[a] != null) {
				delete this.items[id].icons[a]; // clear only specified icon
			}
		}
	}
	this._iconUpdate(id);
};

dhtmlXTreeView.prototype.setIconColor = function(id, color) {
	var icon = this.items[id].item.firstChild.childNodes[this.conf.idx.icon].firstChild;
	if (color == null) {
		if (this.items[id].icon_color != null) {
			delete this.items[id].icon_color;
			icon.style.color = "inherit";
		}
	} else {
		if (this.items[id].icon_color != color) {
			this.items[id].icon_color = color;
			icon.style.color = color;
		}
	}
	icon = null;
};

dhtmlXTreeView.prototype.setIconset = function(name) {
	if (this.icons[name] != null && this.icons[name].r == true) {
		this.conf.icons = this.icons[name];
	}
};

// private
dhtmlXTreeView.prototype._iconModuleInit = function() { // init
	this.attachEvent("_onItemRendered", function(id, data){
		if (data.icons != null) this.items[id].icons = data.icons;
		if (data.icon_color != null) this.items[id].icon_color = data.icon_color;
	});
};

dhtmlXTreeView.prototype._iconConf = function(id) { // return array with icons
	var icons = this.items[id].icons||{};
	for (var a in {folder_opened:1, folder_closed:1, file:1}) {
		if (typeof(icons[a]) == "undefined") icons[a] = this.conf.icons[a]; // if item has own icons missing will updated here
	}
	return icons;
};

dhtmlXTreeView.prototype._iconHtml = function(id, css) { // generate <i> for icon
	var attrs = ['class="'+this.conf.icons.prefix+" "+css+'"'];
	if (this.items[id].icon_color != null) attrs.push('style="color:'+this.items[id].icon_color+';"');
	return "<i "+attrs.join(" ")+"></i>";
};

dhtmlXTreeView.prototype._itemHtml_icon = function(id, nodeIndex) { // item html renderer
	return {
		nodeIndex: 1,
		nodeText: "<div class='dhxtreeview_item_icon' style='left:"+this._getIconOfs(id, nodeIndex)+"px;'>"+this._iconHtml(id, this._iconConf(id).file)+"</div>"
	};
};

dhtmlXTreeView.prototype._iconUpdate = function(id) { // update icon inner call
	var t = this.items[id];
	var icons = this._iconConf(id);
	var css = (t.kids == true || t.kids_request == true ? icons[t.opened?"folder_opened":"folder_closed"] : icons.file);
	t.item.childNodes[0].childNodes[this.conf.idx.icon].innerHTML = this._iconHtml(id, css);
	t = null;
};

// config
dhtmlXTreeView.prototype.icons = {
	tree_native: {
		r: true, // allow rendering depending on browser
		prefix: "dhxtreeview_icon", // common prefix for all icons/arrows/checkboxes/etc
		plus: "dhxtreeview_icon_plus",
		minus: "dhxtreeview_icon_minus",
		file: "dhxtreeview_icon_file",
		folder_opened: "dhxtreeview_icon_folder_opened",
		folder_closed: "dhxtreeview_icon_folder_closed",
		loading: "dhxtreeview_icon_loading",
		chbx_0: "dhxtreeview_icon_chbx_0",
		chbx_1: "dhxtreeview_icon_chbx_1",
		chbx_dis_0: "dhxtreeview_icon_chbx_dis_0",
		chbx_dis_1: "dhxtreeview_icon_chbx_dis_1"
	},
	font_awesome: {
		r: (!(window.dhx4.isIE6 == true || window.dhx4.isIE7 == true)),
		prefix: "fa",
		plus: "fa-caret-right",
		minus: "fa-caret-down",
		file: "fa-file-o",
		folder_opened: "fa-folder-open-o",
		folder_closed: "fa-folder-o",
		loading: "fa-refresh fa-spin",
		chbx_0: "fa-square-o",
		chbx_1: "fa-check-square-o",
		chbx_dis_0: "fa-square-o dhx-disabled",
		chbx_dis_1: "fa-check-square-o dhx-disabled"
	}
};
// register loading module
dhtmlXTreeView.prototype.modules.loading = {
	init: "_loadingInit",
	unload: "_loadingUnload"
};

dhtmlXTreeView.prototype._loadingInit = function(conf) {
	window.dhx4._enableDataLoading(this, "_initObj", "_xmlToObj", "tree", {struct:true});
	this.conf.root_id = (typeof(conf.root_id)=="undefined" || conf.root_id==null ? "0" : conf.root_id); // top-level item
	this._dhxdataload.onBeforeXLS = function(url) { // add tree_id for 1st load if any
		if (this.conf.autoload.url == null) this.conf.autoload.url = url;
		return {url:url.replace(/\{id\}/gi, this.conf.root_id)};
	}
};

dhtmlXTreeView.prototype._loadingUnload = function() {
	window.dhx4._enableDataLoading(this, null, null, null, "clear");
};

dhtmlXTreeView.prototype._initObj = function(data, url, pId, fixArea) {
	
	for (var q=0; q<data.length; q++) {
		
		var id = data[q].id;
		if (id == null) id = "dhxtreeview_id_"+window.dhx4.newId();
		
		// add item if not exists, if already exists - refresh?
		if (this.items[id] == null) this._addItem(id, pId, data[q]);
		
		// nested
		if (data[q].items != null) this._initObj(data[q].items, null, id, true);
	}
	
	// done
	if (fixArea != true) {
		this._fixAreaWidth();
	}
};

dhtmlXTreeView.prototype._xmlToObj = function(root, nested) {
	
	if (nested != true) root = root.getElementsByTagName("tree")[0];
	var data = [];
	
	for (var q=0; q<root.childNodes.length; q++) {
		var node = root.childNodes[q];
		
		if ((node.tagName||"").toLowerCase() == "item") {
			
			// main item attrs
			var item = {};
			for (var w=0; w<node.attributes.length; w++) {
				item[node.attributes[w].name] = node.attributes[w].value;
			}
			
			if (node.childNodes.length > 0) {
				
				// nested items
				var nested = this._xmlToObj(node, true);
				if (nested.length > 0) item.items = nested;
				
				// icons and userdata
				for (var w=0; w<node.childNodes.length; w++) {
					var tag = (node.childNodes[w].tagName||"").toLowerCase();
					if ({icons:1, userdata:1}[tag] == 1) {
						if (item[tag] == null) item[tag] = {};
						for (var e=0; e<node.childNodes[w].attributes.length; e++) {
							var name = node.childNodes[w].attributes[e].name;
							if (item[tag][name] == null) item[tag][name] = node.childNodes[w].attributes[e].value;
						}
					}
					n2 = null;
				}
				
			}
			
			data.push(item);
		}
		
		node = null;
	}
	
	return data;
};

// register dnd module
dhtmlXTreeView.prototype.modules.dnd = {
	init: "_dndInit",
	unload: "_dndUnload"
};

dhtmlXTreeView.prototype.enableDragAndDrop = function(mode) {
	this.conf.enable_dnd = window.dhx4.s2b(mode);
};

dhtmlXTreeView.prototype._dndInit = function(conf) { // init
	
	var that = this;
	
	this.enableDragAndDrop(conf.dnd);
	this.conf.dnd = null;
	
	this._dndOnMouseDown = function(e) {
		
		if (that.conf.enable_dnd != true) return;
		
		e = e||event;
		
		if (typeof(e.button) != "undefined" && e.button >= 2) return false;
		
		var id = null;
		var treeId = null;
		
		var t = e.target||e.srcElement;
		
		var ofs_x = window.dhx4.absLeft(t)+(typeof(e.offsetX)=="undefined"?e.layerX:e.offsetX) - e.clientX;
		var ofs_y = window.dhx4.absTop(t)+(typeof(e.offsetY)=="undefined"?e.layerY:e.offsetY) - e.clientY;
		
		while (t != null && t != that.cont) {
			if ((t.className||"").match(/dhxtreeview_item/) != null && t._itemId != null) {
				id = t._itemId;
				treeId = t._treeId;
				t = null;
			} else {
				t = t.parentNode;
			}
		}
		t = null;
		
		if (id == null) return; // check if empty click and abort
		
		that.conf.dnd = {
			inited: false,
			id: id,
			treeId: treeId,
			selected: (that.conf.selected[id]==true),
			tid: null,
			drop: {},
			x: e.clientX,
			y: e.clientY,
			ofs_x: ofs_x,
			ofs_y: ofs_y,
			zi: window.dhx4.newId(),
			scroll: false,
			scroll_ofs: 5, // offset for single loop
			scroll_time: 30, // timeout
			scroll_tm: null,
			kids: {}, // all kids of dragged to prevent dnd in advance
			idx: {}
		};
		
		
		
		that._dndInitEvents();
		
	}
	
	this._dndOnMouseMove = function(e) {
		
		e = e||event;
		
		if (that.conf.dnd.inited != true) {
			
			if (Math.abs(that.conf.dnd.x - e.clientX) >= 15 || Math.abs(that.conf.dnd.y - e.clientY) >= 15) {
				
				if (that._callPublicEvent("onBeforeDrag", [that.conf.dnd.id]) !== true) return;
				
				that.conf.dnd.inited = true;
				that.cont.className += " dhxtreeview_dnd_mode";
				that._dndInitDraggedObj();
				that._dndCollectKids(that.conf.dnd.id);
				that._dndCollectIndexes(that.area);
				
				// rearrange selection
				if (that._clearSelection(that.conf.dnd.id) == false) that._setSelected(that.conf.dnd.id, true);
				
				// update item css
				that.items[that.conf.dnd.id].item.className += " dhxtreeview_item_dragged";
				document.body.className += " dhxtreeview_dnd_mode";
				
				// tree area to check if scroll should be performed
				that.conf.dnd.cont = {
					x1: window.dhx4.absLeft(that.base),
					y1: window.dhx4.absTop(that.base)
				};
				that.conf.dnd.cont.x2 = that.conf.dnd.cont.x1 + that.base.offsetWidth;
				that.conf.dnd.cont.y2 = that.conf.dnd.cont.y1 + that.base.offsetHeight;
				
			} else {
				return;
			}
			
		}
		
		that.conf.dnd.x = e.clientX;
		that.conf.dnd.y = e.clientY;
		
		that._dndAdjustDraggedObj();
		
		// check tree area edges and scroll content if any
		var stopScroll = true;
		
		if (that.cont.scrollHeight > that.cont.clientHeight) {
			if (that.conf.dnd.x >= that.conf.dnd.cont.x1 && that.conf.dnd.x <= that.conf.dnd.cont.x2) {
				if (that.cont.scrollTop > 0 && that.conf.dnd.y >= that.conf.dnd.cont.y1 && that.conf.dnd.y <= that.conf.dnd.cont.y1 + 10) { // top edge
					that._dndScroll("up");
					stopScroll = false;
				} else if (that.cont.scrollTop+that.cont.clientHeight < that.cont.scrollHeight && that.conf.dnd.y <= that.conf.dnd.cont.y2 && that.conf.dnd.y >= that.conf.dnd.cont.y2 - 10) { // bottom edge
					that._dndScroll("down");
					stopScroll = false;
				}
			}
		}
		
		if (stopScroll == true && that.conf.dnd.scroll == true) {
			that._dndScroll("stop");
		}
		
		// detect node by target
		var t = (e.target||e.srcElement);
		
		// remove blink artefact if any
		if (t.parentNode != null && (t.parentNode.className||"").match(/dhxtreeview_kids_cont/) != null) {
			t = null;
			return;
		}
		
		var upd = false;
		var tid = null;
		var treeId = null;
		
		if (t.className != null) {
			if (t.className.match(/dhxtreeview_item_[li]/) != null) { // label/icon
				tid = t.parentNode.parentNode._itemId;
				treeId = t.parentNode.parentNode._treeId;
			} else if (t.className.match(/dhxtreeview_item_[t]/) != null) { // text
				tid = t.parentNode._itemId;
				treeId = t.parentNode._treeId;
			}
		}
		
		// check if the same tree
		if (tid != null && treeId != that.conf.dnd.treeId) {
			return;
		}
		
		// check if target is the same or if target is child
		if (that.conf.dnd.id == tid || that.conf.dnd.kids[tid] == true) {
			tid = null;
		}
		
		if (tid != null) {
			
			var h = that.items[tid].item.firstChild.offsetHeight;
			var ofs = Math.max(Math.floor(Math.min(e.layerY||e.offsetY, h) * 3 / h), 0);
			
			// depending on item type and offset - allow/block some offsets
			
			if (ofs == 0) { // drop as sibling above target
				
				if (that.items[tid].item.previousSibling == that.items[that.conf.dnd.id].item) { // do not allow if prev sibling is dragged
					ofs = null;
				}
				
			} else if (ofs == 1) { // drop as child of target
				
				if (that.items[that.conf.dnd.id].pId == tid) { // if already child of selected parent
					ofs = null;
				} else if (that.items[tid].kids == true && that.items[tid].item.lastChild.firstChild.firstChild == that.items[that.conf.dnd.id].item) { // do not allo if dragged already 1st child
					ofs = null;
				} else if (that.items[tid].opened == false) { // open node
					//that._openCloseItem(tid, true);
				}
				
			} else if (ofs == 2) { // drop as sibling below target
				
				if (that.items[tid].opened == true) { // do not allow for opened item
					ofs = null;
				} else if (that.items[tid].item.nextSibling == that.items[that.conf.dnd.id].item) { // do not allow if next sibling is dragged
					ofs = null;
				}
			}
			//
			if (ofs != that.conf.dnd.ofs) {
				that.conf.dnd.ofs = ofs;
				upd = true;
			}
		}
		
		if (tid != that.conf.dnd.tid) {
			
			// clear old one
			if (that.conf.dnd.tid != null) {
				that._dndUpdateTargetCss(that.conf.dnd.tid, false);
			}
			// update new
			if (tid != null) {
				upd = true;
			}
			that.conf.dnd.tid = tid;
		}
		
		if (upd == true) {
			
			var mode = false;
			
			if (ofs != null) {
				
				var drop = {
					id: that.conf.dnd.id,
					pId: that.items[tid].pId||null,
					index: null,
					idxOfs: (that.items[that.conf.dnd.id].pId == that.items[tid].pId && that.conf.dnd.idx[that.conf.dnd.id] < that.conf.dnd.idx[tid] ? -1 : 0)
				};
				
				if (ofs == 0 || ofs == 2) {
					drop.index = that.conf.dnd.idx[tid]+(ofs==2?1:0)+drop.idxOfs;
				} else if (ofs == 1) {
					drop.pId = tid;
					drop.index = (that.items[tid].item.lastChild.className.match(/dhxtreeview_kids_cont/)==null?0:that.items[tid].item.lastChild.firstChild.childNodes.length);
				}
				
				if (that.conf.dnd.drop.id != drop.id || that.conf.dnd.drop.pId != drop.pId || that.conf.dnd.drop.index != drop.index) {
					that.conf.dnd.drop = drop;
					if (that._callPublicEvent("onDragOver", [that.conf.dnd.drop.id, that.conf.dnd.drop.pId, that.conf.dnd.drop.index]) === true) mode = true;
				}
				
			}
			
			if (mode != true) that.conf.dnd.ofs = ofs = null;
			
			that._dndUpdateTargetCss(tid, mode);
			
		}
		
	}
	
	this._dndOnMouseUp = function(e) {
		
		e = e||event;
		
		if (typeof(e.button) != "undefined" && e.button >= 2) return;
		
		that._dndUnloadEvents();
		that._dndUnloadDraggedObj();
		
		if (that.conf.dnd.scroll == true) {
			that._dndScroll("stop");
		}
		
		if (that.cont.className.match(/dhxtreeview_dnd_mode/gi) != null) {
			that.cont.className = String(that.cont.className).replace(/\s*dhxtreeview_dnd_mode/gi, "");
		}
		
		if (that.conf.dnd.tid != null) {
			that._dndUpdateTargetCss(that.conf.dnd.tid, false);
		}
		
		if (that.conf.dnd.inited == true) {
			
			that.items[that.conf.dnd.id].item.className = String(that.items[that.conf.dnd.id].item.className).replace(/\s*dhxtreeview_item_dragged/gi, "");
			document.body.className = String(document.body.className).replace(/\s*dhxtreeview_dnd_mode/, "");
			
			if (that.conf.dnd.tid != null && that.conf.dnd.ofs != null) {
				
				if (that._callPublicEvent("onBeforeDrop", [that.conf.dnd.drop.id, that.conf.dnd.drop.pId, that.conf.dnd.drop.index]) === true) {
					
					var obj = that.items[that.conf.dnd.id];
					var tobj = that.items[that.conf.dnd.tid];
					var pobj = (obj.pId != null ? that.items[obj.pId] : null); // prev_parent id
					
					var levelOfs;
					
					// 1) dom
					if (that.conf.dnd.ofs == 1) {
						
						var open = false;
						if (tobj.kids == false) {
							that._initKidsNode(tobj.id);
							open = true;
						}
						tobj.item.lastChild.firstChild.appendChild(obj.item);
						//
						if (open == true) {
							that._openCloseItem(tobj.id, false);
						}
						
						obj.pId = tobj.id;
						levelOfs = tobj.level+1-obj.level;
						
					} else if (that.conf.dnd.ofs == 0 || that.conf.dnd.ofs == 2) { // sibling before/after
						
						if (that.conf.dnd.ofs == 0) { // before
							tobj.item.parentNode.insertBefore(obj.item, tobj.item);
						} else if (tobj.item.nextSibling != null) { // after
							tobj.item.parentNode.insertBefore(obj.item, tobj.item.nextSibling);
						} else { // after
							tobj.item.parentNode.appendChild(obj.item);
						}
						
						obj.pId = tobj.pId;
						levelOfs = tobj.level-obj.level;
					}
					
					// update nested if level changed
					if (levelOfs != 0) {
						that.conf.dnd.kids[obj.id] = true;
						for (var a in that.conf.dnd.kids) {
							that.items[a].level += levelOfs;
							that._refreshItemHtml(a, (that.items[a].kids == true), true);
						}
					}
					
					// 4) check parent's kids area and remove if empty
					if (pobj != null && pobj.kids == true && pobj.item.lastChild.firstChild.childNodes.length == 0) {
						that._clearKidsNode(pobj.id)
						pobj.opened = false;
					}
					
					obj = tobj = pobj = null;
					
					that._fixAreaWidth();
					
					that._callPublicEvent("onDrop", [that.conf.dnd.drop.id, that.conf.dnd.drop.pId, that.conf.dnd.drop.index]);
					
				}
				
			}
			
		}
		
		window.dhx4.zim.clear(that.conf.dnd.zi);
		
		that.conf.dnd = null;
		
	}
	
	this._dndOnContextMenu = function(e) {
		if (that.conf.dnd.inited == true) {
			e = e||event;
			e.cancelBubble = true;
			if (e.preventDefault) e.preventDefault();
			e.returnValue = false;
			return false;
		}
	}
	
	// events
	this._dndInitEvents = function() {
		
		if (typeof(window.addEventListener) == "function") {
			window.addEventListener("mousemove", this._dndOnMouseMove, false);
			window.addEventListener("mouseup", this._dndOnMouseUp, false);
			window.addEventListener("contextmenu", this._dndOnContextMenu, false);
		} else {
			document.body.attachEvent("onmousemove", this._dndOnMouseMove);
			document.body.attachEvent("onmouseup", this._dndOnMouseUp);
			document.body.attachEvent("oncontextmenu", this._dndOnContextMenu);
		}
		
	}
	
	this._dndUnloadEvents = function() {
		if (typeof(window.addEventListener) == "function") {
			window.removeEventListener("mousemove", this._dndOnMouseMove, false);
			window.removeEventListener("mouseup", this._dndOnMouseUp, false);
			window.removeEventListener("contextmenu", this._dndOnContextMenu, false);
		} else {
			document.body.detachEvent("onmousemove", this._dndOnMouseMove);
			document.body.detachEvent("onmouseup", this._dndOnMouseUp);
			document.body.detachEvent("oncontextmenu", this._dndOnContextMenu);
		}
	}
	
	// dragged object
	this._dndInitDraggedObj = function() {
		this.conf.dnd.dragged = document.createElement("DIV");
		this.conf.dnd.dragged.className = "dhxtreeview_dragged_obj_"+this.conf.skin;
		this.conf.dnd.dragged.style.zIndex = window.dhx4.zim.reserve(this.conf.dnd.zi);
		document.body.appendChild(this.conf.dnd.dragged);
		//
		this.conf.dnd.dragged.innerHTML = this.getItemText(this.conf.dnd.id);
	}
	
	this._dndAdjustDraggedObj = function() {
		this.conf.dnd.dragged.style.left = this.conf.dnd.x + this.conf.dnd.ofs_x + 12 + "px";
		this.conf.dnd.dragged.style.top = this.conf.dnd.y + this.conf.dnd.ofs_y + 18 + "px";
	}
	
	this._dndUnloadDraggedObj = function() {
		if (this.conf.dnd.dragged != null) {
			document.body.removeChild(this.conf.dnd.dragged);
			this.conf.dnd.dragged = null;
		}
	}
	
	// target node ui
	this._dndUpdateTargetCss = function(id, mode) {
		
		var t = this.items[id].item.childNodes[0];
		
		if (this.conf.dnd.ofs == null) {
			mode = false;
		}
		
		if (mode == true) {
			
			t.className = String(t.className).replace(/(\s*dhxtreeview_drop_\d)?$/i, " dhxtreeview_drop_"+this.conf.dnd.ofs);
			//
			if (t.nextSibling == null || t.nextSibling.className.match(/dhxtreeview_drop_preview/) == null) {
				var k = document.createElement("DIV");
				k.className = "dhxtreeview_drop_preview";
				k.style.left = t.lastChild.previousSibling.style.left;
				if (t.nextSibling == null) {
					t.parentNode.appendChild(k);
				} else {
					t.parentNode.insertBefore(k, t.nextSibling);
				}
				k = null;
			}
			
			t.nextSibling.className = String(t.nextSibling.className).replace(/(\s*dhxtreeview_drop_\d)?$/i, " dhxtreeview_drop_"+this.conf.dnd.ofs);
			
		} else if (t.className.match(/dhxtreeview_drop_\d/) != null) {
			t.className = String(t.className).replace(/\s*dhxtreeview_drop_\d/gi, "");
			//
			if (t.nextSibling != null && t.nextSibling.className.match(/dhxtreeview_drop_preview/) != null) {
				t.parentNode.removeChild(t.nextSibling);
			}
		}
		
		t = null;
		
	}
	
	// cache for kids items, dnd can't be performed
	this._dndCollectKids = function(pId) {
		for (var a in this.items) {
			if (this.items[a].pId == pId) {
				this.conf.dnd.kids[a] = true;
				if (this.items[a].kids == true) this._dndCollectKids(a);
			}
		}
	}
	
	this._dndCollectIndexes = function(node) {
		for (var q=0; q<node.childNodes.length; q++) {
			this.conf.dnd.idx[node.childNodes[q]._itemId] = q;
			if (node.childNodes[q].lastChild.className.match(/dhxtreeview_kids_cont/) != null) {
				this._dndCollectIndexes(node.childNodes[q].lastChild.firstChild);
			}
		}
	}
	
	// scroll content area
	this._dndScroll = function(mode, force) {
		
		if (mode == "stop") {
			
			if (that.conf.dnd.scroll == true) {
				if (that.conf.dnd.scroll_tm) window.clearTimeout(that.conf.dnd.scroll_tm);
				that.conf.dnd.scroll = false;
			}
			
			return;
			
		} else {
			
			if (that.conf.dnd.scroll == true) {
				if (force != true) return; // call from script, already performed, aborting
			} else {
				that.conf.dnd.scroll = true;
			}
			
			var stopScroll = false;
			if (mode == "up") {
				that.cont.scrollTop = Math.max(0, that.cont.scrollTop-that.conf.dnd.scroll_ofs);
				if (that.cont.scrollTop == 0) stopScroll = true;
			} else {
				that.cont.scrollTop = Math.min(that.cont.scrollHeight-that.cont.clientHeight, that.cont.scrollTop+that.conf.dnd.scroll_ofs);
				if (that.cont.scrollTop+that.cont.clientHeight == that.cont.scrollHeight) stopScroll = true;
			}
			
			if (stopScroll != true) {
				that.conf.dnd.scroll_tm = window.setTimeout(function(){
					that._dndScroll(mode, true);
				}, that.conf.dnd.scroll_time);
			}
			
		}
		
	}
	
	
	if (typeof(window.addEventListener) == "function") {
		this.cont.addEventListener("mousedown", this._dndOnMouseDown, false);
	} else {
		this.cont.attachEvent("onmousedown", this._dndOnMouseDown);
	}
	
	
	// unload
	this._dndUnload = function() {
		
		if (typeof(window.addEventListener) == "function") {
			this.cont.removeEventListener("mousedown", this._dndOnMouseDown, false);
		} else {
			this.cont.detachEvent("onmousedown", this._dndOnMouseDown);
		}
		
		that = null;
	}
	
	conf = null;
	
};
// register context menu module
dhtmlXTreeView.prototype.modules.ctx = {
	init: "_ctxInit",
	unload: "_ctxUnload"
};

// public
dhtmlXTreeView.prototype.enableContextMenu = function(mode) {
	this.conf.ctx = window.dhx4.s2b(mode);
};

// private
dhtmlXTreeView.prototype._ctxInit = function(conf) { // init
	
	var that = this;
	
	this._ctxCall = function(e) {
		
		if (that.conf.ctx != true) return;
		
		e = e||event;
		var t = (e.target||e.srcElement);
		if (t.tagName.toLowerCase() == "i") t = t.parentNode; // check if icon
		var id = (t.parentNode._itemId||t.parentNode.parentNode._itemId);
		
		var cx = window.dhx4.absLeft(t)+(typeof(e.offsetX)=="undefined"?e.layerX:e.offsetX);
		var cy = window.dhx4.absTop(t)+(typeof(e.offsetY)=="undefined"?e.layerY:e.offsetY);
		
		if (id != null && that._callPublicEvent("onContextMenu", [id, cx, cy, e]) !== true) {
			if (e.preventDefault) e.preventDefault();
			e.cancelBubble = true;
			e.returnValue = false;
			return false;
		}
		
	}
	
	if (typeof(window.addEventListener) == "function") {
		this.cont.addEventListener("contextmenu", this._ctxCall, false);
	} else {
		this.cont.attachEvent("oncontextmenu", this._ctxCall);
	}
	
	// unload
	this._ctxUnload = function() {
		if (typeof(window.addEventListener) == "function") {
			this.cont.removeEventListener("contextmenu", this._ctxCall, false);
		} else {
			this.cont.detachEvent("oncontextmenu", this._ctxCall);
		}
		that = null;
	};
	
	// autoload if any
	this.enableContextMenu(conf.context_menu);
	
};
// reguster dynload module
dhtmlXTreeView.prototype.modules.dynload = {
	init: "_dynLoadInit"
};

dhtmlXTreeView.prototype._dynLoadInit = function() {
	
	this.attachEvent("_onItemInited", function(id, data){
		
		// true/false to send extra request to server
		this.items[id].kids_request = window.dhx4.s2b(data.kids);
		
		// kids dyn load if any
		if (this.items[id].kids_request == true) {
			this._initKidsNode(id);
		}
		
		// dynload + open, load more data right after item added
		if (this.items[id].opened == true && this.items[id].kids_request == true) {
			var t = this;
			window.setTimeout(function(){
				t._dynLoadRequest(id);
				t = null;
			}, 100);
		}
		
	});
	
	this.attachEvent("_onBeforeOpen", function(id){
		
		// load more kids if any
		if (this.items[id].opened != true && this.items[id].kids_request == true) {
			if (this._dynLoadRequest(id) != true) {
				// change only plus-minus, will opened after data loaded
				this.items[id].half_opened = true;
				this._signUpdate(id);
				return false;
			}
		}
		
		return true;
	});
};

dhtmlXTreeView.prototype._dynLoadRequest = function(id) {
	
	// return true/false for node auto-open
	// if false - open after data will loaded
	if (typeof(this.conf.autoload.mode) == "function") {
		this.conf.autoload.mode.apply(window,[id]);
		return true;
	}
	
	if (this.conf.autoload.url == null) return; // data was loaded in different way
	
	this._dhxdataload.onBeforeXLS = function(url){
		return {url:url.replace(/\{id\}/gi,id)};
	}
	
	// loading icon
	var t = this;
	this.items[id].kids_loading_tm = window.setTimeout(function(){
		t._dynLoadUpdateIcon(id, true);
		t = null;
	}, 100);
	
	this.loadStruct(this.conf.autoload.url, function(){
		window.clearTimeout(this.items[id].kids_loading_tm);
		this._dynLoadUpdateIcon(id, false);
		if (this.items[id].half_opened) {
			this.items[id].half_opened = false;
			this._openCloseItem(id, true);
		}
	});
	
	this.items[id].kids_request = false;
	
	return false;
};

dhtmlXTreeView.prototype._dynLoadUpdateIcon = function(id, mode) {
	this.items[id].loading = (mode == true);
	if (this.items[id].loading == true) {
		this.items[id].item.childNodes[0].childNodes[this.conf.idx.icon].innerHTML = "<i class='"+this.conf.icons.prefix+" "+this.conf.icons.loading+"'></i>";
	} else {
		this._iconUpdate(id);
	}
};

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

//latest dev. version

/*_TOPICS_
@0:initialization
@1:selection control
@2:rows control
@3:colums control
@4:cells controll
@5:data manipulation
@6:appearence control
@7:overal control
@8:tools
@9:treegrid
@10: event handlers
@11: paginal output
*/

var globalActiveDHTMLGridObject;
String.prototype._dhx_trim=function(){
	return this.replace(/&nbsp;/g, " ").replace(/(^[ \t]*)|([ \t]*$)/g, "");
}

function dhtmlxArray(ar){
	return dhtmlx.extend((ar||new Array()), dhtmlxArray._master);
};
dhtmlxArray._master={
	_dhx_find:function(pattern){
		for (var i = 0; i < this.length; i++){
			if (pattern == this[i])
				return i;
		}
		return -1;
	},
	_dhx_insertAt:function(ind, value){
		this[this.length]=null;
		for (var i = this.length-1; i >= ind; i--)
			this[i]=this[i-1]
		this[ind]=value
	},
	_dhx_removeAt:function(ind){
		this.splice(ind,1)
	},
	_dhx_swapItems:function(ind1, ind2){
		var tmp = this[ind1];
		this[ind1]=this[ind2]
		this[ind2]=tmp;
	}
}

/**
*   @desc: dhtmlxGrid constructor
*   @param: id - (optional) id of div element to base grid on
*   @returns: dhtmlxGrid object
*   @type: public
*/
function dhtmlXGridObject(id){
	if (dhtmlxEvent.initTouch)
		dhtmlxEvent.initTouch();
	
	if (_isIE)
	try{
		document.execCommand("BackgroundImageCache", false, true);
	}
	catch (e){}
	
	if (id){
		if (typeof (id) == 'object'){
			this.entBox=id
			if (!this.entBox.id) this.entBox.id="cgrid2_"+this.uid();
		} else
		this.entBox=document.getElementById(id);
	} else {
		this.entBox=document.createElement("DIV");
		this.entBox.id="cgrid2_"+this.uid();
	}
	this.entBox.innerHTML="";
	dhx4._eventable(this);
	
	var self = this;
	
	this._RaSeCol=[];
	this._wcorr=0;
	this.fontWidth = 7;
	this.cell=null;
	this.row=null;
	this.iconURL="";
	this.editor=null;
	this._f2kE=true;
	this._dclE=true;
	this.combos=new Array(0);
	this.defVal=new Array(0);
	this.rowsAr={
	};
	
	this.rowsBuffer=dhtmlxArray();
	this.rowsCol=dhtmlxArray(); //array of rows by index
	
	this._data_cache={
	};
	
	this._ecache={
	}
	
	this._ud_enabled=true;
	this.xmlLoader=this.doLoadDetails;
	
	this._maskArr=[];
	this.selectedRows=dhtmlxArray(); //selected rows array
	
	this.UserData={};//hash of row related userdata (and for grid - "gridglobaluserdata")
	this._sizeFix=this._borderFix=0;
	/*MAIN OBJECTS*/
	
	this.entBox.className+=" gridbox";
	
	this.entBox.style.width=this.entBox.getAttribute("width")
	||(window.getComputedStyle
		? (this.entBox.style.width||window.getComputedStyle(this.entBox, null)["width"])
		: (this.entBox.currentStyle
			? this.entBox.currentStyle["width"]
			: this.entBox.style.width||0))
	||"100%";
	
	this.entBox.style.height=this.entBox.getAttribute("height")
	||(window.getComputedStyle
		? (this.entBox.style.height||window.getComputedStyle(this.entBox, null)["height"])
		: (this.entBox.currentStyle
			? this.entBox.currentStyle["height"]
			: this.entBox.style.height||0))
	||"100%";
	//cursor and text selection
	this.entBox.style.cursor='default';
	
	this.entBox.onselectstart=function(){
		return false
	}; //avoid text select
	var t_creator=function(name){
		var t=document.createElement("TABLE");
		t.cellSpacing=t.cellPadding=0;
		t.style.cssText='width:100%;table-layout:fixed;';
		t.className=name.substr(2);
		return t;
	}
	this.obj=t_creator("c_obj");
	this.hdr=t_creator("c_hdr");
	this.hdr.style.marginRight="20px";
	this.hdr.style.paddingRight="20px";
	
	this.objBox=document.createElement("DIV");
	this.objBox.style.width="100%";
	this.objBox.style.overflow="auto";
	this.objBox.appendChild(this.obj);
	this.objBox.className="objbox";
	
	if (dhtmlx.$customScroll)
		dhtmlx.CustomScroll.enable(this);
	
	this.hdrBox=document.createElement("DIV");
	this.hdrBox.style.width="100%"
	this.hdrBox.style.height="25px";
	this.hdrBox.style.overflow="hidden";
	this.hdrBox.className="xhdr";
	
	
	this.preloadImagesAr=new Array(0)
	
	this.sortImg=document.createElement("DIV")
	this.sortImg.style.display="none";
	
	this.hdrBox.appendChild(this.sortImg)
	this.hdrBox.appendChild(this.hdr);
	this.hdrBox.style.position="relative";
	
	this.entBox.appendChild(this.hdrBox);
	this.entBox.appendChild(this.objBox);
	
	//add links to current object
	this.entBox.grid=this;
	this.objBox.grid=this;
	this.hdrBox.grid=this;
	this.obj.grid=this;
	this.hdr.grid=this;
	
	/*PROPERTIES*/
	this.cellWidthPX=[];                      //current width in pixels
	this.cellWidthPC=[];                      //width in % if cellWidthType set in pc
	this.cellWidthType=this.entBox.cellwidthtype||"px"; //px or %
	
	this.delim=this.entBox.delimiter||",";
	this._csvDelim=",";
	
	this.hdrLabels=[];
	this.columnIds=[];
	this.columnColor=[];
	this._hrrar=[];
	this.cellType=dhtmlxArray();
	this.cellAlign=[];
	this.initCellWidth=[];
	this.fldSort=[];
	this._srdh=(_isIE && (document.compatMode != "BackCompat") ? 22 : 20);
	this.imgURL=window.dhx_globalImgPath||""; 
	this.isActive=false; //fl to indicate if grid is in work now
	this.isEditable=true;
	this.useImagesInHeader=false; //use images in header or not
	this.pagingOn=false;          //paging on/off
	this.rowsBufferOutSize=0;     //number of rows rendered at a moment
	/*EVENTS*/
	dhtmlxEvent(window, "unload", function(){
			try{
				if (self.destructor) self.destructor();
			}
			catch (e){}
	});
	
	/*XML LOADER(S)*/
	/**
	*   @desc: set one of predefined css styles (xp, mt, gray, light, clear, modern)
	*   @param: name - style name
	*   @type: public
	*   @topic: 0,6
	*/
	this.setSkin=function(name){
		this._srdh=window.dhx4.readFromCss("dhxgrid_rh_"+name)+4;
		this.skin_name=name;
		if (this._imgURL)
			this.setImagePath(this._imgURL);
		
		var classname = this.entBox.className.split(" gridbox")[0];
		this.entBox.className=classname + " gridbox gridbox_"+name+(_isIE?" isIE":" isModern");
		this.skin_h_correction=0;
		
		//#alter_css:06042008{		
		this.enableAlterCss("ev_"+name, "odd_"+name, this.isTreeGrid())
		this._fixAlterCss()
		//#}
		switch (name){
		case "dhx_terrace":
		case "material":
			this._srdh=33;
			this.forceDivInHeader=true;
			break;
			
		case "dhx_web":
		case "material":
			this.forceDivInHeader=true;
			this._srdh = 31;
			break;
			
		case "dhx_skyblue":
			this.forceDivInHeader=true;
			break;
		}
		
		if (_isIE&&this.hdr){
			var d = this.hdr.parentNode;
			d.removeChild(this.hdr);
			d.appendChild(this.hdr);
		}
		this.setSizes();
	}
	
	if (_isIE)
		this.preventIECaching(true);
	if (window.dhtmlDragAndDropObject)
		this.dragger=new dhtmlDragAndDropObject();
	
	/*METHODS. SERVICE*/
	/**
	*   @desc: on scroll grid inner actions
	*   @type: private
	*   @topic: 7
	*/
	this._doOnScroll=function(e, mode){
		this.callEvent("onScroll", [
				this.objBox.scrollLeft,
				this.objBox.scrollTop
		]);
		
		this.doOnScroll(e, mode);
	}
	/**
	*   @desc: on scroll grid more inner action
	*   @type: private
	*   @topic: 7
	*/
	this.doOnScroll=function(e, mode){
		this.hdrBox.scrollLeft=this.objBox.scrollLeft;
		if (this.ftr)
			this.ftr.parentNode.scrollLeft=this.objBox.scrollLeft;
		
		if (mode)
			return;
		
		if (this._srnd){
			if (this._dLoadTimer)
				window.clearTimeout(this._dLoadTimer);
			this._dLoadTimer=window.setTimeout(function(){
					if (self._update_srnd_view)
						self._update_srnd_view();
			}, 100);
		}
	}
	/**
	*   @desc: attach grid to some object in DOM
	*   @param: obj - object to attach to
	*   @type: public
	*   @topic: 0,7
	*/
	this.attachToObject=function(obj){
		obj.appendChild(this.globalBox?this.globalBox:this.entBox);
		//this.objBox.style.height=this.entBox.style.height;
		this.setSizes();
	}
	/**
	*   @desc: initialize grid
	*   @param: fl - if to parse on page xml data island 
	*   @type: public
	*   @topic: 0,7
	*/
	this.init=function(fl){
		if ((this.isTreeGrid())&&(!this._h2)){
			this._h2=this._createHierarchy();
			
			if ((this._fake)&&(!this._realfake))
				this._fake._h2=this._h2;
			this._tgc={
				imgURL: null
			};
		}
		
		if (!this._hstyles)
			return;
		
		if (!this.skin_name)
			this.setSkin(window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxgrid")||"material");
		
		this.editStop()
		/*TEMPORARY STATES*/
		this.lastClicked=null;                //row clicked without shift key. used in multiselect only
		this.resized=null;                    //hdr cell that is resized now
		this.fldSorted=this.r_fldSorted=null; //hdr cell last sorted
		//empty grid if it already was initialized
		this.cellWidthPX=[];
		this.cellWidthPC=[];
		
		if (this.hdr.rows.length > 0){
			var temp = this.xmlFileUrl;
			this.clearAll(true);
			this.xmlFileUrl = temp;
		}
		
		var hdrRow = this.hdr.insertRow(0);
		
		for (var i = 0; i < this.hdrLabels.length; i++){
			hdrRow.appendChild(document.createElement("TH"));
			hdrRow.childNodes[i]._cellIndex=i;
			hdrRow.childNodes[i].style.height="0px";
		}
		
		if (_isIE && _isIE<8 && document.body.style.msTouchAction == this.undefined)
			hdrRow.style.position="absolute";
		else
			hdrRow.style.height='auto';
		
		var hdrRow = this.hdr.insertRow(_isKHTML ? 2 : 1);
		
		hdrRow._childIndexes=new Array();
		var col_ex = 0;
		
		for (var i = 0; i < this.hdrLabels.length; i++){
			hdrRow._childIndexes[i]=i-col_ex;
			
			if ((this.hdrLabels[i] == this.splitSign)&&(i != 0)){
				if (_isKHTML)
					hdrRow.insertCell(i-col_ex);
				hdrRow.cells[i-col_ex-1].colSpan=(hdrRow.cells[i-col_ex-1].colSpan||1)+1;
				hdrRow.childNodes[i-col_ex-1]._cellIndex++;
				col_ex++;
				hdrRow._childIndexes[i]=i-col_ex;
				continue;
			}
			
			hdrRow.insertCell(i-col_ex);
			
			hdrRow.childNodes[i-col_ex]._cellIndex=i;
			hdrRow.childNodes[i-col_ex]._cellIndexS=i;
			this.setColumnLabel(i, this.hdrLabels[i]);
		}
		
		if (col_ex == 0)
			hdrRow._childIndexes=null;
		this._cCount=this.hdrLabels.length;
		
		if (_isIE)
		window.setTimeout(function(){
				if (self.setSizes)
					self.setSizes();
		}, 1);
		
		//create virtual top row
		if (!this.obj.firstChild)
			this.obj.appendChild(document.createElement("TBODY"));
		
		var tar = this.obj.firstChild;
		
		if (!tar.firstChild){
			tar.appendChild(document.createElement("TR"));
			tar=tar.firstChild;
			
			if (_isIE && _isIE<8 && document.body.style.msTouchAction == this.undefined)
				tar.style.position="absolute";
			else
				tar.style.height='auto';
			
			for (var i = 0; i < this.hdrLabels.length; i++){
				tar.appendChild(document.createElement("TH"));
				tar.childNodes[i].style.height="0px";
			}
		}
		
		this._c_order=null;
		
		if (this.multiLine != true)
			this.obj.className+=" row20px";
		
		//
		//this.combos = new Array(this.hdrLabels.length);
		//set sort image to initial state
		this.sortImg.style.position="absolute";
		this.sortImg.style.display="none";
		this.sortImg.className = "dhxgrid_sort_desc";
		this.sortImg.defLeft=0;
		
		if (this.noHeader){
			this.hdrBox.style.display='none';
		}
		else {
			this.noHeader=false
		}
		//#__pro_feature:21092006{
		//#column_hidden:21092006{
		if (this._ivizcol)
			this.setColHidden();
		//#}
		//#}
		//#header_footer:06042008{		
		this.attachHeader();
		this.attachHeader(0, 0, "_aFoot");
		//#}
		this.setSizes();
		
		if (fl)
			this.parseXML()
		this.obj.scrollTop=0
		
		if (this.dragAndDropOff)
			this.dragger.addDragLanding(this.entBox, this);
		
		if (this._initDrF)
			this._initD();
		
		dhx4.callEvent("onGridCreated", [this]);
	};
	
	this.setColumnSizes=function(gridWidth){
		var summ = 0;
		var fcols = []; //auto-size columns
		
		var fix = 0;
		for (var i = 0; i < this._cCount; i++){
			if ((this.initCellWidth[i] == "*") && !this._hrrar[i]){
				this._awdth=false; //disable auto-width
				fcols.push(i);
				continue;
			}
			
			if (this.cellWidthType == '%'){
				if (typeof this.cellWidthPC[i]=="undefined")
					this.cellWidthPC[i]=this.initCellWidth[i];
				var cwidth = (gridWidth*this.cellWidthPC[i]/100)||0;
				if (fix>0.5){
					cwidth++;
					fix--;
				}
				var rwidth = this.cellWidthPX[i]=Math.floor(cwidth);
				var fix =fix + cwidth - rwidth;
			} else{
				if (typeof this.cellWidthPX[i]=="undefined")
					this.cellWidthPX[i]=this.initCellWidth[i];
			}
			if (!this._hrrar[i])
				summ+=this.cellWidthPX[i]*1;
		}
		
		//auto-size columns
		if (fcols.length){
			var ms = Math.floor((gridWidth-summ)/fcols.length);
			if (ms < 0) ms=1;
			
			for (var i = 0; i < fcols.length; i++){
				var next=Math.max((this._drsclmW ? (this._drsclmW[fcols[i]]||0) : 0),ms)
				this.cellWidthPX[fcols[i]]=next;
				summ+=next;
			}
			
			if(gridWidth > summ){
				var last=fcols[fcols.length-1];
				this.cellWidthPX[last]=this.cellWidthPX[last] + (gridWidth-summ);
				summ = gridWidth;
			}
			
			this._setAutoResize();
		}
		
		
		this.obj.style.width=summ+"px";
		this.hdr.style.width=summ+"px";
		if (this.ftr) this.ftr.style.width=summ+"px";
		
		this.chngCellWidth();
		return summ;
	}
	
	/**shz)_
	*   @desc: sets sizes of grid elements
	*   @type: private
	*   @topic: 0,7
	*/
	this.setSizes=function(){
		//drop processing if grid still not initialized 
		if ((!this.hdr.rows[0])) return;
		
		var quirks=this.quirks = (_isIE && document.compatMode=="BackCompat");
		var outerBorder=(this.entBox.offsetWidth-this.entBox.clientWidth)/2;		

		if (!this.dontSetSizes){
			if (this.globalBox){
				if (!this.globalBox.clientWidth) return;
				var ow = this.globalBox.clientWidth;
				var splitOuterBorder=(this.globalBox.offsetWidth-ow)/2;		
				if (this._delta_x && !this._realfake){
					this.globalBox.style.width=this._delta_x;
					var owu = this.globalBox.clientWidth;
					this.entBox.style.width=Math.max(0,(owu+(quirks?splitOuterBorder*2:0))-this._fake.entBox.clientWidth)+"px";
					if (owu != this._lastTimeSplitWidth){
						this._fake._correctSplit(this._fake.entBox.clientWidth);
						this._lastTimeSplitWidth = owu;
					}
				}
				if (this._delta_y && !this._realfake){
					this.globalBox.style.height = this._delta_y;
					this.entBox.style.overflow = this._fake.entBox.style.overflow="hidden";
					this.entBox.style.height = this._fake.entBox.style.height=this.globalBox.clientHeight+(quirks?splitOuterBorder*2:0)+"px";
				}
			} else {
				if (this._delta_x){
					/*when placed directly in TD tag, container can't use native percent based sizes, 
					because table auto-adjust to show all content - too clever*/
					if (this.entBox.parentNode && this.entBox.parentNode.tagName=="TD"){
						this.entBox.style.width="1px";
						this.entBox.style.width=parseInt(this._delta_x)*this.entBox.parentNode.clientWidth/100-outerBorder*2+"px";
					}else
					this.entBox.style.width=this._delta_x;
				}
				if (this._delta_y)
					this.entBox.style.height=this._delta_y;
			}
		}
		
		//if we have container without sizes, wait untill sizes defined
		window.clearTimeout(this._sizeTime);		
		if (!this.entBox.offsetWidth && (!this.globalBox || !this.globalBox.offsetWidth)){
			this._sizeTime=window.setTimeout(function(){
					if (self.setSizes)
						self.setSizes();
			}, 250);
			return;
		}		
		
		var border_x = ((!this._wthB) && ((this.entBox.cmp||this._delta_x) && (this.skin_name||"").indexOf("dhx")==0 && !quirks)?2:0);
		var border_y = ((!this._wthB) && ((this.entBox.cmp||this._delta_y) && (this.skin_name||"").indexOf("dhx")==0 && !quirks)?2:0);
		
		if (this._sizeFix){
			border_x -= this._sizeFix;
			border_y -= this._sizeFix;
		}
		
		var isVScroll = this.parentGrid?false:(this.objBox.scrollHeight > this.objBox.offsetHeight);
		
		var scrfix = dhtmlx.$customScroll?0:18;
		
		var gridWidth=this.entBox.clientWidth-(this.skin_h_correction||0)*(quirks?0:1)-border_x;
		var gridWidthActive=this.entBox.clientWidth-(this.skin_h_correction||0)-border_x;
		var gridHeight=this.entBox.clientHeight-border_y;
		var summ=this.setColumnSizes(gridWidthActive-(isVScroll?scrfix:0)-(this._correction_x||0));
		
		var isHScroll = this.parentGrid?false:((this.objBox.scrollWidth > this.objBox.offsetWidth)||(this.objBox.style.overflowX=="scroll")); 
		var headerHeight = this.hdr.clientHeight;
		var footerHeight = this.ftr?this.ftr.clientHeight:0;
		var newWidth=gridWidth;
		var newHeight=gridHeight-headerHeight-footerHeight;
		
		//if we have auto-width without limitations - ignore h-scroll
		if (this._awdth && this._awdth[0] && this._awdth[1]==99999) isHScroll=0;
		//auto-height
		if (this._ahgr){
			if (this._ahgrMA)
				newHeight=this.entBox.parentNode.clientHeight-headerHeight-footerHeight;
			else
				newHeight=this.obj.offsetHeight+(isHScroll?scrfix:0)+(this._correction_y||0);
			
			if (this._ahgrM){
				if (this._ahgrF) 
					newHeight=Math.min(this._ahgrM,newHeight+headerHeight+footerHeight)-headerHeight-footerHeight;
				else 
					newHeight=Math.min(this._ahgrM,newHeight);
				
			}
			if (isVScroll && newHeight>=this.obj.scrollHeight+(isHScroll?scrfix:0)){
				isVScroll=false;//scroll will be compensated;
				this.setColumnSizes(gridWidthActive-(this._correction_x||0)); //correct auto-size columns
			}
		}
		
		//auto-width
		if ((this._awdth)&&(this._awdth[0])){ 
			//convert percents to PX, because auto-width with procents has no sense
			if (this.cellWidthType == '%') this.cellWidthType="px";
			
			if (this._fake) summ+=this._fake.entBox.clientWidth;	//include fake grid in math
			var newWidth=Math.min(Math.max(summ+(isVScroll?scrfix:0),this._awdth[2]),this._awdth[1])+(this._correction_x||0);
			this.objBox.style.overflowX = (!isVScroll && this.objBox.scrollWidth <= newWidth)?"hidden":"auto";
			if (this._fake) newWidth-=this._fake.entBox.clientWidth;
		}
		
		newHeight=Math.max(0,newHeight);//validate value for IE
		
		//FF3.1, bug in table rendering engine
		this._ff_size_delta=(this._ff_size_delta==0.1)?0.2:0.1;
		if (!_isFF) this._ff_size_delta=0;
		
		if (!this.dontSetSizes){
			this.entBox.style.width=Math.max(0,newWidth+(quirks?2:0)*outerBorder+this._ff_size_delta)+"px";
			this.entBox.style.height=newHeight+(quirks?2:0)*outerBorder+headerHeight+footerHeight+"px";
		}
		this.objBox.style.height=newHeight+((quirks&&!isVScroll)?2:0)*outerBorder+"px";//):this.entBox.style.height);
		this.hdrBox.style.height=headerHeight+"px";		
		
		
		if (newHeight != gridHeight)
			this.doOnScroll(0, !this._srnd);
		var ext=this["setSizes_"+this.skin_name];
		if (ext) ext.call(this);
		
		this.setSortImgPos();	
		
		//it possible that changes of size, has changed header height 
		if (headerHeight != this.hdr.clientHeight && this._ahgr) 	
			this.setSizes();
		this.callEvent("onSetSizes",[]);
	};
	/**
	*   @desc: changes cell width
	*   @param: [ind] - index of row in grid
	*   @type: private
	*   @topic: 4,7
	*/
	this.chngCellWidth=function(){
		if ((_isOpera)&&(this.ftr))
			this.ftr.width=this.objBox.scrollWidth+"px";
		var l = this._cCount;
		
		for (var i = 0; i < l; i++){
			this.hdr.rows[0].cells[i].style.width=this.cellWidthPX[i]+"px";
			this.obj.rows[0].childNodes[i].style.width=this.cellWidthPX[i]+"px";
			
			if (this.ftr)
				this.ftr.rows[0].cells[i].style.width=this.cellWidthPX[i]+"px";
		}
	}
	/**
	*   @desc: set delimiter character used in list values (default is ",")
	*   @param: delim - delimiter as string
	*   @before_init: 1
	*   @type: public
	*   @topic: 0
	*/
	this.setDelimiter=function(delim){
		this.delim=delim;
	}
	/**
	*   @desc: set width of columns in percents
	*   @type: public
	*   @before_init: 1
	*   @param: wp - list of column width in percents
	*   @topic: 0,7
	*/
	this.setInitWidthsP=function(wp){
		this.cellWidthType="%";
		this.initCellWidth=wp.split(this.delim.replace(/px/gi, ""));
		if (!arguments[1]) this._setAutoResize();
	}
	/**
	*	@desc:
	*	@type: private
	*	@topic: 0
	*/
	this._setAutoResize=function(){
		if (this._realfake) return;
		var el = window;
		var self = this;
		
		dhtmlxEvent(window,"resize",function(){
				window.clearTimeout(self._resize_timer);
				if (self._setAutoResize)
				self._resize_timer=window.setTimeout(function(){
						if (self.setSizes)
							self.setSizes();
						if (self._fake)
							self._fake._correctSplit();
				}, 100);
		});

		//prevent multiple initializations
		this._setAutoResize = function(){};
	}
	
	
	/**
	*   @desc: set width of columns in pixels
	*   @type: public
	*   @before_init: 1
	*   @param: wp - list of column width in pixels
	*   @topic: 0,7
	*/
	this.setInitWidths=function(wp){
		this.cellWidthType="px";
		this.initCellWidth=wp.split(this.delim);
		
		if (_isFF){
			for (var i = 0; i < this.initCellWidth.length; i++)
				if (this.initCellWidth[i] != "*")
				this.initCellWidth[i]=parseInt(this.initCellWidth[i]);
		}
	}
	
	/**
	*   @desc: set multiline rows support to enabled or disabled state
	*   @type: public
	*   @before_init: 1
	*   @param: state - true or false
	*   @topic: 0,7
	*/
	this.enableMultiline=function(state){
		this.multiLine=dhx4.s2b(state);
	}
	
	/**
	*   @desc: set multiselect mode to enabled or disabled state
	*   @type: public
	*   @param: state - true or false
	*   @topic: 0,7
	*/
	this.enableMultiselect=function(state){
		this.selMultiRows=dhx4.s2b(state);
	}
	
	/**
	*   @desc: set path to grid internal images (sort direction, any images used in editors, checkbox, radiobutton)
	*   @type: public
	*   @param: path - url (or relative path) of images folder with closing "/"
	*   @topic: 0,7
	*/
	this.setImagePath=function(path){
		path = path.replace(/imgs\/dhxgrid_[a-z]*\/$/,"imgs/");
		this._imgURL= path;
		this.imgURL = path + "dhxgrid_"+(this.skin_name || "dhx_skyblue").replace("dhx_", "") + "/";
		this.iconTree = this.imgURL + "tree/";
	}
	this.setImagesPath=this.setImagePath;
	/**
	*   @desc: set path to external images used in grid ( tree and img column types )
	*   @type: public
	*   @param: path - url (or relative path) of images folder with closing "/"
	*   @topic: 0,7
	*/
	this.setIconPath=function(path){
		this.iconURL=path;
	}	
	this.setIconsPath=this.setIconPath;
	//#column_resize:06042008{
	/**
	*   @desc: part of column resize routine
	*   @type: private
	*   @param: ev - event
	*   @topic: 3
	*/
	this.changeCursorState=function(ev){
		var el = ev.target||ev.srcElement;
		
		if (el.tagName != "TD")
			el=this.getFirstParentOfType(el, "TD")
		if (!el) return;
		if ((el.tagName == "TD")&&(this._drsclmn)&&(!this._drsclmn[el._cellIndex]))
			return el.style.cursor="default";
		var check = (ev.layerX||0)+(((!_isIE)&&(ev.target.tagName == "DIV")) ? el.offsetLeft : 0);
		if ((el.offsetWidth-(ev.offsetX||(parseInt(this.getPosition(el, this.hdrBox))-check)*-1)) < (_isOpera?20:10)){
			el.style.cursor="E-resize";
		}
		else{
			el.style.cursor="default";
		}
		
		if (_isOpera)
			this.hdrBox.scrollLeft=this.objBox.scrollLeft;
	}
	/**
	*   @desc: part of column resize routine
	*   @type: private
	*   @param: ev - event
	*   @topic: 3
	*/
	this.startColResize=function(ev){
		if (this.resized) this.stopColResize();
		this.resized=null;
		var el = ev.target||ev.srcElement;
		if (el.tagName != "TD")
			el=this.getFirstParentOfType(el, "TD")
		var x = ev.clientX;
		var tabW = this.hdr.offsetWidth;
		var startW = parseInt(el.offsetWidth)
		
		if (el.tagName == "TD"&&el.style.cursor != "default"){
			if ((this._drsclmn)&&(!this._drsclmn[el._cellIndex]))
				return;
			
			self._old_d_mm=document.body.onmousemove;
			self._old_d_mu=document.body.onmouseup;
			document.body.onmousemove=function(e){
				if (self)
					self.doColResize(e||window.event, el, startW, x, tabW)
			}
			document.body.onmouseup=function(){
				if (self)
					self.stopColResize();
			}
		}
	}
	/**
	*   @desc: part of column resize routine
	*   @type: private
	*   @param: ev - event
	*   @topic: 3
	*/
	this.stopColResize=function(){ 
		document.body.onmousemove=self._old_d_mm||"";
		document.body.onmouseup=self._old_d_mu||"";
		this.setSizes();
		this.doOnScroll(0, 1)
		this.callEvent("onResizeEnd", [this]);
	}
	/**
	*   @desc: part of column resize routine
	*   @param: el - element (column resizing)
	*   @param: startW - started width
	*   @param: x - x coordinate to resize from
	*   @param: tabW - started width of header table
	*   @type: private
	*   @topic: 3
	*/
	this.doColResize=function(ev, el, startW, x, tabW){
		el.style.cursor="E-resize";
		this.resized=el;
		var fcolW = startW+(ev.clientX-x);
		var wtabW = tabW+(ev.clientX-x)
		
		if (!(this.callEvent("onResize", [
				el._cellIndex,
			fcolW,
			this
		])))
		return;
		
		if (_isIE)
			this.objBox.scrollLeft=this.hdrBox.scrollLeft;
		
		var result = false;
		if (el.colSpan > 1){
			var a_sizes = new Array();
			
			for (var i = 0;
				i < el.colSpan;
				i++)a_sizes[i]=Math.round(fcolW*this.hdr.rows[0].childNodes[el._cellIndexS+i].offsetWidth/el.offsetWidth);
				
				for (var i = 0; i < el.colSpan; i++)
					result = this._setColumnSizeR(el._cellIndexS+i*1, a_sizes[i]);
		} else
		result = this._setColumnSizeR(el._cellIndex, fcolW);
		this.doOnScroll(0, 1);
		
		this.setSizes();
		if (this._fake && this._awdth) this._fake._correctSplit();
		
		return result;
	}
	
	/**
	*   @desc: set width of grid columns ( zero row of header and body )
	*   @type: private
	*   @topic: 7
	*/
	this._setColumnSizeR=function(ind, fcolW){
		if (fcolW > ((this._drsclmW&&!this._notresize) ? (this._drsclmW[ind]||10) : 10)){
			this.obj.rows[0].childNodes[ind].style.width=fcolW+"px";
			this.hdr.rows[0].childNodes[ind].style.width=fcolW+"px";
			
			if (this.ftr)
				this.ftr.rows[0].childNodes[ind].style.width=fcolW+"px";
			
			if (this.cellWidthType == 'px'){
				this.cellWidthPX[ind]=fcolW;
			}
			else {
				var gridWidth = parseInt(this.entBox.offsetWidth);
				
				if (this.objBox.scrollHeight > this.objBox.offsetHeight)
					gridWidth-=17;
				var pcWidth = Math.round(fcolW / gridWidth*100)
				this.cellWidthPC[ind]=pcWidth;
			}
			if (this.sortImg.style.display!="none")
				this.setSortImgPos();
		} else return false;
	}
	//#}
	//#sorting:06042008{
	/**
	*    @desc: sets position and visibility of sort arrow
	*    @param: state - true/false - show/hide image
	*    @param: ind - index of field
	*    @param: order - asc/desc - type of image
	*    @param: row - one based index of header row ( used in multirow headers, top row by default )
	*   @type: public
	*   @topic: 7
	*/
	this.setSortImgState=function(state, ind, order, row){
		order=(order||"asc").toLowerCase();
		
		if (!dhx4.s2b(state)){
			this.sortImg.style.display="none";
			if (this.r_fldSorted)
				this.r_fldSorted.className = "";
			this.fldSorted=this.r_fldSorted = null;
			return;
		}
		
		if (order == "asc")
			this.sortImg.className = "dhxgrid_sort_asc";
		else
			this.sortImg.className = "dhxgrid_sort_desc";
		
		this.sortImg.style.display="";
		this.fldSorted=this.hdr.rows[0].childNodes[ind];
		var r = this.hdr.rows[row||1];
		if (!r) return;
		
		for (var i = 0; i < r.childNodes.length; i++){
			if (r.childNodes[i]._cellIndexS == ind){
				this.r_fldSorted=r.childNodes[i];
				return  this.setSortImgPos();
			}
		}
		return this.setSortImgState(state,ind,order,(row||1)+1);
	}
	
	/**
	*    @desc: sets position and visibility of sort arrow
	*    @param: ind - index of field
	*    @param: ind - index of field
	*    @param: hRowInd - index of row in case of complex header, one-based, optional
	
	*   @type: private
	*   @topic: 7
	*/
	this.setSortImgPos=function(ind, mode, hRowInd, el){
		if (this._hrrar && this._hrrar[this.r_fldSorted?this.r_fldSorted._cellIndex:ind]) return;
		if (this.ar_fldSorted)
			this.ar_fldSorted.className = "";

		if (!el){
			if (!ind)
				var el = this.r_fldSorted;
			else
				var el = this.hdr.rows[hRowInd||0].cells[ind];
		}
		
		if (el != null){
			var pos = this.getPosition(el, this.hdrBox)
			var wdth = el.offsetWidth;
			this.ar_fldSorted = el;
			el.className = this.sortImg.className+"_col";

			this.sortImg.style.left=Number(pos[0]+wdth-13)+"px"; //Number(pos[0]+5)+"px";
			this.sortImg.defLeft=parseInt(this.sortImg.style.left)
			this.sortImg.style.top=Number(pos[1]+5)+"px";
			
			if ((!this.useImagesInHeader)&&(!mode))
				this.sortImg.style.display="inline";
			this.sortImg.style.left=this.sortImg.defLeft+"px"; //-parseInt(this.hdrBox.scrollLeft)
		}
	}
	//#}
	/**
	*   @desc: manage activity of the grid.
	*   @param: fl - true to activate,false to deactivate
	*   @type: private
	*   @topic: 1,7
	*/
	this.setActive=function(fl){
		if (arguments.length == 0)
			var fl = true;
		
		if (fl == true){
			//document.body.onkeydown = new Function("","document.getElementById('"+this.entBox.id+"').grid.doKey()")//
			if (globalActiveDHTMLGridObject&&(globalActiveDHTMLGridObject != this)){
				globalActiveDHTMLGridObject.editStop();
				globalActiveDHTMLGridObject.callEvent("onBlur",[globalActiveDHTMLGridObject]);
			}
			
			globalActiveDHTMLGridObject=this;
			this.isActive=true;
		} else {
			this.isActive=false;
			this.callEvent("onBlur",[this]);
		}
	};
	/**
	*     @desc: called on click occured
	*     @type: private
	*/
	this._doClick=function(ev){
		var selMethod = 0;
		var el = this.getFirstParentOfType(_isIE ? ev.srcElement : ev.target, "TD");
		if (!el || !el.parentNode || !el.parentNode.idd) return;
		var fl = true;
		
		//mm
		//markers start
		if (this.markedCells){
			var markMethod = 0;
			
			if (ev.shiftKey||ev.metaKey){
				markMethod=1;
			}
			
			if (ev.ctrlKey){
				markMethod=2;
			}
			this.doMark(el, markMethod);
			return true;
		}
		//markers end
		//mm
		
		if (this.selMultiRows != false){
			if (ev.shiftKey && this.row != null && this.selectedRows.length){
				selMethod=1;
			}
			
			if (ev.ctrlKey||ev.metaKey){
				selMethod=2;
			}
		}
		return this.doClick(el, fl, selMethod, false)
	};
	
	//#context_menu:06042008{
	/**
	*   @desc: called onmousedown inside grid area
	*   @type: private
	*/
	this._doContClick=function(ev){ 
		var el = this.getFirstParentOfType(_isIE ? ev.srcElement : ev.target, "TD");
		
		if ((!el)||( typeof (el.parentNode.idd) == "undefined")){
			this.callEvent("onEmptyClick", [ev]);
			return true;
		}
		
		if (ev.button == 2||(_isMacOS&&ev.ctrlKey)){
			if (!this.callEvent("onRightClick", [
					el.parentNode.idd,
				el._cellIndex,
				ev
			])){
			var z = function(e){
				(e||event).cancelBubble=true;
				return false;
			};
			
			(ev.srcElement||ev.target).oncontextmenu=z;
			return z(ev);
			}
			
			if (this._ctmndx){
				if (!(this.callEvent("onBeforeContextMenu", [
						el.parentNode.idd,
					el._cellIndex,
					this
				])))
				return true;
				
				if (_isIE)
				ev.srcElement.oncontextmenu=function(){
					event.cancelBubble=true;
					return false;
				};
				
				if (this._ctmndx.showContextMenu){
					
					var dEl0=window.document.documentElement;
					var dEl1=window.document.body;
					var corrector = new Array((dEl0.scrollLeft||dEl1.scrollLeft),(dEl0.scrollTop||dEl1.scrollTop));
					if (_isIE){
						var x= ev.clientX+corrector[0];
						var y = ev.clientY+corrector[1];
					} else {
						var x= ev.pageX;
						var y = ev.pageY;
					}
					this._ctmndx.showContextMenu(x-1,y-1)
					this.contextID=this._ctmndx.contextMenuZoneId=el.parentNode.idd+"_"+el._cellIndex;
					this._ctmndx._skip_hide=true;
				} else {
					el.contextMenuId=el.parentNode.idd+"_"+el._cellIndex;
					el.contextMenu=this._ctmndx;
					el.a=this._ctmndx._contextStart;
					el.a(el, ev);
					el.a=null;
				}
				ev.cancelBubble=true;
				return false;
			}
		}
		
		else if (this._ctmndx){
			if (this._ctmndx.hideContextMenu)
				this._ctmndx.hideContextMenu()
			else
				this._ctmndx._contextEnd();
		}
		return true;
	}
	//#}
	/**
	*    @desc: occures on cell click (supports treegrid)
	*   @param: [el] - cell to click on
	*   @param:   [fl] - true if to call onRowSelect function
	*   @param: [selMethod] - 0 - simple click, 1 - shift, 2 - ctrl
	*   @param: show - true/false - scroll row to view, true by defaul    
	*   @type: private
	*   @topic: 1,2,4,9
	*/
	this.doClick=function(el, fl, selMethod, show){
		if (!this.selMultiRows) selMethod=0; //block programmatical multiselecton if mode not enabled explitly
		var psid = this.row ? this.row.idd : 0;
		
		this.setActive(true);
		
		if (!selMethod)
			selMethod=0;
		
		if (this.cell != null)
			this.cell.className=this.cell.className.replace(/cellselected/g, "");
		
		if (el.tagName == "TD"){
			if (this.checkEvent("onSelectStateChanged"))
				var initial = this.getSelectedId();
			var prow = this.row;
			if (selMethod == 1){
				var elRowIndex = this.rowsCol._dhx_find(el.parentNode)
				var lcRowIndex = this.rowsCol._dhx_find(this.lastClicked)
				
				if (elRowIndex > lcRowIndex){
					var strt = lcRowIndex;
					var end = elRowIndex;
				} else {
					var strt = elRowIndex;
					var end = lcRowIndex;
				}
				
				for (var i = 0; i < this.rowsCol.length; i++)
				if ((i >= strt&&i <= end)){
					if (this.rowsCol[i]&&(!this.rowsCol[i]._sRow)){
						if (!this.rowsCol[i].idd) continue;
						if (this.rowsCol[i].className.indexOf("rowselected")
							== -1&& (this.callEvent("onBeforeSelect", [
									this.rowsCol[i].idd,
									psid,
									el._cellIndex
							]))){
						this.rowsCol[i].className+=" rowselected";
						this.selectedRows[this.selectedRows.length]=this.rowsCol[i]
							}
					} else {
						this.clearSelection();
						return this.doClick(el, fl, 0, show);
					}
				}
			} else if (selMethod == 2){
				if (el.parentNode.className.indexOf("rowselected") != -1){
					el.parentNode.className=el.parentNode.className.replace(/rowselected/g, "");
					this.selectedRows._dhx_removeAt(this.selectedRows._dhx_find(el.parentNode))
					var skipRowSelection = true;
					show = false;
				}
			}
			this.editStop()
			if (typeof (el.parentNode.idd) == "undefined")
				return true;
			
			if ((!skipRowSelection)&&(!el.parentNode._sRow)){
				if (this.callEvent("onBeforeSelect", [
						el.parentNode.idd,
					psid,
					el._cellIndex
				])){
				if (this.getSelectedRowId() != el.parentNode.idd){
					if (selMethod == 0)
						this.clearSelection();
					this.cell=el;
					if ((prow == el.parentNode)&&(this._chRRS))
						fl=false;
					this.row=el.parentNode;
					this.row.className+=" rowselected"
					
					if (this.selectedRows._dhx_find(this.row) == -1)
						this.selectedRows[this.selectedRows.length]=this.row;
				} else {
					this.cell=el;
					this.row = el.parentNode;
				}
				} else fl = false;
			}
			
			if (this.cell && this.cell.parentNode.className.indexOf("rowselected") != -1)
				this.cell.className=this.cell.className.replace(/cellselected/g, "")+" cellselected";
			
			if (selMethod != 1)
				if (!this.row)
				return;
			this.lastClicked=el.parentNode;
			
			var rid = this.row.idd;
			var cid = this.cell;
			
			if (fl&& typeof (rid) != "undefined" && cid && !skipRowSelection) {
				self.onRowSelectTime=setTimeout(function(){
						if (self.callEvent)
						self.callEvent("onRowSelect", [
								rid,
								cid._cellIndex
						]);
				}, 100);
			} else this.callEvent("onRowSelectRSOnly",[rid]);
			
			if (this.checkEvent("onSelectStateChanged")){
				var afinal = this.getSelectedId();
				
				if (initial != afinal)
					this.callEvent("onSelectStateChanged", [afinal,initial]);
			}
			
			if (skipRowSelection) return false;
		}
		this.isActive=true;
		if (show !== false && this.cell && this.cell.parentNode.idd)
			this.moveToVisible(this.cell)
	}
	
	/**
	*   @desc: select all rows in grid, it doesn't fire any events
	*   @param: edit - switch selected cell to edit mode
	*   @type: public
	*   @topic: 1,4
	*/
	this.selectAll=function(){
		this.clearSelection();
		
		var coll = this.rowsBuffer;
		//in paging mode, we select only current page
		if (this.pagingOn) coll = this.rowsCol;
		for (var i = 0; i<coll.length; i ++){
			this.render_row(i).className+=" rowselected";
		}
		
		this.selectedRows=dhtmlxArray([].concat(coll));
		
		if (this.selectedRows.length){
			this.row  = this.selectedRows[0];
			this.cell = this.row.cells[0];
		}
		
		if ((this._fake)&&(!this._realfake))
			this._fake.selectAll();
	}
	/**
	*   @desc: set selection to specified row-cell
	*   @param: r - row object or row index
	*   @param: cInd - cell index
	*   @param: [fl] - true if to call onRowSelect function
	*   @param: preserve - preserve previously selected rows true/false (false by default)
	*   @param: edit - switch selected cell to edit mode
	*   @param: show - true/false - scroll row to view, true by defaul         
	*   @type: public
	*   @topic: 1,4
	*/
	this.selectCell=function(r, cInd, fl, preserve, edit, show){
		if (!fl)
			fl=false;
		
		if (typeof (r) != "object")
			r=this.render_row(r)
		if (!r || r==-1) return null;
		//#__pro_feature:21092006{
		//#colspan:20092006{
		if (r._childIndexes)
			var c = r.childNodes[r._childIndexes[cInd]];
		else
			//#}
		//#}
		var c = r.childNodes[cInd];
		
		if (!c)
			c=r.childNodes[0];
		if(!this.markedCells){
			if (preserve)
				this.doClick(c, fl, 3, show)
			else
				this.doClick(c, fl, 0, show)
		}
		else 
			this.doMark(c,preserve?2:0);
		
		if (edit)
			this.editCell();
	}
	/**
	*   @desc: moves specified cell to visible area (scrolls)
	*   @param: cell_obj - object of the cell to work with
	*   @param: onlyVScroll - allow only vertical positioning
	
	*   @type: private
	*   @topic: 2,4,7
	*/
	this.moveToVisible=function(cell_obj, onlyVScroll){
		if (this.pagingOn){
			var newPage=Math.floor(this.getRowIndex(cell_obj.parentNode.idd) / this.rowsBufferOutSize)+1;
			if (newPage!=this.currentPage)
				this.changePage(newPage);
		}
		
		try{
			if (cell_obj.offsetHeight){
				var distance = cell_obj.offsetLeft+cell_obj.offsetWidth+20;
				
				var scrollLeft = 0;
				
				if (distance > (this.objBox.offsetWidth+this.objBox.scrollLeft)){
					if (cell_obj.offsetLeft > this.objBox.scrollLeft)
						scrollLeft= cell_obj.offsetLeft - (this.objBox.offsetWidth - cell_obj.offsetWidth) +5
				} else if (cell_obj.offsetLeft < this.objBox.scrollLeft){
					distance-=cell_obj.offsetWidth*2/3;
					if (distance < this.objBox.scrollLeft)
						scrollLeft=cell_obj.offsetLeft-5
				}
				
				if ((scrollLeft)&&(!onlyVScroll))
					this.objBox.scrollLeft=scrollLeft;
			}
			
			
			if (!cell_obj.offsetHeight){
				var mask=this._realfake?this._fake.rowsAr[cell_obj.parentNode.idd]:cell_obj.parentNode;
				distance = this.rowsBuffer._dhx_find(mask)*this._srdh;
			}
			else
				distance = cell_obj.offsetTop;
			var distancemax = distance + cell_obj.offsetHeight+38;
			
			if (distancemax > (this.objBox.offsetHeight+this.objBox.scrollTop)){
				var scrollTop = distance;
			} else if (distance < this.objBox.scrollTop){
				var scrollTop = distance-5
			}
			
			if (scrollTop)
				this.objBox.scrollTop=scrollTop;
		}
		catch (er){}
	}
	/**
	*   @desc: creates Editor object and switch cell to edit mode if allowed
	*   @type: public
	*   @topic: 4
	*/
	this.editCell = function(){
		if (this.editor&&this.cell == this.editor.cell)
			return; //prevent reinit for same cell
		
		this.editStop();
		
		if ((this.isEditable != true)||(!this.cell))
			return false;
		var c = this.cell;
		
		//#locked_row:11052006{
		if (c.parentNode._locked)
			return false;
		//#}
		
		this.editor=this.cells4(c);
		
		//initialize editor
		if (this.editor != null){
			if (this.editor.isDisabled()){
				this.editor=null;
				return false;
			}
			
			if (this.callEvent("onEditCell", [
					0,
				this.row.idd,
				this.cell._cellIndex
			]) != false&&this.editor.edit){
			this._Opera_stop=(new Date).valueOf();
			c.className += " editable";
			this.editor.edit();
			this.callEvent("onEditCell", [
					1,
					this.row.idd,
					this.cell._cellIndex
			])
			} else { //preserve editing
				this.editor=null;
			}
		}
	}
	/**
	*   @desc: retuns value from editor(if presents) to cell and closes editor
	*   @mode: if true - current edit value will be reverted to previous one
	*   @type: public
	*   @topic: 4
	*/
	this.editStop=function(mode){
		if (_isOpera)
		if (this._Opera_stop){
			if ((this._Opera_stop*1+50) > (new Date).valueOf())
				return;
			
			this._Opera_stop=null;
		}
		
		if (this.editor&&this.editor != null){
			this.editor.cell.className=this.editor.cell.className.replace("editable", "");
			
			if (mode){
				var t = this.editor.val;
				this.editor.detach();
				this.editor.setValue(t);
				this.editor=null;
				
				this.callEvent("onEditCancel", [
						this.row.idd,
						this.cell._cellIndex,
						t
				]);
				return;
			}
			
			if (this.editor.detach())
				this.cell.wasChanged=true;
			
			var g = this.editor;
			if (g == null) return;
			
			this.editor=null;
			var z = this.callEvent("onEditCell", [
					2,
					this.row.idd,
					this.cell._cellIndex,
					g.getValue(),
					g.val
			]);
			
			if (( typeof (z) == "string")||( typeof (z) == "number"))
				g[g.setImage ? "setLabel" : "setValue"](z);
			
			else if (!z)
				g[g.setImage ? "setLabel" : "setValue"](g.val);
			
			if (this._ahgr && this.multiLine) this.setSizes();
		}
	}
	/**
	*	@desc: 
	*	@type: private
	*/
	this._nextRowCell=function(row, dir, pos){
		row=this._nextRow((this._groups?this.rowsCol:this.rowsBuffer)._dhx_find(row), dir);
		
		if (!row)
			return null;
		
		return row.childNodes[row._childIndexes ? row._childIndexes[pos] : pos];
	}
	/**
	*	@desc: 
	*	@type: private
	*/
	this._getNextCell=function(acell, dir, i){
		
		acell=acell||this.cell;
		
		var arow = acell.parentNode;
		
		if (this._tabOrder){
			i=this._tabOrder[acell._cellIndex];
			
			if (typeof i != "undefined")
				if (i < 0)
				acell=this._nextRowCell(arow, dir, Math.abs(i)-1);
			else
				acell=arow.childNodes[i];
		} else {
			var i = acell._cellIndex+dir;
			
			if (i >= 0&&i < this._cCount){
				if (arow._childIndexes)
					i=arow._childIndexes[acell._cellIndex]+dir;
				acell=arow.childNodes[i];
			} else {
				
				acell=this._nextRowCell(arow, dir, (dir == 1 ? 0 : (this._cCount-1)));
			}
		}
		
		if (!acell){
			if ((dir == 1)&&this.tabEnd){
				this.tabEnd.focus();
				this.tabEnd.focus();
				this.setActive(false);
			}
			
			if ((dir == -1)&&this.tabStart){
				this.tabStart.focus();
				this.tabStart.focus();
				this.setActive(false);
			}
			return null;
		}
		
		//tab out
		
		// tab readonly
		if (acell.style.display != "none"
			&&(!this.smartTabOrder||!this.cells(acell.parentNode.idd, acell._cellIndex).isDisabled()))
		return acell;
		return this._getNextCell(acell, dir);
		// tab readonly
		
	}
	/**
	*	@desc: 
	*	@type: private
	*/
	this._nextRow=function(ind, dir){
		var r = this.render_row(ind+dir);
		if (!r || r==-1) return null;
		if (r&&r.style.display == "none")
			return this._nextRow(ind+dir, dir);
		
		return r;
	}
	/**
	*	@desc: 
	*	@type: private
	*/
	this.scrollPage=function(dir){ 
		if (!this.rowsBuffer.length) return;
		var master = this._realfake?this._fake:this;
		var new_ind = Math.floor((master._r_select||this.getRowIndex(this.row.idd)||0)+(dir)*this.objBox.offsetHeight / (this._srdh||20));
		
		if (new_ind < 0)
			new_ind=0;
		if (new_ind >= this.rowsBuffer.length)
			new_ind=this.rowsBuffer.length-1;
		
		if (this._srnd && !this.rowsBuffer[new_ind]){			
			this.objBox.scrollTop+=Math.floor((dir)*this.objBox.offsetHeight / (this._srdh||20))*(this._srdh||20);
			if (this._fake) this._fake.objBox.scrollTop = this.objBox.scrollTop;
			master._r_select=new_ind;
		} else {
			this.selectCell(new_ind, this.cell._cellIndex, true, false,false,(this.multiLine || this._srnd));
			if (!this.multiLine && !this._srnd && !this._realfake){
				this.objBox.scrollTop=this.getRowById(this.getRowId(new_ind)).offsetTop;
				if (this._fake) this._fake.objBox.scrollTop = this.objBox.scrollTop;
			}
			master._r_select=null;
		}
	}
	
	/**
	*   @desc: manages keybord activity in grid
	*   @type: private
	*   @topic: 7
	*/
	this.doKey=function(ev){
		if (!ev)
			return true;
		
		if ((ev.target||ev.srcElement).value !== window.undefined){
			var zx = (ev.target||ev.srcElement);
			
			if (zx.className!="dhxcombo_input"&&((!zx.parentNode)||(zx.parentNode.className.indexOf("editable") == -1)))
				return true;
		}
		
		if ((globalActiveDHTMLGridObject)&&(this != globalActiveDHTMLGridObject))
			return globalActiveDHTMLGridObject.doKey(ev);
		
		if (this.isActive == false){
			//document.body.onkeydown = "";
			return true;
		}
		
		if (this._htkebl)
			return true;
		
		if (!this.callEvent("onKeyPress", [
				ev.keyCode,
			ev.ctrlKey,
			ev.shiftKey,
			ev
		]))
		return false;
		
		var code = "k"+ev.keyCode+"_"+(ev.ctrlKey ? 1 : 0)+"_"+(ev.shiftKey ? 1 : 0);
		
		if (this.cell){ //if selection exists in grid only
			if (this._key_events[code]){
				if (false === this._key_events[code].call(this))
					return true;
				
				if (ev.preventDefault)
					ev.preventDefault();
				ev.cancelBubble=true;
				return false;
			}
			
			if (this._key_events["k_other"])
				this._key_events.k_other.call(this, ev);
		}
		
		return true;
	}
	
	/**
	*   @desc: selects row (and first cell of it)
	*   @param: r - row index or row object
	*   @param: fl - if true, then call function on select
	*   @param: preserve - preserve previously selected rows true/false (false by default)
	*   @param: show - true/false - scroll row to view, true by defaul    
	*   @type: public
	*   @topic: 1,2
	*/
	this.selectRow=function(r, fl, preserve, show){
		if (typeof (r) != 'object')
			r=this.render_row(r);
		this.selectCell(r, 0, fl, preserve, false, show)
	};
	
	/**
	*   @desc: called when row was double clicked
	*   @type: private
	*   @topic: 1,2
	*/
	this.wasDblClicked=function(ev){
		var el = this.getFirstParentOfType(_isIE ? ev.srcElement : ev.target, "TD");
		
		if (el){
			var rowId = el.parentNode.idd;
			return this.callEvent("onRowDblClicked", [
					rowId,
					el._cellIndex,
					ev
			]);
		}
	}
	
	/**
	*   @desc: called when header was clicked
	*   @type: private
	*   @topic: 1,2
	*/
	this._onHeaderClick=function(e, el){
		var that = this.grid;
		el=el||that.getFirstParentOfType(_isIE ? event.srcElement : e.target, "TD");
		
		if (this.grid.resized == null){
			if (!(this.grid.callEvent("onHeaderClick", [
					el._cellIndexS,
				(e||window.event)
			])))
			return false;
			//#sorting:06042008{				
			that.sortField(el._cellIndexS, false, el)
			//#}
		}
		this.grid.resized = null;
	}
	
	/**
	*   @desc: deletes selected row(s)
	*   @type: public
	*   @topic: 2
	*/
	this.deleteSelectedRows=function(){
		var num = this.selectedRows.length //this.obj.rows.length
		
		if (num == 0)
			return;
		
		var tmpAr = this.selectedRows;
		this.selectedRows=dhtmlxArray()
		for (var i = num-1; i >= 0; i--){
			var node = tmpAr[i]
			
			if (!this.deleteRow(node.idd, node)){
				this.selectedRows[this.selectedRows.length]=node;
			}
			else {
				if (node == this.row){
					var ind = i;
				}
			}
			/*
			this.rowsAr[node.idd] = null;
			var posInCol = this.rowsCol._dhx_find(node)
			this.rowsCol[posInCol].parentNode.removeChild(this.rowsCol[posInCol]);//nb:this.rowsCol[posInCol].removeNode(true);
			this.rowsCol._dhx_removeAt(posInCol)*/
		}
		
		if (ind){
			try{
				if (ind+1 > this.rowsCol.length) //this.obj.rows.length)
					ind--;
				this.selectCell(ind, 0, true)
			}
			catch (er){
				this.row=null
				this.cell=null
			}
		}
	}
	
	/**
	*   @desc: gets selected row id
	*   @returns: id of selected row (list of ids with default delimiter) or null if non row selected
	*   @type: public
	*   @topic: 1,2,9
	*/
	this.getSelectedRowId=function(){
		var selAr = new Array(0);
		var uni = {
		};
		
		for (var i = 0; i < this.selectedRows.length; i++){
			var id = this.selectedRows[i].idd;
			
			if (uni[id])
				continue;
			
			selAr[selAr.length]=id;
			uni[id]=true;
		}
		
		//..
		if (selAr.length == 0)
			return null;
		else
			return selAr.join(this.delim);
	}
	
	/**
	*   @desc: gets index of selected cell
	*   @returns: index of selected cell or -1 if there is no selected sell
	*   @type: public
	*   @topic: 1,4
	*/
	this.getSelectedCellIndex=function(){
		if (this.cell != null)
			return this.cell._cellIndex;
		else
			return -1;
	}
	/**
	*   @desc: gets width of specified column in pixels
	*   @param: ind - column index
	*   @returns: column width in pixels
	*   @type: public
	*   @topic: 3,7
	*/
	this.getColWidth=function(ind){
		return parseInt(this.cellWidthPX[ind]);
	}
	
	/**
	*   @desc: sets width of specified column in pixels (soen't works with procent based grid)
	*   @param: ind - column index
	*   @param: value - new width value
	*   @type: public
	*   @topic: 3,7
	*/
	this.setColWidth=function(ind, value){
		if (value == "*")
			this.initCellWidth[ind] = "*";
		else {
			if (this._hrrar[ind]) return; //hidden
			if (this.cellWidthType == 'px')
				this.cellWidthPX[ind]=parseInt(value);
			else
				this.cellWidthPC[ind]=parseInt(value);
		}
		this.setSizes();
	}
	/**
	*   @desc: gets row index by id (grid only)
	*   @param: row_id - row id
	*   @returns: row index or -1 if there is no row with specified id
	*   @type: public
	*   @topic: 2
	*/
	this.getRowIndex=function(row_id){
		for (var i = 0; i < this.rowsBuffer.length; i++)
			if (this.rowsBuffer[i]&&this.rowsBuffer[i].idd == row_id)
			return i;
		return -1;
	}
	/**
	*   @desc: gets row id by index
	*   @param: ind - row index
	*   @returns: row id or null if there is no row with specified index
	*   @type: public
	*   @topic: 2
	*/
	this.getRowId=function(ind){
		return this.rowsBuffer[ind] ? this.rowsBuffer[ind].idd : this.undefined;
	}
	/**
	*   @desc: sets new id for row by its index
	*   @param: ind - row index
	*   @param: row_id - new row id
	*   @type: public
	*   @topic: 2
	*/
	this.setRowId=function(ind, row_id){
		this.changeRowId(this.getRowId(ind), row_id)
	}
	/**
	*   @desc: changes id of the row to the new one
	*   @param: oldRowId - row id to change
	*   @param: newRowId - row id to set
	*   @type:public
	*   @topic: 2
	*/
	this.changeRowId=function(oldRowId, newRowId){
		if (oldRowId == newRowId)
			return;
		/*
		for (var i=0; i<row.childNodes.length; i++)
		if (row.childNodes[i]._code)
		this._compileSCL("-",row.childNodes[i]);      */
		var row = this.rowsAr[oldRowId]
		row.idd=newRowId;
		
		if (this.UserData[oldRowId]){
			this.UserData[newRowId]=this.UserData[oldRowId]
			this.UserData[oldRowId]=null;
		}
		
		if (this._h2&&this._h2.get[oldRowId]){
			this._h2.get[newRowId]=this._h2.get[oldRowId];
			this._h2.get[newRowId].id=newRowId;
			delete this._h2.get[oldRowId];
		}
		
		this.rowsAr[oldRowId]=null;
		this.rowsAr[newRowId]=row;
		
		for (var i = 0; i < row.childNodes.length; i++)
			if (row.childNodes[i]._code)
			row.childNodes[i]._code=this._compileSCL(row.childNodes[i]._val, row.childNodes[i]);
		
		if (this._mat_links && this._mat_links[oldRowId]){
			var a=this._mat_links[oldRowId];
			delete this._mat_links[oldRowId];
			for (var c in a)
				for (var i=0; i < a[c].length; i++)
				this._compileSCL(a[c][i].original,a[c][i]);
		}
		
		this.callEvent("onRowIdChange",[oldRowId,newRowId]);
	}
	/**
	*   @desc: sets ids to every column. Can be used then to retreive the index of the desired colum
	*   @param: [ids] - delimitered list of ids (default delimiter is ","), or empty if to use values set earlier
	*   @type: public
	*   @topic: 3
	*/
	this.setColumnIds=function(ids){
		this.columnIds=ids.split(this.delim)
	}
	/**
	*   @desc: sets ids to specified column.
	*   @param: ind- index of column
	*   @param: id- id of column
	*   @type: public
	*   @topic: 3
	*/
	this.setColumnId=function(ind, id){
		this.columnIds[ind]=id;
	}
	/**
	*   @desc: gets column index by column id
	*   @param: id - column id
	*   @returns: index of the column
	*   @type: public
	*   @topic: 3
	*/
	this.getColIndexById=function(id){
		for (var i = 0; i < this.columnIds.length; i++)
			if (this.columnIds[i] == id)
			return i;
	}
	/**
	*   @desc: gets column id of column specified by index
	*   @param: cin - column index
	*   @returns: column id
	*   @type: public
	*   @topic: 3
	*/
	this.getColumnId=function(cin){
		return this.columnIds[cin];
	}
	
	/**
	*   @desc: gets label of column specified by index
	*   @param: cin - column index
	*   @returns: column label
	*   @type: public
	*   @topic: 3
	*/
	this.getColumnLabel=function(cin, ind, hdr, raw){
		var z = (hdr||this.hdr).rows[(ind||0)+1];
		for (var i=0; i<z.cells.length; i++)
			if (z.cells[i]._cellIndexS==cin) return raw ? z.cells[i].firstChild.innerHTML : (_isIE ? z.cells[i].innerText : z.cells[i].textContent);
		return "";
	};
	this.getColLabel = this.getColumnLabel;
	/**
	*   @desc: gets label of footer specified by index
	*   @param: cin - column index
	*   @returns: column label
	*   @type: public
	*   @topic: 3
	*/
	this.getFooterLabel=function(cin, ind, raw){
		return this.getColumnLabel(cin,ind,this.ftr, raw);
	}
	
	
	/**
	*   @desc: sets row text BOLD
	*   @param: row_id - row id
	*   @type: public
	*   @topic: 2,6
	*/
	this.setRowTextBold=function(row_id){
		var r=this.getRowById(row_id)
		if (r) r.style.fontWeight="bold";
	}
	/**
	*   @desc: sets style to row
	*   @param: row_id - row id
	*   @param: styleString - style string in common format (exmpl: "color:red;border:1px solid gray;")
	*   @type: public
	*   @topic: 2,6
	*/
	this.setRowTextStyle=function(row_id, styleString){
		var r = this.getRowById(row_id)
		if (!r) return;
		for (var i = 0; i < r.childNodes.length; i++){
			var pfix = r.childNodes[i]._attrs["style"]||"";
			//#__pro_feature:21092006{
			//#column_hidden:21092006{
			if ((this._hrrar)&&(this._hrrar[i]))
				pfix="display:none;";
			//#}
			//#}
			if (_isIE)
				r.childNodes[i].style.cssText=pfix+"width:"+r.childNodes[i].style.width+";"+styleString;
			else
				r.childNodes[i].style.cssText=pfix+"width:"+r.childNodes[i].style.width+";"+styleString;
		}
	}
	/**
	*   @desc: sets background color of row (via bgcolor attribute)
	*   @param: row_id - row id
	*   @param: color - color value
	*   @type: public
	*   @topic: 2,6
	*/
	this.setRowColor=function(row_id, color){
		var r = this.getRowById(row_id)
		
		for (var i = 0; i < r.childNodes.length; i++)r.childNodes[i].bgColor=color;
	}
	/**
	*   @desc: sets style to cell
	*   @param: row_id - row id
	*   @param: ind - cell index
	*   @param: styleString - style string in common format (exmpl: "color:red;border:1px solid gray;")
	*   @type: public
	*   @topic: 2,6
	*/
	this.setCellTextStyle=function(row_id, ind, styleString){
		var r = this.getRowById(row_id)
		
		if (!r)
			return;
		
		var cell = r.childNodes[r._childIndexes ? r._childIndexes[ind] : ind];
		
		if (!cell)
			return;
		var pfix = "";
		//#__pro_feature:21092006{
		//#column_hidden:21092006{
		if ((this._hrrar)&&(this._hrrar[ind]))
			pfix="display:none;";
		//#}
		//#}
		if (_isIE)
			cell.style.cssText=pfix+"width:"+cell.style.width+";"+styleString;
		else
			cell.style.cssText=pfix+"width:"+cell.style.width+";"+styleString;
	}
	
	/**
	*   @desc: sets row text weight to normal
	*   @param: row_id - row id
	*   @type: public
	*   @topic: 2,6
	*/
	this.setRowTextNormal=function(row_id){
		var r=this.getRowById(row_id);
		if (r) r.style.fontWeight="normal";
	}
	/**
	*   @desc: determines if row with specified id exists
	*   @param: row_id - row id
	*   @returns: true if exists, false otherwise
	*   @type: public
	*   @topic: 2,7
	*/
	this.doesRowExist=function(row_id){
		if (this.getRowById(row_id) != null)
			return true
		else
			return false
	}
	
	
	
	/**
	*   @desc: gets number of columns in grid
	*   @returns: number of columns in grid
	*   @type: public
	*   @topic: 3,7
	*/
	this.getColumnsNum=function(){
		return this._cCount;
	}
	
	
	//#moving_rows:06042008{
	/**
	*   @desc: moves row one position up if possible
	*   @param: row_id -  row id
	*   @type: public
	*   @topic: 2
	*/
	this.moveRowUp=function(row_id){
		var r = this.getRowById(row_id)
		
		if (this.isTreeGrid())
			return this.moveRowUDTG(row_id, -1);
		
		var rInd = this.rowsCol._dhx_find(r)
		if ((r.previousSibling)&&(rInd != 0)){
			r.parentNode.insertBefore(r, r.previousSibling)
			this.rowsCol._dhx_swapItems(rInd, rInd-1)
			this.setSizes();
			var bInd=this.rowsBuffer._dhx_find(r);
			this.rowsBuffer._dhx_swapItems(bInd,bInd-1);
			
			if (this._cssEven)
				this._fixAlterCss(rInd-1);
		}
	}
	/**
	*   @desc: moves row one position down if possible
	*   @param: row_id -  row id
	*   @type: public
	*   @topic: 2
	*/
	this.moveRowDown=function(row_id){
		var r = this.getRowById(row_id)
		
		if (this.isTreeGrid())
			return this.moveRowUDTG(row_id, 1);
		
		var rInd = this.rowsCol._dhx_find(r);
		if (r.nextSibling){ 
			this.rowsCol._dhx_swapItems(rInd, rInd+1)
			
			if (r.nextSibling.nextSibling)
				r.parentNode.insertBefore(r, r.nextSibling.nextSibling)
			else
				r.parentNode.appendChild(r)
			this.setSizes();
			
			var bInd=this.rowsBuffer._dhx_find(r);
			this.rowsBuffer._dhx_swapItems(bInd,bInd+1);
			
			if (this._cssEven)
				this._fixAlterCss(rInd);
		}
	}
	//#}
	//#co_excell:06042008{
	/**
	* @desc: gets Combo object of specified column. Use it to change select box value for cell before editor opened
	*   @type: public
	*   @topic: 3,4
	*   @param: col_ind - index of the column to get combo object for
	*/
	this.getCombo=function(col_ind){
		if (!this.combos[col_ind]){
			this.combos[col_ind]=new dhtmlXGridComboObject();
		}
		return this.combos[col_ind];
	}
	//#}
	/**
	*   @desc: sets user data to row
	*   @param: row_id -  row id. if empty then user data is set for grid (not row)
	*   @param: name -  name of user data block
	*   @param: value -  value of user data block
	*   @type: public
	*   @topic: 2,5
	*/
	this.setUserData=function(row_id, name, value){
		if (!row_id)
			row_id="gridglobaluserdata";
		
		if (!this.UserData[row_id])
			this.UserData[row_id]=new Hashtable()
		this.UserData[row_id].put(name, value)
	}
	/**
	*   @desc: gets user Data
	*   @param: row_id -  row id. if empty then user data is for grid (not row)
	*   @param: name -  name of user data
	*   @returns: value of user data
	*   @type: public
	*   @topic: 2,5
	*/
	this.getUserData=function(row_id, name){
		if (!row_id)
			row_id="gridglobaluserdata";		
		this.getRowById(row_id); //parse row if necessary
		
		var z = this.UserData[row_id];
		return (z ? z.get(name) : "");
	}
	
	/**
	*   @desc: manage editibility of the grid
	*   @param: [fl] - set not editable if FALSE, set editable otherwise
	*   @type: public
	*   @topic: 7
	*/
	this.setEditable=function(fl){
		this.isEditable=dhx4.s2b(fl);
	}
	/**
	*   @desc: selects row by ID
	*   @param: row_id - row id
	*   @param: multiFL - VOID. select multiple rows
	*   @param: show - true/false - scroll row to view, true by defaul    
	*   @param: call - true to call function on select
	*   @type: public
	*   @topic: 1,2
	*/
	this.selectRowById=function(row_id, multiFL, show, call){
		if (!call)
			call=false;
		this.selectCell(this.getRowById(row_id), 0, call, multiFL, false, show);
	}
	
	/**
	*   @desc: removes selection from the grid
	*   @type: public
	*   @topic: 1,9
	*/
	this.clearSelection=function(){
		this.editStop()
		
		for (var i = 0; i < this.selectedRows.length; i++){
			var r = this.rowsAr[this.selectedRows[i].idd];
			
			if (r)
				r.className=r.className.replace(/rowselected/g, "");
		}
		
		//..
		this.selectedRows=dhtmlxArray()
		this.row=null;
		
		if (this.cell != null){
			this.cell.className=this.cell.className.replace(/cellselected/g, "");
			this.cell=null;
		}
		
		this.callEvent("onSelectionCleared",[]);
	}
	/**
	*   @desc: copies row content to another existing row
	*   @param: from_row_id - id of the row to copy content from
	*   @param: to_row_id - id of the row to copy content to
	*   @type: public
	*   @topic: 2,5
	*/
	this.copyRowContent=function(from_row_id, to_row_id){
		var frRow = this.getRowById(from_row_id)
		
		if (!this.isTreeGrid())
		for (var i = 0; i < frRow.cells.length; i++){
			this.cells(to_row_id, i).setValue(this.cells(from_row_id, i).getValue())
		}
		else
			this._copyTreeGridRowContent(frRow, from_row_id, to_row_id);
		
		//for Mozilla (to avaoid visual glitches)
		if (!_isIE)
			this.getRowById(from_row_id).cells[0].height=frRow.cells[0].offsetHeight
	}
	/**
	*   @desc: sets new label for cell in footer
	*   @param: col - header column index
	*   @param: label - new label for the cpecified footer's column. Can contai img:[imageUrl]Text Label
	*	@param: ind - header row index 
	*   @type: public
	*   @topic: 3,6
	*/
	this.setFooterLabel=function(c, label, ind){
		return this.setColumnLabel(c,label,ind,this.ftr);
	};
	/**
	*   @desc: sets new column header label
	*   @param: col - header column index
	*   @param: label - new label for the cpecified header's column. Can contai img:[imageUrl]Text Label
	*	@param: ind - header row index 
	*   @type: public
	*   @topic: 3,6
	*/
	this.setColumnLabel=function(c, label, ind, hdr){
		var z = (hdr||this.hdr).rows[ind||1];
		var col = (z._childIndexes ? z._childIndexes[c] : c);
		if (!z.cells[col]) return;
		if (!this.useImagesInHeader){
			var hdrHTML = "<div class='hdrcell'>"
			
			if (label.indexOf('img:[') != -1){
				var imUrl = label.replace(/.*\[([^>]+)\].*/, "$1");
				label=label.substr(label.indexOf("]")+1, label.length)
				hdrHTML+="<img width='18px' height='18px' align='absmiddle' src='"+imUrl+"' hspace='2'>"
			}
			hdrHTML+=label;
			hdrHTML+="</div>";
			z.cells[col].innerHTML=hdrHTML;
			
			if (this._hstyles[c])
				z.cells[col].style.cssText=this._hstyles[c];
		} else { //if images in header header
			z.cells[col].style.textAlign="left";
			z.cells[col].innerHTML="<img src='"+label+"'>";
			//preload sorting headers (asc/desc)
			var a = new Image();
			a.src=""+label.replace(/(\.[a-z]+)/, ".des$1");
			this.preloadImagesAr[this.preloadImagesAr.length]=a;
			var b = new Image();
			b.src=""+label.replace(/(\.[a-z]+)/, ".asc$1");
			this.preloadImagesAr[this.preloadImagesAr.length]=b;
		}
		
		if ((label||"").indexOf("#") != -1){
			var t = label.match(/(^|{)#([^}]+)(}|$)/);
			
			if (t){
				var tn = "_in_header_"+t[2];
				
				if (this[tn])
					this[tn]((this.forceDivInHeader ? z.cells[col].firstChild : z.cells[col]), col, label.split(t[0]));
			}
		}
	};
	this.setColLabel = function(a,b,ind,c){
		return this.setColumnLabel(a,b,(ind||0)+1,c);
	};
	/**
	*   @desc: deletes all rows in grid
	*   @param: header - (boolean) enable/disable cleaning header
	*   @type: public
	*   @topic: 5,7,9
	*/
	this.clearAll=function(header){
		if (!this.obj.rows[0]) return; //call before initilization
		if (this._h2){
			this._h2=this._createHierarchy();
			
			if (this._fake){
				if (this._realfake)
					this._h2=this._fake._h2;
				else
					this._fake._h2=this._h2;
			}
		}
		
		this.limit=this._limitC=0;
		this.editStop(true);
		
		if (this._dLoadTimer)
			window.clearTimeout(this._dLoadTimer);
		
		if (this._dload){
			this.objBox.scrollTop=0;
			this.limit=this._limitC||0;
			this._initDrF=true;
		}
		
		var len = this.rowsCol.length;
		
		//for some case
		len=this.obj.rows.length;
		
		for (var i = len-1; i > 0; i--){
			var t_r = this.obj.rows[i];
			t_r.parentNode.removeChild(t_r);
		}
		
		if (header){
			this._master_row=null;
			this.obj.rows[0].parentNode.removeChild(this.obj.rows[0]);
			
			for (var i = this.hdr.rows.length-1; i >= 0; i--){
				var t_r = this.hdr.rows[i];
				t_r.parentNode.removeChild(t_r);
			}
			
			if (this.ftr){
				this.ftr.parentNode.removeChild(this.ftr);
				this.ftr=null;
			}
			this._aHead=this.ftr=this.cellWidth=this._aFoot=null;
			this.cellType=dhtmlxArray();
			this._hrrar=[];
			this.columnIds=[];
			this.combos=[];
			this._strangeParams=[];
			this.defVal = [];
			this._ivizcol = null;
		}
		
		//..
		this.row=null;
		this.cell=null;
		
		this.rowsCol=dhtmlxArray()
		this.rowsAr={}; //array of rows by idd
		this._RaSeCol=[];
		this.rowsBuffer=dhtmlxArray()
		this.UserData=[]
		this.selectedRows=dhtmlxArray();
		
		if (this.pagingOn || this._srnd)
			this.xmlFileUrl="";
		if (this.pagingOn)
			this.changePage(1);
		
		//  if (!this._fake){
		/*
		if ((this._hideShowColumn)&&(this.hdr.rows[0]))
		for (var i=0; i<this.hdr.rows[0].cells.length; i++)
		this._hideShowColumn(i,"");
		this._hrrar=new Array();*/
		//}
		if (this._contextCallTimer)
			window.clearTimeout(this._contextCallTimer);
		
		if (this._sst)
			this.enableStableSorting(true);
		this._fillers=this.undefined;
		this.setSortImgState(false);
		this.setSizes();
		//this.obj.scrollTop = 0;
		
		this.callEvent("onClearAll", []);
	}
	
	//#sorting:06042008{
	/**
	*   @desc: sorts grid by specified field
	*    @invoke: header click
	*   @param: [ind] - index of the field
	*   @param: [repeatFl] - if to repeat last sorting
	*   @type: private
	*   @topic: 3
	*/
	this.sortField=function(ind, repeatFl, r_el){
		if (this.getRowsNum() == 0)
			return false;
		
		var el = this.hdr.rows[0].cells[ind];
		
		if (!el)
			return; //somehow
		// if (this._dload  && !this.callEvent("onBeforeSorting",[ind,this]) ) return true;
		
		if (el.tagName == "TH"&&(this.fldSort.length-1) >= el._cellIndex
			&&this.fldSort[el._cellIndex] != 'na'){ //this.entBox.fieldstosort!="" &&
		var data=this.getSortingState();
		var sortType= ( data[0]==ind && data[1]=="asc" ) ? "des" : "asc";
		
		if (!this.callEvent("onBeforeSorting", [
				ind,
			this.fldSort[ind],
			sortType
		]))
		return;
		this.sortImg.className="dhxgrid_sort_"+(sortType == "asc" ? "asc" : "desc");
		
		//for header images
		if (this.useImagesInHeader){
			var cel = this.hdr.rows[1].cells[el._cellIndex].firstChild;
			
			if (this.fldSorted != null){
				var celT = this.hdr.rows[1].cells[this.fldSorted._cellIndex].firstChild;
				celT.src=celT.src.replace(/(\.asc\.)|(\.des\.)/, ".");
			}
			cel.src=cel.src.replace(/(\.[a-z]+)$/, "."+sortType+"$1")
		}
		//.
		this.sortRows(el._cellIndex, this.fldSort[el._cellIndex], sortType)
		this.fldSorted=el;
		if (r_el && r_el.tagName.toLowerCase() != "th")
			this.r_fldSorted=r_el;

		var c = this.hdr.rows[1];
		var c = r_el.parentNode;
		var real_el = c._childIndexes ? c._childIndexes[el._cellIndex] : el._cellIndex;
		this.setSortImgPos(false, false, false, r_el);
			}
	}
	//#__pro_feature:21092006{
	//#custom_sort:21092006{
	/**
	*   @desc: set custom sorting (custom sort has three params - valueA,valueB,order; where order can be asc or des)
	*   @param: func - function to use for comparison
	*   @param:   col - index of column to apply custom sorting to
	*   @type: public
	*   @edition: Professional
	*   @topic: 3
	*/
	this.setCustomSorting=function(func, col){
		if (!this._customSorts)
			this._customSorts=new Array();
		this._customSorts[col]=( typeof (func) == "string") ? eval(func) : func;
		this.fldSort[col]="cus";
	}
	//#}
	//#}
	//#}
	/**
	*   @desc: specify if values passed to Header are images file names
	*   @param: fl - true to treat column header values as image names
	*   @type: public
	*   @before_init: 1
	*   @topic: 0,3
	*/
	this.enableHeaderImages=function(fl){
		this.useImagesInHeader=fl;
	}
	
	/**
	*   @desc: set header label and default params for new headers
	*   @param: hdrStr - header string with delimiters
	*   @param: splitSign - string used as a split marker, optional. Default is "#cspan"
	*   @param: styles - array of header styles
	*   @type: public
	*   @before_init: 1
	*   @topic: 0,3
	*/
	this.setHeader=function(hdrStr, splitSign, styles){
		if (typeof (hdrStr) != "object")
			var arLab = this._eSplit(hdrStr);
		else
			arLab=[].concat(hdrStr);
		
		var arWdth = new Array(0);
		var arTyp = new dhtmlxArray(0);
		var arAlg = new Array(0);
		var arVAlg = new Array(0);
		var arSrt = new Array(0);
		
		for (var i = 0; i < arLab.length; i++){
			arWdth[arWdth.length]=Math.round(100 / arLab.length);
			arTyp[arTyp.length]="ed";
			arAlg[arAlg.length]="left";
			arVAlg[arVAlg.length]="middle"; //top
			arSrt[arSrt.length]="na";
		}
		
		this.splitSign=splitSign||"#cspan";
		this.hdrLabels=arLab;
		this.cellWidth=arWdth;
		if (!this.initCellWidth.length) this.setInitWidthsP(arWdth.join(this.delim),true);
		this.cellType=arTyp;
		this.cellAlign=arAlg;
		this.cellVAlign=arVAlg;
		this.fldSort=arSrt;
		this._hstyles=styles||[];
	}
	/**
	*   @desc: 
	*   @param: str - ...
	*   @type: private
	*/
	this._eSplit=function(str){
		if (![].push)
			return str.split(this.delim);
		
		var a = "r"+(new Date()).valueOf();
		var z = this.delim.replace(/([\|\+\*\^])/g, "\\$1")
		return (str||"").replace(RegExp(z, "g"), a).replace(RegExp("\\\\"+a, "g"), this.delim).split(a);
	}
	
	/**
	*   @desc: get column type by column index
	*   @param: cInd - column index
	*   @returns:  type code
	*   @type: public
	*   @topic: 0,3,4
	*/
	this.getColType=function(cInd){
		return this.cellType[cInd];
	}
	
	/**
	*   @desc: get column type by column ID
	*   @param: cID - column id
	*   @returns:  type code
	*   @type: public
	*   @topic: 0,3,4
	*/
	this.getColTypeById=function(cID){
		return this.cellType[this.getColIndexById(cID)];
	}
	
	/**
	*   @desc: set column types
	*   @param: typeStr - type codes list (default delimiter is ",")
	*   @before_init: 2
	*   @type: public
	*   @topic: 0,3,4
	*/
	this.setColTypes=function(typeStr){
		this.cellType=dhtmlxArray(typeStr.split(this.delim));
		this._strangeParams=new Array();
		
		for (var i = 0; i < this.cellType.length; i++){
			if ((this.cellType[i].indexOf("[") != -1)){
				var z = this.cellType[i].split(/[\[\]]+/g);
				this.cellType[i]=z[0];
				this.defVal[i]=z[1];
				
				if (z[1].indexOf("=") == 0){
					this.cellType[i]="math";
					this._strangeParams[i]=z[0];
				}
			}
			if (!window["eXcell_"+this.cellType[i]]) dhx4.callEvent("onConfigurationError",["Incorrect cell type: "+this.cellType[i],this,this.cellType[i]]);
		}
	}
	/**
	*   @desc: set column sort types (avaialble: str, int, date, na or function object for custom sorting)
	*   @param: sortStr - sort codes list with default delimiter
	*   @before_init: 1
	*   @type: public
	*   @topic: 0,3,4
	*/
	this.setColSorting=function(sortStr){
		this.fldSort=sortStr.split(this.delim)
		//#__pro_feature:21092006{
		//#custom_sort:21092006{
		//str, int, date
		var check = {str:1, "int":1, date:1};
		for (var i = 0; i < this.fldSort.length; i++)
		if ((!check[this.fldSort[i]])&&( typeof (window[this.fldSort[i]]) == "function")){
			if (!this._customSorts)
				this._customSorts=new Array();
			this._customSorts[i]=window[this.fldSort[i]];
			this.fldSort[i]="cus";
		}
		//#}
		//#}
	}
	/**
	*   @desc: set align of values in columns
	*   @param: alStr - list of align values (possible values are: right,left,center,justify). Default delimiter is ","
	*   @before_init: 1
	*   @type: public
	*   @topic: 0,3
	*/
	this.setColAlign=function(alStr){
		this.cellAlign=alStr.split(this.delim)
		for (var i=0; i < this.cellAlign.length; i++)
			this.cellAlign[i]=this.cellAlign[i]._dhx_trim();
	}
	/**
	*   @desc: set vertical align of columns
	*   @param: valStr - vertical align values list for columns (possible values are: baseline,sub,super,top,text-top,middle,bottom,text-bottom)
	*   @before_init: 1
	*   @type: public
	*   @topic: 0,3
	*/
	this.setColVAlign=function(valStr){
		this.cellVAlign=valStr.split(this.delim)
	}
	
	/**
	* 	@desc: create grid with no header. Call before initialization, but after setHeader. setHeader have to be called in any way as it defines number of columns
	*   @param: fl - true to use no header in the grid
	*   @type: public
	*   @before_init: 1
	*   @topic: 0,7
	*/
	this.setNoHeader=function(fl){
		this.noHeader=dhx4.s2b(fl);
	}
	/**
	*   @desc: scrolls row to the visible area
	*   @param: rowID - row id
	*   @type: public
	*   @topic: 2,7
	*/
	this.showRow=function(rowID){
		this.getRowById(rowID)
		
		if (this._h2) this.openItem(this._h2.get[rowID].parent.id);
		var c = this.getRowById(rowID).childNodes[0];
		
		while (c&&c.style.display == "none")
			c=c.nextSibling;
		
		if (c)
			this.moveToVisible(c, true)
	}
	
	/**
	*   @desc: modify default style of grid and its elements. Call before or after Init
	*   @param: ss_header - style def. expression for header
	*   @param: ss_grid - style def. expression for grid cells
	*   @param: ss_selCell - style def. expression for selected cell
	*   @param: ss_selRow - style def. expression for selected Row
	*   @type: public
	*   @before_init: 2
	*   @topic: 0,6
	*/
	this.setStyle=function(ss_header, ss_grid, ss_selCell, ss_selRow){
		this.ssModifier=[
			ss_header,
			ss_grid,
			ss_selCell,
			ss_selCell,
			ss_selRow
		];
		
		var prefs = ["#"+this.entBox.id+" table.hdr td", "#"+this.entBox.id+" table.obj td",
			"#"+this.entBox.id+" table.obj tr.rowselected td.cellselected",
		"#"+this.entBox.id+" table.obj td.cellselected", "#"+this.entBox.id+" table.obj tr.rowselected td"];
		
		var index = 0;
		while (!_isIE){
			try{
				var temp = document.styleSheets[index].cssRules.length;
			} catch(e) { index++; continue; }
			break;
		}
		
		for (var i = 0; i < prefs.length; i++)
		if (this.ssModifier[i]){
			if (_isIE)
				document.styleSheets[0].addRule(prefs[i], this.ssModifier[i]);
			else
				document.styleSheets[index].insertRule(prefs[i]+(" { "+this.ssModifier[i]+" }"), document.styleSheets[index].cssRules.length);
		}
	}
	/**
	*   @desc: colorize columns  background.
	*   @param: clr - colors list
	*   @type: public
	*   @before_init: 1
	*   @topic: 3,6
	*/
	this.setColumnColor=function(clr){
		this.columnColor=clr.split(this.delim)
	}
	//#alter_css:06042008{
	/**
	*   @desc: set even/odd css styles
	*   @param: cssE - name of css class for even rows
	*   @param: cssU - name of css class for odd rows
	*   @param: perLevel - true/false - mark rows not by order, but by level in treegrid
	*   @param: levelUnique - true/false - creates additional unique css class based on row level
	*   @type: public
	*   @before_init: 1
	*   @topic: 3,6
	*/
	this.enableAlterCss=function(cssE, cssU, perLevel, levelUnique){
		if (cssE||cssU)
		this.attachEvent("onGridReconstructed",function(){
				this._fixAlterCss();
				if (this._fake)
					this._fake._fixAlterCss();
		});
		
		this._cssSP=perLevel;
		this._cssSU=levelUnique;
		this._cssEven=cssE;
		this._cssUnEven=cssU;
	}
	//#}
	/**
	*   @desc: recolor grid from defined point
	*   @type: private
	*   @before_init: 1
	*   @topic: 3,6
	*/
	this._fixAlterCss=function(ind){
		//#alter_css:06042008{		
		if (this._h2 && (this._cssSP || this._cssSU))
			return this._fixAlterCssTGR(ind);
		if (!this._cssEven && !this._cssUnEven) return;
		ind=ind||0;
		var j = ind;
		
		for (var i = ind; i < this.rowsCol.length; i++){
			if (!this.rowsCol[i])
				continue;
			
			if (this.rowsCol[i].style.display != "none"){
				if (this.rowsCol[i]._cntr) { j=1; continue; }
				if (this.rowsCol[i].className.indexOf("rowselected") != -1){
					if (j%2 == 1)
						this.rowsCol[i].className=this._cssUnEven+" rowselected "+(this.rowsCol[i]._css||"");
					else
						this.rowsCol[i].className=this._cssEven+" rowselected "+(this.rowsCol[i]._css||"");
				} else {
					if (j%2 == 1)
						this.rowsCol[i].className=this._cssUnEven+" "+(this.rowsCol[i]._css||"");
					else
						this.rowsCol[i].className=this._cssEven+" "+(this.rowsCol[i]._css||"");
				}
				j++;
			}
		}
		//#}		
	}
	//#__pro_feature:21092006{
	/**
	*     @desc: clear wasChanged state for all cells in grid
	*     @type: public
	*     @edition: Professional
	*     @topic: 7
	*/
	this.clearChangedState=function(){
		for (var i = 0; i < this.rowsCol.length; i++){
			var row = this.rowsCol[i];
			if (row && row.childNodes){
				var cols = row.childNodes.length;
				for (var j = 0; j < cols; j++)row.childNodes[j].wasChanged=false;
			}
		}
	};
	
	/**
	*     @desc: get list of IDs of changed rows
	*     @type: public
	*     @edition: Professional
	*     @return: list of ID of changed rows
	*     @topic: 7
	*/
	this.getChangedRows=function(and_added){
		var res = new Array();
		this.forEachRow(function(id){
				var row = this.rowsAr[id];
				if (row.tagName!="TR") return; 
				var cols = row.childNodes.length;
				if (and_added && row._added)
					res[res.length]=row.idd;
				else
					for (var j = 0; j < cols; j++)
					if (row.childNodes[j].wasChanged){
						res[res.length]=row.idd;
						break;
					}
		})
		return res.join(this.delim);
	};
	
	
	//#serialization:21092006{
	
	this._sUDa=false;
	this._sAll=false;
	
	/**
	*     @desc: configure XML serialization
	*     @type: public
	*     @edition: Professional
	*     @param: userData - enable/disable user data serialization
	*     @param: fullXML - enable/disable full XML serialization (selection state)
	*     @param: config - serialize grid configuration
	*     @param: changedAttr - include changed attribute
	*     @param: onlyChanged - include only Changed  rows in result XML
	*     @param: asCDATA - output cell values as CDATA sections (prevent invalid XML)
	*     @topic: 0,5,7
	*/
	this.setSerializationLevel=function(userData, fullXML, config, changedAttr, onlyChanged, asCDATA){
		this._sUDa=userData;
		this._sAll=fullXML;
		this._sConfig=config;
		this._chAttr=changedAttr;
		this._onlChAttr=onlyChanged;
		this._asCDATA=asCDATA;
	}
	
	
	/**
	*     @desc: configure which column must be serialized (if you do not use this method, then all columns will be serialized)
	*     @type: public
	*     @edition: Professional
	*     @param: list - list of true/false values separated by comma, if list empty then all fields will be serialized
	*     @topic: 0,5,7
	*/
	this.setSerializableColumns=function(list){
		if (!list){
			this._srClmn=null;
			return;
		}
		this._srClmn=(list||"").split(",");
		
		for (var i = 0; i < this._srClmn.length; i++)this._srClmn[i]=dhx4.s2b(this._srClmn[i]);
	}
	
	/**
	*     @desc: serialize a collection of rows
	*     @type: private
	*     @topic: 0,5,7
	*/
	this._serialise=function(rCol, inner, closed){
		this.editStop()
		var out = [];
		//rows collection
		var close = "</"+this.xml.s_row+">"
		
		if (this.isTreeGrid()){
			this._h2.forEachChildF(0, function(el){
					var temp = this._serializeRow(this.render_row_tree(-1, el.id));
					out.push(temp);
					
					if (temp)
						return true;
					else
						return false;
			}, this, function(){
				out.push(close);
			});
		}
		else
			for (var i = 0; i < this.rowsBuffer.length; i++)
			if (this.rowsBuffer[i]){
				if (this._chAttr && this.rowsBuffer[i]._locator)
					continue;
				
				var temp = this._serializeRow(this.render_row(i));
				out.push(temp);
				
				if (temp)
					out.push(close);
			}
			
			return [out.join("")];
	}
	
	/**
	*   @desc: serialize TR or xml node to grid formated xml (row tag)
	*   @param: r - TR or xml node (row)
	*   @retruns: string - xml representation of passed row
	*   @type: private
	*/
	this._serializeRow=function(r, i){
		var out = [];
		var ra = this.xml.row_attrs;
		var ca = this.xml.cell_attrs;
		
		out.push("<"+this.xml.s_row);
		out.push(" id='"+r.idd+"'");
		
		if ((this._sAll)&&this.selectedRows._dhx_find(r) != -1)
			out.push(" selected='1'");
		
		if (this._h2&&this._h2.get[r.idd].state == "minus")
			out.push(" open='1'");
		
		if (ra.length)
			for (var i = 0; i < ra.length; i++)out.push(" "+ra[i]+"='"+r._attrs[ra[i]]+"'");
		out.push(">");
		
		//userdata
		if (this._sUDa&&this.UserData[r.idd]){
			keysAr=this.UserData[r.idd].getKeys()
			
			for (var ii = 0; ii < keysAr.length; ii++){
				var subkey = keysAr[ii];
				if (subkey.indexOf("__") !== 0)
					out.push("<userdata name='"+subkey+"'>"+(this._asCDATA?"<![CDATA[":"")+this.UserData[r.idd].get(subkey)+(this._asCDATA?"]]>":"")+"</userdata>");
			}
		}
		
		
		//cells
		var changeFl = false;
		
		for (var jj = 0; jj < this._cCount; jj++){
			if ((!this._srClmn)||(this._srClmn[jj])){
				var zx = this.cells3(r, jj);
				out.push("<cell");
				
				if (ca.length)
					for (var i = 0; i < ca.length; i++)out.push(" "+ca[i]+"='"+zx.cell._attrs[ca[i]]+"'");
				zxVal=zx[this._agetm]();
				
				if (this._asCDATA)
					zxVal="<![CDATA["+zxVal+"]]>";
				
				//#colspan:20092006{
				if ((this._ecspn)&&(zx.cell.colSpan)&&zx.cell.colSpan > 1)
					out.push(" colspan=\""+zx.cell.colSpan+"\" ");
				//#}
				
				if (this._chAttr){
					if (zx.wasChanged()){
						out.push(" changed=\"1\"");
						changeFl=true;
					}
				}
				
				else if ((this._onlChAttr)&&(zx.wasChanged()))
					changeFl=true;
				
				if (this._sAll && this.cellType[jj]=="tree")
					out.push((this._h2 ? (" image='"+this._h2.get[r.idd].image+"'") : "")+">"+zxVal+"</cell>");
				else
					out.push(">"+zxVal+"</cell>");
				
				//#colspan:20092006{
				if ((this._ecspn)&&(zx.cell.colSpan))
				for (var u = 0; u < zx.cell.colSpan-1; u++){
					out.push("<cell/>");
					jj++;
				}
				//#}
			}
		}
		
		if ((this._onlChAttr)&&(!changeFl)&&(!r._added))
			return "";
		
		return out.join("");
	}
	
	/**
	*     @desc: serialize grid configuration
	*     @type: private
	*     @topic: 0,5,7
	*/
	this._serialiseConfig=function(){
		var out = "<head>";
		
		for (var i = 0; i < this.hdr.rows[0].cells.length; i++){
			if (this._srClmn && !this._srClmn[i]) continue;
			var sort = this.fldSort[i];
			if (sort == "cus"){
				sort = this._customSorts[i].toString();
				sort=sort.replace(/function[\ ]*/,"").replace(/\([^\f]*/,"");
			}
			out+="<column width='"+this.getColWidth(i)+"' align='"+this.cellAlign[i]+"' type='"+this.cellType[i]
			+"' sort='"+(sort||"na")+"' color='"+(this.columnColor[i]||"")+"'"
			+(this.columnIds[i]
				? (" id='"+this.columnIds[i]+"'")
				: "")+">";
			if (this._asCDATA)
				out+="<![CDATA["+this.getColumnLabel(i)+"]]>";
			else
				out+=this.getColumnLabel(i);
			var z = this.getCombo(i);
			
			if (z)
				for (var j = 0; j < z.keys.length; j++)out+="<option value='"+z.keys[j]+"'>"+z.values[j]+"</option>";
			out+="</column>"
		}
		return out+="</head>";
	}
	/**
	*     @desc: get actual xml of grid. The depth of serialization can be set with setSerializationLevel method
	*     @type: public
	*     @edition: Professional
	*     @topic: 5,7
	*/
	this.serialize=function(){
		var out = '<?xml version="1.0"?><rows>';
		
		if (this._mathSerialization)
			this._agetm="getMathValue";
		else
			this._agetm="getValue";
		
		if (this._sUDa&&this.UserData["gridglobaluserdata"]){
			var keysAr = this.UserData["gridglobaluserdata"].getKeys()
			
			for (var i = 0;
				i < keysAr.length;
				i++)out+="<userdata name='"+keysAr[i]+"'>"+this.UserData["gridglobaluserdata"].get(keysAr[i])
				+"</userdata>";
		}
		
		if (this._sConfig)
			out+=this._serialiseConfig();
		out+=this._serialise();
		
		out+='</rows>';
		return out;
	}
	//#}
	//#}
	
	/**
	*    @desc: returns absolute left and top position of specified element
	*    @returns: array of two values: absolute Left and absolute Top positions
	*    @param: oNode - element to get position of
	*   @type: private
	*   @topic: 8
	*/
	this.getPosition=function(oNode, pNode){
		if (!pNode){
			var pos = dhx4.getOffset(oNode);
			return [pos.left, pos.top];
		}
		pNode = pNode||document.body;
		
		var oCurrentNode = oNode;
		var iLeft = 0;
		var iTop = 0;
		
		while ((oCurrentNode)&&(oCurrentNode != pNode)){ //.tagName!="BODY"){
			iLeft+=oCurrentNode.offsetLeft-oCurrentNode.scrollLeft;
			iTop+=oCurrentNode.offsetTop-oCurrentNode.scrollTop;
			oCurrentNode=oCurrentNode.offsetParent;
		}
		
		if (pNode == document.body){
			if (_isIE){
				iTop+=document.body.offsetTop||document.documentElement.offsetTop;
				iLeft+=document.body.offsetLeft||document.documentElement.offsetLeft;
			} else if (!_isFF){
				iLeft+=document.body.offsetLeft;
				iTop+=document.body.offsetTop;
			}
		}
		return [iLeft, iTop];
	}
	/**
	*   @desc: gets nearest parent of specified type
	*   @param: obj - input object
	*   @param: tag - string. tag to find as parent
	*   @returns: object. nearest paraent object (including spec. obj) of specified type.
	*   @type: private
	*   @topic: 8
	*/
	this.getFirstParentOfType=function(obj, tag){
		while (obj&&obj.tagName != tag&&obj.tagName != "BODY"){
			obj=obj.parentNode;
		}
		return obj;
	}
	
	
	
	/*INTERNAL EVENT HANDLERS*/
	this.objBox.onscroll=function(){
		this.grid._doOnScroll();
	};
	this.hdrBox.onscroll=function(){
		if (this._try_header_sync) return;
		this._try_header_sync = true;
		if (Math.abs(this.grid.objBox.scrollLeft - this.scrollLeft)>1){
			this.grid.objBox.scrollLeft = this.scrollLeft;
		}
		this._try_header_sync = false;
	}
	//#column_resize:06042008{
	if ((!_isOpera)||(_OperaRv > 8.5)){
		this.hdr.onmousemove=function(e){
			this.grid.changeCursorState(e||window.event);
		};
		this.hdr.onmousedown=function(e){
			return this.grid.startColResize(e||window.event);
		};		
	}
	//#}
	//#tooltips:06042008{
	this.obj.onmousemove=this._drawTooltip;
	//#}
	this.objBox.onclick=function(e){
		e = e||event;
		e.cancelBubble=true;
		this.firstChild.grid.setActive(true);
		window.dhx4.callEvent("_onGridClick", [e, this.firstChild.grid]);
	};
	this.obj.onclick=function(e){
		if (this.grid._doClick(e||window.event) !== false){
			if (this.grid._sclE) 
				this.grid.editCell(e||window.event); 
			else
				this.grid.editStop();
		}
		
		e = e||event;
		e.cancelBubble=true;
		window.dhx4.callEvent("_onGridClick", [e, this.grid]);
	};
	//#context_menu:06042008{
	if (_isMacOS){
		this.entBox.oncontextmenu=function(e){
			e.cancelBubble=true;
			if (e.preventDefault) e.preventDefault(); else e.returnValue=false;
			var that = this.grid; if (that._realfake) that = that._fake;
			return that._doContClick(e||window.event);
		};
	} else {
		this.entBox.onmousedown=function(e){
			return this.grid._doContClick(e||window.event);
		};
		this.entBox.oncontextmenu=function(e){
			if (this.grid._ctmndx)
				(e||event).cancelBubble=true;
			return !this.grid._ctmndx;
		};
	}
    	
	//#}		
	this.obj.ondblclick=function(e){
		if (!this.grid.wasDblClicked(e||window.event)) 
			return false; 
		if (this.grid._dclE) {
			var row = this.grid.getFirstParentOfType((_isIE?event.srcElement:e.target),"TR");
			if (row == this.grid.row)
				this.grid.editCell(e||window.event);  
		}
		(e||event).cancelBubble=true;
		if (_isOpera) return false; //block context menu for Opera 9+
	};
	this.hdr.onclick=this._onHeaderClick;
	this.sortImg.onclick=function(){
		self._onHeaderClick.apply({
				grid: self
		}, [
			null,
			self.r_fldSorted
		]);
	};
	
	this.hdr.ondblclick=this._onHeaderDblClick;
	
	
	if (!document.body._dhtmlxgrid_onkeydown){
		dhtmlxEvent(document, "keydown",function(e){
				if (globalActiveDHTMLGridObject) 
					return globalActiveDHTMLGridObject.doKey(e||window.event);
		});
		document.body._dhtmlxgrid_onkeydown=true;
	}
	
	dhtmlxEvent(document.body, "click", function(){
			if (self.editStop) self.editStop();
			if (self.isActive) self.setActive(false);
	});
	
	
	if (this.entBox.style.height.toString().indexOf("%") != -1)
		this._delta_y = this.entBox.style.height;
	if (this.entBox.style.width.toString().indexOf("%") != -1)
		this._delta_x = this.entBox.style.width;
	
	if (this._delta_x||this._delta_y)
		this._setAutoResize();
	
	
	/* deprecated names */
	this.setColHidden=this.setColumnsVisibility
	this.enableCollSpan = this.enableColSpan
	this.setMultiselect=this.enableMultiselect;
	this.setMultiLine=this.enableMultiline;
	this.deleteSelectedItem=this.deleteSelectedRows;
	this.getSelectedId=this.getSelectedRowId;
	this.getHeaderCol=this.getColumnLabel;
	this.isItemExists=this.doesRowExist;
	this.getColumnCount=this.getColumnsNum;
	this.setSelectedRow=this.selectRowById;
	this.setHeaderCol=this.setColumnLabel;
	this.preventIECashing=this.preventIECaching;
	this.enableAutoHeigth=this.enableAutoHeight;
	this.getUID=this.uid;
	
	if (dhtmlx.image_path) this.setImagePath(dhtmlx.image_path);
	if (dhtmlx.skin) this.setSkin(dhtmlx.skin);
	
	return this;
}

dhtmlXGridObject.prototype={
	getRowAttribute: function(id, name){
		return this.getRowById(id)._attrs[name];
	},
	setRowAttribute: function(id, name, value){
		this.getRowById(id)._attrs[name]=value;
	},
	/**
	*   @desc: detect is current grid is a treeGrid
	*   @type: private
	*   @topic: 2
	*/
	isTreeGrid:function(){
		return (this.cellType._dhx_find("tree") != -1);
	},
	
	//#column_hidden:21092006{	
	/**
	*   @desc: hide/show row (warning! - this command doesn't affect row indexes, only visual appearance)
	*   @param: ind - column index
	*   @param: state - true/false - hide/show row
	*   @type:  public
	*/
	setRowHidden:function(id, state){
		var f = dhx4.s2b(state);
		//var ind=this.getRowIndex(id);
		//if (id<0)
		//   return;
		var row = this.getRowById(id) //this.rowsCol[ind];
		
		if (!row)
			return;
		
		if (row.expand === "")
			this.collapseKids(row);
		
		if ((state)&&(row.style.display != "none")){
			row.style.display="none";
			var z = this.selectedRows._dhx_find(row);
			
			if (z != -1){
				row.className=row.className.replace("rowselected", "");
				
				for (var i = 0;
					i < row.childNodes.length;
					i++)row.childNodes[i].className=row.childNodes[i].className.replace(/cellselected/g, "");
					this.selectedRows._dhx_removeAt(z);
			}
			this.callEvent("onGridReconstructed", []);
		}
		
		if ((!state)&&(row.style.display == "none")){
			row.style.display="";
			this.callEvent("onGridReconstructed", []);
		}
		this.callEvent("onRowHide",[id, state]);
		this.setSizes();
	},
	
	//#__pro_feature:21092006{
	/**
	*   @desc: hide/show column
	*   @param: ind - column index
	*   @param: state - true/false - hide/show column
	*   @type:  public
	*   @edition: Professional
	*/
	setColumnHidden:function(ind, state){
		if (!this.hdr.rows.length){
			if (!this._ivizcol)
				this._ivizcol=[];
			return this._ivizcol[ind]=state;
		}
		
		if ((this.fldSorted)&&(this.fldSorted.cellIndex == ind)&&(state))
			this.sortImg.style.display="none";
		
		var f = dhx4.s2b(state);
		
		if (f){
			if (!this._hrrar)
				this._hrrar=new Array();
			
			else if (this._hrrar[ind])
				return;
			this._hrrar[ind]="display:none;";
			this._hideShowColumn(ind, "none");
		} else {
			if ((!this._hrrar)||(!this._hrrar[ind]))
				return;
			this._hrrar[ind]="";
			this._hideShowColumn(ind, "");
		}
		
		if ((this.fldSorted)&&(this.fldSorted.cellIndex == ind)&&(!state))
			this.sortImg.style.display="inline";
		
		this.setSortImgPos();
		this.callEvent("onColumnHidden",[ind,state])
	},
	
	
	/**
	*   @desc: get show/hidden status of column
	*   @param: ind - column index
	*   @type:  public
	*   @edition: Professional
	*   @returns:  if column hidden then true else false
	*/
	isColumnHidden:function(ind){
		if ((this._hrrar)&&(this._hrrar[ind]))
			return true;
		
		return false;
	},
	/**
	*   @desc: set list of visible/hidden columns
	*   @param: list - list of true/false separated by comma
	*   @type:  public
	*	@newmethod: setColumnsVisibility
	*   @edition: Professional
	*   @topic:0
	*/
	setColumnsVisibility:function(list){
		if (list)
			this._ivizcol=list.split(this.delim);
		
		if (this.hdr.rows.length&&this._ivizcol)
			for (var i = 0; i < this._ivizcol.length; i++)this.setColumnHidden(i, this._ivizcol[i]);
	},
	/**
	*   @desc: fix hidden state for column in all rows
	*   @type: private
	*/
	_fixHiddenRowsAll:function(pb, ind, prop, state, index){
		index=index||"_cellIndex";
		var z = pb.rows.length;
		
		for (var i = 0; i < z; i++){
			var x = pb.rows[i].childNodes;
			
			if (x.length != this._cCount){
				for (var j = 0; j < x.length; j++)
				if (x[j][index] == ind){
					x[j].style[prop]=state;
					break;
				}
			} else
			x[ind].style[prop]=state;
		}
	},
	/**
	*   @desc: hide column
	*   @param: ind - column index
	*   @param: state - hide/show
	*   @edition: Professional
	*   @type:  private
	*/
	_hideShowColumn:function(ind, state){
		var hind = ind;
		
		if (this.hdr.rows[1] && (this.hdr.rows[1]._childIndexes)&&(this.hdr.rows[1]._childIndexes[ind] != ind))
			hind=this.hdr.rows[1]._childIndexes[ind];
		
		if (state == "none"){
			this.hdr.rows[0].cells[ind]._oldWidth=this.hdr.rows[0].cells[ind].style.width||(this.initCellWidth[ind]+"px");
			this.hdr.rows[0].cells[ind]._oldWidthP=this.cellWidthPC[ind];
			this.obj.rows[0].cells[ind].style.width="0px";
			
			
			var t={rows:[this.obj.rows[0]]}
			this.forEachRow(function(id){
					if (this.rowsAr[id].tagName=="TR")
						t.rows.push(this.rowsAr[id])
			})
			this._fixHiddenRowsAll(t, ind, "display", "none");
			
			if (this.isTreeGrid())
				this._fixHiddenRowsAllTG(ind, "none");
			
			if ((_isOpera&&_OperaRv < 9)||_isKHTML||(_isFF)){ 
				this._fixHiddenRowsAll(this.hdr, ind, "display", "none","_cellIndexS");
				
			}
			if (this.ftr)
				this._fixHiddenRowsAll(this.ftr.childNodes[0], ind, "display", "none");			
			this._fixHiddenRowsAll(this.hdr, ind, "whiteSpace", "nowrap","_cellIndexS");
			
			if (!this.cellWidthPX.length&&!this.cellWidthPC.length)
				this.cellWidthPX=[].concat(this.initCellWidth);
			
			if (this.cellWidthPX[ind])
				this.cellWidthPX[ind]=0;
			
			if (this.cellWidthPC[ind])
				this.cellWidthPC[ind]=0;
		} else {
			if (this.hdr.rows[0].cells[ind]._oldWidth){
				var zrow = this.hdr.rows[0].cells[ind];
				
				if (_isOpera||_isKHTML||(_isFF))
					this._fixHiddenRowsAll(this.hdr, ind, "display", "","_cellIndexS");
				
				if (this.ftr)
					this._fixHiddenRowsAll(this.ftr.childNodes[0], ind, "display", "");
				
				
				var t={rows:[this.obj.rows[0]]}
				this.forEachRow(function(id){
						if (this.rowsAr[id].tagName=="TR")
							t.rows.push(this.rowsAr[id])
				})
				this._fixHiddenRowsAll(t, ind, "display", "");
				
				if (this.isTreeGrid())
					this._fixHiddenRowsAllTG(ind, "");
				
				this._fixHiddenRowsAll(this.hdr, ind, "whiteSpace", "normal","_cellIndexS");
				
				if (zrow._oldWidthP)
					this.cellWidthPC[ind]=zrow._oldWidthP;
				
				if (zrow._oldWidth)
					this.cellWidthPX[ind]=parseInt(zrow._oldWidth);
			}
		}

		if (!state && this._realfake)
			this.setColumnSizes(this.entBox.clientWidth);

		this.setSizes();
		
		if ((!_isIE)&&(!_isFF)){
			//dummy Opera/Safari fix
			this.obj.border=1;
			this.obj.border=0;
		}
	},
	//#}	
	//#}
	//#__pro_feature:21092006{	
	//#colspan:20092006{
	/**
	*   @desc: enable/disable colspan support
	*   @param: mode - true/false
	*   @type:  public
	*   @edition: Professional
	*/
	enableColSpan:function(mode){
		this._ecspn=dhx4.s2b(mode);
	},
	//#}
	//#}
	//#hovering:060402008{	
	/**
	*   @desc: enable/disable hovering row on mouse over
	*   @param: mode - true/false
	*   @param: cssClass - css class for hovering row
	*   @type:  public
	*/
	enableRowsHover:function(mode, cssClass){
		this._unsetRowHover(false,true);
		this._hvrCss=cssClass;
		
		if (dhx4.s2b(mode)){
			if (!this._elmnh){
				this.obj._honmousemove=this.obj.onmousemove;
				this.obj.onmousemove=this._setRowHover;
				
				if (_isIE)
					this.obj.onmouseleave=this._unsetRowHover;
				else
					this.obj.onmouseout=this._unsetRowHover;
				
				this._elmnh=true;
			}
		} else {
			if (this._elmnh){
				this.obj.onmousemove=this.obj._honmousemove;
				
				if (_isIE)
					this.obj.onmouseleave=null;
				else
					this.obj.onmouseout=null;
				
				this._elmnh=false;
			}
		}
	},
	//#}	
	/**
	*   @desc: enable/disable events which fire excell editing, mutual exclusive with enableLightMouseNavigation
	*   @param: click - true/false - enable/disable editing by single click
	*   @param: dblclick - true/false - enable/disable editing by double click
	*   @param: f2Key - enable/disable editing by pressing F2 key
	*   @type:  public
	*/
	enableEditEvents:function(click, dblclick, f2Key){
		this._sclE=dhx4.s2b(click);
		this._dclE=dhx4.s2b(dblclick);
		this._f2kE=dhx4.s2b(f2Key);
	},
	
	//#hovering:060402008{	
	/**
	*   @desc: enable/disable light mouse navigation mode (row selection with mouse over, editing with single click), mutual exclusive with enableEditEvents
	*   @param: mode - true/false
	*   @type:  public
	*/
	enableLightMouseNavigation:function(mode){
		if (dhx4.s2b(mode)){
			if (!this._elmn){
				this.entBox._onclick=this.entBox.onclick;
				this.entBox.onclick=function(){
					return true;
				};
				
				this.obj._onclick=this.obj.onclick;
				this.obj.onclick=function(e){
					var c = this.grid.getFirstParentOfType(e ? e.target : event.srcElement, 'TD');
					if (!c) return;
					this.grid.editStop();
					this.grid.doClick(c);
					this.grid.editCell();
					(e||event).cancelBubble=true;
				}
				
				this.obj._onmousemove=this.obj.onmousemove;
				this.obj.onmousemove=this._autoMoveSelect;
				this._elmn=true;
			}
		} else {
			if (this._elmn){
				this.entBox.onclick=this.entBox._onclick;
				this.obj.onclick=this.obj._onclick;
				this.obj.onmousemove=this.obj._onmousemove;
				this._elmn=false;
			}
		}
	},
	
	
	/**
	*   @desc: remove hover state on row
	*   @type:  private
	*/
	_unsetRowHover:function(e, c){
		if (c)
			that=this;
		else
			that=this.grid;
		
		if ((that._lahRw)&&(that._lahRw != c)){
			for (var i = 0;
				i < that._lahRw.childNodes.length;
				i++)that._lahRw.childNodes[i].className=that._lahRw.childNodes[i].className.replace(that._hvrCss, "");
				that._lahRw=null;
		}
	},
	
	/**
	*   @desc: set hover state on row
	*   @type:  private
	*/
	_setRowHover:function(e){
		var c = this.grid.getFirstParentOfType(e ? e.target : event.srcElement, 'TD');
		
		if (c && c.parentNode!=this.grid._lahRw) {
			this.grid._unsetRowHover(0, c);
			c=c.parentNode;
	  		if (!c.idd || c.idd=="__filler__") return;
			for (var i = 0; i < c.childNodes.length; i++)c.childNodes[i].className+=" "+this.grid._hvrCss;
			this.grid._lahRw=c;
		}
		this._honmousemove(e);
	},
	
	/**
	*   @desc: onmousemove, used in light mouse navigaion mode
	*   @type:  private
	*/
	_autoMoveSelect:function(e){
		//this - grid.obj
		if (!this.grid.editor){
			var c = this.grid.getFirstParentOfType(e ? e.target : event.srcElement, 'TD');
			
			if (c.parentNode.idd)
				this.grid.doClick(c, true, 0);
		}
		this._onmousemove(e);
	},
	//#}	
	//#__pro_feature:21092006{
	//#distrb_parsing:21092006{
	/**
	*   @desc: enable/disable distributed parsing (rows paresed portion by portion with some timeout)
	*   @param: mode - true/false
	*   @param: count - count of nodes parsed by one step (the 10 by default)
	*   @param: time - time between parsing counts in milli seconds (the 250 by default)
	*   @type:  public
	*   @edition: Professional
	*/
	enableDistributedParsing:function(mode, count, time){
		if (dhx4.s2b(mode)){
			this._ads_count=count||10;
			this._ads_time=time||250;
		} else
		this._ads_count=0;
	},
	//#}
	//#}
	/**
	*     @desc: destructor, removes grid and cleans used memory
	*     @type: public
	*     @topic: 0
	*/
	destructor:function(){
		this.editStop(true);
		//add links to current object
		if (this._sizeTime)
			this._sizeTime=window.clearTimeout(this._sizeTime);
		this.entBox.className=(this.entBox.className||"").replace(/gridbox.*/,"");
		if (this.formInputs)
			for (var i = 0; i < this.formInputs.length; i++)this.parentForm.removeChild(this.formInputs[i]);
		
		var a;
		
		for (var i = 0; i < this.rowsCol.length; i++)
			if (this.rowsCol[i])
			this.rowsCol[i].grid=null;
		
		for (i in this.rowsAr)
			if (this.rowsAr[i])
			this.rowsAr[i]=null;
		
		this.rowsCol=new dhtmlxArray();
		this.rowsAr={};
		this.entBox.innerHTML="";
		
		var dummy=function(){};
		this.entBox.onclick = this.entBox.onmousedown = this.entBox.onbeforeactivate = this.entBox.onbeforedeactivate = this.entBox.onbeforedeactivate = this.entBox.onselectstart = dummy;
		this.setSizes = this._update_srnd_view = this.callEvent = dummy;
		this.entBox.grid=this.objBox.grid=this.hdrBox.grid=this.obj.grid=this.hdr.grid=null;
		if (this._fake){
			this.globalBox.innerHTML = "";
			this._fake.setSizes = this._fake._update_srnd_view = this._fake.callEvent = dummy;
			this.globalBox.onclick = this.globalBox.onmousedown = this.globalBox.onbeforeactivate = this.globalBox.onbeforedeactivate = this.globalBox.onbeforedeactivate = this.globalBox.onselectstart = dummy;
		}
		
		for (a in this){
			if ((this[a])&&(this[a].m_obj))
				this[a].m_obj=null;
			this[a]=null;
		}
		
		if (this == globalActiveDHTMLGridObject)
			globalActiveDHTMLGridObject=null;
		//   self=null;
		return null;
	},
	
	//#sorting:06042008{	
	/**
	*     @desc: get sorting state of grid
	*     @type: public
	*     @returns: array, first element is index of sortef column, second - direction of sorting ("asc" or "des").
	*     @topic: 0
	*/
	getSortingState:function(){
		var z = new Array();
		
		if (this.fldSorted){
			z[0]=this.fldSorted._cellIndex;
			z[1]=(this.sortImg.className == "dhxgrid_sort_desc" ? "des" : "asc");
		}
		return z;
	},
	//#}
	
	/**
	*     @desc: enable autoheight of grid
	*     @param: mode - true/false
	*     @param: maxHeight - maximum height before scrolling appears (no limit by default)
	*     @param: countFullHeight - control the usage of maxHeight parameter - when set to true all grid height included in max height calculation, if false then only data part (no header) of grid included in calcualation (false by default)
	*     @type: public
	*     @topic: 0
	*/
	enableAutoHeight:function(mode, maxHeight, countFullHeight){
		this._ahgr=dhx4.s2b(mode);
		this._ahgrF=dhx4.s2b(countFullHeight);
		this._ahgrM=maxHeight||null;
		if (arguments.length == 1){
			this.objBox.style.overflowY=mode?"hidden":"auto";
		}
		if (maxHeight == "auto"){
			this._ahgrM=null;
			this._ahgrMA=true;
			this._setAutoResize();
			//   this._activeResize();
		}
	},
	//#sorting:06042008{	
	enableStableSorting:function(mode){
		this._sst=dhx4.s2b(mode);
		this.rowsCol.stablesort=function(cmp){
			var size = this.length-1;
			
			for (var i = 0; i < this.length-1; i++){
				for (var j = 0; j < size; j++)
				if (cmp(this[j], this[j+1]) > 0){
					var temp = this[j];
					this[j]=this[j+1];
					this[j+1]=temp;
				}
				size--;
			}
		}
	},
	//#}
	
	/**
	*     @desc: enable/disable hot keys in grid
	*     @param: mode - true/false
	*     @type: public
	*     @topic: 0
	*/
	enableKeyboardSupport:function(mode){
		this._htkebl=!dhx4.s2b(mode);
	},
	
	//#context_menu:06042008{	
	/**
	*     @desc: enable/disable context menu
	*     @param: dhtmlxMenu object, if null - context menu will be disabled
	*     @type: public
	*     @topic: 0
	*/
	enableContextMenu:function(menu){
		this._ctmndx=menu;
	},
	//#}	
	
	/*backward compatibility*/
	setScrollbarWidthCorrection:function(width){
	},
	//#tooltips:06042008{	
	/**
	*     @desc: enable/disable tooltips for specified colums
	*     @param: list - list of true/false values, tooltips enabled for all columns by default
	*     @type: public
	*     @topic: 0
	*/
	enableTooltips:function(list){
		this._enbTts=list.split(",");
		
		for (var i = 0; i < this._enbTts.length; i++)this._enbTts[i]=dhx4.s2b(this._enbTts[i]);
	},
	//#}	
	
	//#column_resize:06042008{
	/**
	*     @desc: enable/disable resizing for specified colums
	*     @param: list - list of true/false values, resizing enabled for all columns by default
	*     @type: public
	*     @topic: 0
	*/
	enableResizing:function(list){
		this._drsclmn=list.split(",");
		
		for (var i = 0; i < this._drsclmn.length; i++)this._drsclmn[i]=dhx4.s2b(this._drsclmn[i]);
	},
	
	/**
	*     @desc: set minimum column width ( works only for manual resizing )
	*     @param: width - minimum column width, can be set for specified column, or as comma separated list for all columns
	*     @param: ind - column index
	*     @type: public
	*     @topic: 0
	*/
	setColumnMinWidth:function(width, ind){
		if (arguments.length == 2){
			if (!this._drsclmW)
				this._drsclmW=new Array();
			this._drsclmW[ind]=width;
		} else
		this._drsclmW=width.split(",");
	},
	//#}	
	
	/**
	*     @desc: enable/disable unique id for cells (id will be automaticaly created using the following template: "c_[RowId]_[colIndex]")
	*     @param: mode - true/false - enable/disable
	*     @type: public
	*     @topic: 0
	*/
	enableCellIds:function(mode){
		this._enbCid=dhx4.s2b(mode);
	},
	
	
	//#locked_row:11052006{
	/**
	*     @desc: lock/unlock row for editing
	*     @param: rowId - id of row
	*     @param: mode - true/false - lock/unlock
	*     @type: public
	*     @topic: 0
	*/
	lockRow:function(rowId, mode){
		var z = this.getRowById(rowId);
		
		if (z){
			z._locked=dhx4.s2b(mode);
			
			if ((this.cell)&&(this.cell.parentNode.idd == rowId))
				this.editStop();
		}
	},
	//#}
	
	/**
	*   @desc:  get values of all cells in row
	*   @type:  private
	*/
	_getRowArray:function(row){
		var text = new Array();
		
		for (var ii = 0; ii < row.childNodes.length; ii++){
			var a = this.cells3(row, ii);
			text[ii]=a.getValue();
		}
		
		return text;
	},
	//#__pro_feature:21092006{	
	//#data_format:12052006{
	/**
	*     @desc: set mask for date formatting in cell
	*     @param: mask - date mask, d,m,y will mean day,month,year; for example "d/m/y" - 22/05/1985
	*     @type: public
	*     @edition: Professional
	*     @topic: 0
	*/
	setDateFormat:function(mask,incoming){
		this._dtmask=mask;
		this._dtmask_inc=incoming;
	},
	
	/**
	*     @desc: set mask for formatting numeric data ( works for [ed/ro]n excell only or oher cell types with suport for this method)
	*     @param: mask - numeric mask; for example 0,000.00 - 1,234.56
	*     @param: cInd - column index
	*     @param: p_sep - char used as decimalseparator ( point by default )
	*     @param: d_sep - char used as groups part separator ( comma by default )
	*     @type: public
	*     @edition: Professional
	*     @topic: 0
	*/
	setNumberFormat:function(mask, cInd, p_sep, d_sep){
		var nmask = mask.replace(/[^0\,\.]*/g, "");
		var pfix = nmask.indexOf(".");
		
		if (pfix > -1)
			pfix=nmask.length-pfix-1;
		var dfix = nmask.indexOf(",");
		
		if (dfix > -1)
			dfix=nmask.length-pfix-2-dfix;
		if (typeof p_sep != "string")
			p_sep=this.i18n.decimal_separator;
		if (typeof d_sep != "string")
			d_sep=this.i18n.group_separator;
		var pref = mask.split(nmask)[0];
		var postf = mask.split(nmask)[1];
		this._maskArr[cInd]=[
			pfix,
			dfix,
			pref,
			postf,
			p_sep,
			d_sep
		];
	},
	/**
	*   @desc:  convert formated value to original
	*   @type:  private
	*/
	_aplNFb:function(data, ind){
		var a = this._maskArr[ind];
		
		if (!a)
			return data;
		
		var ndata = parseFloat(data.toString().replace(/[^0-9]*/g, ""));
		
		if (data.toString().substr(0, 1) == "-")
			ndata=ndata*-1;
		
		if (a[0] > 0)
			ndata=ndata / Math.pow(10, a[0]);
		return ndata;
	},
	
	/**
	*   @desc:  format data with mask
	*   @type:  private
	*/
	_aplNF:function(data, ind){
		var a = this._maskArr[ind];
		
		if (!a)
			return data;
		
		var c = (parseFloat(data) < 0 ? "-" : "")+a[2];
		data=Math.abs(Math.round(parseFloat(data)*Math.pow(10, a[0] > 0 ? a[0] : 0))).toString();
		data=(data.length
			< a[0]
			? Math.pow(10, a[0]+1-data.length).toString().substr(1, a[0]+1)+data.toString()
			: data).split("").reverse();
			data[a[0]]=(data[a[0]]||"0")+a[4];
			
			if (a[1] > 0)
				for (var j = (a[0] > 0 ? 0 : 1)+a[0]+a[1]; j < data.length; j+=a[1])data[j]+=a[5];
			return c+data.reverse().join("")+a[3];
	},
	//#}
	//#}	
	
	//#config_from_xml:20092006{
	
	/**
	*   @desc:  configure grid structure from XML
	*   @type:  private
	*/
	_launchCommands:function(arr){
		for (var i = 0; i < arr.length; i++){
			var args = new Array();
			
			for (var j = 0; j < arr[i].childNodes.length; j++)
				if (arr[i].childNodes[j].nodeType == 1)
				args[args.length]=arr[i].childNodes[j].firstChild.data;
			
			this[arr[i].getAttribute("command")].apply(this, args);
		}
	},
	
	
	/**
	*   @desc:  configure grid structure from XML
	*   @type:  private
	*/
	_parseHead:function(xmlDoc){
		var hheadCol = dhx4.ajax.xpath("./head", xmlDoc);
		
		if (hheadCol.length){
			var headCol = dhx4.ajax.xpath("./column", hheadCol[0]);
			var asettings = dhx4.ajax.xpath("./settings", hheadCol[0]);
			var awidthmet = "setInitWidths";
			var split = false;
			
			if (asettings[0]){
				for (var s = 0; s < asettings[0].childNodes.length; s++)switch (asettings[0].childNodes[s].tagName){
				case "colwidth":
					if (asettings[0].childNodes[s].firstChild&&asettings[0].childNodes[s].firstChild.data == "%")
						awidthmet="setInitWidthsP";
					break;
					
				case "splitat":
					split=(asettings[0].childNodes[s].firstChild ? asettings[0].childNodes[s].firstChild.data : false);
					break;
				}
			}
			this._launchCommands(dhx4.ajax.xpath("./beforeInit/call", hheadCol[0]));
			
			if (headCol.length > 0){
				if (this.hdr.rows.length > 0) this.clearAll(true); //drop existing grid here, to prevent loss of initialization parameters
				var sets = [
					[],
					[],
					[],
					[],
					[],
					[],
					[],
					[],
					[]
				];
				
				var attrs = ["", "width", "type", "align", "sort", "color", "format", "hidden", "id"];
				var calls = ["", awidthmet, "setColTypes", "setColAlign", "setColSorting", "setColumnColor", "",
				"", "setColumnIds"];
				
				for (var i = 0; i < headCol.length; i++){
					for (var j = 1; j < attrs.length; j++)sets[j].push(headCol[i].getAttribute(attrs[j]));
					sets[0].push((headCol[i].firstChild
						? headCol[i].firstChild.data
						: "").replace(/^\s*((\s\S)*.+)\s*$/gi, "$1"));
				};
				
				this.setHeader(sets[0]);
				for (var i = 0; i < calls.length; i++)
					if (calls[i])
					this[calls[i]](sets[i].join(this.delim))
				
				for (var i = 0; i < headCol.length; i++){
					if ((this.cellType[i].indexOf('co') == 0)||(this.cellType[i] == "clist")){
						var optCol = dhx4.ajax.xpath("./option", headCol[i]);
						
						if (optCol.length){
							var resAr = new Array();
							
							if (this.cellType[i] == "clist"){
								for (var j = 0;
									j < optCol.length;
									j++)resAr[resAr.length]=optCol[j].firstChild
								? optCol[j].firstChild.data
								: "";
								
								this.registerCList(i, resAr);
							} else {
								var combo = this.getCombo(i);
								
								for (var j = 0;
									j < optCol.length;
									j++)combo.put(optCol[j].getAttribute("value"),
										optCol[j].firstChild
										? optCol[j].firstChild.data
										: "");
							}
						}
					}
					
					else if (sets[6][i])
						if ((this.cellType[i].toLowerCase().indexOf("calendar")!=-1)||(this.fldSort[i] == "date"))
						this.setDateFormat(sets[6][i]);
					else
						this.setNumberFormat(sets[6][i], i);
				}
				
				this.init();
				
				var param=sets[7].join(this.delim);
				//preserving state of hidden columns, if not specified directly
				if (this.setColHidden && param.replace(/,/g,"")!="")
					this.setColHidden(param);
				
				if ((split)&&(this.splitAt))
					this.splitAt(split);
			}
			this._launchCommands(dhx4.ajax.xpath("./afterInit/call", hheadCol[0]));
		}
		//global(grid) user data
		var gudCol = dhx4.ajax.xpath("//rows/userdata", xmlDoc);
		
		if (gudCol.length > 0){
			
			if (!this.UserData["gridglobaluserdata"])
				this.UserData["gridglobaluserdata"]=new Hashtable();
			
			for (var j = 0; j < gudCol.length; j++){
				var u_record = "";
				for (var xj=0; xj < gudCol[j].childNodes.length; xj++)
					u_record += gudCol[j].childNodes[xj].nodeValue;
				this.UserData["gridglobaluserdata"].put(gudCol[j].getAttribute("name"),u_record);
			}
		}
	},
	
	
	//#}
	
	
	/**
	*   @desc: get list of Ids of all rows with checked exCell in specified column
	*   @type: public
	*   @param: col_ind - column index
	*   @topic: 5
	*/
	getCheckedRows:function(col_ind){
		var d = new Array();
		this.forEachRowA(function(id){
				var cell = this.cells(id, col_ind);
				if (cell.changeState && cell.getValue() != 0)
					d.push(id);
		},true);
		return d.join(",");
	},
	/**
	*   @desc: check all checkboxes in grid
	*   @type: public
	*   @param: col_ind - column index
	*   @topic: 5
	*/	
	checkAll:function(){var mode=arguments.length?arguments[0]:1;
	for (var cInd=0;cInd<this.getColumnsNum();cInd++){if(this.getColType(cInd)=="ch")this.setCheckedRows(cInd,mode)}},
		/**
	*   @desc: uncheck all checkboxes in grid
	*   @type: public
	*   @param: col_ind - column index
	*   @topic: 5
	*/	
	uncheckAll:function(){ this.checkAll(0); },
	/**
	*   @desc: set value for all checkboxes in specified column
	*   @type: public
	*   @param: col_ind - column index
	*   @topic: 5
	*/	
	setCheckedRows:function(cInd,v){this.forEachRowA(function(id){if(this.cells(id,cInd).isCheckbox())this.cells(id,cInd).setValue(v)})},
	//#tooltips:06042008{	
	/**
	*   @desc:  grid body onmouseover function
	*   @type:  private
	*/
	_drawTooltip:function(e){
		var c = this.grid.getFirstParentOfType(e ? e.target : event.srcElement, 'TD');
		
		if (!c || ((this.grid.editor)&&(this.grid.editor.cell == c)))
			return true;
		
		var r = c.parentNode;
		
		if (!r.idd||r.idd == "__filler__")
			return;
		var el = (e ? e.target : event.srcElement);
		
		if (r.idd == window.unknown)
			return true;
		
		if (!this.grid.callEvent("onMouseOver", [
				r.idd,
			c._cellIndex,
			(e||window.event)
		]))
		return true;
		
		if ((this.grid._enbTts)&&(!this.grid._enbTts[c._cellIndex])){
			if (el.title)
				el.title='';
			return true;
		}
		
		if (c._cellIndex >= this.grid._cCount)
			return;
		var ced = this.grid.cells3(r, c._cellIndex);
		if (!ced || !ced.cell || !ced.cell._attrs) return; // fix for public release
		
		if (el._title)
			ced.cell.title="";
		
		if (!ced.cell._attrs['title'])
			el._title=true;
		
		if (ced)
			el.title=ced.cell._attrs['title']
		||(ced.getTitle
			? ced.getTitle()
			: (ced.getValue()||"").toString().replace(/<[^>]*>/gi, ""));
		
		return true;
	},
	//#}	
	/**
	*   @desc:  can be used for setting correction for cell padding, while calculation setSizes
	*   @type:  private
	*/
	enableCellWidthCorrection:function(size){
		if (_isFF)
			this._wcorr=parseInt(size);
	},
	
	
	/**
	*	@desc: gets a list of all row ids in grid
	*	@param: separator - delimiter to use in list
	*	@returns: list of all row ids in grid
	*	@type: public
	*	@topic: 2,7
	*/
	getAllRowIds:function(separator){
		var ar = [];
		
		for (var i = 0; i < this.rowsBuffer.length; i++)
			if (this.rowsBuffer[i])
			ar.push(this.rowsBuffer[i].idd);
		
		return ar.join(separator||this.delim)
	},
	getAllItemIds:function(){
		return this.getAllRowIds();
	},
	
	//#__pro_feature:21092006{	
	//#colspan:20092006{
	
	/**
	*   @desc: dynamicaly set colspan in row starting from specified column index
	*   @param: row_id - row id
	*   @param: col_id - index of column
	*   @param: colspan - size of colspan
	*   @type: public
	*   @edition: Professional
	*   @topic: 2,9
	*/
	setColspan:function(row_id, col_ind, colspan){
		if (!this._ecspn)
			return;
		
		var r = this.getRowById(row_id);
		
		if ((r._childIndexes)&&(r.childNodes[r._childIndexes[col_ind]])){
			var j = r._childIndexes[col_ind];
			var n = r.childNodes[j];
			var m = n.colSpan;
			n.colSpan=1;
			
			if ((m)&&(m != 1))
			for (var i = 1; i < m; i++){
				var c = document.createElement("TD");
				
				if (n.nextSibling)
					r.insertBefore(c, n.nextSibling);
				else
					r.appendChild(c);
				r._childIndexes[col_ind+i]=j+i;
				c._cellIndex=col_ind+i;
				c.style.textAlign=this.cellAlign[i];
				c.style.verticalAlign=this.cellVAlign[i];
				n=c;
				this.cells3(r, col_ind+i).setValue("");
			}
			
			for (var z = col_ind*1+1*m; z < r._childIndexes.length; z++){
				r._childIndexes[z]+=(m-1)*1;
			}
		}
		
		if ((colspan)&&(colspan > 1)){
			if (r._childIndexes)
				var j = r._childIndexes[col_ind];
			else {
				var j = col_ind;
				r._childIndexes=new Array();
				
				for (var z = 0; z < r.childNodes.length; z++)r._childIndexes[z]=z;
			}
			
			r.childNodes[j].colSpan=colspan;
			
			for (var z = 1; z < colspan; z++){
				r._childIndexes[r.childNodes[j+1]._cellIndex]=j;
				r.removeChild(r.childNodes[j+1]);
			}
			
			var c1 = r.childNodes[r._childIndexes[col_ind]]._cellIndex;
			
			for (var z = c1*1+1*colspan; z < r._childIndexes.length; z++)r._childIndexes[z]-=(colspan-1);
		}
	},
	
	//#}
	//#}
	
	/**
	*   @desc: prevent caching in IE  by adding random values to URL string
	*   @param: mode - enable/disable random values in URLs ( disabled by default )
	*   @type: public
	*   @topic: 2,9
	*/
	preventIECaching:function(mode){
		dhx4.ajax.cache = !mode;
	},
	enableColumnAutoSize:function(mode){
		this._eCAS=dhx4.s2b(mode);
	},
	/**
	*   @desc: called when header was dbllicked
	*   @type: private
	*   @topic: 1,2
	*/
	_onHeaderDblClick:function(e){
		var that = this.grid;
		var el = that.getFirstParentOfType(_isIE ? event.srcElement : e.target, "TD");
		
		if (!that._eCAS)
			return false;
		that.adjustColumnSize(el._cellIndexS)
	},
	
	/**
	*   @desc: autosize column  to max content size
	*   @param: cInd - index of column
	*   @type:  public
	*/
	adjustColumnSize:function(cInd, complex){
		if (this._hrrar && this._hrrar[cInd]) return;
		this._notresize=true;
		var m = 0;
		this._setColumnSizeR(cInd, 20);
		
		for (var j = 1; j < this.hdr.rows.length; j++){
			var a = this.hdr.rows[j];
			a=a.childNodes[(a._childIndexes) ? a._childIndexes[cInd] : cInd];
			
			if ((a)&&((!a.colSpan)||(a.colSpan < 2)) && a._cellIndex==cInd){
				if ((a.childNodes[0])&&(a.childNodes[0].className == "hdrcell"))
					a=a.childNodes[0];
				m=Math.max(m, a.scrollWidth);
			}
		}
		
		var l = this.obj.rows.length;
		var z = 0;
		var tree = this.cellType._dhx_find("tree");
		
		for (var i = 1; i < l; i++){
			var row = this.obj.rows[i];
			var col = cInd;
			if (!this.rowsAr[row.idd]) continue;
			
			if (row._childIndexes){
				if (row._childIndexes[cInd] == row._childIndexes[cInd+1] )
					continue;
				col = row._childIndexes[cInd];
			}

			if (!row.childNodes[col] || row.childNodes[col]._cellIndex != cInd)
				continue;

			z= ( row.childNodes[col].innerText || row.childNodes[col].textContent || "" ).length*this.fontWidth;
			if (this._h2 && cInd == tree)
				z += this._h2.get[row.idd].level * 22;
			
			
			
			if (z > m)
				m=z;
		}
		m+=20+(complex||0);
		
		this._setColumnSizeR(cInd, m);
		this._notresize=false;
		this.setSizes();
	},
	
	//#header_footer:06042008{
	/**
	*   @desc: remove header line from grid (opposite to attachHeader)
	*   @param: index - index of row to be removed ( zero based )
	*	@param: hdr - header object (optional)
	*   @type:  public
	*/
	detachHeader:function(index, hdr){
		hdr=hdr||this.hdr;
		var row = hdr.rows[index+1];
		
		if (row)
			row.parentNode.removeChild(row);
		this.setSizes();
	},
	
	/**
	*   @desc: remove footer line from grid (opposite to attachFooter)
	*   @param: values - array of header titles
	*   @type:  public
	*/
	detachFooter:function(index){
		this.detachHeader(index, this.ftr);
	},
	
	/**
	*   @desc: attach additional line to header
	*   @param: values - array of header titles
	*   @param: style - array of styles, optional
	*	@param: _type - reserved
	*   @type:  public
	*/
	attachHeader:function(values, style, _type){
		if (typeof (values) == "string")
			values=this._eSplit(values);
		
		if (typeof (style) == "string")
			style=style.split(this.delim);
		_type=_type||"_aHead";
		
		if (this.hdr.rows.length){
			if (values)
			this._createHRow([
					values,
					style
				], this[(_type == "_aHead") ? "hdr" : "ftr"]);
			
			else if (this[_type])
				for (var i = 0; i < this[_type].length; i++)this.attachHeader.apply(this, this[_type][i]);
		} else {
			if (!this[_type])
				this[_type]=new Array();
			this[_type][this[_type].length]=[
				values,
				style,
				_type
			];
		}
	},
	/**
	*	@desc:
	*	@type: private
	*/
	_createHRow:function(data, parent){
		if (!parent){
			if (this.entBox.style.position!="absolute")
				this.entBox.style.position="relative";
			var z = document.createElement("DIV");
			z.className="c_ftr".substr(2);
			this.entBox.appendChild(z);
			var t = document.createElement("TABLE");
			t.cellPadding=t.cellSpacing=0;
			
			if (!_isIE || _isIE == 8){
				t.width="100%";
				t.style.paddingRight="20px";
			}
			t.style.marginRight="20px";
			t.style.tableLayout="fixed";
			
			z.appendChild(t);
			t.appendChild(document.createElement("TBODY"));
			this.ftr=parent=t;
			
			var hdrRow = t.insertRow(0);
			var thl = ((this.hdrLabels.length <= 1) ? data[0].length : this.hdrLabels.length);
			
			for (var i = 0; i < thl; i++){
				hdrRow.appendChild(document.createElement("TH"));
				hdrRow.childNodes[i]._cellIndex=i;
			}
			
			if (_isIE && _isIE<8)
				hdrRow.style.position="absolute";
			else
				hdrRow.style.height='auto';
		}
		var st1 = data[1];
		var z = document.createElement("TR");
		parent.rows[0].parentNode.appendChild(z);
		
		for (var i = 0; i < data[0].length; i++){
			if (data[0][i] == "#cspan"){
				var pz = z.cells[z.cells.length-1];
				pz.colSpan=(pz.colSpan||1)+1;
				continue;
			}
			
			if ((data[0][i] == "#rspan")&&(parent.rows.length > 1)){
				var pind = parent.rows.length-2;
				var found = false;
				var pz = null;
				
				while (!found){
					var pz = parent.rows[pind];
					
					for (var j = 0; j < pz.cells.length; j++)
					if (pz.cells[j]._cellIndex == i){
						found=j+1;
						break;
					}
					pind--;
				}
				
				pz=pz.cells[found-1];
				pz.rowSpan=(pz.rowSpan||1)+1;
				continue;
				//            data[0][i]="";
			}
			
			var w = document.createElement("TD");
			w._cellIndex=w._cellIndexS=i;
			if (this._hrrar && this._hrrar[i] && !_isIE)
				w.style.display='none';
			
			if (typeof data[0][i] == "object")
				w.appendChild(data[0][i]);
			else {
				if (this.forceDivInHeader)
					w.innerHTML="<div class='hdrcell'>"+(data[0][i]||"&nbsp;")+"</div>";
				else
					w.innerHTML=(data[0][i]||"&nbsp;");
				
				if ((data[0][i]||"").indexOf("#") != -1){
					var t = data[0][i].match(/(^|{)#([^}]+)(}|$)/);
					
					if (t){
						var tn = "_in_header_"+t[2];
						
						if (this[tn])
							this[tn]((this.forceDivInHeader ? w.firstChild : w), i, data[0][i].split(t[0]));
					}
				}
			}
			if (st1)
				w.style.cssText=st1[i];
			
			z.appendChild(w);
		}
		var self = parent;
		
		if (_isKHTML){
			if (parent._kTimer)
				window.clearTimeout(parent._kTimer);
			parent._kTimer=window.setTimeout(function(){
					parent.rows[1].style.display='none';
					window.setTimeout(function(){
							parent.rows[1].style.display='';
					}, 1);
			}, 500);
		}
	},
	//#__pro_feature:21092006{	
	/**
	*   @desc: attach additional line to footer
	*   @param: values - array of header titles
	*   @param: style - array of styles, optional
	*   @edition: Professional
	*   @type:  public
	*/
	attachFooter:function(values, style){
		this.attachHeader(values, style, "_aFoot");
	},
	//#}
	//#}
	//#__pro_feature:21092006{
	//#dyn_cell_types:04062008{
	/**
	*   @desc: set excell type for cell in question
	*   @param: rowId - row ID
	*   @param: cellIndex - cell index
	*   @param: type - type of excell (code like "ed", "txt", "ch" etc.)
	*   @edition: Professional
	*   @type:  public
	*/
	setCellExcellType:function(rowId, cellIndex, type){
		this.changeCellType(this.getRowById(rowId), cellIndex, type);
	},
	/**
	*	@desc: 
	*	@type: private
	*/
	changeCellType:function(r, ind, type){
		type=type||this.cellType[ind];
		var z = this.cells3(r, ind);
		var v = z.getValue();
		z.cell._cellType=type;
		var z = this.cells3(r, ind);
		z.setValue(v);
	},
	/**
	*   @desc: set excell type for all cells in specified row
	*   @param: rowId - row ID
	*   @param: type - type of excell
	*   @edition: Professional
	*   @type:  public
	*/
	setRowExcellType:function(rowId, type){
		var z = this.rowsAr[rowId];
		
		for (var i = 0; i < z.childNodes.length; i++)this.changeCellType(z, i, type);
	},
	/**
	*   @desc: set excell type for all cells in specified column
	*   @param: colIndex - column index
	*   @param: type - type of excell
	*   @edition: Professional
	*   @type:  public
	*/
	setColumnExcellType:function(colIndex, type){
		for (var i = 0; i < this.rowsBuffer.length; i++)
			if (this.rowsBuffer[i] && this.rowsBuffer[i].tagName=="TR")
			this.changeCellType(this.rowsBuffer[i], colIndex, type);
		if (this.cellType[colIndex]=="math")
			this._strangeParams[i]=type;
		else
			this.cellType[colIndex]=type;
	},
	
	//#}
	//#}
	
	/**
	*   @desc: execute code for each row in a grid
	*   @param: custom_code - function which get row id as incomming argument
	*   @type:  public
	*/
	forEachRow:function(custom_code){
		for (var a in this.rowsAr)
			if (this.rowsAr[a]&&this.rowsAr[a].idd)
			custom_code.apply(this, [this.rowsAr[a].idd]);
	},
	forEachRowA:function(custom_code){
		for (var a =0; a<this.rowsBuffer.length; a++){
			if (this.rowsBuffer[a])
				custom_code.call(this, this.render_row(a).idd);
		}
	},
	/**
	*   @desc: execute code for each cell in a row
	*   @param: rowId - id of row where cell must be itterated
	*   @param: custom_code - function which get eXcell object as incomming argument
	*   @type:  public
	*/
	forEachCell:function(rowId, custom_code){
		var z = this.getRowById(rowId);
		
		if (!z)
			return;
		
		for (var i = 0; i < this._cCount; i++) custom_code(this.cells3(z, i),i);
	},
	/**
	*   @desc: changes grid's container size on the fly to fit total width of grid columns
	*   @param: mode  - truse/false - enable / disable
	*   @param: max_limit  - max allowed width, not limited by default
	*   @param: min_limit  - min allowed width, not limited by default
	*   @type:  public
	*/
	enableAutoWidth:function(mode, max_limit, min_limit){
		this._awdth=[
			dhx4.s2b(mode),
			parseInt(max_limit||99999),
			parseInt(min_limit||0)
		];
		if (arguments.length == 1)
			this.objBox.style.overflowX=mode?"hidden":"auto";
	},
	//#update_from_xml:06042008{	
	/**
	*   @desc: refresh grid from XML ( doesnt work for buffering, tree grid or rows in smart rendering mode )
	*   @param: insert_new - insert new items
	*   @param: del_missed - delete missed rows
	*   @param: afterCall - function, will be executed after refresh completted
	*   @type:  public
	*/
	
	updateFromXML:function(url, insert_new, del_missed, afterCall){
		if (typeof insert_new == "undefined")
			insert_new=true;
		this._refresh_mode=[
			true,
			insert_new,
			del_missed
		];
		this.load(url,afterCall)
	},
	_refreshFromXML:function(xml){
		if (this._f_rowsBuffer) this.filterBy(0,"");
		reset = false;
		if (window.eXcell_tree){
			eXcell_tree.prototype.setValueX=eXcell_tree.prototype.setValue;
			eXcell_tree.prototype.setValue=function(content){
				var r=this.grid._h2.get[this.cell.parentNode.idd]
				if (r && this.cell.parentNode.valTag){
					this.setLabel(content);
				} else
				this.setValueX(content);
			};
		}
		
		var tree = this.cellType._dhx_find("tree");
		var top = dhx4.ajax.xmltop("rows", xml);
		var pid = top.getAttribute("parent")||0;
		
		var del = {
		};
		
		if (this._refresh_mode[2]){
			if (tree != -1)
			this._h2.forEachChild(pid, function(obj){
					del[obj.id]=true;
			}, this);
			else
			this.forEachRow(function(id){
					del[id]=true;
			});
		}
		
		var rows = dhx4.ajax.xpath("//row", top);
		
		for (var i = 0; i < rows.length; i++){
			var row = rows[i];
			var id = row.getAttribute("id");
			del[id]=false;
			var pid = row.parentNode.getAttribute("id")||pid;
			if (this.rowsAr[id] && this.rowsAr[id].tagName!="TR"){
				if (this._h2)
					this._h2.get[id].buff.data=row;
				else
					this.rowsBuffer[this.getRowIndex(id)].data=row;
				this.rowsAr[id]=row;
			} else if (this.rowsAr[id]){
				this._process_xml_row(this.rowsAr[id], row, -1);
				this._postRowProcessing(this.rowsAr[id],true)
				if (this._fake && this._fake.rowsAr[id])
					this._fake._process_xml_row(this._fake.rowsAr[id], row, -1);
			} else if (this._refresh_mode[1]){
				var dadd={
					idd: id,
					data: row,
					_parser: this._process_xml_row,
					_locator: this._get_xml_data
				};
				
				var render_index = this.rowsBuffer.length;
				if (this._refresh_mode[1]=="top"){
					this.rowsBuffer.unshift(dadd);
					render_index = 0;
				} else
				this.rowsBuffer.push(dadd);
				
				if (this._h2){ 
					reset=true;
					(this._h2.add(id,(row.parentNode.getAttribute("id")||row.parentNode.getAttribute("parent")))).buff=this.rowsBuffer[this.rowsBuffer.length-1];
				} else if (this._srnd)
				reset = true;
				
				this.rowsAr[id]=row;
				row=this.render_row(render_index);
				this._insertRowAt(row,render_index?-1:0)
			}
		}
		
		if (this._refresh_mode[2])
		for (id in del){
			if (del[id]&&this.rowsAr[id])
				this.deleteRow(id);
		}
		
		this._refresh_mode=null;
		if (window.eXcell_tree)
			eXcell_tree.prototype.setValue=eXcell_tree.prototype.setValueX;
		
		if (reset){
			if (this._h2) 
				this._renderSort();
			else
				this.render_dataset();
		}
		
		if (this._f_rowsBuffer) {
			this._f_rowsBuffer = null;
			this.filterByAll();
		}
	},
	//#}	
	//#co_excell:06042008{
	/**
	*   @desc: get combobox specific for cell in question
	*   @param: id - row id
	*   @param: ind  - column index
	*   @type:  public
	*/
	getCustomCombo:function(id, ind){
		var cell = this.cells(id, ind).cell;
		
		if (!cell._combo)
			cell._combo=new dhtmlXGridComboObject();
		return cell._combo;
	},
	//#}
	/**
	*   @desc: set tab order of columns
	*   @param: order - list of tab indexes (default delimiter is ",")
	*   @type:  public
	*/
	setTabOrder:function(order){
		var t = order.split(this.delim);
		this._tabOrder=[];
		var max=this._cCount||order.length;
		
		for (var i = 0; i < max; i++)t[i]={
			c: parseInt(t[i]),
			ind: i
		};
		t.sort(function(a, b){
				return (a.c > b.c ? 1 : -1);
		});
		
		for (var i = 0; i < max; i++)
			if (!t[i+1]||( typeof t[i].c == "undefined"))
			this._tabOrder[t[i].ind]=(t[0].ind+1)*-1;
		else
			this._tabOrder[t[i].ind]=t[i+1].ind;
	},
	
	i18n:{
		loading: "Loading",
		decimal_separator:".",
		group_separator:","
	},
	
	//key_ctrl_shift
	_key_events:{
		k13_1_0: function(){
			var rowInd = this.rowsCol._dhx_find(this.row)
			this.selectCell(this.rowsCol[rowInd+1], this.cell._cellIndex, true);
		},
		k13_0_1: function(){
			var rowInd = this.rowsCol._dhx_find(this.row)
			this.selectCell(this.rowsCol[rowInd-1], this.cell._cellIndex, true);
		},
		k13_0_0: function(){
			this.editStop();
			this.callEvent("onEnter", [
					(this.row ? this.row.idd : null),
					(this.cell ? this.cell._cellIndex : null)
			]);
			this._still_active=true;
		},
		k9_0_0: function(){
			this.editStop();
			if (!this.callEvent("onTab",[true])) return true;
			var z = this._getNextCell(null, 1);
			
			if (z){
				this.selectCell(z.parentNode, z._cellIndex, (this.row != z.parentNode), false, true);
				this._still_active=true;
			}
		},
		k9_0_1: function(){
			this.editStop();
			if (!this.callEvent("onTab",[false])) return false;
			var z = this._getNextCell(null, -1);
			
			if (z){
				this.selectCell(z.parentNode, z._cellIndex, (this.row != z.parentNode), false, true);
				this._still_active=true;
			}
		},
		k113_0_0: function(){
			if (this._f2kE)
				this.editCell();
		},
		k32_0_0: function(){
			var c = this.cells4(this.cell);
			
			if (!c.changeState||(c.changeState() === false))
				return false;
		},
		k27_0_0: function(){
			this.editStop(true);
		},
		k33_0_0: function(){
			if (this.pagingOn)
				this.changePage(this.currentPage-1);
			else
				this.scrollPage(-1);
		},
		k34_0_0: function(){
			if (this.pagingOn)
				this.changePage(this.currentPage+1);
			else
				this.scrollPage(1);
		},
		k37_0_0: function(){
			if (!this.editor&&this.isTreeGrid())
				this.collapseKids(this.row)
			else
				return false;
		},
		k39_0_0: function(){
			if (!this.editor&&this.isTreeGrid())
				this.expandKids(this.row)
			else
				return false;
		},
		k40_0_0: function(){
			var master = this._realfake?this._fake:this;
			if (this.editor&&this.editor.combo)
				this.editor.shiftNext();
			else {
				if (!this.row.idd) return;
				var rowInd = Math.max((master._r_select||0),this.getRowIndex(this.row.idd));
				var row = this._nextRow(rowInd, 1);
				if (row){
					master._r_select=null;
					this.selectCell(row, this.cell._cellIndex, true);
					if (master.pagingOn) master.showRow(row.idd);
				} else {
					if (!this.callEvent("onLastRow", [])) return false;
					this._key_events.k34_0_0.apply(this, []);
					if (this.pagingOn && this.rowsCol[rowInd+1])
						this.selectCell(rowInd+1, 0, true);
				}
			}
			this._still_active=true;
		},
		k38_0_0: function(){
			var master = this._realfake?this._fake:this;
			if (this.editor&&this.editor.combo)
				this.editor.shiftPrev();
			else {
				if (!this.row.idd) return;
				var rowInd = this.getRowIndex(this.row.idd)+1;
				if (rowInd != -1 && (!this.pagingOn || (rowInd!=1))){
					var nrow = this._nextRow(rowInd-1, -1);
					this.selectCell(nrow, this.cell._cellIndex, true);
					if (master.pagingOn && nrow) master.showRow(nrow.idd);
				} else {
					this._key_events.k33_0_0.apply(this, []);
					/*
					if (this.pagingOn && this.rowsCol[this.rowsBufferOutSize-1])
					this.selectCell(this.rowsBufferOutSize-1, 0, true);
					*/
				}
			}
			this._still_active=true;
		}
	},
	
	//(c)dhtmlx ltd. www.dhtmlx.com
	
	_build_master_row:function(){
		var t = document.createElement("DIV");
		var html = ["<table><tr>"];
		
		for (var i = 0; i < this._cCount; i++)html.push("<td></td>");
		html.push("</tr></table>");
		t.innerHTML=html.join("");
		this._master_row=t.firstChild.rows[0];
	},
	
	_prepareRow:function(new_id){ /*TODO: hidden columns */
		if (!this._master_row)
			this._build_master_row();
		
		var r = this._master_row.cloneNode(true);
		
		for (var i = 0; i < r.childNodes.length; i++){
			r.childNodes[i]._cellIndex=i;
			if (this._enbCid) r.childNodes[i].id="c_"+new_id+"_"+i;
			if (this.dragAndDropOff)
				this.dragger.addDraggableItem(r.childNodes[i], this);
		}
		r.idd=new_id;
		r.grid=this;
		
		return r;
	},
	
	//#non_xml_data:06042008{
	_process_jsarray_row:function(r, data){
		r._attrs={
		};
		
		for (var j = 0; j < r.childNodes.length; j++)r.childNodes[j]._attrs={
		};
		
		this._fillRow(r, (this._c_order ? this._swapColumns(data) : data));
		return r;
	},
	_get_jsarray_data:function(data, ind){
		return data[ind];
	},
	_process_json_row:function(r, data){
		data = this._c_order ? this._swapColumns(data.data) : data.data;
		return this._process_some_row(r, data);
	},
	_process_some_row:function(r,data){
		r._attrs={};
		
		for (var j = 0; j < r.childNodes.length; j++)
			r.childNodes[j]._attrs={};
		
		this._fillRow(r, data);
		return r;
	},
	_get_json_data:function(data, ind){
		return data.data[ind];
	},
	
	
	_process_js_row:function(r, data){
		var arr = [];
		for (var i=0; i<this.columnIds.length; i++){
			arr[i] = data[this.columnIds[i]];
			if (!arr[i] && arr[i]!==0)
				arr[i]="";
		}
		this._process_some_row(r,arr);
		
		r._attrs = data;
		return r;
	},
	_get_js_data:function(data, ind){
		return data[this.columnIds[ind]];
	},
	_process_csv_row:function(r, data){
		r._attrs={
		};
		
		for (var j = 0; j < r.childNodes.length; j++)r.childNodes[j]._attrs={
		};
		
		this._fillRow(r, (this._c_order ? this._swapColumns(data.split(this.csv.cell)) : data.split(this.csv.cell)));
		return r;
	},
	_get_csv_data:function(data, ind){
		return data.split(this.csv.cell)[ind];
	},
	//#}
	_process_store_row:function(row, data){
		var result = [];
		for (var i = 0; i < this.columnIds.length; i++)
			result[i] = data[this.columnIds[i]];
		for (var j = 0; j < row.childNodes.length; j++)
			row.childNodes[j]._attrs={};
		
		row._attrs = data;
		this._fillRow(row, result);
	},	
	//#xml_data:06042008{
	_process_xml_row:function(r, xml){		
		var cellsCol = dhx4.ajax.xpath(this.xml.cell, xml);
		var strAr = [];
		
		r._attrs=this._xml_attrs(xml);
		
		//load userdata
		if (this._ud_enabled){
			var udCol = dhx4.ajax.xpath("./userdata", xml);
			
			for (var i = udCol.length-1; i >= 0; i--){
				var u_record = "";
				for (var j=0; j < udCol[i].childNodes.length; j++)
					u_record += udCol[i].childNodes[j].nodeValue;
				
				this.setUserData(r.idd,udCol[i].getAttribute("name"), u_record);
			}
		}
		
		//load cell data
		for (var j = 0; j < cellsCol.length; j++){
			var cellVal = cellsCol[this._c_order?this._c_order[j]:j];
			if (!cellVal) continue;
			var cind = r._childIndexes?r._childIndexes[j]:j;
			var exc = cellVal.getAttribute("type");
			
			if (r.childNodes[cind]){
				if (exc)
					r.childNodes[cind]._cellType=exc;
				r.childNodes[cind]._attrs=this._xml_attrs(cellVal);
			}
			
			if (!cellVal.getAttribute("xmlcontent")){
				if (cellVal.firstChild)
					cellVal=cellVal.firstChild.wholeText||cellVal.firstChild.data;
				else
					cellVal="";
			}
			
			strAr.push(cellVal);
		}
		
		for (j < cellsCol.length; j < r.childNodes.length; j++)r.childNodes[j]._attrs={
		};
		
		//treegrid
		if (r.parentNode&&r.parentNode.tagName == "row")
			r._attrs["parent"]=r.parentNode.getAttribute("idd");
		
		//back to common code
		this._fillRow(r, strAr);
		return r;
	},
	_get_xml_data:function(data, ind){ 
		data=data.firstChild;
		
		while (true){
			if (!data)
				return "";
			
			if (data.tagName == "cell")
				ind--;
			
			if (ind < 0)
				break;
			data=data.nextSibling;
		}
		return (data.firstChild ? data.firstChild.data : "");
	},
	//#}	
	_fillRow:function(r, text){
		if (this.editor && this.editor.parentNode && this.editor.parentNode.idd == r.idd)
			this.editStop();
		
		for (var i = 0; i < r.childNodes.length; i++){
			if ((i < text.length)||(this.defVal[i])){
				
				var ii=r.childNodes[i]._cellIndex;
				var val = text[ii];
				var aeditor = this.cells4(r.childNodes[i]);
				
				if ((this.defVal[ii])&&((val == "")||( typeof (val) == "undefined")))
					val=this.defVal[ii];
				
				if (aeditor) aeditor.setValue(val)
			} else {
				r.childNodes[i].innerHTML="&nbsp;";
				r.childNodes[i]._clearCell=true;
			}
		}
		
		return r;
	},
	
	_postRowProcessing:function(r,donly){ 
		if (r._attrs["class"])
			r._css=r.className=r._attrs["class"];
		
		if (r._attrs.locked)
			r._locked=true;
		
		if (r._attrs.bgColor)
			r.bgColor=r._attrs.bgColor;
		var cor=0;	
		
		for (var i = 0; i < r.childNodes.length; i++){
			var c=r.childNodes[i];
			var ii=c._cellIndex;
			//style attribute
			var s = c._attrs.style||r._attrs.style;
			
			if (s)
				c.style.cssText+=";"+s;
			
			if (c._attrs["class"])
				c.className=c._attrs["class"];
			s=c._attrs.align||this.cellAlign[ii];
			
			
			if (s)
				c.align=s;
			c.vAlign=c._attrs.valign||this.cellVAlign[ii];
			var color = c._attrs.bgColor||this.columnColor[ii];
			
			
			if (color)
				c.bgColor=color;
			
			if (c._attrs["colspan"] && !donly){ 
				this.setColspan(r.idd, i+cor, c._attrs["colspan"]);
				//i+=(c._attrs["colspan"]-1);
				cor+=(c._attrs["colspan"]-1);
			}
			
			if (this._hrrar&&this._hrrar[ii]&&!donly){
				c.style.display="none";
			}
		};
		this.callEvent("onRowCreated", [
				r.idd,
				r,
				null
		]);
	},
	/**
	*   @desc: load data from external file ( xml, json, jsarray, csv )
	*   @param: url - url to external file
	*   @param: call - after loading callback function, optional, can be ommited
	*   @param: type - type of data (xml,csv,json,jsarray) , optional, xml by default
	*   @type:  public
	*/			
	load:function(url, call, type){
		this.callEvent("onXLS", [this]);
		if (arguments.length == 2 && typeof call != "function"){
			type=call;
			call=null;
		}
		type=type||"xml";
		
		if (!this.xmlFileUrl)
			this.xmlFileUrl=url;
		this._data_type=type;
		
		this.xmlLoader = this.doLoadDetails;
		
		var that = this;
		this.xmlLoader = function(xml){
			if (!that.callEvent) return;
			that["_process_"+type](xml.xmlDoc);
			if (!that._contextCallTimer)
				that.callEvent("onXLE", [that,0,0,xml.xmlDoc,type]);
			
			if (call){
				call();
				call=null;
			}
		};
		return dhx4.ajax.get(url, this.xmlLoader);
	},
	//#__pro_feature:21092006{		
	loadXMLString:function(str, afterCall){
		if (window.console && window.console.info)
          window.console.info("loadXMLString was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");

		this.parse( { responseXML: dhx4.ajax.parse(str) }, afterCall, "xml")
	},
	//#}
	loadXML:function(url, afterCall){
		if (window.console && window.console.info)
        	window.console.info("loadXML was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");

		this.load(url, afterCall, "xml")
	},
	/**
	*   @desc: load data from local datasource ( xml string, csv string, xml island, xml object, json objecs , javascript array )
	*   @param: data - string or object
	*   @param: type - data type (xml,json,jsarray,csv), optional, data threated as xml by default
	*   @type:  public
	*/			
	parse:function(data, call, type){
		if (arguments.length == 2 && typeof call != "function"){
			type=call;
			call=null;
		}
		type=type||"xml";
		this._data_type=type;
		
		if (type == "xml" && typeof data == "string")
			data = { responseXML: dhx4.ajax.parse(data) };
		
		this["_process_"+type](data);
		if (!this._contextCallTimer)
			this.callEvent("onXLE", [this,0,0,data,type]);
		if (call)
			call();
	},
	
	xml:{
		top: "rows",
		row: "./row",
		cell: "./cell",
		s_row: "row",
		s_cell: "cell",
		row_attrs: [],
		cell_attrs: []
	},
	
	csv:{
		row: "\n",
		cell: ","
	},
	
	_xml_attrs:function(node){
		var data = {
		};
		
		if (node.attributes.length){
			for (var i = 0; i < node.attributes.length; i++)data[node.attributes[i].name]=node.attributes[i].value;
		}
		
		return data;
	},
	//#xml_data:06042008{	
	_process_xml:function(xhr){
		if (this._refresh_mode) return this._refreshFromXML(xhr);
		this._parsing=true;
		var top = dhx4.ajax.xmltop(this.xml.top, xhr);
		if (top.tagName!=this.xml.top) return;
		var skey = top.getAttribute("dhx_security");
		if (skey)
			dhtmlx.security_key = skey;
		
		//#config_from_xml:20092006{
		this._parseHead(top);
		//#}
		var rows = dhx4.ajax.xpath(this.xml.row, top)
		var cr = parseInt(top.getAttribute("pos")||0);
		var total = parseInt(top.getAttribute("total_count")||0);
		if (!this.pagingOn)
			var total = Math.min(total, 32000000/this._srdh);
		
		var reset = false;
		if (total && total!=this.rowsBuffer.length){
			if (!this.rowsBuffer[total-1]){
				if (this.rowsBuffer.length)
					reset=true;
				this.rowsBuffer[total-1]=null;
			} 
			if (total<this.rowsBuffer.length){
				this.rowsBuffer.splice(total, this.rowsBuffer.length - total);
				reset = true;
			}
		}
		
		
		if (this.isTreeGrid())
			return this._process_tree_xml(top);
		
		
		for (var i = 0; i < rows.length; i++){
			if (this.rowsBuffer[i+cr])
				continue;
			var id = rows[i].getAttribute("id")||(i+cr+1);
			this.rowsBuffer[i+cr]={
				idd: id,
				data: rows[i],
				_parser: this._process_xml_row,
				_locator: this._get_xml_data
			};
			
			this.rowsAr[id]=rows[i];
			//this.callEvent("onRowCreated",[r.idd]);
		}
		
		this.callEvent("onDataReady", []);
		if (reset && this._srnd){
			var h = this.objBox.scrollTop;
			this._reset_view();
			this.objBox.scrollTop = h;
		} else {
			this.render_dataset();
		}
		
		this._parsing=false;
	},
	//#}
	//#non_xml_data:06042008{	
	_process_jsarray:function(data){
		this._parsing=true;
		data = data.responseText || data;
		if (typeof data == "string"){
			eval("dhtmlx.temp="+data+";");
			data = dhtmlx.temp;
		}
		
		for (var i = 0; i < data.length; i++){
			var id = i+1;
			this.rowsBuffer.push({
					idd: id,
					data: data[i],
					_parser: this._process_jsarray_row,
					_locator: this._get_jsarray_data
			});
			
			this.rowsAr[id]=data[i];
			//this.callEvent("onRowCreated",[r.idd]);
		}
		this.render_dataset();
		this._parsing=false;
	},
	
	_process_csv:function(data){
		this._parsing=true;
		data=data.responseText || data;
		data=data.replace(/\r/g,"");
		data=data.split(this.csv.row);
		if (this._csvHdr){
   			this.clearAll();
   			var thead=data.splice(0,1)[0].split(this.csv.cell);
   			if (!this._csvAID) thead.splice(0,1);
	   		this.setHeader(thead.join(this.delim));
	   		this.init();
   		}
   		
		for (var i = 0; i < data.length; i++){
			if (!data[i] && i==data.length-1) continue; //skip new line at end of text
			if (this._csvAID){
				var id = i+1;
				this.rowsBuffer.push({
						idd: id,
						data: data[i],
						_parser: this._process_csv_row,
						_locator: this._get_csv_data
				});
			} else {
				var temp = data[i].split(this.csv.cell);
				var id = temp.splice(0,1)[0];
				this.rowsBuffer.push({
						idd: id,
						data: temp,
						_parser: this._process_jsarray_row,
						_locator: this._get_jsarray_data
				});
			}
			
			
			this.rowsAr[id]=data[i];
			//this.callEvent("onRowCreated",[r.idd]);
		}
		this.render_dataset();
		this._parsing=false;
	},
	
	_process_js:function(data){
		return this._process_json(data, "js");
	},
	
	_process_json:function(data, mode){
		this._parsing=true;
		
		var data = data.responseText || data;
		if (typeof data == "string"){
			eval("dhtmlx.temp="+data+";");
			data = dhtmlx.temp;
		}
		
		if (mode == "js"){
			if (data.data)
				data = data.data;
			for (var i = 0; i < data.length; i++){
				var row = data[i];
				var id  = row.id||(i+1);
				this.rowsBuffer.push({
						idd: id,
						data: row,
						_parser: this._process_js_row,
						_locator: this._get_js_data
				});
				
				this.rowsAr[id]=data[i];
			}
		} else {
			if (data.rows){
				for (var i = 0; i < data.rows.length; i++){
					var id = data.rows[i].id;
					this.rowsBuffer.push({
							idd: id,
							data: data.rows[i],
							_parser: this._process_json_row,
							_locator: this._get_json_data
					});
					
					this.rowsAr[id]=data.rows[i];
				}
			}
		}
		if (data.dhx_security)
			dhtmlx.security_key = data.dhx_security;
		
		this.callEvent("onDataReady", []);
		this.render_dataset();
		this._parsing=false;
	},
	//#}	
	render_dataset:function(min, max){ 
		//normal mode - render all
		//var p=this.obj.parentNode;
		//p.removeChild(this.obj,true)
		if (this._srnd){
			if (this._fillers)
				return this._update_srnd_view();
			
			max=Math.min((this._get_view_size()+(this._srnd_pr||0)), this.rowsBuffer.length);
			
		}
		
		if (this.pagingOn){
			min=Math.max((min||0),(this.currentPage-1)*this.rowsBufferOutSize);
			max=Math.min(this.currentPage*this.rowsBufferOutSize, this.rowsBuffer.length)
		} else {
			min=min||0;
			max=max||this.rowsBuffer.length;
		}
		
		for (var i = min; i < max; i++){
			var r = this.render_row(i)
			
			if (r == -1){
				if (this.xmlFileUrl){
					if (this.callEvent("onDynXLS",[i,(this._dpref?this._dpref:(max-i))]))
						this.load(this.xmlFileUrl+dhtmlx.url(this.xmlFileUrl)+"posStart="+i+"&count="+(this._dpref?this._dpref:(max-i)), this._data_type);
				}
				max=i;
				break;
			}
			
			if (!r.parentNode||!r.parentNode.tagName){ 
				this._insertRowAt(r, i);
				if (r._attrs["selected"] || r._attrs["select"]){
					this.selectRow(r,r._attrs["call"]?true:false,true);
					r._attrs["selected"]=r._attrs["select"]=null;
				}
			}
			
			
			if (this._ads_count && i-min==this._ads_count){
				var that=this;
				this._context_parsing=this._context_parsing||this._parsing;
				return this._contextCallTimer=window.setTimeout(function(){
						that._contextCallTimer=null;
						that.render_dataset(i,max);
						if (!that._contextCallTimer){
							if(that._context_parsing)
								that.callEvent("onXLE",[])
							else 
								that._fixAlterCss();
							that._context_parsing=false;
						}
				},this._ads_time)
			}
		}
		if (this._ads_count && i == max)
			this.callEvent("onDistributedEnd",[]);
		
		if (this._srnd&&!this._fillers){
			var add_count = this.rowsBuffer.length-max;
			this._fillers = [];
			if (this._fake && !this._realfake) this._fake._fillers = [];
			
			var block_size = Math.round(990000/this._srdh);
			while (add_count > 0){
				var add_step = (_isIE || window._FFrv)?Math.min(add_count, block_size):add_count;
				var new_filler = this._add_filler(max, add_step);
				if (new_filler)
					this._fillers.push(new_filler);
				add_count -= add_step;
				max += add_step;
			}				
		}
		
		//p.appendChild(this.obj)
		this.setSizes();
	},
	
	render_row:function(ind){
		if (!this.rowsBuffer[ind])
			return -1;
		
		if (this.rowsBuffer[ind]._parser){
			var r = this.rowsBuffer[ind];
			if (this.rowsAr[r.idd] && this.rowsAr[r.idd].tagName=="TR")
				return this.rowsBuffer[ind]=this.rowsAr[r.idd];
			var row = this._prepareRow(r.idd);
			this.rowsBuffer[ind]=row;
			this.rowsAr[r.idd]=row;
			
			r._parser.call(this, row, r.data);
			this._postRowProcessing(row);
			return row;
		}
		return this.rowsBuffer[ind];
	},
	
	
	_get_cell_value:function(row, ind, method){
		if (row._locator){
			/*if (!this._data_cache[row.idd])
			this._data_cache[row.idd]=[];
			if (this._data_cache[row.idd][ind]) 
			return this._data_cache[row.idd][ind];
			else
			return this._data_cache[row.idd][ind]=row._locator.call(this,row.data,ind);
			*/
			if (this._c_order)
				ind=this._c_order[ind];
			return row._locator.call(this, row.data, ind);
		}
		return this.cells3(row, ind)[method ? method : "getValue"]();
	},
	//#sorting:06042008{	
	/**
	*   @desc: sort grid
	*   @param: col - index of column, by which grid need to be sorted
	*   @param: type - sorting type (str,int,date), optional, by default sorting type taken from column setting
	*   @param: order - sorting order (asc,des), optional, by default sorting order based on previous sorting operation
	*   @type:  public
	*/		
	sortRows:function(col, type, order){
		this.editStop();
		//default values
		order=(order||"asc").toLowerCase();
		type=(type||this.fldSort[col]);
		col=col||0;
		
		if (this.isTreeGrid())
			this.sortTreeRows(col, type, order);
		else{
			
			var arrTS = {
			};
			
			var atype = this.cellType[col];
			var amet = "getValue";
			
			if (atype == "link")
				amet="getContent";
			
			if (atype == "dhxCalendar"||atype == "dhxCalendarA")
				amet="getDate";
			
			for (var i = 0;
				i < this.rowsBuffer.length;
				i++)arrTS[this.rowsBuffer[i].idd]=this._get_cell_value(this.rowsBuffer[i], col, amet);
				
				this._sortRows(col, type, order, arrTS);
		}
		this.callEvent("onAfterSorting", [col,type,order]);
	},
	/**
	*	@desc: 
	*	@type: private
	*/
	_sortCore:function(col, type, order, arrTS, s){
		var sort = "sort";
		
		if (this._sst){
			s["stablesort"]=this.rowsCol.stablesort;
			sort="stablesort";
		}
		//#__pro_feature:21092006{	
		//#custom_sort:21092006{
		if (type.length > 4)
			type=window[type];
		
		if (type == 'cus'){
			var cstr=this._customSorts[col];
			s[sort](function(a, b){
					return cstr(arrTS[a.idd], arrTS[b.idd], order, a.idd, b.idd);
			});
		}
		else if (typeof (type) == 'function'){
			s[sort](function(a, b){
					return type(arrTS[a.idd], arrTS[b.idd], order, a.idd, b.idd);
			});
		}
		else
			//#}
		//#}
		if (type == 'str'){
			s[sort](function(a, b){
					if (order == "asc")
						return arrTS[a.idd] > arrTS[b.idd] ? 1 : (arrTS[a.idd] < arrTS[b.idd] ? -1 : 0);
					else
						return arrTS[a.idd] < arrTS[b.idd] ? 1 : (arrTS[a.idd] > arrTS[b.idd] ? -1 : 0);
			});
		}
		else if (type == 'int'){
			s[sort](function(a, b){
					var aVal = parseFloat(arrTS[a.idd]);
					aVal=isNaN(aVal) ? -99999999999999 : aVal;
					var bVal = parseFloat(arrTS[b.idd]);
					bVal=isNaN(bVal) ? -99999999999999 : bVal;
					
					if (order == "asc")
						return aVal-bVal;
					else
						return bVal-aVal;
			});
		}
		else if (type == 'date'){
			s[sort](function(a, b){
					var aVal = Date.parse(arrTS[a.idd])||(Date.parse("01/01/1900"));
					var bVal = Date.parse(arrTS[b.idd])||(Date.parse("01/01/1900"));
					
					if (order == "asc")
						return aVal-bVal
					else
						return bVal-aVal
			});
		}
	},
	/**
	*   @desc: inner sorting routine
	*   @type: private
	*   @topic: 7
	*/
	_sortRows:function(col, type, order, arrTS){
		this._sortCore(col, type, order, arrTS, this.rowsBuffer);
		this._reset_view();
		this.callEvent("onGridReconstructed", []);
	},
	//#}		
	_reset_view:function(skip){
		if (!this.obj.rows[0]) return;
		if (this._lahRw) this._unsetRowHover(0, true); //remove hovering during reset
		this.callEvent("onResetView",[]);
		var tb = this.obj.rows[0].parentNode;
		var tr = tb.removeChild(tb.childNodes[0], true)
		if (_isKHTML) //Safari 2x
			for (var i = tb.parentNode.childNodes.length-1; i >= 0; i--) { if (tb.parentNode.childNodes[i].tagName=="TR") tb.parentNode.removeChild(tb.parentNode.childNodes[i],true); }
		else if (_isIE)
			for (var i = tb.childNodes.length-1; i >= 0; i--) tb.childNodes[i].removeNode(true);
		else
			tb.innerHTML="";
		tb.appendChild(tr)
		this.rowsCol=dhtmlxArray();
		if (this._sst)
			this.enableStableSorting(true);
		this._fillers=this.undefined;
		if (!skip){
			if (_isIE && this._srnd){
				// var p=this._get_view_size;
				// this._get_view_size=function(){ return 1; }
				this.render_dataset();
				// this._get_view_size=p;
			}
			else
				this.render_dataset();
		}
		
		
	},
	
	/**
	*   @desc: delete row from the grid
	*   @param: row_id - row ID
	*   @type:  public
	*/		
	deleteRow:function(row_id, node){
		if (!node)
			node=this.getRowById(row_id)
		
		if (!node)
			return;
		
		this.editStop();
		if (!this._realfake)
			if (this.callEvent("onBeforeRowDeleted", [row_id]) == false)
			return false;
		
		var pid=0;
		if (this.cellType._dhx_find("tree") != -1 && !this._realfake){
			pid=this._h2.get[row_id].parent.id;
			this._removeTrGrRow(node);
		}
		else {
			if (node.parentNode)
				node.parentNode.removeChild(node);
			
			var ind = this.rowsCol._dhx_find(node);
			
			if (ind != -1)
				this.rowsCol._dhx_removeAt(ind);
			
			for (var i = 0; i < this.rowsBuffer.length; i++)
			if (this.rowsBuffer[i]&&this.rowsBuffer[i].idd == row_id){
				this.rowsBuffer._dhx_removeAt(i);
				ind=i;
				break;
			}
		}
		this.rowsAr[row_id]=null;
		
		for (var i = 0; i < this.selectedRows.length; i++)
			if (this.selectedRows[i].idd == row_id)
			this.selectedRows._dhx_removeAt(i);
		
		if (this._srnd){
			for (var i = 0; i < this._fillers.length; i++){
				var f = this._fillers[i]
				if (!f) continue; //can be null	
				if (f[0] >= ind)
					this._update_fillers(i, 0, -1);
				else if (f[0]+f[1] > ind)
					this._update_fillers(i, -1, 0);
			};
			
			this._update_srnd_view();
		}
		
		if (this.pagingOn)
			this.changePage();
		if (!this._realfake)  this.callEvent("onAfterRowDeleted", [row_id,pid]);
		this.callEvent("onGridReconstructed", []);
		if (this._ahgr) this.setSizes();
		return true;
	},
	
	_addRow:function(new_id, text, ind){
		if (ind == -1|| typeof ind == "undefined")
			ind=this.rowsBuffer.length;
		if (typeof text == "string") text=text.split(this.delim);
		var row = this._prepareRow(new_id);
		row._attrs={
		};
		
		for (var j = 0; j < row.childNodes.length; j++)row.childNodes[j]._attrs={
		};
		
		
		this.rowsAr[row.idd]=row;
		if (this._h2) this._h2.get[row.idd].buff=row;	//treegrid specific
		this._fillRow(row, text);
		this._postRowProcessing(row);
		if (this._skipInsert){
			this._skipInsert=false;
			return this.rowsAr[row.idd]=row;
		}
		
		if (this.pagingOn){
			this.rowsBuffer._dhx_insertAt(ind,row);
			this.rowsAr[row.idd]=row;
			return row;
		}
		
		if (this._fillers){ 
			this.rowsCol._dhx_insertAt(ind, null);
			this.rowsBuffer._dhx_insertAt(ind,row);
			if (this._fake) this._fake.rowsCol._dhx_insertAt(ind, null);
			this.rowsAr[row.idd]=row;
			var found = false;
			
			for (var i = 0; i < this._fillers.length; i++){
				var f = this._fillers[i];
				
				if (f&&f[0] <= ind&&(f[0]+f[1]) >= ind){
					f[1]=f[1]+1;
					var nh = f[2].firstChild.style.height=parseInt(f[2].firstChild.style.height)+this._srdh+"px";
					found=true;
					if (this._fake){
						this._fake._fillers[i][1]++;
						this._fake._fillers[i][2].firstChild.style.height = nh;
					}
				}
				
				if (f&&f[0] > ind){
					f[0]=f[0]+1
					if (this._fake) this._fake._fillers[i][0]++;
				}
			}
			
			if (!found)
			this._fillers.push(this._add_filler(ind, 1, (ind == 0 ? {
					parentNode: this.obj.rows[0].parentNode,
					nextSibling: (this.rowsCol[1])
			} : this.rowsCol[ind-1])));
			
			return row;
		}
		this.rowsBuffer._dhx_insertAt(ind,row);
		return this._insertRowAt(row, ind);
	},
	
	/**
	*   @desc: add row to the grid
	*   @param: new_id - row ID, must be unique
	*   @param: text - row values, may be a comma separated list or an array
	*   @param: ind - index of new row, optional, row added to the last position by default
	*   @type:  public
	*/	
	addRow:function(new_id, text, ind){
		var r = this._addRow(new_id, text, ind);
		
		if (!this.dragContext)
			this.callEvent("onRowAdded", [new_id]);
		
		if (this.pagingOn)
			this.changePage(this.currentPage)
		
		if (this._srnd)
			this._update_srnd_view();
		
		r._added=true;
		
		if (this._srnd && !this._fillers)
			this._fillers = [];
		
		if (this._ahgr)
			this.setSizes();
		this.callEvent("onGridReconstructed", []);
		return r;
	},
	
	_insertRowAt:function(r, ind, skip){
		this.rowsAr[r.idd]=r;
		
		if (this._skipInsert){
			this._skipInsert=false;
			return r;
		}
		
		if ((ind < 0)||((!ind)&&(parseInt(ind) !== 0)))
			ind=this.rowsCol.length;
		else {
			if (ind > this.rowsCol.length)
				ind=this.rowsCol.length;
		}
		
		if (this._cssEven){
			var css = r.className.replace(this._cssUnEven, "");
			if ((this._cssSP ? this.getLevel(r.idd) : ind)%2 == 1)
				r.className=css+" "+this._cssUnEven+(this._cssSU ? (" "+this._cssUnEven+"_"+this.getLevel(r.idd)) : "");
			else
				r.className=css+" "+this._cssEven+(this._cssSU ? (" "+this._cssEven+"_"+this.getLevel(r.idd)) : "");
		}
		/*
		if (r._skipInsert) {                
		this.rowsAr[r.idd] = r;
		return r;
		}*/
		if (!skip)
			if ((ind == (this.obj.rows.length-1))||(!this.rowsCol[ind]))
			if (_isKHTML)
			this.obj.appendChild(r);
		else {
			this.obj.firstChild.appendChild(r);
		}
		else {
			this.rowsCol[ind].parentNode.insertBefore(r, this.rowsCol[ind]);
		}
		
		this.rowsCol._dhx_insertAt(ind, r);
		this.callEvent("onRowInserted",[r, ind]);
		return r;
	},
	
	getRowById:function(id){
		var row = this.rowsAr[id];
		
		if (row){
			if (row.tagName != "TR"){
				for (var i = 0; i < this.rowsBuffer.length; i++)
					if (this.rowsBuffer[i] && this.rowsBuffer[i].idd == id)
					return this.render_row(i);
				if (this._h2) return this.render_row(null,row.idd);
			}
			return row;
		}
		return null;
	},
	
	/**
	*   @desc: gets dhtmlXGridCellObject object (if no arguments then gets dhtmlXGridCellObject object of currently selected cell)
	*   @param: row_id -  row id
	*   @param: col -  column index
	*   @returns: dhtmlXGridCellObject object (see its methods below)
	*   @type: public
	*   @topic: 4
	*/
	cellById:function(row_id, col){
		return this.cells(row_id, col);
	},
	/**
	*   @desc: gets dhtmlXGridCellObject object (if no arguments then gets dhtmlXGridCellObject object of currently selected cell)
	*   @param: row_id -  row id
	*   @param: col -  column index
	*   @returns: dhtmlXGridCellObject object (use it to get/set value to cell etc.)
	*   @type: public
	*   @topic: 4
	*/
	cells:function(row_id, col){
		if (arguments.length == 0)
			return this.cells4(this.cell);
		else
			var c = this.getRowById(row_id);
		var cell = (c._childIndexes ? c.childNodes[c._childIndexes[col]] : c.childNodes[col]);
		if (!cell && c._childIndexes)
			cell = c.firstChild || {};
		return this.cells4(cell);
	},
	/**
	*   @desc: gets dhtmlXGridCellObject object
	*   @param: row_index -  row index
	*   @param: col -  column index
	*   @returns: dhtmlXGridCellObject object (see its methods below)
	*   @type: public
	*   @topic: 4
	*/
	cellByIndex:function(row_index, col){
		return this.cells2(row_index, col);
	},
	/**
	*   @desc: gets dhtmlXGridCellObject object
	*   @param: row_index -  row index
	*   @param: col -  column index
	*   @returns: dhtmlXGridCellObject object (see its methods below)
	*   @type: public
	*   @topic: 4
	*/
	cells2:function(row_index, col){
		var c = this.render_row(row_index);
		var cell = (c._childIndexes ? c.childNodes[c._childIndexes[col]] : c.childNodes[col]);
		if (!cell && c._childIndexes)
			cell = c.firstChild || {};
		return this.cells4(cell);
	},
	/**
	*   @desc: gets exCell editor for row  object and column id
	*   @type: private
	*   @topic: 4
	*/
	cells3:function(row, col){
		var cell = (row._childIndexes ? row.childNodes[row._childIndexes[col]] : row.childNodes[col]);
		return this.cells4(cell);
	},
	/**
	*   @desc: gets exCell editor for cell  object
	*   @type: private
	*   @topic: 4
	*/
	cells4:function(cell){
		var type = window["eXcell_"+(cell._cellType||this.cellType[cell._cellIndex])];
		
		if (type)
			return new type(cell);
	},	
	cells5:function(cell, type){ 
		var type = type||(cell._cellType||this.cellType[cell._cellIndex]);
		
		if (!this._ecache[type]){
			if (!window["eXcell_"+type])
				var tex = eXcell_ro;
			else
				var tex = window["eXcell_"+type];
			
			this._ecache[type]=new tex(cell);
		}
		this._ecache[type].cell=cell;
		return this._ecache[type];
	},
	dma:function(mode){
		if (!this._ecache)
		this._ecache={
		};
		
		if (mode&&!this._dma){
			this._dma=this.cells4;
			this.cells4=this.cells5;
		} else if (!mode&&this._dma){
			this.cells4=this._dma;
			this._dma=null;
		}
	},
	
	/**
	*   @desc: returns count of row in grid ( in case of dynamic mode it will return expected count of rows )
	*   @type:  public
	*	@returns: count of rows in grid
	*/	
	getRowsNum:function(){
		return this.rowsBuffer.length;
	},
	
	
	/**
	*   @desc: enables/disables mode when readonly cell is not available with tab 
	*   @param: mode - (boolean) true/false
	*   @type:  public
	*/
	enableEditTabOnly:function(mode){
		if (arguments.length > 0)
			this.smartTabOrder=dhx4.s2b(mode);
		else
			this.smartTabOrder=true;
	},
	/**
	*   @desc: sets elements which get focus when tab is pressed in the last or first (tab+shift) cell 
	*   @param: start - html object or its id - gets focus when tab+shift are pressed in the first cell  
	*   @param: end - html object or its id - gets focus when tab is pressed in the last cell  
	*   @type:  public
	*/
	setExternalTabOrder:function(start, end){
		var grid = this;
		this.tabStart=( typeof (start) == "object") ? start : document.getElementById(start);
		
		var oldkeydown_start = this.tabStart.onkeydown;
		this.tabStart.onkeydown=function(e){
			if (oldkeydown_start)
				oldkeydown_start.call(this, e);
			
			var ev = (e||window.event);
			if (ev.keyCode == 9 && !ev.shiftKey){
				
				ev.cancelBubble=true;		
				grid.selectCell(0, 0, 0, 0, 1);
				
				if (grid.smartTabOrder && grid.cells2(0, 0).isDisabled()){
					grid._key_events["k9_0_0"].call(grid);
				}
				this.blur();
				return false;
			}
		};
		if(_isOpera) this.tabStart.onkeypress = this.tabStart.onkeydown;
		this.tabEnd=( typeof (end) == "object") ? end : document.getElementById(end);
		
		var oldkeydown_end= this.tabEnd.onkeydown;
		this.tabEnd.onkeydown=this.tabEnd.onkeypress=function(e){
			if (oldkeydown_end)
				oldkeydown_end.call(this, e);
			
			var ev = (e||window.event);
			if (ev.keyCode == 9 && ev.shiftKey){
				ev.cancelBubble=true;
				grid.selectCell((grid.getRowsNum()-1), (grid.getColumnCount()-1), 0, 0, 1);
				
				if (grid.smartTabOrder && grid.cells2((grid.getRowsNum()-1), (grid.getColumnCount()-1)).isDisabled()){
					grid._key_events["k9_0_1"].call(grid);
				}
				this.blur();
				return false;
			}
		};
		if(_isOpera) this.tabEnd.onkeypress = this.tabEnd.onkeydown;
	},
	/**
	*   @desc: returns unique ID
	*   @type:  public
	*/	
	uid:function(){
		if (!this._ui_seed) this._ui_seed=(new Date()).valueOf();
		return this._ui_seed++;
	},
	setIconset:function(name){
		this.iconset = name;
	},
	/**
	*   @desc: clears existing grid state and load new XML
	*   @type:  public
	*/
	clearAndLoad:function(){
		if (this._last_load_request){
			//abort last loading if new issued
			var last = this._last_load_request.xmlDoc;
			if (last.readyState != 4){
				try{
					last.onreadystatechange = function(){};
					last.abort();
				} catch(e){}
			}
		};

		var t=this._pgn_skin; this._pgn_skin=null;
		this.clearAll();
		this._pgn_skin=t;
		this._last_load_request = this.load.apply(this,arguments);
	},
	/**
	*   @desc: returns details about current grid state
	*   @type:  public
	*/
	getStateOfView:function(){
		if (this.pagingOn){
			var start = (this.currentPage-1)*this.rowsBufferOutSize;
			return [this.currentPage, start, Math.min(start+this.rowsBufferOutSize,this.rowsBuffer.length), this.rowsBuffer.length ];
		}
 		return [
 			Math.floor(this.objBox.scrollTop/this._srdh),
			Math.ceil(parseInt(this.objBox.offsetHeight)/this._srdh),
			this.rowsBuffer.length
		];
	}
};

//grid
(function(){
		//local helpers
		function direct_set(name,value){ this[name]=value; 	}
		function direct_call(name,value){ this[name].call(this,value); 	}
		function joined_call(name,value){ this[name].call(this,value.join(this.delim));  }
		function set_options(name,value){
			for (var i=0; i < value.length; i++) 
			if (typeof value[i] == "object"){
				var combo = this.getCombo(i);
				for (var key in value[i])
					combo.put(key, value[i][key]);
			}
		}
		function header_set(name,value,obj){
			//make a matrix
			var rows = 1;
			var header = [];
			function add(i,j,value){
				if (!header[j]) header[j]=[];
				if (typeof value == "object") value.toString=function(){ return this.text; }
				header[j][i]=value;
			}
			
			for (var i=0; i<value.length; i++) {
				if (typeof(value[i])=="object" && value[i].length){
					for (var j=0; j < value[i].length; j++)
						add(i,j,value[i][j]);		
				} else
				add(i,0,value[i]);		
			}
			for (var i=0; i<header.length; i++)
			for (var j=0; j<header[0].length; j++){
				var h=header[i][j];
				header[i][j]=(h||"").toString()||"&nbsp;";
				if (h&&h.colspan)
					for (var k=1; k < h.colspan; k++) add(j+k,i,"#cspan");
				if (h&&h.rowspan)
					for (var k=1; k < h.rowspan; k++) add(j,i+k,"#rspan");
			}
			
			this.setHeader(header[0]);
			for (var i=1; i < header.length; i++) 
				this.attachHeader(header[i]);
		}
		
		//defenitions
		var columns_map=[
			{name:"label", 	def:"&nbsp;", 	operation:"setHeader",		type:header_set		},
			{name:"id", 	def:"", 		operation:"columnIds",		type:direct_set		},
			{name:"width", 	def:"*", 		operation:"setInitWidths", 	type:joined_call	},
			{name:"align", 	def:"left", 	operation:"cellAlign",		type:direct_set		},
			{name:"valign", def:"middle", 	operation:"cellVAlign",		type:direct_set		},
			{name:"sort", 	def:"na", 		operation:"fldSort",		type:direct_set		},
			{name:"type", 	def:"ro", 		operation:"setColTypes",	type:joined_call	},
			{name:"options",def:"", 		operation:"",				type:set_options	}
		];
		
		//extending	
		dhtmlx.extend_api("dhtmlXGridObject",{
				_init:function(obj){
					return [obj.parent];
				},
				image_path:"setImagePath",
				columns:"columns",
				rows:"rows",
				headers:"headers",
				skin:"setSkin",
				smart_rendering:"enableSmartRendering",
				css:"enableAlterCss",
				auto_height:"enableAutoHeight",
				save_hidden:"enableAutoHiddenColumnsSaving",
				save_cookie:"enableAutoSaving",
				save_size:"enableAutoSizeSaving",
				auto_width:"enableAutoWidth",
				block_selection:"enableBlockSelection",
				csv_id:"enableCSVAutoID",
				csv_header:"enableCSVHeader",
				cell_ids:"enableCellIds",
				colspan:"enableColSpan",
				column_move:"enableColumnMove",
				context_menu:"enableContextMenu",
				distributed:"enableDistributedParsing",
				drag:"enableDragAndDrop",
				drag_order:"enableDragOrder",
				tabulation:"enableEditTabOnly",
				header_images:"enableHeaderImages",
				header_menu:"enableHeaderMenu",
				keymap:"enableKeyboardSupport",
				mouse_navigation:"enableLightMouseNavigation",
				markers:"enableMarkedCells",
				math_editing:"enableMathEditing",
				math_serialization:"enableMathSerialization",
				drag_copy:"enableMercyDrag",
				multiline:"enableMultiline",
				multiselect:"enableMultiselect",
				save_column_order:"enableOrderSaving",
				hover:"enableRowsHover",
				rowspan:"enableRowspan",
				smart:"enableSmartRendering",
				save_sorting:"enableSortingSaving",
				stable_sorting:"enableStableSorting",
				undo:"enableUndoRedo",
				csv_cell:"setCSVDelimiter",
				date_format:"setDateFormat",
				drag_behavior:"setDragBehavior",
				editable:"setEditable",
				without_header:"setNoHeader",
				submit_changed:"submitOnlyChanged",
				submit_serialization:"submitSerialization",
				submit_selected:"submitOnlySelected",
				submit_id:"submitOnlyRowID",		
				xml:"load"
		},{
			columns:function(obj){
				for (var j=0; j<columns_map.length; j++){
					var settings = [];
					for (var i=0; i<obj.length; i++)
						settings[i]=obj[i][columns_map[j].name]||columns_map[j].def;
					var type=columns_map[j].type||direct_call;
					type.call(this,columns_map[j].operation,settings,obj);
				}
				this.init();
			},
			rows:function(obj){
				
			},
			headers:function(obj){
				for (var i=0; i < obj.length; i++) 
					this.attachHeader(obj[i]);
			}
		});
		
})();


dhtmlXGridObject.prototype._dp_init=function(dp){
	dp.attachEvent("insertCallback", function(upd, id) {
			if (this.obj._h2)
				this.obj.addRow(id, row, null, parent);
			else
				this.obj.addRow(id, [], 0);
			
			var row = this.obj.getRowById(id);
			if (row){
				this.obj._process_xml_row(row, upd.firstChild);
				this.obj._postRowProcessing(row);	
			}
	});
	dp.attachEvent("updateCallback", function(upd, id) {
			var row = this.obj.getRowById(id);
			if (row){
				this.obj._process_xml_row(row, upd.firstChild);
				this.obj._postRowProcessing(row);	
			}
	});
	dp.attachEvent("deleteCallback", function(upd, id) {
			this.obj.setUserData(id, this.action_param, "true_deleted");
			this.obj.deleteRow(id);
	});
	
	
	dp._methods=["setRowTextStyle","setCellTextStyle","changeRowId","deleteRow"];
	this.attachEvent("onEditCell",function(state,id,index){
			if (dp._columns && !dp._columns[index]) return true;
			var cell = this.cells(id,index)
			if (state==1){
				if(cell.isCheckbox()){
					dp.setUpdated(id,true)
				}
			} else if (state==2){
				if(cell.wasChanged()){
					dp.setUpdated(id,true)
				}
			}
			return true;
	});
	this.attachEvent("onRowPaste",function(id){
			dp.setUpdated(id,true)
	});
	this.attachEvent("onUndo",function(id){
			dp.setUpdated(id,true)
	});
	this.attachEvent("onRowIdChange",function(id,newid){
			var ind=dp.findRow(id);
			if (ind<dp.updatedRows.length)
				dp.updatedRows[ind]=newid;
	});
	this.attachEvent("onSelectStateChanged",function(rowId){
			if(dp.updateMode=="row")
				dp.sendData();
			return true;
	});
	this.attachEvent("onEnter",function(rowId,celInd){
			if(dp.updateMode=="row")
				dp.sendData();
			return true;
	});
	this.attachEvent("onBeforeRowDeleted",function(rowId){
			if (dp._silent_mode || (!this.rowsAr[rowId])) return true;
			if (this.dragContext && dp.dnd) {
				window.setTimeout(function(){
						dp.setUpdated(rowId,true);
				},1);
				return true;
			}
			var z=dp.getState(rowId);
			if (this._h2){
				this._h2.forEachChild(rowId,function(el){
						dp.setUpdated(el.id,false);
						dp.markRow(el.id,true,"deleted");
				},this);
			}
			if (z=="inserted") {  dp.set_invalid(rowId,false); dp.setUpdated(rowId,false);		return true; }
			if (z=="deleted")  return false;
			if (z=="true_deleted")  { dp.setUpdated(rowId,false); return true; }
			
			dp.setUpdated(rowId,true,"deleted");
			return false;
	});
	this.attachEvent("onBindUpdate", function(data, key, id){
		dp.setUpdated(id, true);
	});
	this.attachEvent("onRowAdded",function(rowId){
			if (this.dragContext && dp.dnd) return true;
			dp.setUpdated(rowId,true,"inserted")
			return true;
	});
	dp._getRowData=function(rowId,pref){
		var data = [];
		
		data["gr_id"]=rowId;
		if (this.obj.isTreeGrid())
			data["gr_pid"]=this.obj.getParentId(rowId);
		
		var r=this.obj.getRowById(rowId);
		for (var i=0; i<this.obj._cCount; i++){
			if (this.obj._c_order)
		   		var i_c=this.obj._c_order[i];
		   	else
			   	var i_c=i;
			
			var c=this.obj.cells(r.idd,i);
			if (this._changed && !c.wasChanged()) continue;
			if (this._endnm)
				data[this.obj.getColumnId(i)]=c.getValue();
			else
				data["c"+i_c]=c.getValue();
		}
		
		var udata=this.obj.UserData[rowId];
		if (udata){
			for (var j=0; j<udata.keys.length; j++)
				if (udata.keys[j] && udata.keys[j].indexOf("__")!=0)
				data[udata.keys[j]]=udata.values[j];
		}
		var udata=this.obj.UserData["gridglobaluserdata"];
		if (udata){
			for (var j=0; j<udata.keys.length; j++)
				data[udata.keys[j]]=udata.values[j];
		}
		return data;
	};
	dp._clearUpdateFlag=function(rowId){
		var row=this.obj.getRowById(rowId);
		if (row)
			for (var j=0; j<this.obj._cCount; j++)
			this.obj.cells(rowId,j).cell.wasChanged=false;	//using cells because of split
	};
	dp.checkBeforeUpdate=function(rowId){ 
		var valid=true; var c_invalid=[];
		for (var i=0; i<this.obj._cCount; i++)
		if (this.mandatoryFields[i]){
			var res=this.mandatoryFields[i].call(this.obj,this.obj.cells(rowId,i).getValue(),rowId,i);
			if (typeof res == "string"){
				this.messages.push(res);
				valid = false;
			} else {
				valid&=res;
				c_invalid[i]=!res;
			}
		}
		if (!valid){
			this.set_invalid(rowId,"invalid",c_invalid);
			this.setUpdated(rowId,false);
		}
		return valid;
	};	
};


dhx4.attachEvent("onGridCreated", function(grid){
		//make separate config array for each grid
		grid._con_f_used = [].concat(grid._con_f_used);
		dhtmlXGridObject.prototype._con_f_used=[];
		
		var clear_url=function(url){
			url=url.replace(/(\?|\&)connector[^\f]*/g,"");
			return url+(url.indexOf("?")!=-1?"&":"?")+"connector=true"+(this.hdr.rows.length > 0 ? "&dhx_no_header=1":"");
		};
		var combine_urls=function(url){
			return clear_url.call(this,url)+(this._connector_sorting||"")+(this._connector_filter||"");
		};
		var sorting_url=function(url,ind,dir){
			this._connector_sorting="&dhx_sort["+ind+"]="+dir;
			return combine_urls.call(this,url);
		};
		var filtering_url=function(url,inds,vals){
			var chunks = [];
			for (var i=0; i<inds.length; i++)
				chunks[i]="dhx_filter["+inds[i]+"]="+encodeURIComponent(vals[i]);
			this._connector_filter="&"+chunks.join("&");
			return combine_urls.call(this,url);
		};
		grid.attachEvent("onCollectValues",function(ind){
				if (this._con_f_used[ind]){
					if (typeof(this._con_f_used[ind]) == "object")
						return this._con_f_used[ind];
					else
						return false;
				}
				return true;
		});	
		grid.attachEvent("onDynXLS",function(){
				if (this.xmlFileUrl)
					this.xmlFileUrl=combine_urls.call(this,this.xmlFileUrl);
				return true;
		});				
		grid.attachEvent("onBeforeSorting",function(ind,type,dir){
				if (type=="connector"){
					var self=this;
					this.clearAndLoad(sorting_url.call(this,this.xmlFileUrl,ind,dir),function(){
							self.setSortImgState(true,ind,dir);
					});
					return false;
				}
				return true;
		});
		grid.attachEvent("onFilterStart",function(a,b){
				if (this._con_f_used.length){
					var ss = this.getSortingState();
					var self=this;
					this.clearAndLoad(filtering_url.call(this,this.xmlFileUrl,a,b));
					if (ss.length)
						self.setSortImgState(true,ss[0],ss[1]);
					return false;
				}
				return true;
		});
});

dhtmlXGridObject.prototype._con_f_used=[];
dhtmlXGridObject.prototype._in_header_connector_text_filter=function(t,i){
	if (!this._con_f_used[i])
		this._con_f_used[i]=1;
	return this._in_header_text_filter(t,i);
};
dhtmlXGridObject.prototype._in_header_connector_select_filter=function(t,i){
	if (!this._con_f_used[i])
		this._con_f_used[i]=2;
	return this._in_header_select_filter(t,i);
};

if (!dhtmlXGridObject.prototype.load_connector){
	
	dhtmlXGridObject.prototype.load_connector=dhtmlXGridObject.prototype.load;
	dhtmlXGridObject.prototype.load=function(url, call, type){
		if (!this._colls_loaded && this.cellType){
			var ar=[];
			for (var i=0; i < this.cellType.length; i++)
				if (this.cellType[i].indexOf("co")==0 || this.cellType[i].indexOf("clist")==0 || this._con_f_used[i]==2) ar.push(i);
			if (ar.length)
				arguments[0]+=(arguments[0].indexOf("?")!=-1?"&":"?")+"connector=true&dhx_colls="+ar.join(",");
		}
		return this.load_connector.apply(this,arguments);
	};
	dhtmlXGridObject.prototype._parseHead_connector=dhtmlXGridObject.prototype._parseHead;
	dhtmlXGridObject.prototype._parseHead=function(url, call, type){
		this._parseHead_connector.apply(this,arguments);
		if (!this._colls_loaded){
			var cols = dhx4.ajax.xpath("./coll_options", arguments[0]);
			for (var i=0; i < cols.length; i++){
				var f = cols[i].getAttribute("for");
				var v = [];
				var combo=null;
				if (this.cellType[f] == "combo")
					combo = this.getColumnCombo(f);
				else if (this.cellType[f].indexOf("co")==0)
					combo=this.getCombo(f);
				
				var os = dhx4.ajax.xpath("./item",cols[i]);
				var opts = [];
				for (var j=0; j<os.length; j++){
					var val=os[j].getAttribute("value");
					
					if (combo){
						var lab=os[j].getAttribute("label")||val;
						
						if (combo.addOption)
							opts.push([val, lab]);
						else
							combo.put(val,lab);
						
						v[v.length]=lab;
					} else
					v[v.length]=val;
				}
				if (opts.length){
					if (combo)
						combo.addOption(opts);
				} else if (v.length && !combo)
				if (this.registerCList)
					this.registerCList(f*1, v);
				
				
				if (this._con_f_used[f*1])
					this._con_f_used[f*1]=v;
			}
			this._colls_loaded=true;
		}
	};
	
}	

//(c)dhtmlx ltd. www.dhtmlx.com

/**
*	@desc: dhtmlxGrid cell object constructor (shouldn't be accesed directly. Use cells and cells2 methods of the grid instead)
*	@type: cell
*	@returns: dhtmlxGrid cell
*/
function dhtmlXGridCellObject(obj){
	/**
	*	@desc: desctructor, clean used memory
	*	@type: public
	*/
	this.destructor=function(){
		this.cell.obj=null;
		this.cell=null;
		this.grid=null;
		this.base=null;
		return null;
	}
	this.cell=obj;
	/**
	*	@desc: gets Value of cell
	*	@type: public
	*/
	this.getValue=function(){
		if ((this.cell.textContent)&&(this.cell.textContent.tagName == "TEXTAREA"))
			return this.cell.textContent.value;
		else
			return this.cell.innerHTML._dhx_trim(); //innerText;
	}

	/**
	*	@desc: gets math formula of cell if any
	*	@type: public
	*/
	this.getMathValue=function(){
		if (this.cell.original)
			return this.cell.original; //innerText;
		else
			return this.getValue();
	}
	
//#excell_methods:04062008{
	/**
	*	@desc: determ. font style if it was set
	*	@returns: font name only if it was set for the cell
	*	@type: public
	*/
	this.getFont=function(){
		arOut=new Array(3);

		if (this.cell.style.fontFamily)
			arOut[0]=this.cell.style.fontFamily

		if (this.cell.style.fontWeight == 'bold'||this.cell.parentNode.style.fontWeight == 'bold')
			arOut[1]='bold';

		if (this.cell.style.fontStyle == 'italic'||this.cell.parentNode.style.fontWeight == 'italic')
			arOut[1]+='italic';

		if (this.cell.style.fontSize)
			arOut[2]=this.cell.style.fontSize
		else
			arOut[2]="";
		return arOut.join("-")
	}
	/**
	*	@desc: determ. cell's text color
	*	@returns: cell's text color
	*	@type: public
	*/
	this.getTextColor=function(){
		if (this.cell.style.color)
			return this.cell.style.color
		else
			return "#000000";
	}
	/**
	*	@desc: determ. cell's background color
	*	@returns: cell's background color
	*	@type: public
	*/
	this.getBgColor=function(){
		return this.cell.style.backgroundColor || "#FFFFFF";
	}
	/**
	*	@desc: determines horisontal align od the cell
	*	@returns: horisontal align of cell content
	*	@type: public
	*/
	this.getHorAlign=function(){
		if (this.cell.style.textAlign)
			return this.cell.style.textAlign;

		else if (this.cell.style.textAlign)
			return this.cell.style.textAlign;

		else
			return "left";
	}
	/**
	*	@desc: gets width of the cell in pixel
	*	@returns: width of the cell in pixels
	*	@type: public
	*/
	this.getWidth=function(){
		return this.cell.scrollWidth;
	}

	/**
	*	@desc: sets font family to the cell
	*	@param: val - string in format: Arial-bold(italic,bolditalic,underline)-12px
	*	@type: public
	*/
	this.setFont=function(val){
		fntAr=val.split("-");
		this.cell.style.fontFamily=fntAr[0];
		this.cell.style.fontSize=fntAr[fntAr.length-1]

		if (fntAr.length == 3){
			if (/bold/.test(fntAr[1]))
				this.cell.style.fontWeight="bold";

			if (/italic/.test(fntAr[1]))
				this.cell.style.fontStyle="italic";

			if (/underline/.test(fntAr[1]))
				this.cell.style.textDecoration="underline";
		}
	}
	/**
	*	@desc: sets text color to the cell
	*	@param: val - color value (name or hex)
	*	@type: public
	*/
	this.setTextColor=function(val){
		this.cell.style.color=val;
	}
	/**
	*	@desc: sets background color to the cell
	*	@param: val - color value (name or hex)
	*	@type: public
	*/
	this.setBgColor=function(val){
		if (val == "")
			val=null;
		this.cell.style.background=val;
	}
	/**
	*	@desc: sets horisontal align to the cell
	*	@param: val - value in single-letter or full format(exmp: r or right)
	*	@type: public
	*/
	this.setHorAlign=function(val){
		if (val.length == 1){
			if (val == 'c')
				this.cell.style.textAlign='center'

			else if (val == 'l')
				this.cell.style.textAlign='left';

			else
				this.cell.style.textAlign='right';
		} else
			this.cell.style.textAlign=val
	}
//#}
	/**
	*	@desc: determines whether cell value was changed
	*	@returns: true if cell value was changed, otherwise - false
	*	@type: public
	*/
	this.wasChanged=function(){
		if (this.cell.wasChanged)
			return true;
		else
			return false;
	}
	/**
	*	@desc: determines whether first child of the cell is checkbox or radio
	*	@returns: true if first child of the cell is input element of type radio or checkbox
	*	@type: deprecated
	*/
	this.isCheckbox=function(){
		var ch = this.cell.firstChild;

		if (ch&&ch.tagName == 'INPUT'){
			type=ch.type;

			if (type == 'radio'||type == 'checkbox')
				return true;
			else
				return false;
		} else
			return false;
	}
	/**
	*	@desc: determines whether radio or checkbox inside is checked
	*	@returns: true if first child of the cell is checked
	*	@type: public
	*/
	this.isChecked=function(){
		if (this.isCheckbox()){
			return this.cell.firstChild.checked;
		}
	}
	/**
	*	@desc: determines whether cell content (radio,checkbox) is disabled
	*	@returns: true if first child of the cell is disabled
	*	@type: public
	*/
	this.isDisabled=function(){
		return this.cell._disabled;
	}
	/**
	*	@desc: checks checkbox or radion
	*	@param: fl - true or false
	*	@type: public
	*/
	this.setChecked=function(fl){
		if (this.isCheckbox()){
			if (fl != 'true'&&fl != 1)
				fl=false;
			this.cell.firstChild.checked=fl;
		}
	}
	/**
	*	@desc: disables radio or checkbox
	*	@param: fl - true or false
	*	@type: public
	*/
	this.setDisabled=function(fl){
		if (fl != 'true'&&fl != 1)
			fl=false;

		if (this.isCheckbox()){
			this.cell.firstChild.disabled=fl;

			if (this.disabledF)
				this.disabledF(fl);
		}
		this.cell._disabled=fl;
	}
}

dhtmlXGridCellObject.prototype={
	getAttribute: function(name){
		return this.cell._attrs[name];
	},
	setAttribute: function(name, value){
		this.cell._attrs[name]=value;
	},
	getInput:function(){
		if (this.obj && (this.obj.tagName=="INPUT" || this.obj.tagName=="TEXTAREA")) return this.obj;
		
		var inps=(this.obj||this.cell).getElementsByTagName("TEXTAREA");
		if (!inps.length)
			inps=(this.obj||this.cell).getElementsByTagName("INPUT");
		return inps[0];
	}
}

/**
*	@desc: sets value to the cell
*	@param: val - new value
*	@type: public
*/
dhtmlXGridCellObject.prototype.setValue=function(val){
	if (( typeof (val) != "number")&&(!val||val.toString()._dhx_trim() == "")){
		val="&nbsp;"
		this.cell._clearCell=true;
	} else
		this.cell._clearCell=false;
	this.setCValue(val);
}
/**
*	@desc: sets value to the cell
*	@param: val - new value
*	@param: val2
*	@type: private
*/
dhtmlXGridCellObject.prototype.getTitle=function(){
	return (_isIE ? this.cell.innerText : this.cell.textContent);
}

dhtmlXGridCellObject.prototype.setCValue=function(val, val2){
	this.cell.innerHTML=val;
//#__pro_feature:21092006{
//#on_cell_changed:23102006{
	this.grid.callEvent("onCellChanged", [
		this.cell.parentNode.idd,
		this.cell._cellIndex,
		(arguments.length > 1 ? val2 : val)
	]);
//#}
//#}
}

dhtmlXGridCellObject.prototype.setCTxtValue=function(val){
	this.cell.innerHTML="";
	this.cell.appendChild(document.createTextNode(val));
//#__pro_feature:21092006{	
//#on_cell_changed:23102006{
	this.grid.callEvent("onCellChanged", [
		this.cell.parentNode.idd,
		this.cell._cellIndex,
		val
	]);
//#}
//#}
}

/**
*	@desc: sets text representation of cell which contains math formula ( setLabel doesn't triger math calculations as setValue do)
*	@param: val - new value
*	@type: public
*/
dhtmlXGridCellObject.prototype.setLabel=function(val){
	this.cell.innerHTML=val;
}

/**
*	@desc: get formula of ExCell ( actual only for math based exCells )
*	@type: public
*/
dhtmlXGridCellObject.prototype.getMath=function(){
	if (this._val)
		return this.val;
	else
		return this.getValue();
}

/**
*	@desc: dhtmlxGrid cell editor constructor (base for all eXcells). Shouldn't be accessed directly
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell(){
	this.obj=null; //editor
	//this.cell = null//cell to get value from
	this.val=null; //current value (before edit)
	/**
	*	@desc: occures on space for example 
	*	@type: private
	*/
	this.changeState=function(){
		return false
	}
	/**
	*	@desc: opens editor
	*	@type: private
	*/
	this.edit=function(){
		this.val=this.getValue()
	} //
	/**
	*	@desc: return value to cell, closes editor
	*	@returns: if cell's value was changed (true) or not
	*	@type: private
	*/
	this.detach=function(){
		return false
	} //
	/**
	*	@desc: gets position (left-right) of element
	*	@param: oNode - element to get position of
	*	@type: private
	*	@topic: 8
	*/
	this.getPosition=function(oNode){
		var oCurrentNode = oNode;
		var iLeft = 0;
		var iTop = 0;

		while (oCurrentNode.tagName != "BODY"){
			iLeft+=oCurrentNode.offsetLeft;
			iTop+=oCurrentNode.offsetTop;
			oCurrentNode=oCurrentNode.offsetParent;
		}
		return new Array(iLeft, iTop);
	}
}
eXcell.prototype=new dhtmlXGridCellObject;


/**
*	@desc: simple text editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_ed(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.edit=function(){
		this.cell.atag=(!this.grid.multiLine) ? "INPUT" : "TEXTAREA";
		this.val=this.getValue();
		this.obj=document.createElement(this.cell.atag);
		this.obj.setAttribute("autocomplete", "off");
		this.obj.style.height=(this.cell.offsetHeight-(this.grid.multiLine ? 9 : 4))+"px";
		
		this.obj.className="dhx_combo_edit";
		this.obj.wrap="soft";
		this.obj.style.textAlign=this.cell.style.textAlign;
		this.obj.onclick=function(e){
			(e||event).cancelBubble=true
		}
		this.obj.onmousedown=function(e){
			(e||event).cancelBubble=true
		}
		this.obj.value=this.val
		this.cell.innerHTML="";
		this.cell.appendChild(this.obj);

		this.obj.onselectstart=function(e){
			if (!e)
				e=event;
			e.cancelBubble=true;
			return true;
		};
		if (_isIE){
			this.obj.focus();
			this.obj.blur();
		}
		this.obj.focus();
	}
	this.getValue=function(){
		if ((this.cell.firstChild)&&((this.cell.atag)&&(this.cell.firstChild.tagName == this.cell.atag)))
			return this.cell.firstChild.value;

		if (this.cell._clearCell)
			return "";

		return this.cell.innerHTML.toString()._dhx_trim();
	}

	this.detach=function(){
		this.setValue(this.obj.value);
		return this.val != this.getValue();
	}
}
eXcell_ed.prototype=new eXcell;

/**
*	@desc: pure text editor ( HTML not supported )
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_edtxt(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.getValue=function(){
		if ((this.cell.firstChild)&&((this.cell.atag)&&(this.cell.firstChild.tagName == this.cell.atag)))
			return this.cell.firstChild.value;

		if (this.cell._clearCell)
			return "";

		return (_isIE ? this.cell.innerText : this.cell.textContent);
	}
	this.setValue=function(val){
		if (!val||val.toString()._dhx_trim() == ""){
			val=" ";
			this.cell._clearCell=true;
		} else
			this.cell._clearCell=false;
		this.setCTxtValue(val);
	}
}
eXcell_edtxt.prototype=new eXcell_ed;
//#__pro_feature:21092006{
/**
*	@desc: simple numeric text editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*	@edition: professional
*/
function eXcell_edn(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.getValue=function(){
		//this.grid.editStop();
		if ((this.cell.firstChild)&&(this.cell.firstChild.tagName == "TEXTAREA"))
			return this.cell.firstChild.value;

		if (this.cell._clearCell)
			return "";

		return this.cell._orig_value||this.grid._aplNFb(this.cell.innerHTML.toString()._dhx_trim(), this.cell._cellIndex);
	}

	this.detach=function(){
		var tv = this.obj.value;
		this.setValue(tv);
		return this.val != this.getValue();
	}
}
eXcell_edn.prototype=new eXcell_ed;
eXcell_edn.prototype.setValue=function(val){ 
	if (!val||val.toString()._dhx_trim() == ""){
		this.cell._clearCell=true;
		return this.setCValue("&nbsp;",0);
	} else {
		this.cell._clearCell=false;
		this.cell._orig_value = val;
	}
	this.setCValue(this.grid._aplNF(val, this.cell._cellIndex), val);
}
//#}

//#ch_excell:04062008{
/**
*	@desc: checkbox editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_ch(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}

	this.disabledF=function(fl){
		if ((fl == true)||(fl == 1))
			this.cell.innerHTML=this.cell.innerHTML.replace("item_chk0.", "item_chk0_dis.").replace("item_chk1.",
				"item_chk1_dis.");
		else
			this.cell.innerHTML=this.cell.innerHTML.replace("item_chk0_dis.", "item_chk0.").replace("item_chk1_dis.",
				"item_chk1.");
	}

	this.changeState=function(fromClick){
		//nb:
		if (fromClick===true && !this.grid.isActive) {
			if (window.globalActiveDHTMLGridObject != null && window.globalActiveDHTMLGridObject != this.grid && window.globalActiveDHTMLGridObject.isActive) window.globalActiveDHTMLGridObject.setActive(false);
			this.grid.setActive(true);
		}
		if ((!this.grid.isEditable)||(this.cell.parentNode._locked)||(this.isDisabled()))
			return;

		if (this.grid.callEvent("onEditCell", [
			0,
			this.cell.parentNode.idd,
			this.cell._cellIndex
		])){
			this.val=this.getValue()

			if (this.val == "1")
				this.setValue("0")
			else
				this.setValue("1")

			this.cell.wasChanged=true;
			//nb:
			this.grid.callEvent("onEditCell", [
				1,
				this.cell.parentNode.idd,
				this.cell._cellIndex
			]);

			this.grid.callEvent("onCheckbox", [
				this.cell.parentNode.idd,
				this.cell._cellIndex,
				(this.val != '1')
			]);

			this.grid.callEvent("onCheck", [
				this.cell.parentNode.idd,
				this.cell._cellIndex,
				(this.val != '1')
			]);
		} else { //preserve editing (not tested thoroughly for this editor)
			this.editor=null;
		}
	}
	this.getValue=function(){
		return this.cell.chstate ? this.cell.chstate.toString() : "0";
	}

	this.isCheckbox=function(){
		return true;
	}
	this.isChecked=function(){
		if (this.getValue() == "1")
			return true;
		else
			return false;
	}

	this.setChecked=function(fl){
		this.setValue(fl.toString())
	}
	this.detach=function(){
		return this.val != this.getValue();
	}
	this.edit=null;
}
eXcell_ch.prototype=new eXcell;
eXcell_ch.prototype.setValue=function(val){
	this.cell.style.verticalAlign="middle"; //nb:to center checkbox in line
	//val can be int
	if (val){
		val=val.toString()._dhx_trim();

		if ((val == "false")||(val == "0"))
			val="";
	}

	if (val){
		val="1";
		this.cell.chstate="1";
	} else {
		val="0";
		this.cell.chstate="0"
	}
	var obj = this;
	this.cell.setAttribute("excell", "ch");
	this.setCValue("<img src='"+this.grid.imgURL+"item_chk"+val
		+".gif' onclick='new eXcell_ch(this.parentNode).changeState(true); (arguments[0]||event).cancelBubble=true; '>",
		this.cell.chstate);
}
//#}
//#ra_excell:04062008{
/**
*	@desc: radio editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_ra(cell){
	this.base=eXcell_ch;
	this.base(cell)
	this.grid=cell.parentNode.grid;

	this.disabledF=function(fl){
		if ((fl == true)||(fl == 1))
			this.cell.innerHTML=this.cell.innerHTML.replace("radio_chk0.", "radio_chk0_dis.").replace("radio_chk1.",
				"radio_chk1_dis.");
		else
			this.cell.innerHTML=this.cell.innerHTML.replace("radio_chk0_dis.", "radio_chk0.").replace("radio_chk1_dis.",
				"radio_chk1.");
	}

	this.changeState=function(mode){
		if (mode===false && this.getValue()==1) return;

		if ((!this.grid.isEditable)||(this.cell.parentNode._locked)||(this.isDisabled()))
			return;

		if (this.grid.callEvent("onEditCell", [
			0,
			this.cell.parentNode.idd,
			this.cell._cellIndex
		]) != false){
			this.val=this.getValue()

			if (this.val == "1")
				this.setValue("0")
			else
				this.setValue("1")
			this.cell.wasChanged=true;
			//nb:
			this.grid.callEvent("onEditCell", [
				1,
				this.cell.parentNode.idd,
				this.cell._cellIndex
			]);

			this.grid.callEvent("onCheckbox", [
				this.cell.parentNode.idd,
				this.cell._cellIndex,
				(this.val != '1')
			]);

			this.grid.callEvent("onCheck", [
				this.cell.parentNode.idd,
				this.cell._cellIndex,
				(this.val != '1')
			]);
		} else { //preserve editing (not tested thoroughly for this editor)
			this.editor=null;
		}
	}
	this.edit=null;
}
eXcell_ra.prototype=new eXcell_ch;
eXcell_ra.prototype.setValue=function(val){
	this.cell.style.verticalAlign="middle"; //nb:to center checkbox in line

	if (val){
		val=val.toString()._dhx_trim();

		if ((val == "false")||(val == "0"))
			val="";
	}

	if (val){
		if (!this.grid._RaSeCol)
			this.grid._RaSeCol=[];

		if (this.grid._RaSeCol[this.cell._cellIndex]){
			var z = this.grid.cells(this.grid._RaSeCol[this.cell._cellIndex], this.cell._cellIndex);
			z.setValue("0")
			if (this.grid.rowsAr[z.cell.parentNode.idd])
			this.grid.callEvent("onEditCell", [
				1,
				z.cell.parentNode.idd,
				z.cell._cellIndex
			]);
		}

		this.grid._RaSeCol[this.cell._cellIndex]=this.cell.parentNode.idd;

		val="1";
		this.cell.chstate="1";
	} else {
		val="0";
		this.cell.chstate="0"
	}
	this.cell.setAttribute("excell", "ra");
	this.setCValue("<img src='"+this.grid.imgURL+"radio_chk"+val+".gif' onclick='new eXcell_ra(this.parentNode).changeState(false);'>",
		this.cell.chstate);
}
//#}
//#txt_excell:04062008{
/**
*	@desc: multilene popup editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_txt(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.edit=function(){
		this.val=this.getValue()
		this.obj=document.createElement("TEXTAREA");
		this.obj.className="dhx_textarea";

		this.obj.onclick=function(e){
			(e||event).cancelBubble=true
		}
		var arPos = this.grid.getPosition(this.cell); //,this.grid.objBox

		this.obj.value=this.val;

		this.obj.style.display="";
		this.obj.style.textAlign=this.cell.style.textAlign;

		document.body.appendChild(this.obj); //nb:
		if(_isOpera) this.obj.onkeypress=function(ev){ if (ev.keyCode == 9||ev.keyCode == 27) return false; }
		this.obj.onkeydown=function(e){
			var ev = (e||event);

			if (ev.keyCode == 9||ev.keyCode == 27){
				globalActiveDHTMLGridObject.entBox.focus();
				globalActiveDHTMLGridObject.doKey({
					keyCode: ev.keyCode,
					shiftKey: ev.shiftKey,
					srcElement: "0"
					});

				return false;
			}
		}

		this.obj.style.left=arPos[0]+"px";
		this.obj.style.top=arPos[1]+this.cell.offsetHeight+"px";

		if (this.cell.offsetWidth < 200)
			var pw = 200;
		else
			var pw = this.cell.offsetWidth;
		this.obj.style.width=pw+16+"px"

		if (_isIE) { this.obj.select(); this.obj.value=this.obj.value; }//dzen of IE
		this.obj.focus()
	}
	this.detach=function(){
		var a_val = "";

		a_val=this.obj.value;

		if (a_val == ""){
			this.cell._clearCell=true;
		}
		else
			this.cell._clearCell=false;
		this.setValue(a_val);
		document.body.removeChild(this.obj);
		this.obj=null;
		return this.val != this.getValue();
	}
	this.getValue=function(){
		if (this.obj){
			return this.obj.value;
		}
				
		if (this.cell._clearCell)
			return "";

		if (typeof this.cell._brval != "undefined") return this.cell._brval;

		if ((!this.grid.multiLine))
			return this.cell._brval||this.cell.innerHTML;
		else
			return this.cell._brval||this.cell.innerHTML.replace(/<br[^>]*>/gi, "\n")._dhx_trim(); //innerText;
	}
}

eXcell_txt.prototype=new eXcell;

/**
*	@desc: multiline text editor without HTML support
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_txttxt(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.getValue=function(){
		if ((this.cell.firstChild)&&(this.cell.firstChild.tagName == "TEXTAREA"))
			return this.cell.firstChild.value;

		if (this.cell._clearCell)
			return "";

		if ((!this.grid.multiLine)&&this.cell._brval)
			return this.cell._brval;

		return (_isIE ? this.cell.innerText : this.cell.textContent);
	}
	this.setValue=function(val){
		this.cell._brval=val;

		if (!val||val.toString()._dhx_trim() == ""){
			val=" ";
			this.cell._clearCell=true;
		} else
			this.cell._clearCell=false;
		this.setCTxtValue(val);
	}
}

eXcell_txttxt.prototype=new eXcell_txt;

eXcell_txt.prototype.setValue=function(val){
	this.cell._brval=val;

	if (!val||val.toString()._dhx_trim() == ""){
		val="&nbsp;"
		this.cell._clearCell=true;
	} else
		this.cell._clearCell=false;

	if ((!this.grid.multiLine) || this.cell._clearCell)
		this.setCValue(val, this.cell._brval);
	else
		this.setCValue(val.replace(/\n/g, "<br/>"), val);
}
//#}
//#co_excell:04062008{
/**
*	@desc: combobox editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_co(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
		this.combo=(this.cell._combo||this.grid.getCombo(this.cell._cellIndex));
		this.editable=true
	}
	this.shiftNext=function(){
		var z = this.list.options[this.list.selectedIndex+1];

		if (z)
			z.selected=true;
		this.obj.value=this.list.options[this.list.selectedIndex].text;

		return true;
	}
	this.shiftPrev=function(){
		if (this.list.selectedIndex != 0){
			var z = this.list.options[this.list.selectedIndex-1];

			if (z)
				z.selected=true;
			this.obj.value=this.list.options[this.list.selectedIndex].text;
		}

		return true;
	}

	this.edit=function(){
		this.val=this.getValue();
		this.text=this.getText()._dhx_trim();
		var arPos = this.grid.getPosition(this.cell) //,this.grid.objBox)

		this.obj=document.createElement("TEXTAREA");
		this.obj.className="dhx_combo_edit";

		this.obj.style.height=(this.cell.offsetHeight-(this.grid.multiLine ? 9 : 4))+"px";

		this.obj.wrap="soft";
		this.obj.style.textAlign=this.cell.style.textAlign;
		this.obj.onclick=function(e){
			(e||event).cancelBubble=true
		}
		this.obj.onmousedown=function(e){
			(e||event).cancelBubble=true
		}
		this.obj.value=this.text
		this.obj.onselectstart=function(e){
			if (!e)
				e=event;
			e.cancelBubble=true;
			return true;
		};
		var editor_obj = this;
		this.obj.onkeyup=function(e){
			var key=(e||event).keyCode;
			if (key==38 || key==40 || key==9) return;
			var val = this.readonly ? String.fromCharCode(key) : this.value;
			
			var c = editor_obj.list.options;

			for (var i = 0; i < c.length; i++)
				if (c[i].text.indexOf(val) == 0)
					return c[i].selected=true;
		}
		this.list=document.createElement("SELECT");

		this.list.className='dhx_combo_select';
		this.list.style.width=this.cell.offsetWidth+"px";
		this.list.style.left=arPos[0]+"px";                       //arPos[0]
		this.list.style.top=arPos[1]+this.cell.offsetHeight+"px"; //arPos[1]+this.cell.offsetHeight;
		this.list.onclick=function(e){
			var ev = e||window.event;
			var cell = ev.target||ev.srcElement

			//tbl.editor_obj.val=cell.combo_val;
			if (cell.tagName == "OPTION")
				cell=cell.parentNode;
			//editor_obj.list.value = cell.value;
			editor_obj.editable=false;
			editor_obj.grid.editStop();
			ev.cancelBubble = true;
		}
		var comboKeys = this.combo.getKeys();
		var fl = false
		var selOptId = 0;

		for (var i = 0; i < comboKeys.length; i++){
			var val = this.combo.get(comboKeys[i])
			this.list.options[this.list.options.length]=new Option(val, comboKeys[i]);

			if (comboKeys[i] == this.val){
				selOptId=this.list.options.length-1;
				fl=true;
			}
		}

		if (fl == false){ //if no such value in combo list
			this.list.options[this.list.options.length]=new Option(this.text, this.val === null ? "" : this.val);
			selOptId=this.list.options.length-1;
		}
		document.body.appendChild(this.list) //nb:this.grid.objBox.appendChild(this.listBox);
		this.list.size="6";
		this.cstate=1;

		if (this.editable){
			this.cell.innerHTML="";
		}
		else {
			this.obj.style.width="0px";
			this.obj.style.height="0px";
		}
		this.cell.appendChild(this.obj);
		this.list.options[selOptId].selected=true;

		//fix for coro - FF scrolls grid in incorrect position
		if (this.editable){
			this.obj.focus();
			this.obj.focus();
		}

		if (!this.editable){
			this.obj.style.visibility="hidden";
			this.obj.style.position="absolute";
			this.list.focus();
			this.list.onkeydown=function(e){
				e=e||window.event;
				editor_obj.grid.setActive(true)

				if (e.keyCode < 30)
					return editor_obj.grid.doKey({
						target: editor_obj.cell,
						keyCode: e.keyCode,
						shiftKey: e.shiftKey,
						ctrlKey: e.ctrlKey
						})
			}
		}
	}

	this.getValue=function(){
		return ((this.cell.combo_value == window.undefined) ? "" : this.cell.combo_value);
	}
	this.detach=function(){
		if (this.val != this.getValue()){
			this.cell.wasChanged=true;
		}

		if (this.list.parentNode != null){
			if (this.editable){
					var ind = this.list.options[this.list.selectedIndex]
					if (ind&&ind.text == this.obj.value)
						this.setValue(this.list.value)
					else{
						var combo=(this.cell._combo||this.grid.getCombo(this.cell._cellIndex));
						var val=combo.values._dhx_find(this.obj.value);
						if (val!=-1) this.setValue(combo.keys[val]);
						else this.setValue(this.cell.combo_value=this.obj.value);
					}
			}
			else
				this.setValue(this.list.value)
		}

		if (this.list.parentNode)
			this.list.parentNode.removeChild(this.list);

		if (this.obj.parentNode)
			this.obj.parentNode.removeChild(this.obj);

		return this.val != this.getValue();
	}
}
eXcell_co.prototype=new eXcell;
eXcell_co.prototype.getText=function(){
	return this.cell.innerHTML;
}
eXcell_co.prototype.setValue=function(val){
	if (typeof (val) == "object"){
		var optCol = dhx4.ajax.xpath("./option", val);

		if (optCol.length)
			this.cell._combo=new dhtmlXGridComboObject();

		for (var j = 0;
			j < optCol.length;
			j++)this.cell._combo.put(optCol[j].getAttribute("value"),
			optCol[j].firstChild
				? optCol[j].firstChild.data
				: "");
		val=val.firstChild.data;
	}

	if ((val||"").toString()._dhx_trim() == "")
		val=null
	this.cell.combo_value=val;
	
	if (val !== null){
		var label = (this.cell._combo||this.grid.getCombo(this.cell._cellIndex)).get(val);
		this.setCValue(label===null?val:label, val);
	}else
		this.setCValue("&nbsp;", val);

	
}
/**
*	@desc: selectbox editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_coro(cell){
	this.base=eXcell_co;
	this.base(cell)
	this.editable=false;
}
eXcell_coro.prototype=new eXcell_co;

function eXcell_cotxt(cell){
	this.base=eXcell_co;
	this.base(cell)
}
eXcell_cotxt.prototype=new eXcell_co;
eXcell_cotxt.prototype.getText=function(){
	return (_isIE ? this.cell.innerText : this.cell.textContent);
}
eXcell_cotxt.prototype.setValue=function(val){
	if (typeof (val) == "object"){
		var optCol = dhx4.ajax.xpath("./option", val);

		if (optCol.length)
			this.cell._combo=new dhtmlXGridComboObject();

		for (var j = 0;
			j < optCol.length;
			j++)this.cell._combo.put(optCol[j].getAttribute("value"),
			optCol[j].firstChild
				? optCol[j].firstChild.data
				: "");
		val=val.firstChild.data;
	}

	if ((val||"").toString()._dhx_trim() == "")
		val=null

	if (val !== null)
		this.setCTxtValue((this.cell._combo||this.grid.getCombo(this.cell._cellIndex)).get(val)||val, val);
	else
		this.setCTxtValue(" ", val);

	this.cell.combo_value=val;
}

function eXcell_corotxt(cell){
	this.base=eXcell_co;
	this.base(cell)
	this.editable=false;
}
eXcell_corotxt.prototype=new eXcell_cotxt;
//#}

//#cp_excell:04062008{
/**
*	@desc: color picker editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_cp(cell){
	try{
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	catch (er){}
	this.edit=function(){
		this.val=this.getValue()
		this.obj=document.createElement("SPAN");
		this.obj.style.border="1px solid black";
		this.obj.style.position="absolute";
		var arPos = this.grid.getPosition(this.cell); //,this.grid.objBox
		this.colorPanel(4, this.obj)
		document.body.appendChild(this.obj);          //this.grid.objBox.appendChild(this.obj);
		this.obj.style.left=arPos[0]+"px";
		this.obj.style.zIndex=1000;
		this.obj.style.top=arPos[1]+this.cell.offsetHeight+"px";
	}
	this.toolDNum=function(value){
		if (value.length == 1)
			value='0'+value;
		return value;
	}
	this.colorPanel=function(index, parent){
		var tbl = document.createElement("TABLE");
		parent.appendChild(tbl)
		tbl.cellSpacing=0;
		tbl.editor_obj=this;
		tbl.style.cursor="default";
		tbl.onclick=function(e){
			var ev = e||window.event
			var cell = ev.target||ev.srcElement;
			var ed = cell.parentNode.parentNode.parentNode.editor_obj
			if (ed){
				ed.setValue(cell._bg);
				ed.grid.editStop();
			}
		}
		var cnt = 256 / index;
		for (var j = 0; j <= (256 / cnt); j++){
			var r = tbl.insertRow(j);

			for (var i = 0; i <= (256 / cnt); i++){
				for (var n = 0; n <= (256 / cnt); n++){
					R=new Number(cnt*j)-(j == 0 ? 0 : 1)
					G=new Number(cnt*i)-(i == 0 ? 0 : 1)
					B=new Number(cnt*n)-(n == 0 ? 0 : 1)
					var rgb =
						this.toolDNum(R.toString(16))+""+this.toolDNum(G.toString(16))+""+this.toolDNum(B.toString(16));
					var c = r.insertCell(i);
					c.width="10px";
					c.innerHTML="&nbsp;"; //R+":"+G+":"+B;//
					c.title=rgb.toUpperCase()
					c.style.backgroundColor="#"+rgb
					c._bg="#"+rgb;

					if (this.val != null&&"#"+rgb.toUpperCase() == this.val.toUpperCase()){
						c.style.border="2px solid white"
					}
				}
			}
		}
	}
	this.getValue=function(){
		return this.cell.firstChild._bg||""; //this.getBgColor()
	}
	this.getRed=function(){
		return Number(parseInt(this.getValue().substr(1, 2), 16))
	}
	this.getGreen=function(){
		return Number(parseInt(this.getValue().substr(3, 2), 16))
	}
	this.getBlue=function(){
		return Number(parseInt(this.getValue().substr(5, 2), 16))
	}
	this.detach=function(){
		if (this.obj.offsetParent != null)
			document.body.removeChild(this.obj);
		//this.obj.removeNode(true)
		return this.val != this.getValue();
	}
}
eXcell_cp.prototype=new eXcell;
eXcell_cp.prototype.setValue=function(val){
    this.setCValue("<div style='width:100%;height:"+((this.grid.multiLine?"100%":23))+";background-color:"+(val||"")
		+";border:0px;'>&nbsp;</div>",
		val);
	this.cell.firstChild._bg=val;
}
//#}

//#img_excell:04062008{
/**
*	@desc: image editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
/*
	The corresponding  cell value in XML should be a "^" delimited list of following values:
	1st - image src
	2nd - image alt text (optional)
	3rd - link (optional)
	4rd - target (optional, default is _self)
*/
function eXcell_img(cell){
	try{
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	catch (er){}
	this.getValue=function(){
		if (this.cell.firstChild.tagName == "IMG")
			return this.cell.firstChild.src+(this.cell.titFl != null
				? "^"+this.cell._brval
				: "");
			else if (this.cell.firstChild.tagName == "A"){
			var out = this.cell.firstChild.firstChild.src+(this.cell.titFl != null ? "^"+this.cell._brval : "");
			out+="^"+this.cell.lnk;

			if (this.cell.trg)
				out+="^"+this.cell.trg
			return out;
		}
	}
	this.isDisabled=function(){
		return true;
	}
}
eXcell_img.prototype=new eXcell;
eXcell_img.prototype.getTitle=function(){
	return this.cell._brval
}
eXcell_img.prototype.setValue=function(val){
	var title = val;

	if ((val||"").indexOf("^") != -1){
		var ar = val.split("^");
		val=ar[0]
		title=this.cell._attrs.title||ar[1];

		//link
		if (ar.length > 2){
			this.cell.lnk=ar[2]

			if (ar[3])
				this.cell.trg=ar[3]
		}
		this.cell.titFl="1";
	}
	if (!this.grid.multiLine)
		this.setCValue("<img src='"+this.grid.iconURL+(val||"")._dhx_trim()+"' border='0' style='max-height:"+(this.grid._srdh-4)+"px'>", val);
	else
		this.setCValue("<img src='"+this.grid.iconURL+(val||"")._dhx_trim()+"' border='0'>", val);

	if (this.cell.lnk){
		this.cell.innerHTML="<a href='"+this.cell.lnk+"' target='"+this.cell.trg+"'>"+this.cell.innerHTML+"</a>"
	}
	this.cell._brval=title;
}
function eXcell_icon(cell){
	this.base=eXcell_ed;
	this.base(cell)
	try{
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	catch (er){}

	this.setValue=function(val){
		this.cell._raw_value = val;
		this.setCValue('<div class="dhx_grid_icon"><i class="fa fa-'+val.toString()._dhx_trim()+'"></i></div>');
	}
	this.getValue=function(){
		return this.cell._raw_value;
	}
	this.isDisabled=function(){
		return true;
	}
}
eXcell_icon.prototype=new eXcell_ed;
//#}

//#price_excell:04062008{
/**
*	@desc: text editor with price (USD) formatting
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_price(cell){
	this.base=eXcell_ed;
	this.base(cell)
	this.getValue=function(){
		if (this.cell.childNodes.length > 1)
			return this.cell.childNodes[1].innerHTML.toString()._dhx_trim()
		else
			return "0";
	}
}

eXcell_price.prototype=new eXcell_ed;
eXcell_price.prototype.setValue=function(val){
	if (isNaN(parseFloat(val))){
		val=this.val||0;
	}
	var color = "green";

	if (val < 0)
		color="red";

	this.setCValue("<span>$</span><span style='padding-right:2px;color:"+color+";'>"+val+"</span>", val);
}
//#}

//#dyn_excells:04062008{
/**
*	@desc: text editor with additional formatting for positive and negative numbers (arrow down/up and color)
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_dyn(cell){
	this.base=eXcell_ed;
	this.base(cell)
	this.getValue=function(){
		return this.cell.firstChild.childNodes[1].innerHTML.toString()._dhx_trim()
	}
}

eXcell_dyn.prototype=new eXcell_ed;
eXcell_dyn.prototype.setValue=function(val){
	if (!val||isNaN(Number(val))){
		if (val!=="")
			val=0;
	}

	if (val > 0){
		var color = "green";
		var img = "dyn_up.gif";
	} else if (val == 0){
		var color = "black";
		var img = "dyn_.gif";
	} else {
		var color = "red";
		var img = "dyn_down.gif";
	}
	this.setCValue("<div class='grid_cell_dyn'><img src='"+this.grid.imgURL+""+img
		+"'><span style='color:"+color+";'>"+val
		+"</span></div>",
		val);
}
//#}

/**
*	@desc: readonly editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_ro(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.edit=function(){
	}

	this.isDisabled=function(){
		return true;
	}
	this.getValue=function(){
		return this.cell._clearCell?"":this.cell.innerHTML.toString()._dhx_trim();
	}
}
eXcell_ro.prototype=new eXcell;


window.eXcell_hidden = function(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.edit=function(){
	}

	this.isDisabled=function(){
		return true;
	}
	this.getValue=function(){
		return this.cell.val;
	}
}
eXcell_hidden.prototype=new eXcell;
eXcell_hidden.prototype.setValue = function(value){
	this.cell.val = value;
}

function eXcell_ron(cell){
	this.cell=cell;
	this.grid=this.cell.parentNode.grid;
	this.edit=function(){
	}

	this.isDisabled=function(){
		return true;
	}
	this.getValue=function(){
		return this.cell._clearCell?"":this.cell._orig_value||this.grid._aplNFb(this.cell.innerHTML.toString()._dhx_trim(), this.cell._cellIndex).toString();
	}
}
eXcell_ron.prototype=new eXcell;
eXcell_ron.prototype.setValue=function(val){ 
	if (val === 0){}
	else if (!val||val.toString()._dhx_trim() == ""){
		this.setCValue("&nbsp;");
		return this.cell._clearCell=true;
	}
	this.cell._orig_value = val;
	this.cell._clearCell=false;
	this.setCValue(val?this.grid._aplNF(val, this.cell._cellIndex):"0");
}


/**
*	@desc: readonly pure text editor (without HTML support)
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_rotxt(cell){
	this.cell=cell;
	this.grid=this.cell.parentNode.grid;
	this.edit=function(){
	}

	this.isDisabled=function(){
		return true;
	}
	this.setValue=function(val){
		if (!val){
			val=" ";
			this.cell._clearCell = true;
		}
		else
			this.cell._clearCell = false;
			
		this.setCTxtValue(val);
	}
	this.getValue=function(){
		if (this.cell._clearCell)
			return "";
		return (_isIE ? this.cell.innerText : this.cell.textContent);
	}	
}
eXcell_rotxt.prototype=new eXcell;

/**
	*	@desc: combobox object constructor (shouldn't be accessed directly - instead please use getCombo(...) method of the grid)
	*	@type: private
	*	@returns: combobox for dhtmlxGrid
	*/
function dhtmlXGridComboObject(){
	this.keys=new dhtmlxArray();
	this.values=new dhtmlxArray();
	/**
	*	@desc: puts new combination of key and value into combobox
	*	@type: public
	*	@param: key - object to use as a key (should be a string in the case of combobox)
	*	@param: value - object value of combobox line
	*/
	this.put=function(key, value){
		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] == key){
				this.values[i]=value;
				return true;
			}
		}
		this.values[this.values.length]=value;
		this.keys[this.keys.length]=key;
	}
	/**
	*	@desc: gets value corresponding to the given key
	*	@type: public
	*	@param: key - object to use as a key (should be a string in the case of combobox)
	*	@returns: value correspond. to given key or null if no such key
	*/
	this.get=function(key){
		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] == key){
				return this.values[i];
			}
		}
		return null;
	}
	/**
	*	@desc: clears combobox
	*	@type: public
	*/
	this.clear=function(){
		/*for(var i=0;i<this.keys.length;i++){
				this.keys._dhx_removeAt(i);
				this.values._dhx_removeAt(i);
		}*/
		this.keys=new dhtmlxArray();
		this.values=new dhtmlxArray();
	}
	/**
	*	@desc: remove pair of key-value from combobox with given key 
	*	@type: public
	*	@param: key - object to use as a key
	*/
	this.remove=function(key){
		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] == key){
				this.keys._dhx_removeAt(i);
				this.values._dhx_removeAt(i);
				return true;
			}
		}
	}
	/**
	*	@desc: gets the size of combobox 
	*	@type: public
	*	@returns: current size of combobox
	*/
	this.size=function(){
		var j = 0;

		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] != null)
				j++;
		}
		return j;
	}
	/**
	*	@desc: gets array of all available keys present in combobox
	*	@type: public
	*	@returns: array of all available keys
	*/
	this.getKeys=function(){
		var keyAr = new Array(0);

		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] != null)
				keyAr[keyAr.length]=this.keys[i];
		}
		return keyAr;
	}

	/**
	*	@desc: save curent state
	*	@type: public
	*/
	this.save=function(){
		this._save=new Array();

		for (var i = 0; i < this.keys.length; i++)this._save[i]=[
			this.keys[i],
			this.values[i]
		];
	}


	/**
	*	@desc: restore saved state
	*	@type: public
	*/
	this.restore=function(){
		if (this._save){
			this.keys[i]=new Array();
			this.values[i]=new Array();

			for (var i = 0; i < this._save.length; i++){
				this.keys[i]=this._save[i][0];
				this.values[i]=this._save[i][1];
			}
		}
	}
	return this;
}

function Hashtable(){
	this.keys=new dhtmlxArray();
	this.values=new dhtmlxArray();
	return this;
}
Hashtable.prototype=new dhtmlXGridComboObject;

//(c)dhtmlx ltd. www.dhtmlx.com
if (typeof(window.dhtmlXCellObject) != "undefined") {
	
	dhtmlXCellObject.prototype.attachGrid = function() {
		
		this.callEvent("_onBeforeContentAttach",["grid"]);
		
		var obj = document.createElement("DIV");
		obj.style.width = "100%";
		obj.style.height = "100%";
		obj.style.position = "relative";
		obj.style.overflow = "hidden";
		this._attachObject(obj);
		
		this.dataType = "grid";
		this.dataObj = new dhtmlXGridObject(obj);
		this.dataObj.setSkin(this.conf.skin);
		
		// fix for grid atatched to tabbar for safari on ios 5.1.7
		if (typeof(window.dhtmlXTabBarCell) == "function" && this instanceof window.dhtmlXTabBarCell && navigator.userAgent.match(/7[\.\d]* mobile/gi) != null && navigator.userAgent.match(/AppleWebKit/gi) != null) {
			this.dataObj.objBox.style.webkitOverflowScrolling = "auto";
		}
		
		// fix layout cell for material
		if (this.conf.skin == "material" && typeof(window.dhtmlXLayoutCell) == "function" && this instanceof window.dhtmlXLayoutCell) {
			this.cell.childNodes[this.conf.idx.cont].style.overflow = "hidden";
		}
		
		
		// keep border for window and remove for other
		if (this.conf.skin == "dhx_skyblue" && typeof(window.dhtmlXWindowsCell) == "function" && this instanceof window.dhtmlXWindowsCell) {
			this.dataObj.entBox.style.border = "1px solid #a4bed4";
			this.dataObj._sizeFix = 0;
		} else {
			this.dataObj.entBox.style.border = "0px solid white";
			this.dataObj._sizeFix = 2;
		}
		
		obj = null;
		
		this.callEvent("_onContentAttach",[]);
		
		return this.dataObj;
	};
	
}


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*     @desc: enable/disable drag-and-drop
*     @type: public
*     @param: mode - enabled/disabled [ can be true/false/temporary_disabled - last value mean that tree can be D-n-D can be switched to true later ]
*     @topic: 0
*/
   dhtmlXGridObject.prototype.enableDragAndDrop=function(mode){
        if  (mode=="temporary_disabled"){
            this.dADTempOff=false;
            mode=true;                  }
        else
            this.dADTempOff=true;

		this.dragAndDropOff=dhx4.s2b(mode);
		this._drag_validate=true;
		if (mode)
			this.objBox.ondragstart = function (e) {
				(e||event).cancelBubble = true;
				return false;
			}
       };

/**
*     @desc: set Drag-And-Drop behavior (child - drop as chils, sibling - drop as sibling
*     @type: public
*     @param: mode - behavior name (child,sibling,complex)
*     @topic: 0
*/
dhtmlXGridObject.prototype.setDragBehavior=function(mode){
        this.dadmodec=this.dadmodefix=0;
      switch (mode) {
         case "child": this.dadmode=0; this._sbmod=false;  break;
         case "sibling": this.dadmode=1; this._sbmod=false;  break;
         case "sibling-next": this.dadmode=1; this._sbmod=true; break;
         case "complex": this.dadmode=2; this._sbmod=false;  break;
         case "complex-next": this.dadmode=2; this._sbmod=true;  break;
      }    };


/**
*     @desc: switch to mode when draged item, droped in target location in same order as they was in source grid
*     @type: public
*     @param: mode - true/false to enable/disable mode
*     @topic: 0
*/
dhtmlXGridObject.prototype.enableDragOrder=function(mode){
        this._dndorder=dhx4.s2b(mode);
};


dhtmlXGridObject.prototype._checkParent=function(row,ids){
	var z=this._h2.get[row.idd].parent;
	if (!z.parent) return;
	for (var i=0; i<ids.length; i++) 
		if (ids[i]==z.id) return true;
		
	return this._checkParent(this.rowsAr[z.id],ids);
}

/**
*     @desc: create html element for dragging
*     @type: private
*     @param: htmlObject - html node object
*     @topic: 1
*/
dhtmlXGridObject.prototype._createDragNode=function(htmlObject,e){
	  this.editStop();
	  if (window.dhtmlDragAndDrop.dragNode) return null;
      if (!this.dADTempOff) return null;
      htmlObject.parentObject=new Object();
      htmlObject.parentObject.treeNod=this;

	var text=this.callEvent("onBeforeDrag",[htmlObject.parentNode.idd,htmlObject._cellIndex, e]);
	if (!text) return null;

      var z=new Array();
//#__pro_feature:21092006{
      z=this.getSelectedId();
	  z=(((z)&&(z!=""))?z.split(this.delim):[]);
      var exst=false;
      for (var i=0; i<z.length; i++)
        if (z[i]==htmlObject.parentNode.idd)  exst=true;
      if (!exst){
      	this.selectRow(this.rowsAr[htmlObject.parentNode.idd],false,e.ctrlKey,false);
      	if (!e.ctrlKey) {
      		z=[];
  		}
//#}
          z[this.selMultiRows?z.length:0]=htmlObject.parentNode.idd;
//#__pro_feature:21092006{
    }
//#}

	//remove child in case of treeGrid
	if (this.isTreeGrid()){
		for (var i=z.length-1; i>=0; i--) 
			if (this._checkParent(this.rowsAr[z[i]],z)) z.splice(i,1);
				
	}
	

	var self=this;
	if (z.length && this._dndorder)
		z.sort(function(a,b){ return (self.rowsAr[a].rowIndex>self.rowsAr[b].rowIndex?1:-1); });

     var el = this.getFirstParentOfType(_isIE?e.srcElement:e.target,"TD");
     if (el) this._dndExtra=el._cellIndex;
      this._dragged=new Array();
      for (var i=0; i<z.length; i++)
          if (this.rowsAr[z[i]]){
          this._dragged[this._dragged.length]=this.rowsAr[z[i]];
          this.rowsAr[z[i]].treeNod=this;
          }

      htmlObject.parentObject.parentNode=htmlObject.parentNode;

   var dragSpan=document.createElement('div');
   dragSpan.innerHTML=(text!==true?text:this.rowToDragElement(htmlObject.parentNode.idd));
   dragSpan.style.position="absolute";
   dragSpan.className="dragSpanDiv";
   return dragSpan;
}



/**
*   @desc:  create a drag visual marker
*   @type:  private
*/
dhtmlXGridObject.prototype._createSdrgc=function(){
    this._sdrgc=document.createElement("DIV");
    this._sdrgc.innerHTML="&nbsp;";
    this._sdrgc.className="gridDragLine";
    this.objBox.appendChild(this._sdrgc);
}











/**
*   @desc:  create a drag context object
*   @type:  private
*/
function dragContext(a,b,c,d,e,f,j,h,k,l,m){
    this.source=a||"grid";
    this.target=b||"grid";
    this.mode=c||"move";
    this.dropmode=d||"child";
    this.sid=e||0;
    this.tid=f;
    this.sobj=j||null;
    this.tobj=h||null;
   this.sExtra=k||null;
   this.tExtra=l||null;
   this.before=m||false;
    return this;
}
/**
*   @desc:  check is operation possible
*   @type:  private
*/
dragContext.prototype.valid=function(){
   if (this.sobj!=this.tobj) return true;
   if (this.sid==this.tid) return false;
   if (this.target=="treeGrid"){
      var z=this.tid
      while (z = this.tobj.getParentId(z) ){
         if (this.sid==z) return false;
         }
   }
   return true;
}
/**
*   @desc:  close context
*   @type:  private
*/
dragContext.prototype.close=function(){
    this.sobj=null;
    this.tobj=null;
}
/**
*   @desc:  return copy of context
*   @type:  private
*/
dragContext.prototype.copy=function(){
    return new dragContext(this.source,this.target,this.mode,this.dropmode,this.sid,this.tid,this.sobj,this.tobj,this.sExtra,this.tExtra,this.before);
}
/**
*   @desc:  set a lue of context attribute
*   @type:  private
*/
dragContext.prototype.set=function(a,b){
    this[a]=b;
    return this;
}
/**
*   @desc:  generate an Id for new node
*   @type:  private
*/
dragContext.prototype.uid=function(a,b){
    this.nid=this.sid;
    while (this.tobj.rowsAr[this.nid])
        this.nid=this.nid+((new Date()).valueOf());

    return this;
}
/**
*   @desc:  get data array for grid row
*   @type:  private
*/
dragContext.prototype.data=function(){
    if (this.sobj==this.tobj)
        return this.sobj._getRowArray(this.sobj.rowsAr[this.sid]);
    if (this.source=="tree")
        return this.tobj.treeToGridElement(this.sobj,this.sid,this.tid);
    else
        return this.tobj.gridToGrid(this.sid,this.sobj,this.tobj);
}
dragContext.prototype.attrs=function(){
    if (this.source=="tree")
        return {};
    else
        return this.sobj.rowsAr[this.sid]._attrs;
}
dragContext.prototype.childs=function(){
    if (this.source=="treeGrid")
		return this.sobj._h2.get[this.sid]._xml_await?this.sobj._h2.get[this.sid].has_kids:null;
	return null;
}

/**
*   @desc:  return parent id for row in context
*   @type:  private
*/
dragContext.prototype.pid=function(){
    if (!this.tid) return 0;
	if (!this.tobj._h2) return 0;
    if (this.target=="treeGrid")
        if (this.dropmode=="child")
            return this.tid;
        else{
			var z=this.tobj.rowsAr[this.tid];
			var apid=this.tobj._h2.get[z.idd].parent.id;
			if ((this.alfa)&&(this.tobj._sbmod)&&(z.nextSibling)){
				var zpid=this.tobj._h2.get[z.nextSibling.idd].parent.id;
				if (zpid==this.tid)
            		return this.tid;
				if (zpid!=apid)
            		return zpid;
			}
	        return apid;
	   }
}
/**
*   @desc:  get index of target position
*   @type:  private
*/
dragContext.prototype.ind=function(){ 
    if (this.tid==window.unknown) return this.tobj.rowsBuffer.length;
    if (this.target=="treeGrid"){
      if (this.dropmode=="child")
            this.tobj.openItem(this.tid);
      else
         this.tobj.openItem(this.tobj.getParentId(this.tid));
   }
    var ind=this.tobj.rowsBuffer._dhx_find(this.tobj.rowsAr[this.tid]);
	if ((this.alfa)&&(this.tobj._sbmod)&&(this.dropmode=="sibling")){
		var z=this.tobj.rowsAr[this.tid];
		if ((z.nextSibling)&&(this._h2.get[z.nextSibling.idd].parent.id==this.tid))
			return ind+1;
	}

    return (ind+1+((this.target=="treeGrid" && ind>=0 && this.tobj._h2.get[this.tobj.rowsBuffer[ind].idd].state=="minus")?this.tobj._getOpenLenght(this.tobj.rowsBuffer[ind].idd,0):0));
}

/**
*   @desc:  get row related image
*   @type:  private
*/
dragContext.prototype.img=function(){
    if ((this.target!="grid")&&(this.sobj._h2))
      return this.sobj.getItemImage(this.sid);
   else return null;
}

/**
*   @desc:  return list of rows in context
*   @type:  private
*/
dragContext.prototype.slist=function(){
    var res=new Array();
    for (var i=0; i<this.sid.length; i++)
        res[res.length]=this.sid[i][(this.source=="tree")?"id":"idd"];

    return res.join(",");
}


/**
*   @desc:  drag entry point
*   @type:  private
*/
dhtmlXGridObject.prototype._drag=function(sourceHtmlObject,dhtmlObject,targetHtmlObject,lastLanding){
   if (this._realfake) return this._fake._drag();

   var z=(this.lastLanding)
    //close unfinished tasks
    if  (this._autoOpenTimer) window.clearTimeout(this._autoOpenTimer);

    //detect details
    var r1=targetHtmlObject.parentNode;
    var r2=sourceHtmlObject.parentObject;
    //drop on header
    if (!r1.idd) { r1.grid=this;    this.dadmodefix=0; }

    var c=new dragContext(0,0,0,((r1.grid.dadmode==1 || r1.grid.dadmodec)?"sibling":"child"));


    if (r2 && r2.childNodes)
        c.set("source","tree").set("sobj",r2.treeNod).set("sid",c.sobj._dragged);
    else{
    	if (!r2) return true;
        if (r2.treeNod.isTreeGrid && r2.treeNod.isTreeGrid())
        	c.set("source","treeGrid");
        c.set("sobj",r2.treeNod).set("sid",c.sobj._dragged);
        }

    if (r1.grid.isTreeGrid())
        c.set("target","treeGrid");
	else
		c.set("dropmode","sibling");
    c.set("tobj",r1.grid).set("tid",r1.idd);

//#__pro_feature:21092006{
    //complex drag mode - adjust tartget element
    if (((c.tobj.dadmode==2)&&(c.tobj.dadmodec==1))&&(c.tobj.dadmodefix<0))
       if (c.tobj.obj.rows[1].idd!=c.tid) c.tid=r1.previousSibling.idd;
       else {
         if (this._h2 && c.tid)
           c.before = true;
         else c.tid=0;
       }
//#}

   var el = this.getFirstParentOfType(lastLanding,"TD")
   if (el) c.set("tExtra",el._cellIndex);
   if (el) c.set("sExtra",c.sobj._dndExtra);

    if (c.sobj.dpcpy) c.set("mode","copy");
    
    if (c.tobj._realfake) c.tobj=c.tobj._fake;
    if (c.sobj._realfake) c.sobj=c.sobj._fake;
    
    c.tobj._clearMove();
    
	if (r2 && r2.treeNod && r2.treeNod._nonTrivialRow)
		r2.treeNod._nonTrivialRow(this,c.tid,c.dropmode,r2);
	else {
		c.tobj.dragContext=c;
	    if (!c.tobj.callEvent("onDrag",[c.slist(),c.tid,c.sobj,c.tobj,c.sExtra,c.tExtra]))  return  c.tobj.dragContext=null;
	
	   //all ready, start mantras
	   var result=new Array();
	   if (typeof(c.sid)=="object"){
	        var nc=c.copy();
	        for (var i=0; i<c.sid.length; i++){
	         if (!nc.set("alfa",(!i)).set("sid",c.sid[i][(c.source=="tree"?"id":"idd")]).valid()) continue;
	            nc.tobj._dragRoutine(nc);
	            if (nc.target=="treeGrid" && nc.dropmode == "child") nc.tobj.openItem(nc.tid);
	            result[result.length]=nc.nid;
	         nc.set("dropmode","sibling").set("tid",nc.nid);
	            }
	        nc.close();
	        }
	    else
	       c.tobj._dragRoutine(c);		

	   //finish math if any awaiting
	   if (c.tobj.laterLink) c.tobj.laterLink();
	   //destroy context
		c.tobj.callEvent("onDrop",[c.slist(),c.tid,result.join(","),c.sobj,c.tobj,c.sExtra,c.tExtra]);
	}

   c.tobj.dragContext=null;
   c.close();
}


/**
*   @desc:  context drag routine
*   @type:  private
*/
dhtmlXGridObject.prototype._dragRoutine=function(c){
      if ((c.sobj==c.tobj)&&(c.source=="grid")&&(c.mode=="move")&&!this._fake){
         //special case for moving rows in same grid
         if (c.sobj._dndProblematic) return;
         var fr=c.sobj.rowsAr[c.sid];
         var bind=c.sobj.rowsCol._dhx_find(fr);
         c.sobj.rowsCol._dhx_removeAt(c.sobj.rowsCol._dhx_find(fr));
         c.sobj.rowsBuffer._dhx_removeAt(c.sobj.rowsBuffer._dhx_find(fr));
         c.sobj.rowsBuffer._dhx_insertAt(c.ind(),fr);
         if (c.tobj._fake){
         	c.tobj._fake.rowsCol._dhx_removeAt(bind);
         	var tr=c.tobj._fake.rowsAr[c.sid];
         	tr.parentNode.removeChild(tr);
     	 }         
         c.sobj._insertRowAt(fr,c.ind()-(this.pagingOn?((this.currentPage-1)*this.rowsBufferOutSize):0));

         c.nid=c.sid;
         c.sobj.callEvent("onGridReconstructed",[]);
         return;
      }
      var new_row;
		if (this._h2 && typeof c.tid !="undefined" && c.dropmode=="sibling" && (this._sbmod || c.tid)){
      if (c.before)
        new_row=c.uid().tobj.addRowBefore(c.nid,c.data(),c.tid,c.img(),c.childs());
			else if (c.alfa && this._sbmod && this._h2.get[c.tid].childs.length){
				this.openItem(c.tid)
				new_row=c.uid().tobj.addRowBefore(c.nid,c.data(),this._h2.get[c.tid].childs[0].id,c.img(),c.childs());
			}
			else
		  	new_row=c.uid().tobj.addRowAfter(c.nid,c.data(),c.tid,c.img(),c.childs());
		}
		else
        	new_row=c.uid().tobj.addRow(c.nid,c.data(),c.ind(),c.pid(),c.img(),c.childs());

          new_row._attrs = c.attrs();
		
		
        if (c.source=="tree"){
        	this.callEvent("onRowAdded",[c.nid]);            
            var sn=c.sobj._globalIdStorageFind(c.sid);
            if (sn.childsCount){
                var nc=c.copy().set("tid",c.nid).set("dropmode",c.target=="grid"?"sibling":"child");
              for(var j=0;j<sn.childsCount;j++){
                    c.tobj._dragRoutine(nc.set("sid",sn.childNodes[j].id));
                    if (c.mode=="move") j--;
                    }
                nc.close();
                }
        }
        else{
            c.tobj._copyUserData(c);
			this.callEvent("onRowAdded",[c.nid]);            
			
            if ((c.source=="treeGrid")){
            	
            	if (c.sobj==c.tobj) new_row._xml=c.sobj.rowsAr[c.sid]._xml;
                var snc=c.sobj._h2.get[c.sid];
                if ((snc)&&(snc.childs.length)){
                    var nc=c.copy().set("tid",c.nid);
                    if(c.target=="grid")
                        nc.set("dropmode","sibling");
                    else {
                        if (!nc.tobj.kidsXmlFile)
                    	   nc.tobj.openItem(c.tid);
                        nc.set("dropmode","child");
                        }
					var l=snc.childs.length;
                    if (!nc.tobj.kidsXmlFile)
                    for(var j=0;j<l;j++){
                    	c.sobj.render_row_tree(null,snc.childs[j].id);
                        c.tobj._dragRoutine(nc.set("sid",snc.childs[j].id));
                        if (l!=snc.childs.length) {  j--; l=snc.childs.length; }
                        }
                    nc.close();
                    }
            }
        }

        if (c.mode=="move"){
           c.sobj[(c.source=="tree")?"deleteItem":"deleteRow"](c.sid);
           if ((c.sobj==c.tobj)&&(!c.tobj.rowsAr[c.sid])) {
               c.tobj.changeRowId(c.nid,c.sid);
            c.nid=c.sid;
         }
      }
}


/**
*   @desc: redefine this method in your code to define how grid row values should be used in another grid
*   @param: rowId - id of draged row
*   @param: sgrid - source grid object
*   @param: tgrid - target grid object
*   @returns: array of values for cells in target grid row
*   @type: public
*   @topic: 7
*/
dhtmlXGridObject.prototype.gridToGrid = function(rowId,sgrid,tgrid){
    var z=new Array();
    for (var i=0; i<sgrid.hdr.rows[0].cells.length; i++)
        z[i]=sgrid.cells(rowId,i).getValue();
   return z;
}

/**
*   @desc:  check if d-n-d is in allowed rules
*   @type:  private
*/
dhtmlXGridObject.prototype.checkParentLine=function(node,id){
    if ((!this._h2)||(!id)||(!node)) return false;
    if (node.id==id) return true;
    else return this.checkParentLine(node.parent,id);
}

/**
*   @desc:  called when drag moved over landing
*   @type:  private
*/
dhtmlXGridObject.prototype._dragIn=function(htmlObject,shtmlObject,x,y){
                    if (!this.dADTempOff) return 0;
                    var tree=this.isTreeGrid();
                    var obj=shtmlObject.parentNode.idd?shtmlObject.parentNode:shtmlObject.parentObject;
                    
					if (this._drag_validate){
                    	if(htmlObject.parentNode==shtmlObject.parentNode)
                        	return 0;
                        	
	                    if ((tree)&&(this==obj.grid)&&((this.checkParentLine(this._h2.get[htmlObject.parentNode.idd],shtmlObject.parentNode.idd))))
    	                    return 0;
    	            }
                    if (!this.callEvent("onDragIn",[obj.idd||obj.id,htmlObject.parentNode.idd,obj.grid||obj.treeNod,(htmlObject.grid||htmlObject.parentNode.grid)]))
                        return this._setMove(htmlObject,x,y,true);

                    this._setMove(htmlObject,x,y);

                  if ((tree)&&(htmlObject.parentNode.expand!="")){
                    var self = this;
                    this._autoOpenTimer=window.setTimeout(function(){
                      self._autoOpenItem(null, self);
                      self = null;
                    },1000);
                    this._autoOpenId=htmlObject.parentNode.idd;
                  }
                  else
                    if  (this._autoOpenTimer) window.clearTimeout(this._autoOpenTimer);

                    return htmlObject;
}
/**
*   @desc:  open item on timeout
*   @type:  private
*/
dhtmlXGridObject.prototype._autoOpenItem=function(e,gridObject){
	   gridObject.openItem(gridObject._autoOpenId);
}

/**
*   @desc:  called on onmouseout event , when drag out landing zone
*   @type:  private
*/
dhtmlXGridObject.prototype._dragOut=function(htmlObject){
                    this._clearMove();
                    var obj=htmlObject.parentNode.parentObject?htmlObject.parentObject.id:htmlObject.parentNode.idd;
                    this.callEvent("onDragOut",[obj]);
                    if  (this._autoOpenTimer) window.clearTimeout(this._autoOpenTimer);
}
/**
*   @desc:  set visual effect for moving row over landing
*   @type:  private
*/
dhtmlXGridObject.prototype._setMove=function(htmlObject,x,y,skip){
   if (!htmlObject.parentNode.idd) return;
   var a1=dhx4.absTop(htmlObject);
   var a2=dhx4.absTop(this.objBox);
   

   //scroll down
   if ( (a1-a2)>(parseInt(this.objBox.offsetHeight)-50) )
      this.objBox.scrollTop=parseInt(this.objBox.scrollTop)+20;
   //scroll top
   if ( (a1-a2+parseInt(this.objBox.scrollTop))<(parseInt(this.objBox.scrollTop)+30) )
      this.objBox.scrollTop=parseInt(this.objBox.scrollTop)-20;
      
   if (skip) return 0;
   
    if (this.dadmode==2)
    {

        var z=y-a1+(document.body.scrollTop||document.documentElement.scrollTop)-2-htmlObject.offsetHeight/2;
        if ((Math.abs(z)-htmlObject.offsetHeight/6)>0)
        {
        this.dadmodec=1;
      //sibbling zone
        if (z<0)  this.dadmodefix=-1; else   this.dadmodefix=1;
        }
        else this.dadmodec=0;
    }
    else
        this.dadmodec=this.dadmode;




    if (this.dadmodec){
      if (!this._sdrgc) this._createSdrgc();
      this._sdrgc.style.display="block";
      this._sdrgc.style.top=a1-a2+parseInt(this.objBox.scrollTop)+((this.dadmodefix>=0)?htmlObject.offsetHeight:0)+"px";
    }
    else{
      this._llSelD=htmlObject;
      if (htmlObject.parentNode.tagName=="TR")
      for (var i=0; i<htmlObject.parentNode.childNodes.length; i++)
      {
      var z= htmlObject.parentNode.childNodes[i];
	  z._bgCol=z.style.backgroundColor;
      z.style.backgroundColor="#FFCCCC";
      }
    }
}
/**
*   @desc:  remove all visual effects
*   @type:  private
*/
dhtmlXGridObject.prototype._clearMove=function(){
    if (this._sdrgc) this._sdrgc.style.display="none";
    if ((this._llSelD)&&(this._llSelD.parentNode.tagName=="TR")){
    	var coll = this._llSelD.parentNode.childNodes;
        for (var i=0; i<coll.length; i++)
           coll[i].style.backgroundColor=coll[i]._bgCol;
	}       

    this._llSelD=null;
}


/**
*   @desc: redefine this method in your code to define how grid row values should be displaied while draging
*   @param: gridRowId - id of grid row
*   @returns: html string representing dragging row 
*   @type: public
*   @topic: 7
*/
dhtmlXGridObject.prototype.rowToDragElement=function(gridRowId){
    var out=this.cells(gridRowId,0).getValue();
    return out;
}








/**
*   @desc:  copy user data for row
*   @type:  private
*/
dhtmlXGridObject.prototype._copyUserData = function(c){
			if(!c.tobj.UserData[c.nid] || c.tobj!=c.sobj)
            	c.tobj.UserData[c.nid] = new Hashtable();
            else return;

            var z1 = c.sobj.UserData[c.sid];
            var z2 = c.tobj.UserData[c.nid];
            if (z1) {
                z2.keys = z2.keys.concat(z1.keys);
                z2.values = z2.values.concat(z1.values);
            }
    }



/**
*     @desc: move row
*     @type:  public
*     @param: rowId - source row Id
*     @param: mode - moving mode (up,down,row_sibling)
*     @param: targetId - target row  in row_sibling mode
*     @param: targetGrid - used for moving between grids (optional)
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.moveRow=function(rowId,mode,targetId,targetGrid){
      switch(mode){
      case "row_sibling":
                    this.moveRowTo(rowId,targetId,"move","sibling",this,targetGrid);
         break;
      case "up":
               this.moveRowUp(rowId);
         break;
      case "down":
               this.moveRowDown(rowId);
          break;
      }
}





//#__pro_feature:21092006{

/**
*   @desc: move rows from grid to tree
*   @param: tree - object of tree
*   @param: targetObject - target node of tree
*   @param: beforeNode - anchor node of tree
*   @param: itemObject - dragged node
*   @param: z2 - flag of recursion
*   @type:  private
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype._nonTrivialNode=function(tree,targetObject,beforeNode,itemObject,z2)
{
    if ((tree.callEvent)&&(!z2))
          if (!tree.callEvent("onDrag",[itemObject.idd,targetObject.id,(beforeNode?beforeNode.id:null),this,tree])) return false;

    var gridRowId = itemObject.idd;
    var treeNodeId = gridRowId;
    while (tree._idpull[treeNodeId]) treeNodeId+=(new Date()).getMilliseconds().toString();

   var img=(this.isTreeGrid()?this.getItemImage(gridRowId):"")
	if (beforeNode){
		for (i=0; i<targetObject.childsCount; i++)
		    if (targetObject.childNodes[i]==beforeNode) break;
		
		if (i!=0)
		    beforeNode=targetObject.childNodes[i-1];
		else{
		    st="TOP";
		    beforeNode="";
		    }
	}   
   var newone=tree._attachChildNode(targetObject,treeNodeId,this.gridToTreeElement(tree,treeNodeId,gridRowId),"",img,img,img,"","",beforeNode);
    if (this._h2){
      var akids=this._h2.get[gridRowId];
      if (akids.childs.length)
      for (var i=0; i<akids.childs.length; i++){
          this._nonTrivialNode(tree,newone,0,this.rowsAr[akids.childs[i].id],1);
          if (!this.dpcpy) i--;
      }
    }

    if (!this.dpcpy) this.deleteRow(gridRowId);

    if ((tree.callEvent)&&(!z2))
       tree.callEvent("onDrop",[treeNodeId,targetObject.id,(beforeNode?beforeNode.id:null),this,tree]);
}

/**
*   @desc: redefine this method in your code to define how grid row values should be used in tree (using input parameters you can change id of new tree node, set label, set userdata blocks etc.).
*   @param: treeObj - object of tree
*   @param: treeNodeId - id of node created in tree
*   @param: gridRowId - id of grid row
*   @returns: if true, then grid row will be moved to tree, else - copied
*   @type: public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.gridToTreeElement = function(treeObj,treeNodeId,gridRowId){
   return this.cells(gridRowId,0).getValue();
}

/**
*   @desc: redefine this method in your code to define how tree node values should be used in grid (using input parameters you can change id of new row, values for cells, userdata blocks etc.).
*   @param: treeObj - object of tree
*   @param: treeNodeId - id of node created in tree
*   @param: gridRowId - id of grid row
*   @returns: if true, then tree node should be moved to grid, else - copied
*   @type: public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.treeToGridElement = function(treeObj,treeNodeId,gridRowId){
    var w=new Array();
    var z=this.cellType._dhx_find("tree");
   if (z==-1) z=0;
   for(var i=0;i<this.getColumnCount();i++)
        w[w.length]=(i!=z)?(treeObj.getUserData(treeNodeId,this.getColumnId(i))||""):treeObj.getItemText(treeNodeId);
   return w;
}

/**
*     @desc: move row
*     @type:  public
*     @param: srowId - source row Id
*     @param: trowId - target row Id
*     @param: mode - move or copy
*     @param: dropmode - sibling or child
*     @param: sourceGrid - target row  in row_sibling mode
*     @param: targetGrid - used for moving between grids (optional)
*     @returns: moved item ID
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.moveRowTo=function(srowId,trowId,mode,dropmode,sourceGrid,targetGrid){
    var c=new dragContext((sourceGrid||this).isTreeGrid()?"treeGrid":"grid",(targetGrid||this).isTreeGrid()?"treeGrid":"grid",mode,dropmode||"sibling",srowId,trowId,sourceGrid||this,targetGrid||this);
    c.tobj._dragRoutine(c);
    c.close();
    return c.nid;
}

/**
*     @desc: enable drag without removing (copy instead of move)
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @edition:Professional
*     @topic: 0
*/
dhtmlXGridObject.prototype.enableMercyDrag=function(mode){ this.dpcpy=dhx4.s2b(mode); };
//#}
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype.toPDF=function(url,mode,header,footer,rows,target){
	var save_sel = {
		row: (this.getSelectedRowId()||"").split(this.delim),
		col: this.getSelectedCellIndex()
	};
	if (save_sel.row === null || save_sel.col === -1)
		save_sel = false;
	else {
		if (save_sel.row){
			for (var i=0; i<save_sel.row.length; i++){
				if (save_sel.row[i]){
					var el = this.cells(save_sel.row[i], save_sel.col).cell;
					el.parentNode.className = el.parentNode.className.replace(' rowselected', '');
					el.className = el.className.replace(' cellselected', '');
					save_sel.row[i] = el;
				}
			}
		} else 
			save_sel = false;
	}
	mode = mode || "color";	
	var full_color = mode == "full_color";
	var grid = this;
	grid._asCDATA = true;
	if (typeof(target) === 'undefined')
		this.target = " target=\"_blank\"";
	else
		this.target = target;
		
	eXcell_ch.prototype.getContent = function(){
		return this.getValue();
	};
	eXcell_ra.prototype.getContent = function(){
		return this.getValue();
	};
	function xml_top(profile) {
		var spans = [];
		for (var i=1; i<grid.hdr.rows.length; i++){
			spans[i]=[];
			for (var j=0; j<grid._cCount; j++){
				var cell = grid.hdr.rows[i].childNodes[j];
				if (!spans[i][j])
					spans[i][j]=[0,0];
				if (cell)
					spans[i][cell._cellIndexS]=[cell.colSpan, cell.rowSpan];
			}
		}
		
	    var xml = "<rows profile='"+profile+"'";
	       if (header)
	          xml+=" header='"+header+"'";
	       if (footer)
	          xml+=" footer='"+footer+"'";
	    xml+="><head>"+grid._serialiseExportConfig(spans).replace(/^<head/,"<columns").replace(/head>$/,"columns>");
	    for (var i=2; i < grid.hdr.rows.length; i++) {
                var empty_cols = 0;
                var row = grid.hdr.rows[i];
    	        var cxml="";
	    	for (var j=0; j < grid._cCount; j++) {
	    		if ((grid._srClmn && !grid._srClmn[j]) || (grid._hrrar[j] && ( !grid._fake || j >= grid._fake.hdrLabels.length))) {
	    			empty_cols++;
	    			continue;
    			}
	    		var s = spans[i][j];
	    		var rspan =  (( s[0] && s[0] > 1 ) ? ' colspan="'+s[0]+'" ' : "");
                        if (s[1] && s[1] > 1){
                             rspan+=' rowspan="'+s[1]+'" ';
                             empty_cols = -1;
                        }
                        
                
                var val = "";
                //split mode
                var frow = row;
                if (grid._fake && j < grid._fake._cCount)
                	frow = grid._fake.hdr.rows[i];

                for (var k=0; k<frow.cells.length; k++){
					if (frow.cells[k]._cellIndexS==j) {
						if (frow.cells[k].getElementsByTagName("SELECT").length)
							val="";
						else
							val = _isIE?frow.cells[k].innerText:frow.cells[k].textContent;
							val=val.replace(/[ \n\r\t\xA0]+/," ");
						break;
					}
				}
	    		if (!val || val==" ") empty_cols++;
	    		cxml+="<column"+rspan+"><![CDATA["+val+"]]></column>";
	    	};
	    	if (empty_cols != grid._cCount)
	    		xml+="\n<columns>"+cxml+"</columns>";
	    };
	    xml+="</head>\n";
	    xml+=xml_footer();
	    return xml;
	};
	
	function xml_body() {
		var xml =[];
	    if (rows)
	    	for (var i=0; i<rows.length; i++)
	    		xml.push(xml_row(grid.getRowIndex(rows[i])));
	    else
	    	for (var i=0; i<grid.getRowsNum(); i++)
	    		xml.push(xml_row(i));
	    return xml.join("\n");
	}
	function xml_footer() {
		var xml =["<foot>"];
		if (!grid.ftr) return "";
		for (var i=1; i < grid.ftr.rows.length; i++) {
			xml.push("<columns>");
			var row = grid.ftr.rows[i];
			for (var j=0; j < grid._cCount; j++){
				if (grid._srClmn && !grid._srClmn[j]) continue;
				if (grid._hrrar[j] && ( !grid._fake || j >= grid._fake.hdrLabels.length)) continue;
				for (var k=0; k<row.cells.length; k++){
				 	var val = "";
				 	var span = "";
					if (row.cells[k]._cellIndexS==j) {
						val = _isIE?row.cells[k].innerText:row.cells[k].textContent;
						val=val.replace(/[ \n\r\t\xA0]+/," ");
						
						if (row.cells[k].colSpan && row.cells[k].colSpan!=1)
							span = " colspan='"+row.cells[k].colSpan+"' ";
						
						if (row.cells[k].rowSpan && row.cells[k].rowSpan!=1)
							span = " rowspan='"+row.cells[k].rowSpan+"' ";
						break;
					}
				}
				xml.push("<column"+span+"><![CDATA["+val+"]]></column>");
			}
			xml.push("</columns>");
		};
		xml.push("</foot>");
	    return xml.join("\n");
	};
	function get_style(node, style){
		return (window.getComputedStyle?(window.getComputedStyle(node, null)[style]):(node.currentStyle?node.currentStyle[style]:null))||"";
	};
	
	function xml_row(ind){
		if (!grid.rowsBuffer[ind]) return "";
		var r = grid.render_row(ind);
		if (r.style.display=="none") return "";
		var level = grid.isTreeGrid() ? ' level="' + grid.getLevel(r.idd) + '"' : '';
		var xml = "<row" + level + ">";
		for (var i=0; i < grid._cCount; i++) {
			if (((!grid._srClmn)||(grid._srClmn[i]))&&(!grid._hrrar[i] || ( grid._fake && i < grid._fake.hdrLabels.length))){
				var cell = grid.cells(r.idd, i);
				if (full_color){
					var text_color	= get_style(cell.cell,"color");
		        	var bg_color	= get_style(cell.cell,"backgroundColor");
					var bold		= get_style(cell.cell, "font-weight") || get_style(cell.cell, "fontWeight");
					var italic		= get_style(cell.cell, "font-style") || get_style(cell.cell, "fontStyle");
					var align		= get_style(cell.cell, "text-align") || get_style(cell.cell, "textAlign");
					var font	 = get_style(cell.cell, "font-family") || get_style(cell.cell, "fontFamily");
		        	if (bg_color == "transparent" || bg_color == "rgba(0, 0, 0, 0)") bg_color = "rgb(255,255,255)";
		        	xml+="<cell bgColor='"+bg_color+"' textColor='" + text_color + "' bold='" + bold + "' italic='" + italic + "' align='"+align+"' font='" + font + "'>";
				} else 
					xml+="<cell>";
				
				xml+="<![CDATA["+(cell.getContent?cell.getContent():cell.getTitle())+"]]></cell>";
			}
		};
		return xml+"</row>";
	}
	function xml_end(){
	    var xml = "</rows>";
	    return xml;
	}


			
	var d=document.createElement("div");
	d.style.display="none";
	document.body.appendChild(d);
	var uid = "form_"+grid.uid();

	d.innerHTML = '<form id="'+uid+'" method="post" action="'+url+'" accept-charset="utf-8"  enctype="application/x-www-form-urlencoded"' + this.target + '><input type="hidden" name="grid_xml" id="grid_xml"/> </form>';
	document.getElementById(uid).firstChild.value = encodeURIComponent(xml_top(mode).replace("\u2013", "-") + xml_body() + xml_end());
	document.getElementById(uid).submit();
	d.parentNode.removeChild(d);


	grid = null;
	
	if (save_sel && save_sel.row.length) {
		for (var i = 0; i < save_sel.row.length; i++) {
			save_sel.row[i].parentNode.className += ' rowselected';
			if (save_sel.row.length == 1)
				save_sel.row[i].className += ' cellselected';
		}
	};
	save_sel = null;
};
dhtmlXGridObject.prototype._serialiseExportConfig=function(spans){
	function xmlentities(str) {
		if (typeof(str)!=='string') return str;
		str = str.replace(/&/g, "&amp;");
		str = str.replace(/"/g, "&quot;");
		str = str.replace(/'/g, "&apos;");
		str = str.replace(/</g, "&lt;");
		str = str.replace(/>/g, "&gt;");
		return str;
	}
	
	var out = "<head>";

	for (var i = 0; i < this.hdr.rows[0].cells.length; i++){
		if (this._srClmn && !this._srClmn[i]) continue;
		if (this._hrrar[i] && ( !this._fake || i >= this._fake.hdrLabels.length)) continue;
		var sort = this.fldSort[i];
		if (sort == "cus"){
			sort = this._customSorts[i].toString();
			sort=sort.replace(/function[\ ]*/,"").replace(/\([^\f]*/,"");
		}
		var s = spans[1][i];
		var rpans = (( s[1] && s[1] > 1 ) ? ' rowspan="'+s[1]+'" ' : "")+(( s[0] && s[0] > 1 ) ? ' colspan="'+s[0]+'" ' : "");
		out+="<column "+rpans+" width='"+this.getColWidth(i)+"' align='"+this.cellAlign[i]+"' type='"+this.cellType[i] + "' hidden='" + ((this.isColumnHidden && this.isColumnHidden(i)) ? 'true' : 'false')
			+"' sort='"+(sort||"na")+"' color='"+(this.columnColor[i]||"")+"'"
			+(this.columnIds[i]
				? (" id='"+this.columnIds[i]+"'")
				: "")+">";
		if (this._asCDATA)
			out+="<![CDATA["+this.getColumnLabel(i)+"]]>";
		else
			out+=this.getColumnLabel(i);
		var z = this.combos[i]?this.getCombo(i):null;

		if (z)
			for (var j = 0; j < z.keys.length; j++)out+="<option value='"+xmlentities(z.keys[j])+"'><![CDATA["+z.values[j]+"]]></option>";
		out+="</column>";
	}
	return out+="</head>";
};
if (window.eXcell_sub_row_grid)
	window.eXcell_sub_row_grid.prototype.getContent=function(){ return ""; };


dhtmlXGridObject.prototype.toExcel = function(url,mode,header,footer,rows) {
	if (!document.getElementById('ifr')) {
		var ifr = document.createElement('iframe');
		ifr.style.display = 'none';
		ifr.setAttribute('name', 'dhx_export_iframe');
		ifr.setAttribute('src', '');
		ifr.setAttribute('id', 'dhx_export_iframe');
		document.body.appendChild(ifr);
	}

	var target = " target=\"dhx_export_iframe\"";
	this.toPDF(url,mode,header,footer,rows,target);
}


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

//please beware that function started from _in_header_ must not be obfuscated



/**
*   @desc: filter grid by mask
*   @type: public
*   @param: column - {number} zero based index of column
*   @param: value - {string} filtering mask
*   @param: preserve - {bool} filter current or initial state ( false by default )
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.filterBy=function(column, value, preserve){
	if (this.isTreeGrid()) return this.filterTreeBy(column, value, preserve);
	if (this._f_rowsBuffer){
		if (!preserve){
			this.rowsBuffer=dhtmlxArray([].concat(this._f_rowsBuffer));
			if (this._fake) this._fake.rowsBuffer=this.rowsBuffer;
		}
	} else
		this._f_rowsBuffer=[].concat(this.rowsBuffer);	//backup copy
	
		
	if (!this.rowsBuffer.length) return;
	var d=true;
	this.dma(true)
	if (typeof(column)=="object")
		for (var j=0; j<value.length; j++)
			this._filterA(column[j],value[j]);
	else
			this._filterA(column,value);
	this.dma(false)
	if (this.pagingOn && this.rowsBuffer.length/this.rowsBufferOutSize < (this.currentPage-1)) this.changePage(0);
	this._reset_view();
	this.callEvent("onGridReconstructed",[])
}
dhtmlXGridObject.prototype._filterA=function(column,value){ 
	if (value=="") return;
	var d=true;
	if (typeof(value)=="function") d=false;
	else value=(value||"").toString().toLowerCase();
	if (!this.rowsBuffer.length) return;
	
	for (var i=this.rowsBuffer.length-1; i>=0; i--)
		if (d?(this._get_cell_value(this.rowsBuffer[i],column).toString().toLowerCase().indexOf(value)==-1):(!value.call(this, this._get_cell_value(this.rowsBuffer[i],column),this.rowsBuffer[i].idd)))
			this.rowsBuffer.splice(i,1);//filter row
}

dhtmlXGridObject.prototype.getFilterElement=function(index){
	if (!this.filters) return;
	for (var i=0; i < this.filters.length; i++) {
		if (this.filters[i][1]==index)
			return (this.filters[i][0].combo||this.filters[i][0]);
	};
	return null;
}

/**
*   @desc: get all possible values in column
*   @type: public
*   @param: column - {number} zero based index of column
*   @returns: {array} array of all possible values in column
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.collectValues=function(column){
	var evs = this.dhxevs.data.oncollectvalues;
	if (evs){
		var value = true;
		for (var key in evs){
			var nextvalue = evs[key].call(this, column);
			if (nextvalue !== true) value = nextvalue || value;
		}
		if (value !== true)
			return value;
 	}
 	
	if (this.isTreeGrid()) return this.collectTreeValues(column);
	this.dma(true)
	this._build_m_order();
	column=this._m_order?this._m_order[column]:column;
	var c={}; var f=[];
	var col=this._f_rowsBuffer||this.rowsBuffer;
	for (var i=0; i<col.length; i++){
		var val=this._get_cell_value(col[i],column);
		if (val && (!col[i]._childIndexes || col[i]._childIndexes[column]!=col[i]._childIndexes[column-1])) c[val]=true;
	}
	this.dma(false);
	var vals= (this.combos[column]||(this._col_combos?this._col_combos[column]:((this._sub_trees && this._sub_trees[column])?this._sub_trees[column][0]:false)));

	for (var d in c) 
		if (c[d]===true){
           if(vals){
               if(vals.get&&vals.get(d)){
                   d = vals.get(d);
               }
               else if(vals.getOption&&vals.getOption(d)){
                   d = vals.getOption(d).text;
               }
				else if(vals.getItemText){
                   var text = vals.getItemText(d);
                   var t = this._sub_trees[column][1] = this._sub_trees[column][1] || {};
                   t[text] = d;
                   d = text;
               }
           }
           f.push(d);
        }
	
	return f.sort();			
}

dhtmlXGridObject.prototype._build_m_order=function(){
	if (this._c_order){
		this._m_order=[]
		for (var i=0; i < this._c_order.length; i++) {
			this._m_order[this._c_order[i]]=i;
		};
	}
}
/**
*   @desc: force grid filtering by registered inputs ( created by # starting shortcuts, or by makeFilter function )
*   @type: public
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.filterByAll=function(){
	var a=[];
	var b=[];
	this._build_m_order();

	for (var i=0; i<this.filters.length; i++){
		var ind=this._m_order?this._m_order[this.filters[i][1]]:this.filters[i][1];
		if (ind >= this._cCount) continue;
		b.push(ind);

		var val=this.filters[i][0].old_value=this.filters[i][0].value;
		if (this.filters[i][0]._filter)
			val = this.filters[i][0]._filter();
		
		var vals;
		if (typeof val != "function" && (vals=(this.combos[ind]||(this._col_combos?this._col_combos[ind]:((this._sub_trees && this._sub_trees[ind])?this._sub_trees[ind][1]:false))))){
            if(vals.values){
                ind=vals.values._dhx_find(val);
			    val=(ind==-1)?val:vals.keys[ind];
            }
			else if(vals.getOptionByLabel){
                val=(vals.getOptionByLabel(val)?vals.getOptionByLabel(val).value:val);
            } else
            	val = vals[val];
		}
		a.push(val);
		
	}
	if (!this.callEvent("onFilterStart",[b,a])) return;

	this.filterBy(b,a);
	if (this._cssEven) this._fixAlterCss();
	this.callEvent("onFilterEnd",[this.filters]);

	if (this._f_rowsBuffer && this.rowsBuffer.length == this._f_rowsBuffer.length)
		this._f_rowsBuffer = null;
}

/**
*   @desc: create a filter from any input element (text filter), select (dropdown) or DIV (combobox based on dhtmlxCombo)
*   @type: public
*   @param: id - {string|object} input id or input html object
*   @param: column - {number} index of column
*   @param: preserve - {bool} filter current state or initial one ( false by default )
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.makeFilter=function(id,column,preserve){
	if (!this.filters) this.filters=[];
	if (typeof(id)!="object")
		id=document.getElementById(id);
	if(!id) return;
	var self=this;
	
	if (!id.style.width) id.style.width = "90%";
		
	if (id.tagName=='SELECT'){
		this.filters.push([id,column]);
		this._loadSelectOptins(id,column);
		id.onchange=function(){
			self.filterByAll();
		}
		if(_isIE)
			id.style.marginTop="1px";
			
		this.attachEvent("onEditCell",function(stage,a,ind){ 
			this._build_m_order();
			if (stage==2 && this.filters && ( this._m_order?(ind==this._m_order[column]):(ind==column) ))
				this._loadSelectOptins(id,column);
			return true;
		});
	} 
	else if (id.tagName=='INPUT'){
		this.filters.push([id,column]);
		id.old_value = id.value='';
		id.onkeydown=function(){
			if (this._timer) window.clearTimeout(this._timer);
			this._timer=window.setTimeout(function(){
				if (id.value != id.old_value){
					self.filterByAll();
					id.old_value=id.value;
				}
			},500);
		};
	}
	else if (id.tagName=='DIV'){
		this.filters.push([id,column]);
		id.style.padding="0px";id.style.margin="0px";
		if (!window.dhx_globalImgPath) window.dhx_globalImgPath=this.imgURL;
		var z=new dhtmlXCombo(id,"_filter","90%");
		z.filterSelfA=z.filterSelf;
		z.filterSelf=function(){
			if (this.getSelectedIndex()==0) this.setComboText("");
			this.filterSelfA.apply(this,arguments);
			this.optionsArr[0].hide(false);	
		}
         
         
		z.enableFilteringMode(true);
		id.combo=z;
		id.value="";
		
		this._loadComboOptins(id,column);
		z.attachEvent("onChange",function(){
			id.value=z.getSelectedValue();
			if (id.value === null) id.value = "";
			self.filterByAll();
		});
	}
	if (id.parentNode)
		id.parentNode.className+=" filter";
	
	this._filters_ready(); //set event handlers
}
	/**
	*   @desc: find cell in grid by value
	*   @param: value - search string
	*   @param: c_ind - index of column to search in (optional. if not specified, then search everywhere)
	*   @param: count - count of results to return
	*   @edition: Professional
	*   @returns: array each member of which contains array with row ID  and cell index
	*   @type:  public
	*/
	dhtmlXGridObject.prototype.findCell=function(value, c_ind, count, compare){ 
		var compare = compare || (function(master, check){
			return check.toString().toLowerCase().indexOf(master) != -1;
		});
		if (compare === true)
			compare = function(master, check){ return check.toString().toLowerCase() == master; };

		var res = new Array();
		value=value.toString().toLowerCase();
		if (typeof count != "number") count = count?1:0;
	
		if (!this.rowsBuffer.length)
			return res;
	
		for (var i = (c_ind||0); i < this._cCount; i++){
			if (this._h2)
				this._h2.forEachChild(0,function(el){
					if (count && res.length==count) return res;
					if (compare(value, this._get_cell_value(el.buff,i))){
						res.push([el.id,i]);
					}
				},this)
			else
				for (var j=0; j < this.rowsBuffer.length; j++) 
					if (compare(value, this._get_cell_value(this.rowsBuffer[j],i))){
						res.push([this.rowsBuffer[j].idd,i]);
						if (count && res.length==count) return res;
					}
						
			
		
			if (typeof (c_ind) != "undefined")
				return res;
		}
	
		return res;
	}
	
/**
*   @desc: create a search box (set selection to the row with found value) from any input
*   @type: public
*   @param: id - {string|object} input id or input html object
*   @param: column - {number} index of column
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.makeSearch=function(id,column,strict){
	if (typeof(id)!="object")
		id=document.getElementById(id);
	if(!id) return;
	var self=this;
		
	if (id.tagName=='INPUT'){
		id.onkeypress=function(){
			if (this._timer) window.clearTimeout(this._timer);
			this._timer=window.setTimeout(function(){
				if (id.value=="") return;
				var z=self.findCell(id.value,column,true,strict);
				if (z.length){
					if (self._h2)
						self.openItem(z[0][0]);
					self.selectCell(self.getRowIndex(z[0][0]),(column||0))
				}
			},500);
		};
	}
	if (id.parentNode)
		id.parentNode.className+=" filter";
}
	
dhtmlXGridObject.prototype._loadSelectOptins=function(t,c){ 
		var l=this.collectValues(c);
		var v=t.value;
		t.innerHTML="";
		t.options[0]=new Option("","");
		var f=this._filter_tr?this._filter_tr[c]:null;
		for (var i=0; i<l.length; i++)
			t.options[t.options.length]=new Option(f?f(l[i]):l[i],l[i]);
		t.value=v;
}
dhtmlXGridObject.prototype.setSelectFilterLabel=function(ind,fun){ 
		if (!this._filter_tr) this._filter_tr=[];
		this._filter_tr[ind]=fun;
}

dhtmlXGridObject.prototype._loadComboOptins=function(t,c){
	if (!t.combo) return; // prevent calls from refreshFilters
	var l=this.collectValues(c);
	t.combo.clearAll();
	var opts = [["",""]];
	for (var i=0; i<l.length; i++) opts.push([l[i],l[i]]);
	t.combo.addOption(opts);
}

/**
*   @desc: refresh filtering ( can be used if data in grid changed and filters need to be updated )
*   @type: public
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.refreshFilters=function(){
        if(!this.filters) return;
	for (var i=0; i<this.filters.length; i++){
		switch(this.filters[i][0].tagName.toLowerCase()){
			case "input":
				break;
			case "select":
				this._loadSelectOptins.apply(this,this.filters[i]);
				break;
			case "div":
				this._loadComboOptins.apply(this,this.filters[i]);
				break;
		}
	}
}

dhtmlXGridObject.prototype._filters_ready=function(fl,code){
	this.attachEvent("onXLE",this.refreshFilters);
	this.attachEvent("onRowCreated",function(id,r){
		if (this._f_rowsBuffer)
			for (var i=0; i<this._f_rowsBuffer.length; i++)
				if (this._f_rowsBuffer[i].idd == id)
					return this._f_rowsBuffer[i]=r;
	})
	this.attachEvent("onClearAll",function(){ 
	    this._f_rowsBuffer=null; 
		if (!this.hdr.rows.length)
			this.filters=[];
	});
	/*
	if (window.dhtmlXCombo)
		this.attachEvent("onScroll",dhtmlXCombo.prototype.closeAll);
	*/
	this.attachEvent("onSetSizes", this._filters_resize_combo);
	this.attachEvent("onResize", this._filters_resize_combo);
	
	this._filters_ready=function(){};
}

dhtmlXGridObject.prototype._filters_resize_combo=function(){
	if (!this.filters) return;
	for (var q=0; q<this.filters.length; q++) {
		if (this.filters[q][0].combo != null) {
			this.filters[q][0].combo.setSize(Math.round(this.filters[q][0].offsetWidth*90/100));
		}
	}
	return true;
}

dhtmlXGridObject.prototype._in_header_text_filter=function(t,i){
	t.innerHTML="<input type='text'>";
	t.onclick=t.onmousedown = function(e){ (e||event).cancelBubble=true; return true; }
	t.onselectstart=function(){ return (event.cancelBubble=true); }
	this.makeFilter(t.firstChild,i);
}

dhtmlXGridObject.prototype._in_header_text_filter_inc=function(t,i){
	t.innerHTML="<input type='text'>";
	t.onclick=t.onmousedown = function(e){ (e||event).cancelBubble=true; return true; }
	t.onselectstart=function(){ return (event.cancelBubble=true); }
	this.makeFilter(t.firstChild,i);
	t.firstChild._filter=function(){ 
		if (t.firstChild.value=="") return "";
		return function(val){
			return (val.toString().toLowerCase().indexOf(t.firstChild.value.toLowerCase())==0); 
		}
	}
	this._filters_ready();
}

dhtmlXGridObject.prototype._in_header_select_filter=function(t,i){
	t.innerHTML="<select></select>";
	t.onclick=function(e){ (e||event).cancelBubble=true; return false; }
	this.makeFilter(t.firstChild,i);
}

dhtmlXGridObject.prototype._in_header_select_filter_strict=function(t,i){
	t.innerHTML="<select style='width:90%; font-size:8pt; font-family:Tahoma;'></select>";
	t.onclick=function(e){ (e||event).cancelBubble=true; return false; }
	this.makeFilter(t.firstChild,i);
	var combos = this.combos;
	t.firstChild._filter=function(){ 
		var value = t.firstChild.value;
		if (!value) return "";
		if (combos[i])
            value = combos[i].keys[combos[i].values._dhx_find(value)];
       	value = value.toLowerCase();
            
		return function(val){
			return (val.toString().toLowerCase()==value); 
		};
	};
	this._filters_ready();
}

dhtmlXGridObject.prototype._in_header_combo_filter=function(t,i){
	t.innerHTML="<div style='width:100%; padding-left:2px; overflow:hidden; ' class='combo'></div>";
	t.onselectstart=function(){ return (event.cancelBubble=true); }
	t.onclick=t.onmousedown=function(e){ (e||event).cancelBubble=true; return true; }
	this.makeFilter(t.firstChild,i);
}

dhtmlXGridObject.prototype._search_common=function(t, i){
	t.innerHTML="<input type='text' style='width:90%; '>";
	t.onclick= t.onmousedown = function(e){ (e||event).cancelBubble=true; return true; }
	t.onselectstart=function(){ return (event.cancelBubble=true); }
}
dhtmlXGridObject.prototype._in_header_text_search=function(t,i, strict){
	this._search_common(t, i);
	this.makeSearch(t.firstChild,i);
}
dhtmlXGridObject.prototype._in_header_text_search_strict=function(t,i){
	this._search_common(t, i);
	this.makeSearch(t.firstChild,i, true);
}

dhtmlXGridObject.prototype._in_header_numeric_filter=function(t,i){
	this._in_header_text_filter.call(this,t,i);
	t.firstChild._filter=function(){
		var v=this.value;
		
		var r; var op="=="; var num=parseFloat(v.replace("=","")); var num2=null;
		
		if (v){
			if (v.indexOf("..")!=-1){
				v=v.split("..");
				num=parseFloat(v[0]);
				num2=parseFloat(v[1]);
				return function(v){
					if (v>=num && v<=num2) return true;
					return false;
					}
			}
			r=v.match(/>=|<=|>|</)
			if (r) {
				op=r[0];
				num=parseFloat(v.replace(op,""));
			}
			return Function("v"," if (v "+op+" "+num+" ) return true; return false;");
		}
		return "";
	};
}

dhtmlXGridObject.prototype._in_header_master_checkbox=function(t,i,c){
	t.innerHTML=c[0]+"<input type='checkbox' />"+c[1];
	var self=this;
	t.getElementsByTagName("input")[0].onclick=function(e){
		self._build_m_order();
		var j=self._m_order?self._m_order[i]:i;
		var val=this.checked?1:0;
		self.forEachRowA(function(id){
			var c=this.cells(id,j);
			if (c.isCheckbox() && !c.isDisabled()) {
				c.setValue(val);
				c.cell.wasChanged = true;
			}
			this.callEvent("onEditCell",[1,id,j,val]);
			this.callEvent("onCheckbox", [id, j, val]);
			this.callEvent("onCheck", [id, j, val]);
		});
		(e||event).cancelBubble=true;
	}
}

dhtmlXGridObject.prototype._in_header_stat_total=function(t,i,c){
	var calck=function(){
		var summ=0;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		for (var j=0; j<this.rowsBuffer.length; j++){
			var v=parseFloat(this._get_cell_value(this.rowsBuffer[j],ii));
			summ+=isNaN(v)?0:v;
		}
		
		return this._maskArr[ii]?this._aplNF(summ,ii):(Math.round(summ*100)/100);
	}
	this._stat_in_header(t,calck,i,c,c);
}
dhtmlXGridObject.prototype._in_header_stat_multi_total=function(t,i,c){
	var cols=c[1].split(":"); c[1]="";
	for(var k = 0; k < cols.length;k++){
		cols[k]=parseInt(cols[k]);
	}
	var calck=function(){
		var summ=0;
		for (var j=0; j<this.rowsBuffer.length; j++){
			var v = 1;
			for(var k = 0; k < cols.length;k++){
				v *= parseFloat(this._get_cell_value(this.rowsBuffer[j],cols[k]))
			}
			summ+=isNaN(v)?0:v;
		}
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ*100)/100);
	}
	var track=[];
	for(var ind = 0; ind < cols.length;ind++){
		track[cols[ind]]=true;
	}
	this._stat_in_header(t,calck,track,c,c);
}
dhtmlXGridObject.prototype._in_header_stat_max=function(t,i,c){
	var calck=function(){
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		
		var summ=-999999999;
		if (this.getRowsNum()==0) return "&nbsp;";
		for (var j=0; j<this.rowsBuffer.length; j++)
			summ=Math.max(summ,parseFloat(this._get_cell_value(this.rowsBuffer[j],ii)));
		
		return this._maskArr[i]?this._aplNF(summ,i):summ;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_min=function(t,i,c){
	var calck=function(){
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		
		var summ=999999999;
		if (this.getRowsNum()==0) return "&nbsp;";
		for (var j=0; j<this.rowsBuffer.length; j++)
			summ=Math.min(summ,parseFloat(this._get_cell_value(this.rowsBuffer[j],ii)));
		return this._maskArr[i]?this._aplNF(summ,i):summ;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_average=function(t,i,c){
	var calck=function(){
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		
		var summ=0; var count=0;
		if (this.getRowsNum()==0) return "&nbsp;";
		for (var j=0; j<this.rowsBuffer.length; j++){
			var v=parseFloat(this._get_cell_value(this.rowsBuffer[j],ii));
			if (!isNaN(v)){
				summ+=v;
				count++;
			}
		}
		return this._maskArr[i]?this._aplNF(summ/count,i):(Math.round(summ/count*100)/100);
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_count=function(t,i,c){
	var calck=function(){
		return this.getRowsNum();
	}
	this._stat_in_header(t,calck,i,c);
}

dhtmlXGridObject.prototype._stat_in_header=function(t,calck,i,c){
	var that=this;
	var f=function(){
		this.dma(true)
		t.innerHTML=(c[0]?c[0]:"")+calck.call(this)+(c[1]?c[1]:"");
		this.dma(false)
		this.callEvent("onStatReady",[])
	}
	if (!this._stat_events) {
		this._stat_events=[];
		this.attachEvent("onClearAll",function(){ 
			if (!this.hdr.rows[1]){
				for (var i=0; i<this._stat_events.length; i++)
					for (var j=0; j < 4; j++) 
						this.detachEvent(this._stat_events[i][j]);
				this._stat_events=[];	
			}
		})
	}
	
	this._stat_events.push([
	this.attachEvent("onGridReconstructed",f),
	this.attachEvent("onXLE",f),
	this.attachEvent("onFilterEnd",f),
	this.attachEvent("onEditCell",function(stage,id,ind){
		if (stage==2 && ( ind==i || ( i && i[ind]) ) ) f.call(this);
		return true;
		})]);
	t.innerHTML="";
}



//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: load grid from CSV file
*   @param: path - path to file
*   @param: afterCall - function which will be called after xml loading
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.loadCSVFile = function(path,afterCall){
    this.load(path,afterCall,"csv")
}

/**
*   @desc: enable mode, where ID for rows loaded from CSV autogenerated
*   @param: mode - true/false
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableCSVAutoID = function(mode){
   this._csvAID=dhx4.s2b(mode);
}
/**
*   @desc: enable recognizing first row in CSV as header
*   @param: mode - true/false
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableCSVHeader = function(mode){
   this._csvHdr=dhx4.s2b(mode);
}

/**
*   @desc: load grid from CSV string
*   @param: str - delimer used in CSV operations, comma by default ( only single char delimeters allowed )
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.setCSVDelimiter = function(str){
   this.csv.cell=str;
}
dhtmlXGridObject.prototype._csvAID = true;

/**
*   @desc: load grid from CSV string
*   @param: str - CSV  string
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.loadCSVString = function(str){
   this.parse(str,"csv")
}

/**
*   @desc: serialize to CSV string
*   @type: public
*	@param: text only - force serialization of text values ( skip HTML elements ) )
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.serializeToCSV = function(textmode){ 
    this.editStop()
    if (this._mathSerialization)
         this._agetm="getMathValue";
    else if (this._strictText || textmode)
    	this._agetm="getTitle";
    else this._agetm="getValue";

	var out=[];
	if (this._csvHdr){
		for (var j=1; j < this.hdr.rows.length; j++) {
			var a=[]; 
			for (var i=0; i<this._cCount; i++)
				if ((!this._srClmn)||(this._srClmn[i]))
					a.push(this.getColumnLabel(i,j-1));
    		out.push(this.csvParser.str(a,this.csv.cell, this.csv.row));
    	}
    }

    
    //rows collection
    var i=0;
    var leni=this.rowsBuffer.length;

   for(i; i<leni; i++){
		var temp=this._serializeRowToCVS(null,i)      	
		if (temp!="") out.push(temp);
  }

   return this.csvParser.block(out,this.csv.row);
}

/**
*   @desc: serialize TR to CSV
*   @param: r - TR or xml node (row)
*   @retruns: string - CSV representation of passed row
*   @type: private
*/
dhtmlXGridObject.prototype._serializeRowToCVS = function(r,i,start,end){
    var out = new Array();
    if (!r){
	    r=this.render_row(i)
	    if (this._fake && !this._fake.rowsAr[r.idd]) this._fake.render_row(i);
	}
    

    if (!this._csvAID)
       out[out.length]=r.idd;

	start = start||0;
	
    end = end||this._cCount;
    //cells
    var changeFl=false;
    var ind=start;
    //rowspans before block selection
    while (r.childNodes[start]._cellIndex>ind && start) start--; 
    
    
    for(var jj=start;ind<end;jj++){
    	if (!r.childNodes[jj]) break;
    	var real_ind=r.childNodes[jj]._cellIndex;
        if (((!this._srClmn)||(this._srClmn[real_ind])) && (!this._serialize_visible || !this._hrrar[real_ind])){
            var cvx=r.childNodes[jj];

            var zx=this.cells(r.idd,real_ind);
            while (ind!=real_ind){
            	ind++;
            	out.push("")
            	if (ind>=end) break;
            }
            if (ind>=end) break;
            ind++;
        /*	if (zx.getText)
        		zxVal=zx.getText();
        	else*/
            if (zx.cell)
				zxVal=zx[this._agetm]();
			else zxVal="";


		if ((this._chAttr)&&(zx.wasChanged()))
			changeFl=true;

            out[out.length]=((zxVal===null)?"":zxVal)
//#colspan:20092006{
            if ( this._ecspn && cvx.colSpan && cvx.colSpan >1 ){
                cvx=cvx.colSpan-1;
                for (var u=0; u<cvx; u++){
	                out[out.length] = "";
	                ind++;
                }
            }
//#}

 } else ind++;
    }
     if ((this._onlChAttr)&&(!changeFl)) return "";
      return this.csvParser.str(out,this.csv.cell, this.csv.row);
}

dhtmlXGridObject.prototype.toClipBoard=function(val){
    if (window.clipboardData)
      window.clipboardData.setData("Text",val);
   else
      (new Clipboard()).copy(val);

}
dhtmlXGridObject.prototype.fromClipBoard=function(){
   if (window.clipboardData)
      return window.clipboardData.getData("Text");
   else
      return (new Clipboard()).paste();
}

/**
*   @desc: copy value of cell to clipboard
*   @type: public
*   @param: rowId - id of row (optional, use selected row by default)
*   @param: cellInd - column index(optional, use selected cell by default)
*     @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.cellToClipboard = function(rowId,cellInd){
    if ((!rowId)||(!cellInd && cellInd !== 0)){
       if (!this.selectedRows[0]) return;
       rowId=this.selectedRows[0].idd;
       cellInd=this.cell._cellIndex;
   }
   
   	var ed=this.cells(rowId,cellInd);
    this.toClipBoard(((ed.getLabel?ed.getLabel():ed.getValue())||"").toString());
}

/**
*   @desc: set value of cell from clipboard
*   @type: public
*     @edition: Professional
*   @param: rowId - id of row (optional, use selected row by default)
*   @param: cellInd - column index(optional, use selected cell by default)
*   @topic: 5
*/
dhtmlXGridObject.prototype.updateCellFromClipboard = function(rowId,cellInd){
    if ((!rowId)||(!cellInd)){
       if (!this.selectedRows[0]) return;
       rowId=this.selectedRows[0].idd;
       cellInd=this.cell._cellIndex;
   }
   	var ed=this.cells(rowId,cellInd);
    ed[ed.setImage?"setLabel":"setValue"](this.fromClipBoard());
}

/**
*   @desc: copy value of row to clipboard
*   @type: public
*     @edition: Professional
*   @param: rowId - id of row (optional, use selected row by default)
*   @topic: 5
*/
dhtmlXGridObject.prototype.rowToClipboard = function(rowId){
	var out="";
	if (this._mathSerialization)
		this._agetm="getMathValue";
	else if (this._strictText)
		this._agetm="getTitle";
	else 
		this._agetm="getValue";
    
  this._serialize_visible = !this._fake;

	if (rowId)
		out=this._serializeRowToCVS(this.getRowById(rowId));
	else {
   		var data = [];
		for (var i=0; i<this.selectedRows.length; i++){
			data[data.length] = this._serializeRowToCVS(this.selectedRows[i]);
			out = this.csvParser.block(data, this.csv.row);
		}
	}

  this._serialize_visible = false;
	this.toClipBoard(out);
}

/**
*   @desc: set value of row from clipboard
*   @type: public
*     @edition: Professional
*   @param: rowId - id of row (optional, use selected row by default)
*   @topic: 5
*/
dhtmlXGridObject.prototype.updateRowFromClipboard = function(rowId){
	var csv=this.fromClipBoard();
	if (!csv) return;
	if (rowId)
		var r=this.getRowById(rowId);
	else
		var r=this.selectedRows[0];
	if (!r) return;
	
	var parser = this.csvParser;
	csv=parser.unblock(csv,this.csv.cell, this.csv.row)[0];
	if (!this._csvAID) csv.splice(0,1);
	for (var i=0; i<csv.length; i++){
		var ed=this.cells3(r,i);
		ed[ed.setImage?"setLabel":"setValue"](csv[i]);
	}
}

dhtmlXGridObject.prototype.csvParser={
	block:function(data,row){
		return data.join(row);
	},
	unblock:function(str,cell,row){
		var data = (str||"").split(row);	
		for (var i=0; i < data.length; i++)
			data[i]=(data[i]||"").split(cell);
    var last = data.length-1;
    if (data[last].length == 1 && data[last][0]=="")
      data.splice(last,1);
		return data;
	},
	str:function(data,cell,row){
		return data.join(cell);
	}
};
dhtmlXGridObject.prototype.csvExtParser={
	_quote:RegExp('"',"g"),
	_quote_esc:RegExp("\"\"","g"),
	block:function(data,row){
		return data.join(row);
	},
	unblock:function(str,cell,row){ 
		var out = [[]];
		var ind = 0;
		if (!str) return out;

		var quote_start = /^[ ]*"/;
		var quote_end   = /"[ ]*$/;
		var row_exp  = new RegExp(".*"+row+".*$");
		
		var data = str.split(cell);
		for (var i=0; i<data.length; i++){
			if (data[i].match(quote_start)){
				var buff = data[i].replace(quote_start, "");
				while (!data[i].match(quote_end)) {
					i++;
					buff+=data[i];
				}
				out[ind].push(buff.replace(quote_end, "").replace(this._quote_esc,'"'));
			} else if (data[i].match(row_exp)){
        var row_pos = data[i].indexOf(row);
				out[ind].push(data[i].substr(0, row_pos));
				ind++;
				out[ind] = [];
				data[i]=data[i].substr(row_pos+1); i--;
			} else {
				if (data[i] || i!=data.length-1)
					out[ind].push(data[i]);
			}
		}

    var last = out.length-1;
    if (last>0 && !out[last].length)
      out.splice(last,1);
    
		return out;	
	},
	str:function(data,cell,row){
		for (var i=0; i < data.length; i++)
			data[i] = '"'+data[i].replace(this._quote, "\"\"")+'"';
		return data.join(cell);
	}
};

/**
*   @desc: add new row from clipboard
*   @type: public
*     @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.addRowFromClipboard = function(){
   var csv=this.fromClipBoard();
   if (!csv) return;
   var z=this.csvParser.unblock(csv, this.csv.cell, this.csv.row);
   for (var i=0; i<z.length; i++)
      if (z[i]){
         csv=z[i];
         if (!csv.length) continue;
         if (this._csvAID)
         	this.addRow(this.getRowsNum()+2,csv);
         else{
         	if (this.rowsAr[csv[0]])
         		csv[0]=this.uid();
         	this.addRow(csv[0],csv.slice(1));
     		}
      }
}

/**
*   @desc: copy grid in CSV to clipboard
*   @type: public
*     @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.gridToClipboard = function(){
   this.toClipBoard(this.serializeToCSV());
}

/**
*   @desc: init grid from CSV stored in clipboard
*   @type: public
*     @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.gridFromClipboard = function(){
   var csv=this.fromClipBoard();
   if (!csv) return;
   this.loadCSVString(csv);
}

/**
*   @desc: get grid as XML - php required
*   @param: path - path to server side code,optional
*   @type: private
*   @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.getXLS = function(path){
   if (!this.xslform){
      this.xslform=document.createElement("FORM");
      this.xslform.action=(path||"")+"xls.php";
      this.xslform.method="post";
      this.xslform.target=(_isIE?"_blank":"");
      document.body.appendChild(this.xslform);
      var i1=document.createElement("INPUT");
      i1.type="hidden";
      i1.name="csv";
      this.xslform.appendChild(i1);
      var i2=document.createElement("INPUT");
      i2.type="hidden";
      i2.name="csv_header";
      this.xslform.appendChild(i2);
   }
      var cvs = this.serializeToCSV();
      this.xslform.childNodes[0].value = cvs;
        var cvs_header = [];
        var l = this._cCount;
        for (var i=0; i<l; i++) {
         cvs_header.push(this.getHeaderCol(i));
        }
      cvs_header = cvs_header.join(',');
      this.xslform.childNodes[1].value = cvs_header;
       this.xslform.submit();
}

/**
*   @desc: generate print friendly view
*   @type: public
*   @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.printView = function(before,after){
	  var html="<style>TD { font-family:Arial; text-align:center; padding-left:2px;padding-right:2px; } \n td.filter input, td.filter select { display:none; }	\n  </style>";
	  var st_hr=null;
	  if (this._fake) {
	  	st_hr=[].concat(this._hrrar); 
	  	for (var i=0; i<this._fake._cCount; i++)
	  		this._hrrar[i]=null;
	  }
     var port = document.location.port;
     var hostname = document.location.hostname;
	   html+="<base  href='"+(document.location.protocol+"//"+hostname+(port?(":"+port):"")+document.location.pathname)+"'></base>";
	   if (!this.parentGrid) html+=(before||"");
       html += '<table width="100%" border="2px" cellpadding="0" cellspacing="0">';
       var row_length = Math.max(this.rowsBuffer.length,this.rowsCol.length); //paging and smartrendering
       var col_length = this._cCount;
      var width = this._printWidth();
      html += '<tr class="header_row_1">';
        for (var i=0; i<col_length; i++){
        	if (this._hrrar && this._hrrar[i]) continue;
         var hcell=this.hdr.rows[1].cells[this.hdr.rows[1]._childIndexes?this.hdr.rows[1]._childIndexes[parseInt(i)]:i];
         var colspan=(hcell.colSpan||1);
         var rowspan=(hcell.rowSpan||1);
         
         for (var j=1; j<colspan; j++)
         	width[i]+=width[j];
    	html += '<td rowspan="'+rowspan+'" width="'+width[i]+'%" style="background-color:lightgrey;" colspan="'+colspan+'">'+this.getHeaderCol(i)+'</td>';
         i+=colspan-1;
        }
      html += '</tr>';

	  	for (var i=2; i<this.hdr.rows.length; i++){
	  		if (_isIE){
	  			html+="<tr style='background-color:lightgrey' class='header_row_"+i+"'>";
	  			var cells=this.hdr.rows[i].childNodes;
	  			for (var j=0; j < cells.length; j++) 
	  				if (!this._hrrar || !this._hrrar[cells[j]._cellIndex]){
	  					html+=cells[j].outerHTML;
	  				}
	  			html+="</tr>";
	  			}
	  		else
				html+="<tr class='header_row_"+i+"' style='background-color:lightgrey'>"+(this._fake?this._fake.hdr.rows[i].innerHTML:"")+this.hdr.rows[i].innerHTML+"</tr>";
		}

       for (var i=0; i<row_length; i++) {
         html += '<tr>';
           if (this.rowsCol[i] && this.rowsCol[i]._cntr){
           	  html+=this.rowsCol[i].innerHTML.replace(/<img[^>]*>/gi,"")+'</tr>';
           	  continue;
           }
           if (this.rowsCol[i] && this.rowsCol[i].style.display=="none") continue;
           
           var row_id
           if (this.rowsCol[i])
           		row_id=this.rowsCol[i].idd;
           	else if (this.rowsBuffer[i]) 
           		row_id=this.rowsBuffer[i].idd;
           	else continue; //dyn loading 
           	
           for (var j=0; j<col_length; j++) {
           	   if (this._hrrar && this._hrrar[j]) continue;
           	   if(this.rowsAr[row_id] && this.rowsAr[row_id].tagName=="TR") {
	           	   var c=this.cells(row_id, j);
	           	   if (c._setState) var value="";
	           	   else if (c.getContent) value = c.getContent();
	           	   else if (c.getImage || c.combo) var value=c.cell.innerHTML;
	           	   else var value = c.getValue();
           	   } else 
	           	  var value=this._get_cell_value(this.rowsBuffer[i],j);
               var color = this.columnColor[j]?'background-color:'+this.columnColor[j]+';':'';
            var align = this.cellAlign[j]?'text-align:'+this.cellAlign[j]+';':'';
            var cspan =  c.getAttribute("colspan");
            html += '<td style="'+color+align+'" '+(cspan?'colSpan="'+cspan+'"':'')+'>'+(value===""?"&nbsp;":value)+'</td>';
            if (cspan) j+=cspan-1;
           }
         html += '</tr>';
         if (this.rowsCol[i] && this.rowsCol[i]._expanded){
         	 var sub=this.cells4(this.rowsCol[i]._expanded.ctrl);
         	 if (sub.getSubGrid)
         	 	html += '<tr><td colspan="'+col_length+'">'+sub.getSubGrid().printView()+'</td></tr>';
         	 else
         	 	html += '<tr><td colspan="'+col_length+'">'+this.rowsCol[i]._expanded.innerHTML+'</td></tr>';
         }
       }

	   if (this.ftr)
	  	for (var i=1; i<this.ftr.childNodes[0].rows.length; i++)
	  		html+="<tr style='background-color:lightgrey'>"+((this._fake)?this._fake.ftr.childNodes[0].rows[i].innerHTML:"")+this.ftr.childNodes[0].rows[i].innerHTML+"</tr>";
        		

      html += '</table>';
      if (this.parentGrid) return html;
      
      html+=(after||"");
      var d = window.open('', '_blank');
      d.document.write(html);
      d.document.write("<script>window.onerror=function(){return true;}</script>");
      d.document.close();
      if (this._fake) {
	  	this._hrrar=st_hr;
	  }
}
dhtmlXGridObject.prototype._printWidth=function(){
      var width = [];
      var total_width = 0;
      for (var i=0; i<this._cCount; i++) {
         var w = this.getColWidth(i);
         width.push(w);
         total_width += w;
      }
      var percent_width = [];
      var total_percent_width = 0;
      for (var i=0; i<width.length; i++) {
         var p = Math.floor((width[i]/total_width)*100);
         total_percent_width += p;
            percent_width.push(p);
      }
      percent_width[percent_width.length-1] += 100-total_percent_width;
      return percent_width;
   }

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*     @desc: enables block selection mode in grid
*     @type: public
*     @topic: 0
*/
dhtmlXGridObject.prototype.enableBlockSelection = function(mode)
{
	if (typeof this._bs_mode == "undefined"){
		var self = this;
		this.obj.onmousedown = function(e) {
			if (self._bs_mode) self._OnSelectionStart((e||event),this); return true;
		}
		this._CSVRowDelimiter = this.csv.row;
		this.attachEvent("onResize", function() {self._HideSelection(); return true;});
		this.attachEvent("onGridReconstructed", function() {self._HideSelection(); return true;});
		this.attachEvent("onFilterEnd",this._HideSelection);
	}
	if (mode===false){
		this._bs_mode=false;
		return this._HideSelection();
	} else this._bs_mode=true;

	if (!window.dhx4.isIPad){
		var area = this._clip_area = document.createElement("textarea");
		area.style.cssText = "position:absolute; width:1px; height:1px; overflow:hidden; color:transparent; background-color:transparent; bottom:1px; right:1px; border:none;";

		area.onkeydown=function(e){
	            e=e||event;
	            if (e.keyCode == 86 && (e.ctrlKey || e.metaKey))
					self.pasteBlockFromClipboard()
		};
	    document.body.insertBefore(this._clip_area,document.body.firstChild);

	    dhtmlxEvent(this.entBox,"click",function(){
	        if (!self.editor && self._clip_area)
	            self._clip_area.select();
	    });
	}
}
/**
*     @desc:  affect block selection, so it will copy|paste only visible text , not values behind
*	  @param: mode - true/false
*     @type: public
*     @topic: 0
*/
dhtmlXGridObject.prototype.forceLabelSelection = function(mode)
{
	this._strictText = dhx4.s2b(mode)
}


dhtmlXGridObject.prototype.selectBlock = function(sx, sy, ex, ey)
{
	sy = this.getRowIndex(sy);
	ey = this.getRowIndex(ey);

	myGrid._CreateSelection(sy, sx);
    myGrid._selectionArea = myGrid._RedrawSelectionPos(myGrid.cells2(sy, sx).cell, myGrid.cells2(ey, ex).cell);
    myGrid._ShowSelection();
}

dhtmlXGridObject.prototype._OnSelectionStart = function(event, obj)
{

	var self = this;
	if (event.button == 2) return;
	var src = event.srcElement || event.target;
	if (this.editor){
		if (src.tagName && (src.tagName=="INPUT" || src.tagName=="TEXTAREA"))   return;
		this.editStop();
	}
	
	self.setActive(true);
	var pos = this.getPosition(this.obj);
	var x = event.clientX - pos[0] + (document.body.scrollLeft||(document.documentElement?document.documentElement.scrollLeft:0));
	var y = event.clientY - pos[1] + (document.body.scrollTop||(document.documentElement?document.documentElement.scrollTop:0));
	this._CreateSelection(x-4, y-4);

	if (src == this._selectionObj) {
		this._HideSelection();
		this._startSelectionCell = null;
	} else {
	    while (src && (!src.tagName || src.tagName.toLowerCase() != 'td'))
	        src = src.parentNode;
	    this._startSelectionCell = src;
	}
	
	if (this._startSelectionCell){
		if (!this.callEvent("onBeforeBlockSelected",[this._startSelectionCell.parentNode.idd, this._startSelectionCell._cellIndex]))
			return this._startSelectionCell = null;
	}
	
	    //this._ShowSelection();
	    this.obj.onmousedown = null;
		this.obj[_isIE?"onmouseleave":"onmouseout"] = function(e){ if (self._blsTimer) window.clearTimeout(self._blsTimer); };	    
		this.obj.onmmold=this.obj.onmousemove;
		this._init_pos=[x,y];
	    this._selectionObj.onmousemove = this.obj.onmousemove = function(e) {e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false;  self._OnSelectionMove(e);}
	    
	    
	    this._oldDMP=document.body.onmouseup;
	    document.body.onmouseup = function(e) {e = e||event; self._OnSelectionStop(e, this); return true; }
	this.callEvent("onBeforeBlockSelection",[]);
	document.body.onselectstart = function(){return false};//avoid text select	    
}

dhtmlXGridObject.prototype._getCellByPos = function(x,y){
	x=x;//+this.objBox.scrollLeft;
	if (this._fake)
		x+=this._fake.objBox.scrollWidth;
	y=y;//+this.objBox.scrollTop;
	var _x=0;
	for (var i=0; i < this.obj.rows.length; i++) {
		y-=this.obj.rows[i].offsetHeight;
		if (y<=0) {
			_x=this.obj.rows[i];
			break;
		}
	}
	if (!_x || !_x.idd) return null;
	for (var i=0; i < this._cCount; i++) {
		x-=this.getColWidth(i);
		if (x<=0) {
			while(true){
				if (_x._childIndexes && _x._childIndexes[i+1]==_x._childIndexes[i])
					_x=_x.previousSibling;
				else {
					return this.cells(_x.idd,i).cell;
				}
				
			}
		}
	}
	return null;
}

dhtmlXGridObject.prototype._OnSelectionMove = function(event)
{ 
	
	var self=this;
	this._ShowSelection();
	var pos = this.getPosition(this.obj);
	var X = event.clientX - pos[0] + (document.body.scrollLeft||(document.documentElement?document.documentElement.scrollLeft:0));
	var Y = event.clientY - pos[1] + (document.body.scrollTop||(document.documentElement?document.documentElement.scrollTop:0));

	if ((Math.abs(this._init_pos[0]-X)<5) && (Math.abs(this._init_pos[1]-Y)<5)) return this._HideSelection();
	
	var temp = this._endSelectionCell;
	if(this._startSelectionCell==null)
 		this._endSelectionCell  = this._startSelectionCell = this.getFirstParentOfType(event.srcElement || event.target,"TD");		
	else
		if (event.srcElement || event.target) {
			if ((event.srcElement || event.target).className == "dhtmlxGrid_selection")
				this._endSelectionCell=(this._getCellByPos(X,Y)||this._endSelectionCell);
			else {
				var t = this.getFirstParentOfType(event.srcElement || event.target,"TD");
				if (t.parentNode.idd) this._endSelectionCell = t;
			}
		}
		
	if (this._endSelectionCell){
		if (!this.callEvent("onBeforeBlockSelected",[this._endSelectionCell.parentNode.idd, this._endSelectionCell._cellIndex]))
			this._endSelectionCell = temp;
	}
	
		/*
	//window.status = pos[0]+'+'+pos[1];
	var prevX = this._selectionObj.startX;
	var prevY = this._selectionObj.startY;
	var diffX = X - prevX;
	var diffY = Y - prevY;
	
	if (diffX < 0) {
        this._selectionObj.style.left = this._selectionObj.startX + diffX + 1+"px";
        diffX = 0 - diffX;
	} else {
		this._selectionObj.style.left = this._selectionObj.startX - 3+"px";
	}
	if (diffY < 0) {
		this._selectionObj.style.top = this._selectionObj.startY + diffY + 1+"px";
        diffY = 0 - diffY;
	} else {
		this._selectionObj.style.top = this._selectionObj.startY - 3+"px";
	}
    this._selectionObj.style.width = (diffX>4?diffX-4:0) + 'px';
    this._selectionObj.style.height = (diffY>4?diffY-4:0) + 'px';


/* AUTO SCROLL */
	var BottomRightX = this.objBox.scrollLeft + this.objBox.clientWidth;
	var BottomRightY = this.objBox.scrollTop + this.objBox.clientHeight;
	var TopLeftX = this.objBox.scrollLeft;
	var TopLeftY = this.objBox.scrollTop;

	var nextCall=false;
	if (this._blsTimer) window.clearTimeout(this._blsTimer);	
	
	if (X+20 >= BottomRightX) {
		this.objBox.scrollLeft = this.objBox.scrollLeft+20;
		nextCall=true;
	} else if (X-20 < TopLeftX) {
		this.objBox.scrollLeft = this.objBox.scrollLeft-20;
		nextCall=true;
	}
	if (Y+20 >= BottomRightY && !this._realfake) {
		this.objBox.scrollTop = this.objBox.scrollTop+20;
		nextCall=true;
	} else if (Y-20 < TopLeftY && !this._realfake) {
		this.objBox.scrollTop = this.objBox.scrollTop-20;
		nextCall=true;		
	}
	this._selectionArea = this._RedrawSelectionPos(this._startSelectionCell, this._endSelectionCell);
	

	if (nextCall){ 
		var a=event.clientX;
		var b=event.clientY;
		this._blsTimer=window.setTimeout(function(){self._OnSelectionMove({clientX:a,clientY:b})},100);
	}
	
}

dhtmlXGridObject.prototype._OnSelectionStop = function(event)
{
	var self = this;
	if (this._blsTimer) window.clearTimeout(this._blsTimer);	
	this.obj.onmousedown = function(e) {if (self._bs_mode)  self._OnSelectionStart((e||event), this); return true;}
	this.obj.onmousemove = this.obj.onmmold||null;
	this._selectionObj.onmousemove = null;
	document.body.onmouseup = this._oldDMP||null;
	if ( parseInt( this._selectionObj.style.width ) < 2 && parseInt( this._selectionObj.style.height ) < 2) {
		this._HideSelection();
	} else {
	    var src = this.getFirstParentOfType(event.srcElement || event.target,"TD");
	    if ((!src) || (!src.parentNode.idd)){
	    	src=this._endSelectionCell;
    		}
	    while (src && (!src.tagName || src.tagName.toLowerCase() != 'td'))
	        src = src.parentNode;
	    if (!src) 
	    	return this._HideSelection();
	    this._stopSelectionCell = src;
	    this._selectionArea = this._RedrawSelectionPos(this._startSelectionCell, this._stopSelectionCell);
		this.callEvent("onBlockSelected",[]);
	}
	document.body.onselectstart = function(){};//avoid text select
}

dhtmlXGridObject.prototype._RedrawSelectionPos = function(LeftTop, RightBottom)
{

	if (LeftTop.parentNode.grid != RightBottom.parentNode.grid)
		return this._selectionArea;

//	td._cellIndex
//
//	getRowIndex
	var pos = {};
	pos.LeftTopCol = LeftTop._cellIndex;
	pos.LeftTopRow = this.getRowIndex( LeftTop.parentNode.idd );
	pos.RightBottomCol = RightBottom._cellIndex;
	pos.RightBottomRow = this.getRowIndex( RightBottom.parentNode.idd );

	var LeftTop_width = LeftTop.offsetWidth;
	var LeftTop_height = LeftTop.offsetHeight;
	LeftTop = this.getPosition(LeftTop, this.obj);

	var RightBottom_width = RightBottom.offsetWidth;
	var RightBottom_height = RightBottom.offsetHeight;
	RightBottom = this.getPosition(RightBottom, this.obj);

    if (LeftTop[0] < RightBottom[0]) {
		var Left = LeftTop[0];
		var Right = RightBottom[0] + RightBottom_width;
    } else {
    	var foo = pos.RightBottomCol;
        pos.RightBottomCol = pos.LeftTopCol;
        pos.LeftTopCol = foo;
		var Left = RightBottom[0];
		var Right = LeftTop[0] + LeftTop_width;
    }

    if (LeftTop[1] < RightBottom[1]) {
		var Top = LeftTop[1];
		var Bottom = RightBottom[1] + RightBottom_height;
    } else {
    	var foo = pos.RightBottomRow;
        pos.RightBottomRow = pos.LeftTopRow;
        pos.LeftTopRow = foo;
		var Top = RightBottom[1];
		var Bottom = LeftTop[1] + LeftTop_height;
    }

    var Width = Right - Left;
    var Height = Bottom - Top;

	this._selectionObj.style.left = Left + 'px';
	this._selectionObj.style.top = Top + 'px';
	this._selectionObj.style.width =  Width  + 'px';
	this._selectionObj.style.height = Height + 'px';
	return pos;
}

dhtmlXGridObject.prototype._CreateSelection = function(x, y)
{
	if (this._selectionObj == null) {
		var div = document.createElement('div');
		div.style.position = 'absolute';
        div.style.display = 'none';
        div.className = 'dhtmlxGrid_selection';
		this._selectionObj = div;
		this._selectionObj.onmousedown = function(e){
			e=e||event;
			if (e.button==2 || (_isMacOS&&e.ctrlKey))
				return this.parentNode.grid.callEvent("onBlockRightClick", ["BLOCK",e]);
		}
		this._selectionObj.oncontextmenu=function(e){(e||event).cancelBubble=true;return false;}
		this.objBox.appendChild(this._selectionObj);
	}
    //this._selectionObj.style.border = '1px solid #83abeb';
    this._selectionObj.style.width = '0px';
    this._selectionObj.style.height = '0px';
    //this._selectionObj.style.border = '0px';
	this._selectionObj.style.left = x + 'px';
	this._selectionObj.style.top  = y + 'px';
    this._selectionObj.startX = x;
    this._selectionObj.startY = y;
}

dhtmlXGridObject.prototype._ShowSelection = function()
{
	if (this._selectionObj)
	    this._selectionObj.style.display = '';
}

dhtmlXGridObject.prototype._HideSelection = function()
{
	
	if (this._selectionObj)
	    this._selectionObj.style.display = 'none';
    this._selectionArea = null;
    if (this._clip_area){
    	this._clip_area.value="";
    	this._clip_area.blur();
    }
}
/**
*     @desc: copy content of block selection into clipboard in csv format (delimiter as set for csv serialization)
*     @type: public
*     @topic: 0
*/
dhtmlXGridObject.prototype.copyBlockToClipboard = function()
{
	if (!this._clip_area) return;

	if ( this._selectionArea != null ) {
		var serialized = new Array();
	if (this._mathSerialization)
         this._agetm="getMathValue";
    else if (this._strictText)
    	this._agetm="getTitle";
    else this._agetm="getValue";

    this._serialize_visible = true;

		for (var i=this._selectionArea.LeftTopRow; i<=this._selectionArea.RightBottomRow; i++) {
			var data = this._serializeRowToCVS(this.rowsBuffer[i], null,  this._selectionArea.LeftTopCol, this._selectionArea.RightBottomCol+1);
			if (!this._csvAID)
				serialized[serialized.length] = data.substr( data.indexOf( this.csv.cell ) + 1 );	//remove row ID and add to array
			else
				serialized[serialized.length] = data;
		}
		serialized = serialized.join(this._CSVRowDelimiter);
		
		this._clip_area.value = serialized;
        this._clip_area.select();

	this._serialize_visible = false;
	}
}
/**
*     @desc: paste content of clipboard into block selection of grid
*     @type: public
*     @topic: 0
*/
dhtmlXGridObject.prototype.pasteBlockFromClipboard = function(){
	if (!this._clip_area) return;

	this._clip_area.select();
    var self = this;
    window.setTimeout(function(){
        self._pasteBlockFromClipboard();
        self=null;
    },1);
}
dhtmlXGridObject.prototype._pasteBlockFromClipboard = function()
{
	var serialized = this._clip_area.value;
	if (!serialized) return;

    if (this._selectionArea != null) {
        var startRow = this._selectionArea.LeftTopRow;
        var startCol = this._selectionArea.LeftTopCol;
    } else if (this.cell != null && !this.editor) {
        var startRow = this.getRowIndex( this.cell.parentNode.idd );
        var startCol = this.cell._cellIndex;
    } else {
        return false;
    }

	serialized = this.csvParser.unblock(serialized, this.csv.cell, this.csv.row);

    var endRow = startRow+serialized.length;
    var endCol = startCol+serialized[0].length;
    if (endCol > this._cCount)
		endCol = this._cCount;
    var k = 0;
    for (var i=startRow; i<endRow; i++) {
        var row = this.render_row(i);
        if (row==-1) continue;
        var l = 0;
        for (var j=startCol; j<endCol; j++) {
        	if (this._hrrar[j] && !this._fake){
        		endCol = Math.min(endCol+1, this._cCount);
        		continue;
        	}
        	var ed = this.cells3(row, j);
        	if (ed.isDisabled()) {
        	    l++;
        	    continue;
        	}
        	if (this._onEditUndoRedo)
        		this._onEditUndoRedo(2, row.idd, j, serialized[ k ][ l ], ed.getValue());
        	if (ed.combo){
				var comboVa = ed.combo.values;
				for(var n=0; n<comboVa.length; n++)
					if (serialized[ k ][ l ] == comboVa[n]){
						ed.setValue( ed.combo.keys[ n ]);
						comboVa=null;
						break;
					}
				if (comboVa!=null && ed.editable) ed.setValue( serialized[ k ][ l++ ] );
				else l++;
        	}else
        		ed[ ed.setImage ? "setLabel" : "setValue" ]( serialized[ k ][ l++ ] );
        	ed.cell.wasChanged=true;
        }
        this.callEvent("onRowPaste",[row.idd])
        k++;
    }
}

dhtmlXGridObject.prototype.getSelectedBlock = function() {
	// if block selection exists
	if (this._selectionArea)
		return this._selectionArea;
	else if (this.getSelectedRowId() !== null){
		// if one cell is selected
			return {
				LeftTopRow: this.getSelectedRowId(),
				LeftTopCol: this.getSelectedCellIndex(),
				RightBottomRow: this.getSelectedRowId(),
				RightBottomCol: this.getSelectedCellIndex()
			};
		} else
			return null;
};
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: enable smart rendering mode
*   @type: public
*   @param: mode - true|false - enable|disable mode
*   @param: buffer - has sense only in dynamic loading mode, count of rows requrested from server by single operation, optional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableSmartRendering=function(mode,buffer,reserved){
	if (arguments.length>2){
		if (buffer && !this.rowsBuffer[buffer-1]) this.rowsBuffer[buffer-1]=0;
		buffer=reserved;
	}
	this._srnd=dhx4.s2b(mode);
	this._srdh=this._srdh||20;
	this._dpref=buffer||0;
	
};
/**
*   @desc: allows to pre-render rows during scrolling, make scrolling more smooth, but with small drop in overall perfomance
*   @type: public
*   @param: buffer - count of rows, which will be prerendered
*   @topic: 0
*/
dhtmlXGridObject.prototype.enablePreRendering=function(buffer){
	this._srnd_pr=parseInt(buffer||50);
};
/**
*   @desc: force grid in dyn. srnd mode fully load itself from server side
*   @type: public
*   @param: buffer - how much rows grid can request from server side in one operation
*   @topic: 0
*/
dhtmlXGridObject.prototype.forceFullLoading=function(buffer, callback){
	for (var i=0; i<this.rowsBuffer.length; i++)
		if (!this.rowsBuffer[i]){
			var usedbuffer = buffer || (this.rowsBuffer.length-i);
			if (this.callEvent("onDynXLS",[i,usedbuffer])){
				var self=this;
				this.load(this.xmlFileUrl+dhtmlx.url(this.xmlFileUrl)+"posStart="+i+"&count="+usedbuffer, function(){
					window.setTimeout(function(){	self.forceFullLoading(buffer, callback); },100); 
				}, this._data_type);
			}
			return;
		}
	if (callback) callback.call(this);
};

/**
*   @desc: set height which will be used in smart rendering mode for row calculation, function need to be used if you use custom skin for grid which changes default row height
*   @type: public
   @param: {int} height - awaited height of row
*   @returns: void
*   @topic: 0
*/      
dhtmlXGridObject.prototype.setAwaitedRowHeight = function(height) {
   this._srdh=parseInt(height);
};

dhtmlXGridObject.prototype._get_view_size=function(){
	return Math.floor(parseInt(this.entBox.offsetHeight)/this._srdh)+2;
};
dhtmlXGridObject.prototype._add_filler=function(pos,len,fil,rsflag){
	if (!len) return null;
	var id="__filler__";
	var row=this._prepareRow(id);
	row.firstChild.style.width="1px";
	row.firstChild.style.borderWidth = row.firstChild.style.padding = row.firstChild.style.margin ="0px";

	for (var i=1; i<row.childNodes.length; i++)
	    row.childNodes[i].style.display='none';
 	row.firstChild.style.height=len*this._srdh+"px";
 	fil=fil||this.rowsCol[pos];
 	if (fil && fil.nextSibling) 
 		fil.parentNode.insertBefore(row,fil.nextSibling);
 	else
 		if (_isKHTML)
 			this.obj.appendChild(row);
 		else
 			this.obj.rows[0].parentNode.appendChild(row);
 			
 	this.callEvent("onAddFiller",[pos,len,row,fil,rsflag]);
 	return [pos,len,row];
};
dhtmlXGridObject.prototype._update_srnd_view=function(){
	    var min=Math.floor(this.objBox.scrollTop/this._srdh);
        var max=min+this._get_view_size();
        if (this.multiLine) {
        // Calculate the min, by Stephane Bernard
            var pxHeight = this.objBox.scrollTop;
            min = 0;
            while(pxHeight > 0) {
                pxHeight-=this.rowsCol[min]?this.rowsCol[min].offsetHeight:this._srdh;
                min++;
            }
            // Calculate the max
            max=min+this._get_view_size();
            if (min>0) min--;
        }        
        max+=(this._srnd_pr||0);//pre-rendering
        if (max>this.rowsBuffer.length) max=this.rowsBuffer.length;

        for (var j=min; j<max; j++){ 
            if (!this.rowsCol[j]){
				var res=this._add_from_buffer(j);
				if (res==-1){
					if (this.xmlFileUrl){
						if (this._dpref && this.rowsBuffer[max-1]){
							//we have last row in sett, assuming that we in scrolling up process
							var rows_count = this._dpref?this._dpref:(max-j)
							var start_pos = Math.max(0, Math.min(j, max - this._dpref));
							this._current_load=[start_pos, max-start_pos];
						} else 
							this._current_load=[j,(this._dpref?this._dpref:(max-j))];
						if (this.callEvent("onDynXLS",this._current_load))
							this.load(this.xmlFileUrl+dhtmlx.url(this.xmlFileUrl)+"posStart="+this._current_load[0]+"&count="+this._current_load[1], this._data_type);
					}
					return;
				} else {
	               	if (this._tgle){
	               		this._updateLine(this._h2.get[this.rowsBuffer[j].idd],this.rowsBuffer[j]);
	               		this._updateParentLine(this._h2.get[this.rowsBuffer[j].idd],this.rowsBuffer[j]);
	           		}
					if (j && j==(this._realfake?this._fake:this)["_r_select"]){
						this.selectCell(j, this.cell?this.cell._cellIndex:0, true);
					}
				}
            }
		}
	if (this._fake && !this._realfake && this.multiLine) 
		this._fake.objBox.scrollTop = this.objBox.scrollTop;		
}
dhtmlXGridObject.prototype._add_from_buffer=function(ind){
	    var row=this.render_row(ind);
	    if (row==-1) return -1;
	    if (row._attrs["selected"] || row._attrs["select"]){
			this.selectRow(row,false,true);
			row._attrs["selected"]=row._attrs["select"]=null;
		}
						
	    if (!this._cssSP){ 
		    if (this._cssEven && ind%2 == 0 )
				row.className=this._cssEven+((row.className.indexOf("rowselected") != -1)?" rowselected ":" ")+(row._css||"");
			else if (this._cssUnEven && ind%2 == 1 )
			    row.className=this._cssUnEven+((row.className.indexOf("rowselected") != -1)?" rowselected ":" ")+(row._css||"");				
			} else if (this._h2) {
				var x=this._h2.get[row.idd];
				row.className+=" "+((x.level%2)?(this._cssUnEven+" "+this._cssUnEven):(this._cssEven+" "+this._cssEven))+"_"+x.level+(this.rowsAr[x.id]._css||"");
			}
			

	    //now we need to get location of node
	    for (var i=0; i<this._fillers.length; i++){
	    	var f=this._fillers[i];
	    	if (f && f[0]<=ind && (f[0]+f[1])>ind ){
	    		//filler found
	    		var pos=ind-f[0];
	    		if (pos==0){
	    			//start
	    			this._insert_before(ind,row,f[2]);
	    			this._update_fillers(i,-1,1);
	    		} else if (pos == f[1]-1){
	    			this._insert_after(ind,row,f[2]);
	    			this._update_fillers(i,-1,0);
	    		} else {
	    			this._fillers.push(this._add_filler(ind+1,f[1]-pos-1,f[2],1));
	    			this._insert_after(ind,row,f[2]);
	    			this._update_fillers(i,-f[1]+pos,0);
	    		}
	    		return;
	    	}
	    }
}
dhtmlXGridObject.prototype._update_fillers=function(ind,right,left){
	var f=this._fillers[ind];
	f[1]=f[1]+right;
	f[0]=f[0]+left;
	if (!f[1]){
		this.callEvent("onRemoveFiller",[f[2]]);
		f[2].parentNode.removeChild(f[2]);
		this._fillers.splice(ind,1);
	} else {
		f[2].firstChild.style.height=parseFloat(f[2].firstChild.style.height)+right*this._srdh+"px";	
		this.callEvent("onUpdateFiller",[f[2]]);
	}
}
dhtmlXGridObject.prototype._insert_before=function(ind,row,fil){
	fil.parentNode.insertBefore(row,fil);
	this.rowsCol[ind]=row;
	this.callEvent("onRowInserted",[row,null,fil,"before"]);
}
dhtmlXGridObject.prototype._insert_after=function(ind,row,fil){
	if (fil.nextSibling)
		fil.parentNode.insertBefore(row,fil.nextSibling);
	else
		fil.parentNode.appendChild(row);
	this.rowsCol[ind]=row;
	this.callEvent("onRowInserted",[row,null,fil,"after"]);
}


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

// validation
if (typeof(window.dhtmlxValidation) != "undefined") {
	dhtmlxValidation.trackInput = function(el,rule,callback_error,callback_correct) {
		dhtmlxEvent(el, "keyup", function(e){
			if (dhtmlxValidation._timer) {
				window.clearTimeout(dhtmlxValidation._timer);
				dhtmlxValidation._timer = null;
			}
			dhtmlxValidation._timer = window.setTimeout(function(){
				if (!dhtmlxValidation.checkInput(el,rule)){
					if (!callback_error || callback_error(el,el.value,rule)) el.className += " dhtmlx_live_validation_error";
				} else {
					el.className=el.className.replace(/[ ]*dhtmlx_live_validation_error/g,"");
					if (callback_correct) callback_correct(el, el.value, rule);
				}
			},250);
		});
	};
	dhtmlxValidation.checkInput = function(input,rule) {
		return dhtmlxValidation.checkValue(input.value,rule);
	};
	dhtmlxValidation.checkValue = function(value,rule) {
		if (typeof rule=="string") rule = rule.split(",");
		var final_res = true;
		for (var i=0; i<rule.length; i++) {
			if (!this["is"+rule[i]]) {
				alert("Incorrect validation rule: "+rule[i]);
			} else {
				final_res = final_res && this["is"+rule[i]](value);
			}
		}
		return final_res;
	};
};
// extension for the grid
dhtmlXGridObject.prototype.enableValidation=function(mode,live){
	mode=dhx4.s2b(mode);
	if (mode) this._validators = {data:[]}; else this._validators = false;
	if (arguments.length>1) this._validators._live=live;
	if (!this._validators._event) this._validators._event=this.attachEvent("onEditCell",this.validationEvent);
};
dhtmlXGridObject.prototype.setColValidators=function(vals){
	if (!this._validators) this.enableValidation(true);
	if (typeof vals == "string") vals=vals.split(this.delim);
	this._validators.data=vals;
};
dhtmlXGridObject.prototype.validationEvent=function(stage,id,ind,newval,oldval){
	var v=this._validators;
	if (!v) return true; // validators disabled
	var rule=(v.data[ind]||this.cells(id,ind).getAttribute("validate"))||"";
	
	if (stage==1 && rule) {
		var ed = this.editor||(this._fake||{}).editor;
		if (!ed) return true; //event was trigered by checkbox
		ed.cell.className=ed.cell.className.replace(/[ ]*dhtmlx_validation_error/g,"");
		if (v._live){
			var grid=this;
			dhtmlxValidation.trackInput(ed.getInput(),rule,function(element,value,rule){
				return grid.callEvent("onLiveValidationError",[id,ind,value,element,rule]);
			}, function(element,value,rule){
				return grid.callEvent("onLiveValidationCorrect",[id,ind,value,element,rule]);
			});
		}
	}
	
	if (stage==2) this.validateCell(id,ind,rule,newval);
	
	return true;
};

dhtmlXGridObject.prototype.validateCell=function(id,ind,rule,value){
	rule=rule||(this._validators.data[ind]||this.cells(id,ind).getAttribute("validate"));
	value=value||this.cells(id,ind).getValue();
	if (!rule) return;
	var cell = this.cells(id,ind).cell;
	
	var result = true;
	if (typeof rule == "string")
		rule = rule.split(this.delim);
	
	for (var i=0; i < rule.length; i++) {
		if (!dhtmlxValidation.checkValue(value,rule[i])){
			if (this.callEvent("onValidationError",[id,ind,value,rule[i]]))
				cell.className+=" dhtmlx_validation_error";
			result = false;
		}
	}
	if (result){
		this.callEvent("onValidationCorrect",[id,ind,value,rule]);
		cell.className=cell.className.replace(/[ ]*dhtmlx_validation_error/g,"");		
	}
	return result;
};

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/


function eXcell_stree(cell){
	if (cell){
		this.cell = cell;
    	this.grid = this.cell.parentNode.grid;
    
    	if (!this.grid._sub_trees) return;
    	this._sub=this.grid._sub_trees[cell._cellIndex];
    	if (!this._sub) return;
    	this._sub=this._sub[0];
    }
	
	this.getValue = function(){
		return this.cell._val;
	}
	this.setValue = function(val){
		this.cell._val=val;
		val = this._sub.getItemText(this.cell._val);
		this.setCValue((val||"&nbsp;"),val);
	}
	this.edit = function(){
		this._sub.parentObject.style.display='block';
		var arPos = this.grid.getPosition(this.cell);//,this.grid.objBox
		this._sub.parentObject.style.top=arPos[1]+"px";
		this._sub.parentObject.style.left=arPos[0]+"px";
		this._sub.parentObject.style.position="absolute";
		
		var a=this.grid.editStop;
		this.grid.editStop=function(){};
		
		this.grid.editStop=a;
	}
	this.detach=function(){
		this._sub.parentObject.style.display='none';
		if (this.grid._sub_id != null) {
			var old=this.cell._val;
			this.setValue(this._sub.getSelectedItemId());
			this.grid._sub_id = null;
			return this.cell._val!=old;
		}
	}
}
eXcell_stree.prototype = new eXcell;


dhtmlXGridObject.prototype.setSubTree=function(tree,s_index){
		if (!this._sub_trees) 
			this._sub_trees=[];
		this._sub_trees[s_index]=[tree];
		tree.parentObject.style.display="none";
		var that=this;
		tree.parentObject.onclick = function(event) {(event || window.event).cancelBubble = true;return false;}
		tree.ev_onDblClick=null;
		tree.attachEvent("onDblClick",function(id){
			that._sub_id = id;
			that.editStop();
			return true;
		});
		tree._chRRS=true;
};
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/


/*
HTML Link eXcell v.1.0  for dhtmlxGrid 
(c)DHTMLX LTD. 2005


The corresponding  cell value in XML should be a "^" delimited list of following values:
1st - Link Text 
2nd - URL (optional)
3rd - target (optional, default is _blank)

Samples:
<cell>Stephen King</cell>
<cell>Stephen King^http://www.stephenking.com/</cell>
<cell>Stephen King^http://www.stephenking.com/^_self</cell>
*/

/**
*	@desc: link editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/

function eXcell_link(cell){
	this.cell = cell;
    this.grid = this.cell.parentNode.grid;
    this.isDisabled=function(){return true;}
	this.edit = function(){}
	this.getValue = function(){
		if(this.cell.firstChild.getAttribute){
			var target = this.cell.firstChild.getAttribute("target")
			return this.cell.firstChild.innerHTML+"^"+this.cell.firstChild.getAttribute("href")+(target?("^"+target):"");
		}

		else
			return "";
	}
	this.setValue = function(val){
		if((typeof(val)!="number") && (!val || val.toString()._dhx_trim()=="")){		
			this.setCValue("&nbsp;",valsAr);			
			return (this.cell._clearCell=true);
		}
		var valsAr = val.split("^");
		if(valsAr.length==1)
			valsAr[1] = "";
		else{
			if(valsAr.length>1){
				valsAr[1] = "href='"+valsAr[1]+"'";
				if(valsAr.length==3)
					valsAr[1]+= " target='"+valsAr[2]+"'";
				else
					valsAr[1]+= " target='_blank'";
			}
		}

		this.setCValue("<a "+valsAr[1]+" onclick='(_isIE?event:arguments[0]).cancelBubble = true;'>"+valsAr[0]+"</a>",valsAr);
	}
}

eXcell_link.prototype = new eXcell;
eXcell_link.prototype.getTitle=function(){
	var z=this.cell.firstChild;
	return ((z&&z.tagName)?z.getAttribute("href"):"");
}
eXcell_link.prototype.getContent=function(){
	var z=this.cell.firstChild;
	return ((z&&z.tagName)?z.innerHTML:"");
}
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function eXcell_grid(cell){
	if (cell){
		this.cell = cell;
    	this.grid = this.cell.parentNode.grid;
    
    	if (!this.grid._sub_grids) return;
    	this._sub=this.grid._sub_grids[cell._cellIndex];
    	if (!this._sub) return;
    	this._sindex=this._sub[1];
    	this._sub=this._sub[0];
    }
	
	this.getValue = function(){
		return this.cell.val;
	}
	this.setValue = function(val){
		this.cell.val=val;
		
		if (this._sub.getRowById(val)) {
			val=this._sub.cells(val,this._sindex);
		if (val) val=val.getValue();
		else val="";
	 } 
		
		this.setCValue((val||"&nbsp;"),val);
		
	}
	this.edit = function(){ 
		this.val = this.cell.val;
		
		this._sub.entBox.style.display='block';
		var arPos = this.grid.getPosition(this.cell);//,this.grid.objBox
		this._sub.entBox.style.top=arPos[1]+"px";
		this._sub.entBox.style.left=arPos[0]+"px";
		this._sub.entBox.style.position="absolute";
		this._sub.setSizes();
		
		var a=this.grid.editStop;
		this.grid.editStop=function(){};
		if (this._sub.getRowById(this.cell.val)) 
			this._sub.setSelectedRow(this.cell.val);
		this._sub.setActive(true)
		
		this.grid.editStop=a;
	}
	this.detach=function(){
		var old=this.cell.val;
		this._sub.entBox.style.display='none';
		if (this._sub.getSelectedId()===null) return false;
		this.setValue(this._sub.getSelectedId());
		this.grid.setActive(true)
		return this.cell.val!=old;
	}
}
eXcell_grid.prototype = new eXcell;


dhtmlXGridObject.prototype.setSubGrid=function(grid,s_index,t_index){
		if (!this._sub_grids) 
			this._sub_grids=[];
		this._sub_grids[s_index]=[grid,t_index];
		grid.entBox.style.display="none";
		var that=this;

		grid.entBox.onclick = function(event) { (event || window.event).cancelBubble = true;return false; }
		grid.attachEvent("onRowSelect",function(id){
			that.editStop();
			return true;
		});
		grid._chRRS=false;
};
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function eXcell_dhxCalendar(cell) {
	if (cell) {
		this.cell = cell;
		this.grid = this.cell.parentNode.grid;
		
		if (!this.grid._grid_calendarA) {
			
			var cal = this.grid._grid_calendarA = new dhtmlxCalendarObject();
			this.grid.callEvent("onDhxCalendarCreated", [cal]);
			
			var sgrid = this.grid;
			cal.attachEvent("onClick",function(){
                    		this._last_operation_calendar=true;
                    		window.setTimeout(function(){sgrid.editStop()},1);
                    		return true;
                    	});
                    	
                    	var zFunc = function(e){ (e||event).cancelBubble=true; }
                    	dhtmlxEvent(cal.base, "click", zFunc);
                    	cal = null;
                }
	}
}
eXcell_dhxCalendar.prototype = new eXcell;

eXcell_dhxCalendar.prototype.edit = function() {
	
	var arPos = this.grid.getPosition(this.cell);
	this.grid._grid_calendarA._show(false, false);
	this.grid._grid_calendarA.setPosition(arPos[0],arPos[1]+this.cell.offsetHeight);
	this.grid._grid_calendarA._last_operation_calendar = false;
	
	
	this.grid.callEvent("onCalendarShow", [this.grid._grid_calendarA, this.cell.parentNode.idd, this.cell._cellIndex]);
	//var arPos = this.grid.getPosition(this.cell);
	//var pval=this._date2str2(this.cell.val||new Date());
	//window._grid_calendar.render(arPos[0],arPos[1]+this.cell.offsetHeight,this,pval);
	this.cell._cediton = true;
	this.val = this.cell.val;
	this._val = this.cell.innerHTML;
	// alert(this.cell.val);
	var t = this.grid._grid_calendarA.draw;
	this.grid._grid_calendarA.draw = function(){};
	this.grid._grid_calendarA.setDateFormat((this.grid._dtmask||"%d/%m/%Y"));
	this.grid._grid_calendarA.setDate(this.val||(new Date()));
	this.grid._grid_calendarA.draw = t;
	
	//this.grid._grid_calendarA.draw();
}
eXcell_dhxCalendar.prototype.getDate = function() {
	if (this.cell.val) return this.cell.val;
	return null;
}

eXcell_dhxCalendar.prototype.getValue = function() {
	if (this.cell._clearCell) return "";
	if (this.grid._dtmask_inc && this.cell.val) return this.grid._grid_calendarA.getFormatedDate(this.grid._dtmask_inc, this.cell.val).toString();
	return this.cell.innerHTML.toString()._dhx_trim()
}

eXcell_dhxCalendar.prototype.detach = function() {
	if (!this.grid._grid_calendarA) return;
	this.grid._grid_calendarA.hide();
	if (this.cell._cediton) this.cell._cediton = false; else return;
	
	if (this.grid._grid_calendarA._last_operation_calendar) {
		var z1=this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"));
		var z2=this.grid._grid_calendarA.getDate();
		this.cell.val=new Date(z2);
		this.setCValue(z1,z2);
		this.cell._clearCell = !z1;
		var t = this.val;
		this.val = this._val;
		return (this.cell.val.valueOf()!=(t||"").valueOf());
	}
	return false;
}


eXcell_dhxCalendar.prototype.setValue = function(val) {
	
	if (val && typeof val == "object") {
		this.cell.val=val;
		this.cell._clearCell=false;
		this.setCValue(this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"),val).toString(),this.cell.val);
		return;
	}
	
	
	if (!val || val.toString()._dhx_trim()=="") {
		val="&nbsp";
		this.cell._clearCell=true;
		this.cell.val="";
	} else{
		this.cell._clearCell=false;
		this.cell.val=new Date(this.grid._grid_calendarA.setFormatedDate((this.grid._dtmask_inc||this.grid._dtmask||"%d/%m/%Y"),val.toString(),null,true));
		if (this.grid._dtmask_inc)
			val = this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"),this.cell.val);
	}
	
	if ((this.cell.val=="NaN")||(this.cell.val=="Invalid Date")) {
		this.cell._clearCell=true;
		this.cell.val=new Date();
		this.setCValue("&nbsp;",0);
	} else {
		this.setCValue((val||"").toString(),this.cell.val);
	}
}


function eXcell_dhxCalendarA(cell) {
	if (cell) {
		this.cell = cell;
		this.grid = this.cell.parentNode.grid;
		
		if (!this.grid._grid_calendarA) {
			
			var cal = this.grid._grid_calendarA = new dhtmlxCalendarObject();
			this.grid.callEvent("onDhxCalendarCreated",[cal]);
			
			var sgrid=this.grid;
			cal.attachEvent("onClick",function() {
				this._last_operation_calendar=true;
				window.setTimeout(function() {sgrid.editStop()},1);
				return true;
                    	});
                    	
                    	var zFunc=function(e) { (e||event).cancelBubble=true;  }
                    	dhtmlxEvent(cal.base,"click",zFunc);
                }      
	}
}
eXcell_dhxCalendarA.prototype = new eXcell;

eXcell_dhxCalendarA.prototype.edit = function() {
	var arPos = this.grid.getPosition(this.cell);
	
	this.grid._grid_calendarA._show(false, false);
	this.grid._grid_calendarA.setPosition(arPos[0]*1+this.cell.offsetWidth,arPos[1]*1);
	this.grid.callEvent("onCalendarShow",[this.grid._grid_calendarA,this.cell.parentNode.idd,this.cell._cellIndex]);
	this.grid._grid_calendarA._last_operation_calendar=false;
	
	this.cell._cediton=true;
	this.val=this.cell.val;
	this._val=this.cell.innerHTML;
	
	var t=this.grid._grid_calendarA.draw; this.grid._grid_calendarA.draw=function() {};
	this.grid._grid_calendarA.setDateFormat((this.grid._dtmask||"%d/%m/%Y"));
	this.grid._grid_calendarA.setDate(this.val);
	this.grid._grid_calendarA.draw=t;
	
	this.cell.atag=((!this.grid.multiLine)&&(_isKHTML||_isMacOS||_isFF))?"INPUT":"TEXTAREA";
	
	this.obj = document.createElement(this.cell.atag);
	this.obj.style.height = (this.cell.offsetHeight-4)+"px";
	this.obj.className="dhx_combo_edit";
	this.obj.wrap = "soft";
	this.obj.style.textAlign = this.cell.align;
	this.obj.onclick = function(e) {(e||event).cancelBubble = true}
	this.obj.onmousedown = function(e) {(e||event).cancelBubble = true}
	this.obj.value = this.getValue();
	this.cell.innerHTML = "";
	this.cell.appendChild(this.obj);
	if (window.dhx4.isIE) {
		this.obj.style.overflow = "visible";
		if ((this.grid.multiLine)&&(this.obj.offsetHeight>=18)&&(this.obj.offsetHeight<40)) {
			this.obj.style.height = "36px";
			this.obj.style.overflow = "scroll";
		}
	}
	this.obj.onselectstart=function(e) {
		if (!e) e=event;
		e.cancelBubble = true;
		return true;
	};
	this.obj.focus()
	this.obj.focus()
	
}

eXcell_dhxCalendarA.prototype.getDate = function() {
	if (this.cell.val) return this.cell.val;
	return null;
}

eXcell_dhxCalendarA.prototype.getValue = function() {
	if (this.cell._clearCell) return "";
	if (this.grid._dtmask_inc && this.cell.val)
		return this.grid._grid_calendarA.getFormatedDate(this.grid._dtmask_inc, this.cell.val).toString();
	return this.cell.innerHTML.toString()._dhx_trim()
}

eXcell_dhxCalendarA.prototype.detach = function() {
	if (!this.grid._grid_calendarA) return;
	this.grid._grid_calendarA.hide();
	if (this.cell._cediton) this.cell._cediton=false; else return;
	if (this.grid._grid_calendarA._last_operation_calendar) {
		this.grid._grid_calendarA._last_operation_calendar=false;
		var z1=this.grid._grid_calendarA.getFormatedDate(this.grid._dtmask||"%d/%m/%Y");
		var z2=this.grid._grid_calendarA.getDate();
		this.cell.val=new Date(z2);
		this.setCValue(z1,z2);
		this.cell._clearCell = !z1;
		var t = this.val;
		this.val=this._val;
		return (this.cell.val.valueOf()!=(t||"").valueOf());
	}
	this.setValue(this.obj.value);
	var t = this.val;
	this.val = this._val;
	return (this.cell.val.valueOf()!=(t||"").valueOf());
}

eXcell_dhxCalendarA.prototype.setValue = function(val) {
	if (val && typeof val == "object") {
		this.cell.val=val;
		this.cell._clearCell=false;
		this.setCValue(this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"),val).toString(),this.cell.val);
		return;
	}
	
	if (!val || val.toString()._dhx_trim()=="") {
		val="&nbsp";
		this.cell._clearCell=true;
		this.cell.val="";
	} else {
		this.cell._clearCell = false;
		this.cell.val = new Date(this.grid._grid_calendarA.setFormatedDate((this.grid._dtmask_inc||this.grid._dtmask||"%d/%m/%Y"),val.toString(),null,true));
		if (this.grid._dtmask_inc)
			val = this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"),this.cell.val);
	}
	
	if ((this.cell.val=="NaN")||(this.cell.val=="Invalid Date")) {
		this.cell.val=new Date();
		this.cell._clearCell=true;
		this.setCValue("&nbsp;",0);
	} else {
		this.setCValue((val||"").toString(),this.cell.val);
	}
}


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*	@desc: auto counter editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_cntr(cell){
	this.cell = cell;
    this.grid = this.cell.parentNode.grid;
	if (!this.grid._ex_cntr_ready && !this._realfake){
		this.grid._ex_cntr_ready=true;
		if (this.grid._h2)
			this.grid.attachEvent("onOpenEn",function(id){
				this.resetCounter(cell._cellIndex);
			});
		var fix_cnt = function(){ 
			var that=this;
			window.setTimeout(function(){ 
				if (!that.resetCounter) return;
				if (that._fake && !that._realfake && cell._cellIndex<that._fake._cCount) 
					that._fake.resetCounter(cell._cellIndex); 
				else
				    that.resetCounter(cell._cellIndex);
			},1);
			return true;
		};

		this.grid.attachEvent("onBeforeSorting", fix_cnt);
		this.grid.attachEvent("onFilterEnd", fix_cnt);
	}
	
	

	this.edit = function(){}
	this.getValue = function(){
		return this.cell.innerHTML;
	}
	this.setValue = function(val){
		this.cell.style.paddingRight = "2px";
		var cell=this.cell;
		
		window.setTimeout(function(){
			if (!cell.parentNode) return;
			var val=cell.parentNode.rowIndex;
			if (cell.parentNode.grid.currentPage || val<0 || cell.parentNode.grid._srnd) val=cell.parentNode.grid.rowsBuffer._dhx_find(cell.parentNode)+1;
			if (val<=0) return;
			cell.innerHTML = val;
			if (cell.parentNode.grid._fake && cell._cellIndex<cell.parentNode.grid._fake._cCount && cell.parentNode.grid._fake.rowsAr[cell.parentNode.idd]) cell.parentNode.grid._fake.cells(cell.parentNode.idd,cell._cellIndex).setCValue(val);
			cell=null;
		},100);
	}
}
dhtmlXGridObject.prototype.resetCounter=function(ind){
	if (this._fake && !this._realfake && ind < this._fake._cCount) this._fake.resetCounter(ind,this.currentPage);
	var i=arguments[0]||0;
	if (this.currentPage)
		i=(this.currentPage-1)*this.rowsBufferOutSize;
	for (i=0; i<this.rowsBuffer.length; i++)
		if (this.rowsBuffer[i] && this.rowsBuffer[i].tagName == "TR" && this.rowsAr[this.rowsBuffer[i].idd])
			this.rowsAr[this.rowsBuffer[i].idd].childNodes[ind].innerHTML=i+1;
}
eXcell_cntr.prototype = new eXcell;
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*	@desc: skined checkbox editor 
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_acheck(cell){
	try{
		this.cell = cell;
		this.grid = this.cell.parentNode.grid;
		this.cell.obj = this;
	}catch(er){}
	this.changeState = function(){
					//nb:
					    if ((!this.grid.isEditable)||(this.cell.parentNode._locked)||(this.isDisabled())) return;
						if(this.grid.callEvent("onEditCell",[0,this.cell.parentNode.idd,this.cell._cellIndex])!=false){
							this.val = this.getValue()
							if(this.val=="1")
								this.setValue("<checkbox state='false'>")
							else
								this.setValue("<checkbox state='true'>")
								
							this.cell.wasChanged=true;								
							//nb:
							this.grid.callEvent("onEditCell",[1,this.cell.parentNode.idd,this.cell._cellIndex]);
							this.grid.callEvent("onCheck",[this.cell.parentNode.idd,this.cell._cellIndex,(this.val!='1')]);
                            this.grid.callEvent("onCheckbox",[this.cell.parentNode.idd,this.cell._cellIndex,(this.val!='1')]);

						}else{//preserve editing (not tested thoroughly for this editor)
							this.editor=null;
						}
				}
	this.getValue = function(){
						try{
							return this.cell.chstate.toString();
						}catch(er){
							return null;
						}
					}

	this.isCheckbox = function(){
						return true;
					}
	this.isChecked = function(){
						if(this.getValue()=="1")
							return true;
						else
							return false;
					}
	this.setChecked = function(fl){
	this.setValue(fl.toString())
	}
	this.detach = function(){
						return this.val!=this.getValue();
					}
    this.drawCurrentState=function(){
        if (this.cell.chstate==1)
            return "<div  onclick='(new eXcell_acheck(this.parentNode)).changeState(); (arguments[0]||event).cancelBubble=true;'  style='cursor:pointer; font-weight:bold; text-align:center; '><span style='height:8px; width:8px; background:green; display:inline-block;'></span>&nbsp;Yes</div>";
        else
            return "<div  onclick='(new eXcell_acheck(this.parentNode)).changeState(); (arguments[0]||event).cancelBubble=true;' style='cursor:pointer;  text-align:center; '><span style='height:8px; width:8px; background:red; display:inline-block;'></span>&nbsp;No</div>";
    }
}
eXcell_acheck.prototype = new eXcell;
eXcell_acheck.prototype.setValue = function(val){
                        //val can be int
                        val=(val||"").toString();
						if(val.indexOf("1")!=-1 || val.indexOf("true")!=-1){
							val = "1";
							this.cell.chstate = "1";
						}else{
							val = "0";
							this.cell.chstate = "0"
						}
						var obj = this;
						this.setCValue(this.drawCurrentState(),this.cell.chstate);
					}

//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function eXcell_context(cell){
	if (cell){
		this.cell = cell;
    	this.grid = this.cell.parentNode.grid;
    
    	if (!this.grid._sub_context) return;
    	this._sub=this.grid._sub_context[cell._cellIndex];
    	if (!this._sub) return;
    	this._sindex=this._sub[1];
    	this._sub=this._sub[0];
    }
	
	this.getValue = function(){
		return _isIE?this.cell.innerText:this.cell.textContent;
	}
	this.setValue = function(val){
		this.cell._val=val;
		var item  = this._sub.itemPull[this._sub.idPrefix+this.cell._val];
		val = item?item.title:val;
		this.setCValue((val||"&nbsp;"),val);
	}
	this.edit = function(){
		var arPos = this.grid.getPosition(this.cell);//,this.grid.objBox
		
		this._sub.showContextMenu(arPos[0]+this.cell.offsetWidth,arPos[1]);
		var a=this.grid.editStop;
		this.grid.editStop=function(){};
		this.grid.editStop=a;
	}
	this.detach=function(){
		if (this.grid._sub_id != null) {
			var old=this.cell._val;
			this.setValue(this.grid._sub_id);
			this.grid._sub_id = null;
			return this.cell._val!=old;
		}
		this._sub.hideContextMenu();
	}
}
eXcell_context.prototype = new eXcell;


dhtmlXGridObject.prototype.setSubContext=function(ctx,s_index,t_index){
	var that=this;
	ctx.attachEvent("onClick",function(id,value){
		that._sub_id = id;
		that.editStop();
		ctx.hideContextMenu();
		return true;
	});
	if (!this._sub_context) 
		this._sub_context=[];
	this._sub_context[s_index]=[ctx,t_index];
	ctx.hideContextMenu();
};
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXGridFromTable(obj,init){
      if(typeof(obj)!='object')
         obj = document.getElementById(obj);
            var w=document.createElement("DIV");
            w.setAttribute("width",obj.getAttribute("gridWidth")||(obj.offsetWidth?(obj.offsetWidth+"px"):0)||(window.getComputedStyle?window.getComputedStyle(obj,null)["width"]:(obj.currentStyle?obj.currentStyle["width"]:0)));
            w.setAttribute("height",obj.getAttribute("gridHeight")||(obj.offsetHeight?(obj.offsetHeight+"px"):0)||(window.getComputedStyle?window.getComputedStyle(obj,null)["height"]:(obj.currentStyle?obj.currentStyle["height"]:0)));
			w.className = obj.className;
			obj.className="";
			if (obj.id) w.id = obj.id;

            var mr=obj;
            var drag=obj.getAttribute("dragAndDrop");
            mr.parentNode.insertBefore(w,mr);
            var f=mr.getAttribute("name")||("name_"+(new Date()).valueOf());

            var windowf=new dhtmlXGridObject(w);
            window[f]=windowf;

            var acs=mr.getAttribute("onbeforeinit");
            var acs2=mr.getAttribute("oninit");

			if (acs) eval(acs);

        	windowf.setImagePath(windowf.imgURL||(mr.getAttribute("imgpath")|| mr.getAttribute("image_path") ||""));
			var skin = mr.getAttribute("skin");
			if (skin) windowf.setSkin(skin);

        	if (init) init(windowf);

            var hrow=mr.rows[0];
            var za=[];
            var zb="";
            var zc="";
            var zd="";
            var ze="";

            for (var i=0; i<hrow.cells.length; i++){
                za.push(hrow.cells[i].innerHTML);
                var width=hrow.cells[i].getAttribute("width")||hrow.cells[i].offsetWidth||(window.getComputedStyle?window.getComputedStyle(hrow.cells[i],null)["width"]:(hrow.cells[i].currentStyle?hrow.cells[i].currentStyle["width"]:0));
                zb+=(zb?",":"")+(width=="*"?width:parseInt(width));
                zc+=(zc?",":"")+(hrow.cells[i].getAttribute("align")||"left");
                zd+=(zd?",":"")+(hrow.cells[i].getAttribute("type")||"ed");
                ze+=(ze?",":"")+(hrow.cells[i].getAttribute("sort")||"str");
            	var f_a=hrow.cells[i].getAttribute("format");
            	if (f_a)
            		if(hrow.cells[i].getAttribute("type").toLowerCase().indexOf("calendar")!=-1) 
            			windowf._dtmask=f_a;
            		else
            			windowf.setNumberFormat(f_a,i);
            }

        	windowf.setHeader(za);
        	windowf.setInitWidths(zb)
        	windowf.setColAlign(zc)
        	windowf.setColTypes(zd);
        	windowf.setColSorting(ze);
			if (obj.getAttribute("gridHeight")=="auto")
		    	windowf.enableAutoHeigth(true);

			if (obj.getAttribute("multiline")) windowf.enableMultiline(true);

			var lmn=mr.getAttribute("lightnavigation");
			if (lmn) windowf.enableLightMouseNavigation(lmn);

			var evr=mr.getAttribute("evenrow");
			var uevr=mr.getAttribute("unevenrow");

			if (evr||uevr) windowf.enableAlterCss(evr,uevr);
			if (drag) windowf.enableDragAndDrop(true);

            windowf.init();
            if (obj.getAttribute("split")) windowf.splitAt(obj.getAttribute("split"));

            windowf.callEvent("onXLS", []);
            //adding rows
            windowf._process_inner_html(mr,1);
            
			if (acs2) eval(acs2);            
			if (obj.parentNode && obj.parentNode.removeChild)
				obj.parentNode.removeChild(obj);

            windowf.callEvent("onXLE", []);
     return windowf;

            }
dhtmlXGridObject.prototype._process_html=function(xml){
	if (xml.tagName && xml.tagName == "TABLE") return this._process_inner_html(xml,0);
	var temp=document.createElement("DIV");
	temp.innerHTML=xml.xmlDoc.responseText;
	var mr = temp.getElementsByTagName("TABLE")[0];
	this._process_inner_html(mr,0);
}
dhtmlXGridObject.prototype._process_inner_html=function(mr,start){
	var n_l=mr.rows.length;
	for (var j=start; j<n_l; j++){
		var id=mr.rows[j].getAttribute("id")||j;
		this.rowsBuffer.push({ idd:id, data:mr.rows[j], _parser: this._process_html_row, _locator:this._get_html_data });
	}
	this.render_dataset();
	this.setSizes();
}
   
dhtmlXGridObject.prototype._process_html_row=function(r,xml){
	var cellsCol = xml.getElementsByTagName('TD');
    var strAr = [];
    
	r._attrs=this._xml_attrs(xml);
	
	//load cell data
    for(var j=0;j<cellsCol.length;j++){
    	var cellVal=cellsCol[j];
        var exc=cellVal.getAttribute("type");
        if (r.childNodes[j]){
        	if (exc)
        		r.childNodes[j]._cellType=exc;
       		r.childNodes[j]._attrs=this._xml_attrs(cellsCol[j]);
   		}
       
		if (cellVal.firstChild)
		    strAr.push(cellVal.innerHTML);
		else strAr.push("");
        
        if (cellVal.colSpan>1){
            r.childNodes[j]._attrs["colspan"]=cellVal.colSpan;		
            for (var k=1; k<cellVal.colSpan; k++){
                strAr.push("")
            }
        }
		
}
	for(j<cellsCol.length; j<r.childNodes.length; j++)
        r.childNodes[j]._attrs={};

        
    //back to common code
	this._fillRow(r,(this._c_order?this._swapColumns(strAr):strAr));
    return r;
}
dhtmlXGridObject.prototype._get_html_data=function(data,ind){
	data=data.firstChild;
	while (true){
		if (!data) return "";
		if (data.tagName=="TD") ind--;
		if (ind<0) break;
		data=data.nextSibling;
	}
  return (data.firstChild?data.firstChild.data:"");
}



dhtmlxEvent(window,"load",function(){
    var z=document.getElementsByTagName("table");
    for (var a=0; a<z.length; a++)
        if (z[a].className=="dhtmlxGrid"){
            dhtmlXGridFromTable(z[a]);
            //we have found IT!
        }
});


//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype._process_xmlA=function(xml){ 
	this._parsing=true;
	var top=dhx4.ajax.xmltop(this.xml.top, xml);
	//#config_from_xml:20092006{
	this._parseHead(top);
	//#}
	var rows=dhx4.ajax.xpath(this.xml.row,top)
	var cr=parseInt(top.getAttribute("pos")||0);
	var total=parseInt(top.getAttribute("total_count")||0);
	if (total && !this.rowsBuffer[total-1]) this.rowsBuffer[total-1]=null;
	
	if (this.isTreeGrid()){
		this._get_xml_data = this._get_xml_dataA;
		this._process_xml_row = this._process_xml_rowA;
		return this._process_tree_xml(xml);
	}
	
	for (var i=0; i < rows.length; i++) {
		if (this.rowsBuffer[i+cr]) continue;
		var id=rows[i].getAttribute("id")||this.uid();
		this.rowsBuffer[i+cr]={ idd:id, data:rows[i], _parser: this._process_xml_rowA, _locator:this._get_xml_dataA };
		this.rowsAr[id]=rows[i];
		//this.callEvent("onRowCreated",[r.idd]);
	}
	this.render_dataset();
	this._parsing=false;
}

dhtmlXGridObject.prototype._process_xmlB=function(xml){
    
    this._parsing=true;
	var top=dhx4.ajax.xmltop(this.xml.top, xml);
	//#config_from_xml:20092006{
	this._parseHead(top);
	//#}
	var rows=dhx4.ajax.xpath(this.xml.row,top)
	var cr=parseInt(top.getAttribute("pos")||0);
	var total=parseInt(top.getAttribute("total_count")||0);
	if (total && !this.rowsBuffer[total-1]) this.rowsBuffer[total-1]=null;
	
	if (this.isTreeGrid()){
		this._get_xml_data = this._get_xml_dataB;
		this._process_xml_row = this._process_xml_rowB;
		return this._process_tree_xml(xml);
	}
			
	for (var i=0; i < rows.length; i++) {
		if (this.rowsBuffer[i+cr]) continue;
		var id=rows[i].getAttribute("id")||this.uid();
		this.rowsBuffer[i+cr]={ idd:id, data:rows[i], _parser: this._process_xml_rowB, _locator:this._get_xml_dataB };
		this.rowsAr[id]=rows[i];
		//this.callEvent("onRowCreated",[r.idd]);
	}
	this.render_dataset();
	this._parsing=false;
}

dhtmlXGridObject.prototype._process_xml_rowA=function(r,xml){
	var strAr = [];
	r._attrs=this._xml_attrs(xml);
	
	//load cell data
    for(var j=0;j<this.columnIds.length;j++){
    	var cid=this.columnIds[j];
    	var cellVal=r._attrs[cid]||"";
        if (r.childNodes[j])
       		r.childNodes[j]._attrs={};
   		
		strAr.push(cellVal);
	}
	    
    //back to common code
	this._fillRow(r,(this._c_order?this._swapColumns(strAr):strAr));
    return r;
}
dhtmlXGridObject.prototype._get_xml_dataA=function(data,ind){
	return data.getAttribute(this.getColumnId(ind));
}

dhtmlXGridObject.prototype._process_xml_rowB=function(r,xml){
	var strAr = [];
	r._attrs=this._xml_attrs(xml);
	
	//load userdata
	if (this._ud_enabled){	
		var udCol = dhx4.ajax.xpath("./userdata",xml);
    	for (var i = udCol.length - 1; i >= 0; i--)
    		this.setUserData(udCol[i].getAttribute("name"),udCol[i].firstChild?udCol[i].firstChild.data:"");
	}
	
	//load cell data
	
	for (var jx=0; jx < xml.childNodes.length; jx++) {
		var cellVal=xml.childNodes[jx];
    	if (!cellVal.tagName) continue;
    	var j=this.getColIndexById(cellVal.tagName);
    	if (isNaN(j)) continue;
    		
        var exc=cellVal.getAttribute("type");
        if (exc)
        	r.childNodes[j]._cellType=exc;
       	r.childNodes[j]._attrs=this._xml_attrs(cellVal);
   		
		if (cellVal.getAttribute("xmlcontent"))
		{}
		else if (cellVal.firstChild)
			cellVal=cellVal.firstChild.data;
		else cellVal="";
        
		strAr[j]=cellVal;
	}
	for (var i=0; i < r.childNodes.length; i++) {
		if (!r.childNodes[i]._attrs) r.childNodes[i]._attrs={};
	};
            
    //back to common code
	this._fillRow(r,strAr);
    return r;
}
dhtmlXGridObject.prototype._get_xml_dataB=function(data,ind){
	var id=this.getColumnId(ind);
	data=data.firstChild;
	while (true){
		if (!data) return "";
		if (data.tagName==id) return (data.firstChild?data.firstChild.data:"")
		data=data.nextSibling;
	}
  return "";
}

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

   //next function switch grid between fast and normal operation modes
   //limitation - will not work for paging|smart_rendering|dynamic|split modes, most events will not be generated
   
/**
*   @desc: start fast operation mode, in such mode events are not generated, some time consuming actions applied only once, which allow to increase performance
*   @type: public
*   @topic: 0
*/   
   dhtmlXGridObject.prototype.startFastOperations   =    function(){
   		this._disF=["setSizes","callEvent","_fixAlterCss","cells4","forEachRow", "_correctMonolite"];
   		this._disA=[];
   		for (var i = this._disF.length - 1; i >= 0; i--){
   			this._disA[i]=this[this._disF[i]]; this[this._disF[i]]=function(){return true};
   		};
   		
   		this._cellCache=[];
   		this.cells4=function(cell){
   			var c=this._cellCache[cell._cellIndex]
   			if (!c){
   				c=this._cellCache[cell._cellIndex]=this._disA[3].apply(this,[cell]);
	   			c.destructor=function(){return true;}
   				c.setCValue=function(val){c.cell.innerHTML=val;}
   			}
   			
   			c.cell=cell;
   			c.combo=cell._combo||this.combos[cell._cellIndex];
   			return c;
   		}
   		
   }
/**
*   @desc: turn off fast operation mode, need to be executed to normalize view.
*   @type: public
*   @topic: 0
*/      
   dhtmlXGridObject.prototype.stopFastOperations   =    function(){
   		if (!this._disF) return;
   		for (var i = this._disF.length - 1; i >= 0; i--){
   			this[this._disF[i]]=this._disA[i];
   		};

         if (this._correctMonolite)  		
            this._correctMonolite();
   		this.setSizes();
   		this.callEvent("onGridReconstructed",[]);
   }
   
   //(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype._in_header_number_filter=function(t,i){
	this._in_header_text_filter.call(this,t,i);
	var self = this;
	t.firstChild._filter=function(){
		var filters = self._get_filters(this.value, 'num');
		return function(value) {
			var result = filters.length > 0 ? false : true;
			for (var i = 0; i < filters.length; i++)
				result = result || filters[i](value);
			return result;
		}
	};
}


dhtmlXGridObject.prototype._in_header_string_filter=function(t,i){
	this._in_header_text_filter.call(this,t,i);
	var self = this;
	t.firstChild._filter=function(){
		var filters = self._get_filters(this.value, 'str');
		return function(value) {
			var result = filters.length > 0 ? false : true;
			for (var i = 0; i < filters.length; i++)
				result = result || filters[i](value);
			return result;
		}
	};
}


dhtmlXGridObject.prototype._get_filters=function(value, type) {
	var fs = value.split(',');
	var filters = [];
	
	for (var i = 0; i < fs.length; i++) {
		if (fs[i] == '') continue;
		var f = this['_get_' + type + '_filter'](fs[i]);
		filters.push(f);
	}
	return filters;
}


dhtmlXGridObject.prototype._get_str_filter=function(value) {
	// empty, null
	if (value == 'null' || value == 'empty') {
		return new Function('value', 'if (value == null || value == "") return true; return false;');
	}
	
	// not empty, not null
	if (value == '!null' || value == '!empty') {
		return new Function('value', 'if (value == null || value == "") return false; return true;');
	}
	// not equals
	if (value.substr(0, 1) === '!') {
		var substr = value.substr(1);
		return new Function('value', 'if (value !== "' + substr + '") return true; return false;');
	}
	// contains
	if (value.substr(0, 1) === '~') {
		var substr = value.substr(1);
		return new Function('value', 'if (value.indexOf("' + substr + '") !== -1) return true; return false;');
	}
	// ^keyword& 
	if (value.substr(0, 1) === '^' && value.substr(value.length - 1, 1) === '&') {
		value = '=' + value.substr(1, value.length - 2);
	}
	// start with
	if (value.substr(0, 1) === '^') {
		var substr = value.substr(1);
		return new Function('value', 'if (value.substr(0, ' + substr.length + ') === "' + substr + '") return true; return false;');
	}
	// end with
	if (value.substr(value.length - 1, 1) === '&') {
		var substr = value.substr(0, value.length - 1);
		return new Function('value', 'if (value.substr(value.length - ' + substr.length + ') === "' + substr + '") return true; return false;');
	}
	// equals
	if (value.substr(0, 1) === '=')
		var substr = value.substr(1);
	else
		var substr = value;
	return new Function('value', 'if (value === "' + substr + '") return true; return false;');
}


dhtmlXGridObject.prototype._get_num_filter=function(value) {
	// empty, null
	if (value == 'null' || value == 'empty') {
		return new Function('value', 'if (value == null || value == "") return true; return false;');
	}

	// not empty, not null
	if (value == '!null' || value == '!empty') {
		return new Function('value', 'if (value == null || value == "") return false; return true;');
	}
	// in range
	var range = value.split('..');
	if (range.length == 2) {
		var num1 = parseFloat(range[0]);
		var num2 = parseFloat(range[1]);
		return new Function('value', 'if (value >= ' + num1 + ' && value <= ' + num2 + ') return true; return false;');
	}
	var r = value.match(/<>|>=|<=|>|<|=/);
	if (r) {
		var op = r[0];
		var num = parseFloat(value.replace(op, ""));
	} else {
		var op = '==';
		num = parseFloat(value);
	}
	if (op == '<>') op = '!=';
	if (op == '=') op = '==';
	return new Function("value"," if (value " + op + " " + num + " ) return true; return false;");
}

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype.attachHeaderA=dhtmlXGridObject.prototype.attachHeader;
dhtmlXGridObject.prototype.attachHeader=function()
{
	this.attachHeaderA.apply(this,arguments);
	if (this._realfake) return true;
	this.formAutoSubmit();
	if (typeof(this.FormSubmitOnlyChanged)=="undefined")
		this.submitOnlyChanged(true);
		
	if (typeof(this._submitAR)=="undefined")
		this.submitAddedRows(true);
		
	var that=this;
	
	this._added_rows=[];
	this._deleted_rows=[];
	
	this.attachEvent("onRowAdded",function(id){ 
		that._added_rows.push(id);
		that.forEachCell(id,function(a){ a.cell.wasChanged=true; })
		return true;
	});
	this.attachEvent("onBeforeRowDeleted",function(id){
		that._deleted_rows.push(id);
		return true;
	});
	
	this.attachHeader=this.attachHeaderA;
}

dhtmlXGridObject.prototype.formAutoSubmit = function()
{
	this.parentForm = this.detectParentFormPresent();
	if (this.parentForm === false) {
		return false;
	}
	if (this.formEventAttached)
		return;
    this.formInputs = new Array();
	var self = this;
	dhtmlxEvent(this.parentForm, 'submit', function() {if (self.entBox) self.parentFormOnSubmit();});
	this.formEventAttached = true;
}

dhtmlXGridObject.prototype.parentFormOnSubmit = function()
{
	this.formCreateInputCollection();
	if (!this.callEvent("onBeforeFormSubmit",[])) return false;
}

/**
*   @desc: include only changed rows in form submit
*   @type: public
*   @param: mode - {boolean}  enable|disable mode
*   @topic: 0
*/
dhtmlXGridObject.prototype.submitOnlyChanged = function(mode)
{
	this.FormSubmitOnlyChanged = dhx4.s2b(mode);
}

dhtmlXGridObject.prototype.submitColumns=function(names){
	if (typeof names == "string") names=names.split(this.delim);
	this._submit_cols=names;	
}

/**
*   @desc: allows to define input name which will be used for data sending, name may contain next auto-replaced elements - GRID_ID - ID of grids container, ROW_ID - ID of row, ROW_INDEX - index of row, COLUMN_ID - id of column, COLUMN_INDEX - index of column
*   @type: public
*   @param: name - input name mask
*   @topic: 0
*/
dhtmlXGridObject.prototype.setFieldName=function(mask){
	mask=mask.replace(/\{GRID_ID\}/g,"'+a1+'");
	mask=mask.replace(/\{ROW_ID\}/g,"'+a2+'");
	mask=mask.replace(/\{ROW_INDEX\}/g,"'+this.getRowIndex(a2)+'");
	mask=mask.replace(/\{COLUMN_INDEX\}/g,"'+a3+'");
	mask=mask.replace(/\{COLUMN_ID\}/g,"'+this.getColumnId(a3)+'");
	this._input_mask=Function("a1","a2","a3","return '"+mask+"';");
}
 
   
/**
*   @desc: include serialized grid as part of form submit
*   @type: public
*   @param: mode - {boolean}  enable|disable mode
*   @topic: 0
*/
dhtmlXGridObject.prototype.submitSerialization = function(mode)
{
	this.FormSubmitSerialization = dhx4.s2b(mode);
}

/**
*   @desc: include additional data with info about which rows was added and which deleted, enabled by default
*   @type: public
*   @param: mode - {boolean}  enable|disable mode
*   @topic: 0
*/
dhtmlXGridObject.prototype.submitAddedRows = function(mode)
{
	this._submitAR = dhx4.s2b(mode);
}




/**
*   @desc: include only selected rows in form submit
*   @type: public
*   @param: mode - {boolean}  enable|disable mode
*   @topic: 0
*/
dhtmlXGridObject.prototype.submitOnlySelected = function(mode)
{
	this.FormSubmitOnlySelected = dhx4.s2b(mode);
}


/**
*   @desc: include only  row's IDS in form submit
*   @type: public
*   @param: mode - {boolean}  enable|disable mode
*   @topic: 0
*/
dhtmlXGridObject.prototype.submitOnlyRowID = function(mode)
{
	this.FormSubmitOnlyRowID = dhx4.s2b(mode);
}


dhtmlXGridObject.prototype.createFormInput = function(name,value){
    var input = document.createElement('input');
    input.type = 'hidden';
    if (this._input_mask && (typeof name != "string"))
    	input.name=this._input_mask.apply(this,name);
    else
    	input.name =((this.globalBox||this.entBox).id||'dhtmlXGrid')+'_'+name;
    input.value = value;
    this.parentForm.appendChild(input);
    this.formInputs.push(input);
}

dhtmlXGridObject.prototype.createFormInputRow = function(r){ 
	var id=(this.globalBox||this.entBox).id;
	for (var j=0; j<this._cCount; j++){
		var foo_cell = this.cells3(r, j);
		if (((!this.FormSubmitOnlyChanged) || foo_cell.wasChanged()) && (!this._submit_cols || this._submit_cols[j]))
			this.createFormInput(this._input_mask?[id,r.idd,j]:(r.idd+'_'+j),foo_cell.getValue());
	}
}


dhtmlXGridObject.prototype.formCreateInputCollection = function()
{
	if (this.parentForm == false) {
		return false;
	}
	for (var i=0; i<this.formInputs.length; i++) {
		this.parentForm.removeChild(this.formInputs[i]);
	}
    this.formInputs = new Array();
    
    if (this.FormSubmitSerialization){
    	this.createFormInput("serialized",this.serialize());
    } else if (this.FormSubmitOnlySelected){
    	//submit selected
    	if (this.FormSubmitOnlyRowID)
    		this.createFormInput("selected",this.getSelectedId());
    	else
    		for(var i=0;i<this.selectedRows.length;i++)
    			this.createFormInputRow(this.selectedRows[i]);
    	}
    else{
    	//submit all
    		if (this._submitAR){
    			if (this._added_rows.length)
    				this.createFormInput("rowsadded",this._added_rows.join(","));
    			if (this._deleted_rows.length)
    				this.createFormInput("rowsdeleted",this._deleted_rows.join(","));
	    		}
    		this.forEachRow(function(id){
    			 if (this.getRowById(id) !== -1)
    				this.createFormInputRow(this.rowsAr[id]);
			})
    		
    	}
}

dhtmlXGridObject.prototype.detectParentFormPresent = function()
{
	var parentForm = false;
	var parent = this.entBox;
	while(parent && parent.tagName && parent != document.body) {
		if (parent.tagName.toLowerCase() == 'form') {
			parentForm = parent;
			break;
		} else {
        	parent = parent.parentNode;
		}
	}
	return parentForm;
}
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype.unGroup=function(){ 
	if (!this._groups) return;
	this._dndProblematic=false;
	
	delete this._groups;
	delete this._gIndex;	
	if (this._fake)	this._mirror_rowsCol();
	this.forEachRow(function(id){
		this.rowsAr[id].style.display='';
	})
	this._reset_view();
	this.callEvent("onGridReconstructed",[])
	this.callEvent("onUnGroup",[]);
}

dhtmlXGridObject.prototype._mirror_rowsCol=function(){ 
	this._fake._groups=this._groups;
	this._fake._gIndex=this._gIndex;
	this.rowsBuffer=dhtmlxArray(); 
	for (var i=0; i<this.rowsCol.length; i++)
		if (!this.rowsCol[i]._cntr)
			this.rowsBuffer.push(this.rowsCol[i]);
	this._fake.rowsBuffer=dhtmlxArray(); 
	for (var i=0; i<this._fake.rowsCol.length; i++)
		if (!this._fake.rowsCol[i]._cntr)
			this._fake.rowsBuffer.push(this._fake.rowsCol[i]);
}
/**
*	@desc: group grid content by values of specified column
*	@param: ind - column index to group by
*	@edition: Professional
*	@type: public
*/
dhtmlXGridObject.prototype.groupBy=function(ind,mask){
		
	if (this._groups) this.unGroup();
	this._dndProblematic=true;
	this._groups={};
	if (!mask) {
		mask=["#title"];
		for (var i=1; i<this._cCount; i++) mask.push("#cspan");
	}
	this._gmask=document.createElement("TR");
	this._gmask.origin = mask;
	var ltd,rindex=0;
	for (var i=0; i<mask.length; i++){
		if (mask[i]=="#cspan") 
			ltd.colSpan=(parseInt(ltd.colSpan)||1)+1
		else {
			ltd=document.createElement("TD");
			ltd._cellIndex=i;
			if (this._hrrar[i]) ltd.style.display="none";
			ltd.className="group_row";
			ltd.innerHTML="&nbsp;";
			if (mask[i]=="#title") this._gmask._title=rindex;
			else ltd.align=this.cellAlign[i]||"left";
			this._gmask.appendChild(ltd);
			if (mask[i].indexOf("#stat")==0){
				this._gmask._math=true;
				ltd._counter=[this["_g_"+mask[i].replace("#","")],i,rindex];
			}
			rindex++;
		}
	}
	for (var a in this._groups) this._groups[a]=this.undefined;
	this._gIndex=ind;
	
	if (this._fake &&!this._realfake){
		this._fake._groups=[];
		this._fake._gIndex=this._gIndex;
	}
	
	//keyboard commands
	this._nextRow=function(ind,dir){
		var r=this.rowsCol[ind+dir];
		if (r && ( r.style.display=="none" || r._cntr)) return this._nextRow(ind+dir,dir);
		return r;	
	}
	
	if (!this.__sortRowsBG){
		this._key_events=dhtmlx.extend({},this._key_events)
		this._key_events.k38_0_0=function(){
			if (this.editor && this.editor.combo)
				this.editor.shiftPrev();
			else{
				var rowInd = this.row.rowIndex;
				if (!rowInd) return;
				var nrow=this._nextRow(rowInd-1,-1);
				if (nrow)
	        		this.selectCell(nrow,this.cell._cellIndex,true);
			}
		}
		this._key_events.k13_1_0=this._key_events.k13_0_1=function(){};
	this._key_events.k40_0_0=function(){
		if (this.editor && this.editor.combo)
			this.editor.shiftNext();
		else{
			var rowInd = this.row.rowIndex;
			if (!rowInd) return;
			var nrow=this._nextRow(rowInd-1,1);
			if (nrow)
        		this.selectCell(nrow,this.cell._cellIndex,true);
		}
	}	
	
		this.attachEvent("onFilterStart",function(){
			if (this._groups) this._groups=this.undefined;
			return true;
		});
		this.attachEvent("onFilterEnd",function(){
			if (typeof this._gIndex != "undefined") this.groupBy(this._gIndex,this._gmask.origin);
		});
		this.sortRows_bg=this.sortRows;
		this.sortRows=function(ind,type,dir){
			if (typeof(this._groups)=="undefined") 
				return this.sortRows_bg.apply(this,arguments);

			type = type || this.fldSort[ind] || "str";
			dir = dir || "asc";
			if (this.callEvent("onBeforeSorting",[ind, type, dir])){
				if (typeof(this._groups)=="undefined") return true;
				if (ind==this._gIndex) this._sortByGroup(ind,type,dir);
				else this._sortInGroup(ind,type,dir);
				this.setSortImgState(true,ind,dir)
				if (this._fake){ 
					this._mirror_rowsCol();
					this._fake._groups=[];
					this._fake._reset_view();
				}
				this.setSortImgState(true,ind,dir);
				this.callEvent("onAfterSorting",[ind,type,dir]);
			}
			return false;
		};
		this.attachEvent("onClearAll",function(){ this.unGroup(); });
		this.attachEvent("onBeforeRowDeleted",function(id){ 
			if (!this._groups) return true;
			if (!this.rowsAr[id]) return true;
			var val=this.cells(id,this._gIndex).getValue();
			if (val==="") val=" ";
			var z=this._groups[val];
			this._dec_group(z);
			return true;
			});
		this.attachEvent("onAfterRowDeleted",function(id){ 
			this.updateGroups();
			});			
		this.attachEvent("onCheckbox",function(id,index,value){
			this.callEvent("onEditCell",[2,id,index,(value?1:0),(value?0:1)]);
		});
		this.attachEvent("onXLE",this.updateGroups);
		this.attachEvent("onColumnHidden",this.hideGroupColumn);
		this.attachEvent("onEditCell",function(stage,id,ind,val,oldval){
			if (!this._groups) return true;
			if (stage==2 && val!=oldval && ind==this._gIndex){
				if (oldval==="") oldval=" ";
				this._dec_group(this._groups[oldval]);
				var r=this.rowsAr[id];
				var i=this.rowsCol._dhx_find(r)
				var ni=this._inc_group(val);
				var n=this.rowsCol[ni];
				if (r==n) n=n.nextSibling;
					
				
				var p=r.parentNode;
				var o=r.rowIndex;
				
				p.removeChild(r);
				if (n)
					p.insertBefore(r,n);
				else
					p.appendChild(r);
				this.rowsCol._dhx_insertAt(ni,r);
				if (ni<i) i++;
				this.rowsCol._dhx_removeAt(i,r);
				this._fixAlterCss();
			} else if (stage==2 && val!=oldval) {
				this.updateGroups();
				this._updateGroupView(this._groups[this.cells(id,this._gIndex).getValue()||" "]);
				}
			return true;
			})
		this.__sortRowsBG=true;
	}
	
	
	this._groupExisting();	
	if (this._hrrar)
		for (var i=0; i<this._hrrar.length; i++)
			if (this._hrrar[i])
				this.hideGroupColumn(i,true);
	this.callEvent("onGroup",[]);
	if (this._ahgr || this._awdth) this.setSizes();
}
dhtmlXGridObject.prototype._sortInGroup=function(col,type,order){
	var b=this._groups_get();
	b.reverse();

	for (var i=0; i<b.length; i++){
		var c=b[i]._cntr._childs; var a={};
		for (var j=0; j<c.length; j++){
			var cell = this.cells3(c[j],col);
			a[c[j].idd]=cell.getDate?cell.getDate():cell.getValue();
		}
			
		this._sortCore(col,type,order,a,c);
	}
	//add|delete|edit|ungroup
	this._groups_put(b);
	this.setSizes();
	this.callEvent("onGridReconstructed",[])
}

dhtmlXGridObject.prototype._sortByGroup=function(col,type,order){ 
	var b=this._groups_get();
	var a=[];
	for (var i=0; i<b.length; i++){
		b[i].idd="_sort_"+i;
		a["_sort_"+i]=b[i]._cntr.text;
	}
		
	this._sortCore(col,type,order,a,b);
	//add|delete|edit|ungroup
	this._groups_put(b);
	this.callEvent("onGridReconstructed",[])
	this.setSizes();
}
dhtmlXGridObject.prototype._inc_group=function(val,hidden,skip){
	if (val==="") val=" ";
	if (!this._groups[val]){ 
		this._groups[val]={text:val,row:this._addPseudoRow(),count:0,state:hidden?"plus":"minus"}; }
	var z=this._groups[val];
	//this._fixAlterCss();
	z.row._cntr=z;
		
	 
	var ind=this.rowsCol._dhx_find(z.row)+z.count+1;
	z.count++;
	
	if (!skip) {
	this._updateGroupView(z);
		this.updateGroups();
	}
	return ind;
}
dhtmlXGridObject.prototype._dec_group=function(z){
	if (!z) return;
	z.count--;
	if (z.count==0){
		z.row.parentNode.removeChild(z.row);
		this.rowsCol._dhx_removeAt(this.rowsCol._dhx_find(z.row));
		delete this._groups[z.text];
	}
	else
		this._updateGroupView(z);
	if (this._fake && !this._realfake)
		this._fake._dec_group(this._fake._groups[z.text]);
	this.updateGroups();
	return true;	
	}
dhtmlXGridObject.prototype._insertRowAt_gA=dhtmlXGridObject.prototype._insertRowAt;
dhtmlXGridObject.prototype._insertRowAt=function(r,ind,skip){
	if (typeof(this._groups)!="undefined"){
		if (this._realfake)
			var val=this._fake._bfs_cells(r.idd,this._gIndex).getValue();
		else
			if (this._bfs_cells3)
				var val=this._bfs_cells3(r,this._gIndex).getValue();
			else
				var val=this.cells3(r,this._gIndex).getValue();
			if (!val) val=" ";
			ind=this._inc_group(val,r.style.display=="none");		
	}
	var res=this._insertRowAt_gA(r,ind,skip);
	if (typeof(this._groups)!="undefined"){	
		this.expandGroup(val);
		this._updateGroupView(this._groups[val]);
		this.updateGroups();
	}
	return res;
}

dhtmlXGridObject.prototype._updateGroupView=function(z){ 
	if (this._fake && !this._realfake) return z.row.firstChild.innerHTML="&nbsp;";
	var mask = this._gmask||this._fake._gmask;
	var html="<img style='margin-bottom:-4px' src='"+this.imgURL+z.state+".gif'> ";
	if (this.customGroupFormat) html+=this.customGroupFormat(z.text,z.count);
	else html+=z.text+" ( "+z.count+" ) ";
	z.row.childNodes[mask._title].innerHTML=html;
}
dhtmlXGridObject.prototype._addPseudoRow=function(skip){
	
	var mask = this._gmask||this._fake._gmask;
	var r=mask.cloneNode(true)
	//cloneNode ignores custom attributes
	for (var i=0; i<r.childNodes.length; i++) {
		r.childNodes[i]._cellIndex=mask.childNodes[i]._cellIndex;
		if (this._realfake) r.childNodes[i].style.display="";
	}
	var that=this;
	
	r.onclick=function(e){ 
		if (!that.callEvent("onGroupClick",[this._cntr.text]))
			return;

		if (that._fake && that._realfake) 
			that._fake._switchGroupState(that._fake._groups[this._cntr.text].row); 
		else
			that._switchGroupState(this);
		(e||event).cancelBubble="true"; }
	r.ondblclick=function(e){ (e||event).cancelBubble="true"; }
	
	if (!skip){
		if (_isKHTML)
			this.obj.appendChild(r)
		else
			this.obj.firstChild.appendChild(r)
		this.rowsCol.push(r);
	}
	return r;
}

dhtmlXGridObject.prototype._groups_get=function(){
	var b=[];
	this._temp_par=this.obj.parentNode;
	this._temp_par.removeChild(this.obj);
	var a=[];
	for (var i=this.rowsCol.length-1; i>=0; i--){
		if (this.rowsCol[i]._cntr){
			this.rowsCol[i]._cntr._childs=a;
			a=[];
			b.push(this.rowsCol[i]);
		} else a.push(this.rowsCol[i]);
		this.rowsCol[i].parentNode.removeChild(this.rowsCol[i]);
	}
  return b;
}

dhtmlXGridObject.prototype._groups_put=function(b){ 
	var sts = this.rowsCol.stablesort;
	this.rowsCol=new dhtmlxArray(0);
	this.rowsCol.stablesort = sts;
	
	for (var i=0; i<b.length; i++){
		var gr=b[i]._cntr;
		this.obj.firstChild.appendChild(gr.row);
		this.rowsCol.push(gr.row)
		gr.row.idd=null;
		for (var j=0; j<gr._childs.length; j++){
			this.obj.firstChild.appendChild(gr._childs[j]);
			this.rowsCol.push(gr._childs[j])
		}
		delete gr._childs;
	}
	this._temp_par.appendChild(this.obj);
}
dhtmlXGridObject.prototype._groupExisting=function(b){ 
	if (!this.getRowsNum()) return;
	var b=[];
	this._temp_par=this.obj.parentNode;
	this._temp_par.removeChild(this.obj);
	var a=[];
	
	var mlen=this.rowsCol.length;
	for (var i=0; i<mlen; i++){
		var val=this.cells4(this.rowsCol[i].childNodes[this._gIndex]).getValue();
		this.rowsCol[i].style.display = "";
		if (!val) val=" ";
		
		if (!this._groups[val]){
			this._groups[val]={text:val,row:this._addPseudoRow(true),count:0,state:"minus"};
			var z=this._groups[val];
			z.row._cntr=z;
			this._groups[val]._childs=[];
			b.push(z.row)
		}
		
		this._groups[val].count++;
		this._groups[val]._childs.push(this.rowsCol[i]);
		this.rowsCol[i].parentNode.removeChild(this.rowsCol[i]);
	}
  for (var i=0; i<b.length; i++)
 	this._updateGroupView(b[i]._cntr)
  this._groups_put(b);
  if (this._fake && !this._realfake) {
  	this._mirror_rowsCol();
  	this._fake._groups=[];
  	this._fake._reset_view();
  }
  this.callEvent("onGridReconstructed",[])
  this.updateGroups();
}

dhtmlXGridObject.prototype._switchGroupState=function(row){
	var z=row._cntr;
	if (this._fake && !this._realfake) {
		z.state=this._fake._groups[row._cntr.text].row._cntr.state;
		this._fake._switchGroupState(this._fake._groups[row._cntr.text].row)
	}
	
	var ind=this.rowsCol._dhx_find(z.row)+1;
	z.state=z.state=="minus"?"plus":"minus";
	var st=z.state=="plus"?"none":"";
	
	while(this.rowsCol[ind] && !this.rowsCol[ind]._cntr){
		this.rowsCol[ind].style.display=st;
		ind++;
	}

	this._updateGroupView(z);
	this.callEvent("onGroupStateChanged",[z.text, (z.state=="minus")]);
	this.setSizes();
}
/**
*	@desc: expand group of rows
*	@param: val - value to use to determine what group to expand (in other words this should be value common for all of them)
*	@edition: Professional
*	@type: public
*/
dhtmlXGridObject.prototype.expandGroup=function(val){
	if (this._groups[val].state=="plus")
		this._switchGroupState(this._groups[val].row);
}
/**
*	@desc: collapse group of rows
*	@param: val - value to use to determine what group to collapse (in other words this should be value common for all of them)
*	@edition: Professional
*	@type: public
*/
dhtmlXGridObject.prototype.collapseGroup=function(val){
	if (this._groups[val].state=="minus")
		this._switchGroupState(this._groups[val].row);
}
/**
*	@desc: expand all groups
*	@edition: Professional
*	@type: public
*/
dhtmlXGridObject.prototype.expandAllGroups=function(){
	for(var i in this._groups)
		if (this._groups[i] && this._groups[i].state=="plus")
			this._switchGroupState(this._groups[i].row);
}
/**
*	@desc: collapse all groups
*	@edition: Professional
*	@type: public
*/
dhtmlXGridObject.prototype.collapseAllGroups=function(){
	for(var i in this._groups)
		if (this._groups[i] && this._groups[i].state=="minus")
			this._switchGroupState(this._groups[i].row);
}

dhtmlXGridObject.prototype.hideGroupColumn=function(ind,state){
	if (this._fake) return;
	var rind=-1;
	var row = this._gmask.childNodes;
	for (var i=0; i<row.length; i++)
		if (row[i]._cellIndex==ind) {
			rind = i;
			break;
	}
	if (rind == -1) return;
	for (var a in this._groups)
		this._groups[a].row.childNodes[rind].style.display=state?"none":"";
};
dhtmlXGridObject.prototype.groupStat=function(name,ind,math){
	math = this["_g_"+(math||"stat_total")];
	var summ=0; var index=0;
	this.forEachRowInGroup(name,function(id){
		summ=math(summ,this.cells(id,ind).getValue()*1,index)
		index++;
	})
	return summ;
}
dhtmlXGridObject.prototype.forEachRowInGroup=function(name,code){
	var row=this._groups[name].row.nextSibling;
	if (row){
		while (row && !row._cntr) {
			code.call(this,row.idd);
			row=row.nextSibling;
		}
	} else {
		var cs=this._groups[name]._childs;
		if (cs)
			for (var i=0; i<cs.length; i++)
				code.call(this,cs[i].idd);
	}
};
dhtmlXGridObject.prototype.updateGroups=function(){
	if (!this._gmask || !this._gmask._math || this._parsing) return;
	var r=this._gmask.childNodes;
	for (var i=0; i<r.length; i++)
		if (r[i]._counter) this._b_processing.apply(this,r[i]._counter)
}
dhtmlXGridObject.prototype._b_processing=function(a,ind,rind){
	var c=0,j=0; 
	//put editor in cache, so it can be used for custom html containers - can be moved in cells5(?)
	if (!this._ecache[this.cellType[ind]]) this.cells5({parentNode:{grid:this}},this.cellType[ind]);
	for (var i=this.rowsCol.length-1; i>=0; i--){
		if (!this.rowsCol[i]._cntr){
			c=a(c,this.cells3(this.rowsCol[i],ind).getValue()*1,j);
			j++;
		} else {
			this.cells5(this.rowsCol[i].childNodes[rind],this.cellType[ind]).setValue(c);
			j=c=0;
		}
	}
}

dhtmlXGridObject.prototype._g_stat_total=function(c,n,i){
	return c+n;
}
dhtmlXGridObject.prototype._g_stat_min=function(c,n,i){
	if (!i) c=Infinity;
	return Math.min(c,n);
}
dhtmlXGridObject.prototype._g_stat_max=function(c,n,i){
	if (!i) c=-Infinity;
	return Math.max(c,n);
}
dhtmlXGridObject.prototype._g_stat_average=function(c,n,i){
	return (c*i+n)/(i+1);
}
dhtmlXGridObject.prototype._g_stat_count=function(c,n,i){
	return ++c;
}
	
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype._in_header_collapse=function(t,i,c){
	var rt=t.tagName=="TD"?t:t.parentNode;
	i=rt._cellIndexS;
	if (!this._column_groups) this._column_groups=[];
	var cols=c[1].split(":")
	var cols=c[1].split(":");
	cols = [cols.shift(), cols.join(':')];
	var count = parseInt(cols[0]); 
	t.innerHTML=c[0]+"<img src='"+this.imgURL+"minus.gif' style='padding-right:10px;height:16px'/><span style='position:relative; top:-6px;'>"+(cols[1]||"")+"<span>";
	t.style.paddingBottom='0px';
	var self = this;
	this._column_groups[i]=t.getElementsByTagName("IMG")[0];
	this._column_groups[i].onclick=function(e){
		(e||event).cancelBubble=true;
		this._cstate=!this._cstate;
		for (var j=i+1; j<(i+count); j++)
			self.setColumnHidden(j,this._cstate)
		if (this._cstate){
			if (rt.colSpan && rt.colSpan>0) {
				rt._exp_colspan=rt.colSpan;
				var delta=Math.max(1,rt.colSpan-count)
				if (!_isFF) //create additional cells to compensate colspan
				for (var z=0; z<rt.colSpan-delta; z++){
					var td=document.createElement("TD");
					if (rt.nextSibling)
						rt.parentNode.insertBefore(td,rt.nextSibling);
					else
						rt.parentNode.appendChild(td);
				}	
				rt.colSpan=delta;
			}
            self.callEvent("onColumnCollapse",[i,this._cstate]);
		} else 
			if (rt._exp_colspan){
				rt.colSpan=rt._exp_colspan;
				if (!_isFF)
				for (var z=1; z<rt._exp_colspan; z++)
					rt.parentNode.removeChild(rt.nextSibling);
                self.callEvent("onColumnCollapse",[i,this._cstate]);
			}
		this.src=self.imgURL+(this._cstate?"plus.gif":"minus.gif");
		
		if (self.sortImg.style.display!="none")
			self.setSortImgPos();		
	}	
}
dhtmlXGridObject.prototype.collapseColumns = function (ind) {
    if (!this._column_groups[ind] || this._column_groups[ind]._cstate) return;
    this._column_groups[ind].onclick({});
}
dhtmlXGridObject.prototype.expandColumns = function (ind) {
    if (!this._column_groups[ind] || !this._column_groups[ind]._cstate) return;
    this._column_groups[ind].onclick({});
}


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*	@desc: enable pop up menu which allows hidding/showing columns
*	@edition: Professional
*	@type: public
*/
dhtmlXGridObject.prototype.enableHeaderMenu=function(columns)
{
	if (!window.dhtmlXMenuObject)
		return dhtmlx.message("You need to include DHTMLX Menu");

	if (!this._header_menu){
		var menu = this._header_menu = new dhtmlXMenuObject();
		menu.renderAsContextMenu();

		var that=this;
		menu.attachEvent("onBeforeContextMenu", function(){
			that._showHContext(columns);
			return true;
		});
		menu.attachEvent("onClick", function(id){
			var checked = this.getCheckboxState(id);

			var row = that.hdr.rows[1];
			for (var j=0; j<row.cells.length; j++){
				var c = row.cells[j];
				if (c._cellIndexS == id){
					var len = c.colSpan || 1;
					for (var i=0; i<len; i++)
						that.setColumnHidden(id*1+i,!checked);
				}
			}
		});

		this.attachEvent("onInit",function(){
			menu.addContextZone(this.hdr);
		});
		if (this.hdr.rows.length) this.callEvent("onInit",[]);
	}
};

dhtmlXGridObject.prototype.getHeaderMenu=function(columns)
{
	return this._header_menu;
};

dhtmlXGridObject.prototype._hideHContext=function(){
	if (this._header_menu)
		this._header_menu.hide();
};

dhtmlXGridObject.prototype._showHContext=function(columns)
{
	if (typeof columns == "string")
		columns = columns.split(this.delim);
	
	var true_ind = 0;
	var j = 0;
	this._header_menu.clearAll();

	for (var i=0; i<this.hdr.rows[1].cells.length; i++){
		var c = this.hdr.rows[1].cells[i];
		if (!columns || (columns[true_ind] &&  columns[true_ind] != "false")){
			if (c.firstChild && c.firstChild.tagName=="DIV") var val=c.firstChild.innerHTML;
			else var val = c.innerHTML;
			val = val.replace(/<[^>]*>/gi,"");
			var visible = !(this.isColumnHidden(true_ind) || (this.getColWidth(true_ind)==0));
			this._header_menu.addCheckbox("child", this._header_menu.topId, j, true_ind, val, visible);
			j++;
		}
		true_ind+=(c.colSpan||1);
	}	
}
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype._process_json_row=function(r, data){
	r._attrs=data;
	for (var j = 0; j < r.childNodes.length; j++)r.childNodes[j]._attrs={
	};
	if (data.userdata)
		for (var a in data.userdata)
			this.setUserData(r.idd,a,data.userdata[a]);
			
	data = this._c_order?this._swapColumns(data.data):data.data;

	for (var i=0; i<data.length; i++)
		if (typeof data[i] == "object" && data[i] != null){
			r.childNodes[i]._attrs=data[i];
			if (data[i].type) r.childNodes[i]._cellType=data[i].type;
			data[i]=data[i].value;
		}
	this._fillRow(r, data);
	return r;
};


dhtmlXGridObject.prototype._process_js_row=function(r, data){
	r._attrs=data;
	for (var j = 0; j < r.childNodes.length; j++)
		r.childNodes[j]._attrs={};

	if (data.userdata)
		for (var a in data.userdata)
			this.setUserData(r.idd,a,data.userdata[a]);
			
	var arr = [];
	for (var i=0; i<this.columnIds.length; i++){
		arr[i] = data[this.columnIds[i]];
		if (typeof arr[i] == "object" && arr[i] != null){
			r.childNodes[i]._attrs=arr[i];
			if (arr[i].type) r.childNodes[i]._cellType=arr[i].type;
			arr[i]=arr[i].value;
		}
		if (!arr[i] && arr[i]!==0)
			arr[i]="";
	}

	this._fillRow(r, arr);
	return r;
};

dhtmlXGridObject.prototype.updateFromJSON = function(url, insert_new, del_missed, afterCall){
	if (typeof insert_new == "undefined")
		insert_new=true;
	this._refresh_mode=[
		true,
		insert_new,
		del_missed
	];
	
	this.load(url,afterCall,"json");
},
dhtmlXGridObject.prototype._refreshFromJSON = function(data){
		if (this._f_rowsBuffer) this.filterBy(0,"");
		reset = false;
		if (window.eXcell_tree){
			eXcell_tree.prototype.setValueX=eXcell_tree.prototype.setValue;
			eXcell_tree.prototype.setValue=function(content){
				var r=this.grid._h2.get[this.cell.parentNode.idd]
				if (r && this.cell.parentNode.valTag){
					this.setLabel(content);
				} else
					this.setValueX(content);
			};
		}
	
		var tree = this.cellType._dhx_find("tree");
		var pid = data.parent||0;
	
		var del = {
		};
	
		if (this._refresh_mode[2]){
			if (tree != -1)
				this._h2.forEachChild(pid, function(obj){
					del[obj.id]=true;
				}, this);
			else
				this.forEachRow(function(id){
					del[id]=true;
				});
		}
	
		var rows = data.rows;
	
		for (var i = 0; i < rows.length; i++){
			var row = rows[i];
			var id = row.id;
			del[id]=false;
	
			if (this.rowsAr[id] && this.rowsAr[id].tagName!="TR"){
				if (this._h2)
					this._h2.get[id].buff.data=row;
				else
					this.rowsBuffer[this.getRowIndex(id)].data=row;
				this.rowsAr[id]=row;
			} else if (this.rowsAr[id]){
					this._process_json_row(this.rowsAr[id], row, -1);
					this._postRowProcessing(this.rowsAr[id],true)
				} else if (this._refresh_mode[1]){
					var dadd={
						idd: id,
						data: row,
						_parser: this._process_json_row,
						_locator: this._get_json_data
					};
					
					var render_index = this.rowsBuffer.length;
					if (this._refresh_mode[1]=="top"){
						this.rowsBuffer.unshift(dadd);
						render_index = 0;
					} else
						this.rowsBuffer.push(dadd);
						
					if (this._h2){ 
						reset=true;
						(this._h2.add(id,pid)).buff=this.rowsBuffer[this.rowsBuffer.length-1];
					}
						
					this.rowsAr[id]=row;
					row=this.render_row(render_index);
					this._insertRowAt(row,render_index?-1:0)
				}
		}
				
		if (this._refresh_mode[2])
			for (id in del){
				if (del[id]&&this.rowsAr[id])
					this.deleteRow(id);
			}
	
		this._refresh_mode=null;
		if (window.eXcell_tree)
			eXcell_tree.prototype.setValue=eXcell_tree.prototype.setValueX;
			
		if (reset) this._renderSort();
		if (this._f_rowsBuffer) {
			this._f_rowsBuffer = null;
			this.filterByAll();
		}
	},

	dhtmlXGridObject.prototype._process_js=function(data){
		return this._process_json(data, "js");
	},

	dhtmlXGridObject.prototype._parseHeadJson=function(json){
		if (!json.head || !json.head.length) return;

		var headCol = json.head;
		var settings = json.settings;

		var awidthmet = "setInitWidths";
		var split = false;

		if (settings && settings.colwidth == "%")
			awidthmet="setInitWidthsP";
	
		if (settings && settings.splitat == "%")
			split=settings.splitat;

		//drop existing grid here, to prevent loss of initialization parameters
	    if (this.hdr.rows.length > 0) 
	    	this.clearAll(true);

		var sets = [
			[],
			[],
			[],
			[],
			[],
			[],
			[]
		];
	
		var attrs = ["value", "width", "type", "align", "sort","hidden", "id"];
		var calls = ["", awidthmet, "setColTypes", "setColAlign", "setColSorting", 
					"", "setColumnIds"];
	
		for (var i = 0; i < headCol.length; i++)
			for (var j = 0; j < attrs.length; j++)
				sets[j].push(headCol[i][attrs[j]]);

		this.setHeader(sets[0]);
		for (var i = 0; i < calls.length; i++)
			if (calls[i])
				this[calls[i]](sets[i].join(this.delim));
	
		for (var i = 0; i < headCol.length; i++){
			var options = headCol[i].options
			if (headCol[i].options)
				if (this.cellType[i] == "clist"){
					this.registerCList(i, options);
				} else {
					var combo = this.getCombo(i);
					for (var j = 0; j < options.length; j++)
						combo.put(options[j].id, options[j].value);
				}
		}
			
	
		this.init();

        var param=sets[5].join(this.delim);
        //preserving state of hidden columns, if not specified directly
		if (this.setColHidden && param.replace(/,/g,"")!="")
			this.setColHidden(param);

		if ((split)&&(this.splitAt))
			this.splitAt(split);
	};

	dhtmlXGridObject.prototype._process_json=function(data, mode){
		this._parsing=true;
		try {
			var data = data.responseText || data;
			if (typeof data == "string"){
				eval("dhtmlx.temp="+data+";");
				data = dhtmlx.temp;
			}
		} catch(e){
				dhx4.callEvent("onLoadXMLError", ["Incorrect JSON",
					(data.xmlDoc||data),
					this
				]);
				data = {rows:[]};
		}
			
		if (this._refresh_mode) return this._refreshFromJSON(data);				

		if (data.head)
			this._parseHeadJson(data);

		var cr = parseInt(data.pos||0);
		var total = parseInt(data.total_count||0);
		
		var reset = false;
		if (total){
			if (!this.rowsBuffer[total-1]){
				if (this.rowsBuffer.length)
					reset=true;
			this.rowsBuffer[total-1]=null;
			} 
			if (total<this.rowsBuffer.length){
				this.rowsBuffer.splice(total, this.rowsBuffer.length - total);
				reset = true;
			}
		}
			
		var userdata = mode === "js" ? data.userdata : data;
		for (var key in userdata){
			if (mode === "js" || key!="rows")
				this.setUserData("",key, userdata[key]);
		}

		if (mode == "js" && data.collections){
			for (var colkey in data.collections){
				var index = this.getColIndexById(colkey);
				var colrecs = data.collections[colkey];
				if (index !== window.undefined){
					if (this.cellType[index] == "clist"){
						colplaindata=[];
						for (var j=0; j<colrecs.length; j++)
							colplaindata.push(colrecs[j].label);
						this.registerCList(index, colplaindata);
					} else {
						var combo = this.getCombo(index);
						for (var j = 0; j < colrecs.length; j++)
							combo.put(colrecs[j].value, colrecs[j].label);
					}
				}
			}
		}
		
		if (this.isTreeGrid())
			return this._process_tree_json(data, null, null, mode);
			
		if (mode == "js"){
			if (data.data)
				data = data.data;
			for (var i = 0; i < data.length; i++){
				if (this.rowsBuffer[i+cr])
					continue;

				var row = data[i];
				var id  = row.id||(i+1);
				this.rowsBuffer[i+cr]={
					idd: id,
					data: row,
					_parser: this._process_js_row,
					_locator: this._get_js_data
				};

				this.rowsAr[id]=data[i];
			}
		} else {
			for (var i = 0; i < data.rows.length; i++){
				if (this.rowsBuffer[i+cr])
					continue;
				var id = data.rows[i].id;
				this.rowsBuffer[i+cr]={
					idd: id,
					data: data.rows[i],
					_parser: this._process_json_row,
					_locator: this._get_json_data
				};
	
				this.rowsAr[id]=data.rows[i];
			}
		}
		
		this.callEvent("onDataReady", []);
		if (reset && this._srnd){
			var h = this.objBox.scrollTop;
			this._reset_view();
			this.objBox.scrollTop = h;
		} else {
			this.render_dataset();
		}
		
		this._parsing=false;
}

dhtmlXGridObject.prototype._get_json_data=function(data, ind){
	if (typeof data.data[ind] == "object")
		return data.data[ind].value;
	else
		return data.data[ind];
};

dhtmlXGridObject.prototype._process_tree_json=function(data,top,pid,mode){
	this._parsing=true;
	var main=false;
	if (!top){
		this.render_row=this.render_row_tree;
		main=true;
		top=data;
		pid=top.parent||0;
		if (pid=="0") pid=0;
		if (!this._h2)	 this._h2=this._createHierarchy();
		if (this._fake) this._fake._h2=this._h2;
	} 
	
	if (mode == "js"){
		if (top.data && !pid) 
			data = top.data;
		if (top.rows)
			top = top.rows;
		for (var i = 0; i < top.length; i++){
			var id = top[i].id;
			var row=this._h2.add(id,pid);
			row.buff={ idd:id, data:top[i], _parser: this._process_js_row, _locator:this._get_js_data };

			if (top[i].open)
			    row.state="minus";
				
			this.rowsAr[id]=row.buff;
		    this._process_tree_json(top[i],top[i],id,mode);
		}
	} else {
		if (top.rows) {
			for (var i = 0; i < top.rows.length; i++){
					var id = top.rows[i].id;
					var row=this._h2.add(id,pid);
					row.buff={ idd:id, data:top.rows[i], _parser: this._process_json_row, _locator:this._get_json_data };
					if (top.rows[i].open)
					    row.state="minus";
					
					this.rowsAr[id]=row.buff;
				    this._process_tree_json(top.rows[i],top.rows[i],id,mode);
			}
		}
	}
		
	if (main){ 
		
		if (pid!=0) this._h2.change(pid,"state","minus")
		this._updateTGRState(this._h2.get[pid]);
		this._h2_to_buff();
		
		this.callEvent("onDataReady", []);
		if (pid!=0 && (this._srnd || this.pagingOn))
			this._renderSort();
		else
			this.render_dataset();
		
		
	
		if (this._slowParse===false){
			this.forEachRow(function(id){
				this.render_row_tree(0,id)
			})
		}
		this._parsing=false;

		if (pid!=0 && !this._srnd)
		   this.callEvent("onOpenEnd",[pid,1]);	
	}
}	


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

  /**
  *   @desc: sets marked cells support to enabled or disabled state
  *   @type: public
  *   @param: state - true or false
  */
 dhtmlXGridObject.prototype.enableMarkedCells = function(fl){
  	this.markedRowsArr = new dhtmlxArray(0);
	this.markedCellsArr = new Array(0);
	this.lastMarkedRow = null;
	this.lastMarkedColumn = null;
 	this.markedCells = true;
	this.lastMarkMethod = 0;
	if(arguments.length>0){
		if(!dhx4.s2b(fl))
			this.markedCells = false;
	}
 };
  /**
  *   @desc: occures on cell click
  *   @type: private
  *   @param: [el] - cell to click on
  *   @param: [markMethod] - 0 - simple click, 1 - shift, 2 - ctrl
  */
 dhtmlXGridObject.prototype.doMark = function(el,markMethod){ 

				var _rowId = el.parentNode.idd;
				this.setActive(true);
				if (!_rowId) return;
				this.editStop();
				this.cell=el;
				this.row=el.parentNode;
				var _cellIndex = el._cellIndex;				
				
				if(!markMethod) markMethod = 0;
				
           	    if(markMethod==0){
                    this.unmarkAll() ;	 
                }
				else if(markMethod==1){
					
					if(this.lastMarkedRow) {
						var r_start = Math.min(this.getRowIndex(_rowId),this.getRowIndex(this.lastMarkedRow));
						var r_end = Math.max(this.getRowIndex(_rowId),this.getRowIndex(this.lastMarkedRow));
						
						var c_start = Math.min(_cellIndex,this.lastMarkedColumn);
						var c_end = Math.max(_cellIndex,this.lastMarkedColumn);
					
						for(var i = r_start; i < r_end+1; i++){
							for(var j = c_start; j < c_end+1; j++){
								this.mark(this.getRowId(i),j,true);
								
							}
						}
					}
				}
				else if(markMethod==2){
					if(this.markedRowsArr._dhx_find(_rowId)!=-1){ 
						for(var ci = 0; ci < this.markedCellsArr[_rowId].length; ci++){
							if(this.markedCellsArr[_rowId][ci]==_cellIndex){
								this.mark(_rowId,_cellIndex,false);
								return true;
							}
						}
						
					}
					
				}
				
				if(!this.markedCellsArr[_rowId]) 
					this.markedCellsArr[_rowId] = new dhtmlxArray(0);
				
				if(markMethod!=1) 
					this.mark(_rowId,_cellIndex);
					
				this.moveToVisible(this.cells(_rowId,_cellIndex).cell);
				this.lastMarkedRow = _rowId;
				this.lastMarkedColumn = _cellIndex;
				this.lastMarkMethod = markMethod;
				
 }
/**
  	*   @desc: sets selection or removes selection from specified cell
    *   @param: r - row object or row index
    *   @param: cInd - cell index
    *   @param: state - true or false 
	*   @type: public
 */
dhtmlXGridObject.prototype.mark = function(rid,cindex,fl){
	if(arguments.length>2){
		if(!dhx4.s2b(fl)){
			this.cells(rid,cindex).cell.className = this.cells(rid,cindex).cell.className.replace(/cellselected/g,"");
			if(this.markedRowsArr._dhx_find(rid)!=-1){
				var ci = this.markedCellsArr[rid]._dhx_find(cindex);
				if(ci!=-1){
					this.markedCellsArr[rid]._dhx_removeAt(ci);
					if(this.markedCellsArr[rid].length==0){
						this.markedRowsArr._dhx_removeAt(this.markedRowsArr._dhx_find(rid));
					}
					this.callEvent("onCellUnMarked",[rid,cindex]);
				}
			}
			return true;
		}
	}
	this.cells(rid,cindex).cell.className+= " cellselected";
	
	if(this.markedRowsArr._dhx_find(rid)==-1) 
		this.markedRowsArr[this.markedRowsArr.length] = rid;
		
	if(!this.markedCellsArr[rid]) 
		this.markedCellsArr[rid] = new dhtmlxArray(0);
	if(this.markedCellsArr[rid]._dhx_find(cindex)==-1){
		this.markedCellsArr[rid][this.markedCellsArr[rid].length] = cindex;
		this.callEvent("onCellMarked",[rid,cindex]);
	}
	
}
/**
  	*   @desc: removes selection from all marked cell
   	*   @type: public
 */
dhtmlXGridObject.prototype.unmarkAll = function(){
	if(this.markedRowsArr){
		for(var ri = 0; ri < this.markedRowsArr.length; ri++){
			var rid = this.markedRowsArr[ri];
			if (this.rowsAr[rid])
				for(var ci = 0; ci < this.markedCellsArr[rid].length; ci++){
					this.callEvent("onCellUnMarked",[rid,this.markedCellsArr[rid][ci]])
					this.cells(rid,this.markedCellsArr[rid][ci]).cell.className = this.cells(rid,this.markedCellsArr[rid][ci]).cell.className.replace(/cellselected/g,"");
				}
		} 
		this.markedRowsArr = new dhtmlxArray(0);
		this.markedCellsArr = new Array(0);
	}
	return true;
}
/**
  	*   @desc: gets marked cells
   	*   @returns: the array of marked cells	(pairs of row id and column index)
	*   @type: public
 */
dhtmlXGridObject.prototype.getMarked = function(){
	var marked = new Array();
	if(this.markedRowsArr)
	for(var ri = 0; ri < this.markedRowsArr.length; ri++){
		var rid = this.markedRowsArr[ri];
		for(var ci = 0; ci < this.markedCellsArr[rid].length; ci++){
			marked[marked.length] = [rid,this.markedCellsArr[rid][ci]];
		}
	} 
	return marked;		
}


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*	@desc: cell with support for math formulas
*	@param: cell - cell object
*	@type:  private
*   @edition: Professional
*/
function eXcell_math(cell){
	if (cell){
		this.cell = cell;
    	this.grid = this.cell.parentNode.grid;
	}
	this.edit = function(){
		this.grid.editor = new eXcell_ed(this.cell);
		this.grid.editor.fix_self=true;
		this.grid.editor.getValue=this.cell.original?(function(){ return this.cell.original}):this.getValue;
		this.grid.editor.setValue=this.setValue;
		this.grid.editor.edit();
	}
	this.isDisabled = function(){ return !this.grid._mathEdit; }
	this.setValue = function(val){
				val=this.grid._compileSCL(val,this.cell,this.fix_self);
                if (this.grid._strangeParams[this.cell._cellIndex])
    				this.grid.cells5(this.cell,this.grid._strangeParams[this.cell._cellIndex]).setValue(val);
                else{
                    this.setCValue(val);
    	            this.cell._clearCell=false;
	            }
    }
    this.getValue = function(){
        if (this.grid._strangeParams[this.cell._cellIndex])
			return this.grid.cells5(this.cell,this.grid._strangeParams[this.cell._cellIndex]).getValue();
        
        return this.cell.innerHTML;
    }
}
eXcell_math.prototype = new eXcell;

dhx4.attachEvent("onGridCreated", function(grid){
	grid._reset_math();
	grid.attachEvent("onClearAll", grid._reset_math);
	grid.attachEvent("onCellChanged",function(id,ind){
		if (this._mat_links[id]){ 
			var cell=this._mat_links[id][ind];
			if (cell){ 
				for (var i=0; i<cell.length; i++)
          if (cell[i].parentNode)
            this.cells5(cell[i]).setValue(this._calcSCL(cell[i]));
			}
		}
		if (!this._parsing && this._aggregators[ind]){
			var pid=this._h2.get[id].parent.id;
			if (pid!=0){
				var ed=this.cells(pid,ind);
				ed.setValue(this._calcSCL(ed.cell));
			}
		}
	})
	grid.attachEvent("onAfterRowDeleted",function(id,pid){ //will be called for each delete operation, may be optimized
		if (pid!=0)
			if (!this._parsing && this._aggregators.length){
				for (var ind=0; ind < this._aggregators.length; ind++) {
					if (this._aggregators[ind]){
							var ed=this.cells(pid,ind);
							ed.setValue(this._calcSCL(ed.cell));
					}
				};
			}
		return true;
	})
	grid.attachEvent("onXLE", grid._refresh_math);

});

dhtmlXGridObject.prototype._reset_math=function(){
  this._mat_links   = {};
  this._aggregators = [];
};
dhtmlXGridObject.prototype._refresh_math=function(){
  for (var i=0; i < this._aggregators.length; i++) {
    if (this._aggregators[i])
      this._h2.forEachChild(0,function(el){
        if (el.childs.length!=0){
          var ed=this.cells(el.id,i);
          ed.setValue(this._calcSCL(ed.cell));
        }
      },this);
  };
};

dhtmlXGridObject.prototype.refreshMath=function(status){
    this._mat_links = {};
    for (var i=0; i<this.getColumnsNum(); i++){
      if (this.getColType(i) == "math"){
        this.forEachRow(function(id){
          var cell = this.cells(id, i);
          cell.setValue(cell.cell.original || cell.getValue());
        });
      }
    }
};

/**
*	@desc: enable/disable serialization of math formulas
*	@param: status - true/false
*	@type:  public
*   @edition: Professional
*/
dhtmlXGridObject.prototype.enableMathSerialization=function(status){
    this._mathSerialization=dhx4.s2b(status);
}
/**
*	@desc: enable/disable rounding while math calculations
*	@param: digits - set hom many digits must be rounded, set 0 for disabling
*	@type:  public
*   @edition: Professional
*/
dhtmlXGridObject.prototype.setMathRound=function(digits){
	this._roundDl=digits;
    this._roundD=Math.pow(10,digits);
}
/**
*	@desc: enable/disable editing of math cells
*	@param: status - true/false
*	@type:  public
*   @edition: Professional
*/
dhtmlXGridObject.prototype.enableMathEditing=function(status){
    this._mathEdit=dhx4.s2b(status);
}

/**
*	@desc: calculate value of math cell
*	@param: cell - math cell
*	@returns: cell value
*	@type:  private
*   @edition: Professional
*/
dhtmlXGridObject.prototype._calcSCL=function(cell){ 
    if (!cell._code) return this.cells5(cell).getValue();
    try{
    	dhtmlx.agrid=this;
    	var z=eval(cell._code);
    } catch(e){ return ("#SCL"); }
    if (this._roundD)
        { 
        	var pre=Math.abs(z)<1?"0":"";
         	if (z<0) pre="-"+pre;
            z=Math.round(Math.abs(z)*this._roundD).toString();
            if (z==0) return 0;
            if (this._roundDl>0){
            	var n=z.length-this._roundDl;
            	if (n<0) {
            		z=("000000000"+z).substring(9+n);
            		n=0;
            	}
            	return (pre+z.substring(0,n)+"."+z.substring(n,z.length));
            }
          return pre+z;
      }
    return z;      
}

dhtmlXGridObject.prototype._countTotal=function(row,cell){ 
	var b=0;
	var z=this._h2.get[row];
	for (var i=0; i<z.childs.length; i++){
		if (!z.childs[i].buff) return b;	// dnd of item with childs, item inserted in hierarchy but not fully processed
		if (z.childs[i].buff._parser){
      b = 0;
			this._h2.forEachChild(row,function(el){
				if (el.childs.length==0){
          var value = parseFloat(this._get_cell_value(el.buff,cell),10);
          if (value)
					 b += value;
        }
			},this)
			return b;
		}
    var value = parseFloat(this._get_cell_value(z.childs[i].buff,cell),10);
    if (value)
		  b += value;
	}
	return b;
}

/**
*	@desc: compile pseudo code to correct javascript
*	@param: code - pseudo code
*	@param: cell - math cell
*	@returns: valid js code
*	@type:  private
*   @edition: Professional
*/
dhtmlXGridObject.prototype._compileSCL=function(code,cell,fix){ 
		if (code === null || code === window.undefined) return code;
        code=code.toString();
        if (code.indexOf("=")!=0 || !cell.parentNode) {
        	this._reLink([],cell);
        	if (fix) cell._code = cell.original = null;
            return code;
        }
        cell.original=code;
        
        var linked=null;
        code=code.replace("=","");
        if (code.indexOf("sum")!=-1){ 
            code=code.replace("sum","(dhtmlx.agrid._countTotal('"+cell.parentNode.idd+"',"+cell._cellIndex+"))");
            if (!this._aggregators) this._aggregators=[];
            this._aggregators[cell._cellIndex]="sum";
            cell._code=code;
        	return  this._parsing?"":this._calcSCL(cell);
        }
        if (code.indexOf("[[")!=-1){
          var test = /(\[\[([^\,]*)\,([^\]]*)]\])/g;
          dhtmlx.agrid=this;
          linked=linked||(new Array());
          code=code.replace(test,
              function ($0,$1,$2,$3){
                  if ($2=="-")
                      $2=cell.parentNode.idd;
                  if ($2.indexOf("#")==0)
                      $2=dhtmlx.agrid.getRowId($2.replace("#",""));
                      linked[linked.length]=[$2,$3];
                  return "(parseFloat(dhtmlx.agrid.cells(\""+$2+"\","+$3+").getValue(),10))";
              }
          );
        }
        
        if (code.indexOf(":")!=-1){ 
          var test = /:(\w+)/g;
          dhtmlx.agrid=this;
          var id=cell.parentNode.idd;
          linked=linked||(new Array());
          code=code.replace(test,
              function ($0,$1,$2,$3){
                  linked[linked.length]=[id,dhtmlx.agrid.getColIndexById($1)];
                  return '(parseFloat(dhtmlx.agrid.cells("'+id+'",dhtmlx.agrid.getColIndexById("'+$1+'")).getValue(),10))';
              }
          );
        }
        else{
          var test = /c([0-9]+)/g;
          dhtmlx.agrid=this;
          var id=cell.parentNode.idd;
          linked=linked||(new Array());
          code=code.replace(test,
              function ($0,$1,$2,$3){
                  linked[linked.length]=[id,$1];
                  return "(parseFloat(dhtmlx.agrid.cells(\""+id+"\","+$1+").getValue(),10))";
              }
          );
        }
        
        this._reLink(linked,cell);
        cell._code=code;
        return this._calcSCL(cell);
    }

/**
*	@desc: link math cells to it source cells
*	@param: ar - array of nodes for linking
*	@param: cell - math cell
*	@type:  private
*   @edition: Professional
*/
dhtmlXGridObject.prototype._reLink=function(ar,cell){
		if (!ar.length) return; // basically it would be good to clear unused math links, but it will require a symetric structure 
		for (var i=0; i<ar.length; i++){ 
			if (!this._mat_links[ar[i][0]]) this._mat_links[ar[i][0]]={};
			var t=this._mat_links[ar[i][0]];
			if (!t[ar[i][1]]) t[ar[i][1]]=[];
			t[ar[i][1]].push(cell);
		}
}

if (_isKHTML){
// replace callback support for safari.
 (function(){
   var default_replace = String.prototype.replace;
   String.prototype.replace = function(search,replace){
 // replace is not function
 if(typeof replace != "function"){
 return default_replace.apply(this,arguments)
 }
 var str = "" + this;
 var callback = replace;
 // search string is not RegExp
 if(!(search instanceof RegExp)){
 var idx = str.indexOf(search);
 return (
 idx == -1 ? str :
 default_replace.apply(str,[search,callback(search, idx, str)])
 )
 }
 var reg = search;
 var result = [];
 var lastidx = reg.lastIndex;
 var re;
 while((re = reg.exec(str)) != null){
 var idx  = re.index;
 var args = re.concat(idx, str);
 result.push(
 str.slice(lastidx,idx),
 callback.apply(null,args).toString()
 );
 if(!reg.global){
 lastidx += RegExp.lastMatch.length;
 break
 }else{
 lastidx = reg.lastIndex;
 }
 }
 result.push(str.slice(lastidx));
 return result.join("")
   }
 })();
 }
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: add new column to the grid. Can be used after grid was initialized. At least one column should be in grid
*   @param: ind - index of column
*   @param: header - header content of column
*   @param: type - type of column
*   @param: width - width of column
*   @param: sort - sort type of column
*   @param: align - align of column
*   @param: valign - vertical align of column
*   @param: reserved - not used for now
*   @param: columnColor - background color of column
*   @type: public
*   @edition: Professional
*   @topic: 3
*/
dhtmlXGridObject.prototype.insertColumn=function(ind,header,type,width,sort,align,valign,reserved,columnColor){
	ind=parseInt(ind);
	if (ind>this._cCount) ind=this._cCount;
	if (!this._cMod) this._cMod=this._cCount;
	this._processAllArrays(this._cCount,ind-1,[(header||"&nbsp;"),(width||100),(type||"ed"),(align||"left"),(valign||""),(sort||"na"),(columnColor||""),"",this._cMod,(width||100)]);
	this._processAllRows("_addColInRow",ind);

	if (typeof(header)=="object")
		for (var i=1; i < this.hdr.rows.length; i++) {
			if (header[i-1]=="#rspan"){
         		var pind=i-1;
         		var found=false;
         		var pz=null;
         		while(!found){
            		var pz=this.hdr.rows[pind];
            		for (var j=0; j<pz.cells.length; j++)
               			if (pz.cells[j]._cellIndex==ind) {
                  			found=j;
                  			break;
		      		}
            		pind--;
	        	}
	        this.hdr.rows[pind+1].cells[j].rowSpan=(this.hdr.rows[pind].cells[j].rowSpan||1)+1;
			}
			else				
			this.setHeaderCol(ind,(header[i-1]||"&nbsp;"),i);
		}
	else
		this.setHeaderCol(ind,(header||"&nbsp;"));
	this.hdr.rows[0].cells[ind]
	this._cCount++;
	this._cMod++;
	this._master_row=null;
	this.setSizes();
}
/**
*   @desc: delete column
*   @param: ind - index of column
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.deleteColumn=function(ind){
	ind=parseInt(ind);
	if (this._cCount==0) return;
	if (!this._cMod) this._cMod=this._cCount;
	if (ind>=this._cCount) return;
	this._processAllArrays(ind,this._cCount-1,[null,null,null,null,null,null,null,null,null,null,null]);
	this._processAllRows("_deleteColInRow",ind);
	this._cCount--;
	this._master_row=null;
	this.setSizes();

}

/**
*   @desc: call method for all rows in all collections
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._processAllRows = function(method,oldInd,newInd){
	this[method](this.obj.rows[0],oldInd,newInd,0);

	var z=this.hdr.rows.length;
    for (var i=0; i<z; i++)
		this[method](this.hdr.rows[i],oldInd,newInd,i);
		
	if (this.ftr){
		var z=this.ftr.firstChild.rows.length;
	    for (var i=0; i<z; i++)
			this[method](this.ftr.firstChild.rows[i],oldInd,newInd,i);
	}

	this.forEachRow(function(id){
		if (this.rowsAr[id] && this.rowsAr[id].tagName=="TR")
			this[method](this.rowsAr[id],oldInd,newInd,-1);
	});			
	
}

/**
*   @desc: shift data in all arrays
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._processAllArrays = function(oldInd,newInd,vals){
	var ars=["hdrLabels","initCellWidth","cellType","cellAlign","cellVAlign","fldSort","columnColor","_hrrar","_c_order"];
	if (this.cellWidthPX.length) ars.push("cellWidthPX");
	if (this.cellWidthPC.length) ars.push("cellWidthPC");
	if (this._col_combos) ars.push("_col_combos");
    if (this._mCols) ars[ars.length]="_mCols";
    if (this.columnIds) ars[ars.length]="columnIds";
    if (this._maskArr) ars.push("_maskArr");
    if (this._drsclmW) ars.push("_drsclmW");
    if (this._RaSeCol) ars.push("_RaSeCol");
    if (this._hm_config) ars.push("_hm_config");
    if (this._drsclmn) ars.push("_drsclmn");

    if (this.clists) ars.push("clists");
    if (this._validators && this._validators.data) ars.push(this._validators.data);
    
    ars.push("combos");
    if (this._customSorts) ars.push("_customSorts");
    if (this._aggregators)  ars.push("_aggregators");
    var mode=(oldInd<=newInd);

	if (!this._c_order) {
		this._c_order=new Array();
		var l=this._cCount;
		for (var i=0; i<l; i++)
			this._c_order[i]=i;
	}

	for (var i=0; i<ars.length; i++)
		{
			var t=this[ars[i]]||ars[i];
			if (t){
				if (mode){
					var val=t[oldInd];
					for (var j=oldInd; j<newInd; j++)
						t[j]=t[j+1];
					t[newInd]=val;
				} else {
					var val=t[oldInd];
					for (var j=oldInd; j>(newInd+1); j--)
						t[j]=t[j-1];
					t[newInd+1]=val;
				}
				if (vals)
					t[newInd+(mode?0:1)]=vals[i];
			}
		}
}


/**
*   @desc: moves column of specified index to new position
*   @param: oldInd - current index of column
*   @param: newInd - new index of column
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.moveColumn = function(oldInd,newInd){
	newInd--;
    oldInd=parseInt(oldInd); newInd=parseInt(newInd);
	if (newInd<oldInd) var tInd=newInd+1;
	else var tInd=newInd;
	

	if (!this.callEvent("onBeforeCMove",[oldInd,tInd]))  return false;
	if (oldInd==tInd) return;

	
	//replace data
	this.editStop();
    this._processAllRows("_moveColInRow",oldInd,newInd);
    this._processAllArrays(oldInd,newInd);

	//sorting image
	if (this.fldSorted)
		this.setSortImgPos(this.fldSorted._cellIndex);

  /*	for (var i=0; i<this.hdrLabels.length; i++)
		this._c_revers[this._c_order[i]]=i;*/
	this.callEvent("onAfterCMove",[oldInd,tInd]);
};


/**
*   @desc: swap columns in collection
*   @param: cols - collection of collumns
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._swapColumns = function(cols){
	var z=new Array();
	for (var i=0; i<this._cCount; i++){
		var n=cols[this._c_order[i]];
		if (typeof(n)=="undefined") n="";
		z[i]=n;
		}
	return z;
}

/**
*   @desc: move data in the row
*   @param: row - row object
*   @param: oldInd - current index of column
*   @param: newInd - new index of column
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._moveColInRow = function(row,oldInd,newInd){


	var c=row.childNodes[oldInd];
	var ci=row.childNodes[newInd+1];
	if (!c) return;
	if (ci)
		row.insertBefore(c,ci);
	else
		row.appendChild(c);

	for (var i=0; i<row.childNodes.length; i++)
		row.childNodes[i]._cellIndex=row.childNodes[i]._cellIndexS=i;

};
/**
*   @desc: add column in row
*   @param: row - row object
*   @param: ind - current index of column
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._addColInRow = function(row,ind,old,mod){
	var cind=ind;
	if (row._childIndexes){
		if (row._childIndexes[ind-1]==row._childIndexes[ind] || !row.childNodes[row._childIndexes[ind-1]]){
			for (var i=row._childIndexes.length; i>=ind; i--)
			row._childIndexes[i]=i?(row._childIndexes[i-1]+1):0;
			row._childIndexes[ind]--;
			}
		else
		for (var i = row._childIndexes.length; i >= ind; i--)
			row._childIndexes[i]=i?(row._childIndexes[i-1]+1):0;
		var cind=row._childIndexes[ind];
	}
	var c=row.childNodes[cind];
	var z=document.createElement((mod)?"TD":"TH");
	if (mod) { z._attrs={}; } //necessary for code compressor
	else z.style.width=(parseInt(this.cellWidthPX[ind])||"100")+"px";
	if (c)
		row.insertBefore(z,c);
	else
		row.appendChild(z);

	if (this.dragAndDropOff && row.idd) this.dragger.addDraggableItem(row.childNodes[cind],this);
	
	for (var i=cind+1; i<row.childNodes.length; i++){
		row.childNodes[i]._cellIndex=row.childNodes[i]._cellIndexS=row.childNodes[i]._cellIndex+1;
	}
		
	if (row.childNodes[cind]) row.childNodes[cind]._cellIndex=row.childNodes[cind]._cellIndexS=ind;

	if (row.idd || typeof(row.idd)!="undefined"){
		this.cells3(row,ind).setValue("");
		z.align=this.cellAlign[ind];
		z.style.verticalAlign=this.cellVAlign[ind];
		z.bgColor=this.columnColor[ind];
		}
	else if (z.tagName=="TD"){
		if (!row.idd && this.forceDivInHeader) z.innerHTML="<div class='hdrcell'>&nbsp;</div>";
		else	z.innerHTML="&nbsp;";
	} 
};
/**
*   @desc: delete columns from row
*   @param: row - row object
*   @param: ind - current index of column
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._deleteColInRow = function(row,ind){
	var aind = ind; //logical index
	if (row._childIndexes) ind=row._childIndexes[ind];
	var c=row.childNodes[ind];
	if (!c) return;
	if (c.colSpan && c.colSpan>1 && c.parentNode.idd){
		var t=c.colSpan-1;
		var v=this.cells4(c).getValue();
		this.setColspan(c.parentNode.idd,c._cellIndex,1)
		if (t>1){
			var cind=c._cellIndex*1;
			this.setColspan(c.parentNode.idd,cind+1,t)
			this.cells(c.parentNode.idd,c._cellIndex*1+1).setValue(v)
			row._childIndexes.splice(cind,1)
			for (var i=cind; i < row._childIndexes.length; i++) 
				row._childIndexes[i]-=1;
				
		}
	} else if (row._childIndexes){
	    row._childIndexes.splice(aind,1);
	    for (var i=aind; i<row._childIndexes.length; i++) row._childIndexes[i]--;
	}
	if (c)
		row.removeChild(c);

	for (var i=ind; i<row.childNodes.length; i++)
		row.childNodes[i]._cellIndex=row.childNodes[i]._cellIndexS=row.childNodes[i]._cellIndex-1;
};


/**
*   @desc: enable move column functionality
*   @param: mode - true/false
*   @param: columns - list of true/false values, optional
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableColumnMove = function(mode,columns){
	this._mCol=dhx4.s2b(mode);
	if (typeof(columns)!="undefined")
		this._mCols=columns.split(",");
	if (!this._mmevTrue){
		dhtmlxEvent(this.hdr,"mousedown",this._startColumnMove);
		dhtmlxEvent(document.body,"mousemove",this._onColumnMove);
		dhtmlxEvent(document.body,"mouseup",this._stopColumnMove);
		this._mmevTrue=true;
	}
};

dhtmlXGridObject.prototype._startColumnMove = function(e){
	e=e||event;
	var el = e.target||e.srcElement;
//	var grid=globalActiveDHTMLGridObject;
	   	var zel=el;
	   	while(zel.tagName!="TABLE") zel=zel.parentNode;
		var grid=zel.grid;
		if (!grid) return; //somehow grid not found
		grid.setActive();
	if (!grid._mCol || e.button==2) return;
	
	el = grid.getFirstParentOfType(el,"TD")
    if(el.style.cursor!="default") return true;
	if ((grid)&&(!grid._colInMove)){
		grid.resized = null;
		if ((!grid._mCols)||(grid._mCols[el._cellIndex]=="true"))
	    	grid._colInMove=el._cellIndex+1;
	}
	grid._colInMovePos = {
		x: e.clientX, y: e.clientY
	};
	return true;
};
dhtmlXGridObject.prototype._onColumnMove = function(e){
	e=e||event;
	var grid=window.globalActiveDHTMLGridObject;
	if ((grid)&&(grid._colInMove)){
		var diff = Math.max(
			Math.abs(e.clientX - grid._colInMovePos.x),
			Math.abs(e.clientY - grid._colInMovePos.y)
		);
		if (diff < 20) return;


		if (grid._hideHContext) grid._hideHContext();
    	if (typeof(grid._colInMove)!="object"){
        	var z=document.createElement("DIV");
			z._aIndex=(grid._colInMove-1);
			z._bIndex=null;
			z.innerHTML=grid.getHeaderCol(z._aIndex);
			z.className="dhx_dragColDiv";
			z.style.position="absolute";
			document.body.appendChild(z);
            grid._colInMove=z;
		}
		
		var cor=[];
		cor[0]=(document.body.scrollLeft||document.documentElement.scrollLeft);
		cor[1]=(document.body.scrollTop||document.documentElement.scrollTop);
		
		
		grid._colInMove.style.left=e.clientX+cor[0]+8+"px";
		grid._colInMove.style.top=e.clientY+cor[1]+8+"px";
		
        var el = e.target||e.srcElement;
		while ((el)&&(typeof(el._cellIndexS)=="undefined"))
			el=el.parentNode;

		if (grid._colInMove._oldHe){
			grid._colInMove._oldHe.className=grid._colInMove._oldHe.className.replace(/columnTarget(L|R)/g,"");
			grid._colInMove._oldHe=null;
			grid._colInMove._bIndex=null;
			}
		if (el) {
			if (grid.hdr.rows[1]._childIndexes)
				var he=grid.hdr.rows[1].cells[grid.hdr.rows[1]._childIndexes[el._cellIndexS]];
			else
				var he=grid.hdr.rows[1].cells[el._cellIndexS];
			var z=e.clientX-(dhx4.absLeft(he)-grid.hdrBox.scrollLeft);
            if (z/he.offsetWidth>0.5){
				he.className+=" columnTargetR";
				grid._colInMove._bIndex=el._cellIndexS;
				}
			else {
				he.className+=" columnTargetL";
				grid._colInMove._bIndex=el._cellIndexS-1;
			}
			if (he.offsetLeft<(grid.objBox.scrollLeft+20))
				grid.objBox.scrollLeft=Math.max(0,he.offsetLeft-20);

			if ((he.offsetLeft+he.offsetWidth-grid.objBox.scrollLeft)>(grid.objBox.offsetWidth-20))
				grid.objBox.scrollLeft=Math.min(grid.objBox.scrollLeft+he.offsetWidth+20,grid.objBox.scrollWidth-grid.objBox.offsetWidth);	
				
            grid._colInMove._oldHe=he;
		}
		//prevent selection, or other similar reactions while column draged
		e.cancelBubble = true;  
        return false;  
	}
	return true;
};
dhtmlXGridObject.prototype._stopColumnMove = function(e){
	e=e||event;
	var grid=window.globalActiveDHTMLGridObject;
	if ((grid)&&(grid._colInMove)){
		if (typeof(grid._colInMove)=="object"){
			grid._colInMove.parentNode.removeChild(grid._colInMove);
			if (grid._colInMove._bIndex!=null)
				grid.moveColumn(grid._colInMove._aIndex,grid._colInMove._bIndex+1);

			if (grid._colInMove._oldHe)
				grid._colInMove._oldHe.className=grid._colInMove._oldHe.className.replace(/columnTarget(L|R)/g,"");
			grid._colInMove._oldHe=null;
			grid._colInMove.grid=null;
			grid.resized = true;
			}
        grid._colInMove=0;
	}
	return true;
};



//(c)dhtmlx ltd. www.dhtmlx.com



/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype.mouseOverHeader=function(func){
		var self=this;
		dhtmlxEvent(this.hdr,"mousemove",function(e){
				e=e||window.event;
				var el=e.target||e.srcElement;
            	if(el.tagName!="TD")
                	el = self.getFirstParentOfType(el,"TD")				
                if (el && (typeof(el._cellIndex)!="undefined"))
					func(el.parentNode.rowIndex,el._cellIndex);
		});
}
dhtmlXGridObject.prototype.mouseOver=function(func){
		var self=this;	
		dhtmlxEvent(this.obj,"mousemove",function(e){
				e=e||window.event;
				var el=e.target||e.srcElement;
            	if(el.tagName!="TD")
                	el = self.getFirstParentOfType(el,"TD")				
                if (el && (typeof(el._cellIndex)!="undefined"))
					func(el.parentNode.rowIndex,el._cellIndex);
		});
}
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*  @desc: enable smart paging mode
*  @type: public
*  @param: fl - true|false - enable|disable mode
*  @param: pageSize - count of rows per page
*  @param: pagesInGrp - count of visible page selectors
*  @param: parentObj - ID or container which will be used for showing paging controls
*  @param: showRecInfo - true|false - enable|disable showing of additional info about paging state
*  @param: recInfoParentObj - ID or container which will be used for showing paging state
*  @edition: Professional
*  @topic: 0
*/
dhtmlXGridObject.prototype.enablePaging = function(fl,pageSize,pagesInGrp,parentObj,showRecInfo,recInfoParentObj){
	this._pgn_parentObj = typeof(parentObj)=="string" ? document.getElementById(parentObj) : parentObj;
	this._pgn_recInfoParentObj = typeof(recInfoParentObj)=="string" ? document.getElementById(recInfoParentObj) : recInfoParentObj;
	
	this.pagingOn = fl;
	this.showRecInfo = showRecInfo;
	this.rowsBufferOutSize = parseInt(pageSize);
	this.currentPage = 1;
	this.pagesInGroup = parseInt(pagesInGrp);
	this._init_pgn_events()
	this.setPagingSkin("default");
}
/**
*  @desc: allow to configure settings of dynamical paging
*  @type: public
*  @param: filePath - path which will be used for requesting data ( parth from load command used by default )
*  @param: buffer -  count of rows requrested from server by single operation, optional
*  @edition: Professional
*  @topic: 0
*/
dhtmlXGridObject.prototype.setXMLAutoLoading = function(filePath,bufferSize){
	this.xmlFileUrl = filePath;
	this._dpref = bufferSize;
}
/**
*  @desc: change current page in grid
*  @type: public
*  @param: ind - correction ( -1,1,2  etc) to current active page
*  @edition: Professional
*  @topic: 0
*/
dhtmlXGridObject.prototype.changePageRelative = function(ind){ 
	this.changePage(this.currentPage+ind);
}
/**
*  @desc: change current page in grid
*  @type: public
*  @param: pageNum -  new active page
*  @edition: Professional
*  @topic: 0
*/
dhtmlXGridObject.prototype.changePage = function(pageNum){ 
	if (arguments.length==0) pageNum=this.currentPage||0;
	pageNum=parseInt(pageNum);
	pageNum=Math.max(1,Math.min(pageNum,Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize)));
	
	if(!this.callEvent("onBeforePageChanged",[this.currentPage,pageNum]))
		return;
	
	this.currentPage = parseInt(pageNum);
	this._reset_view();
	this._fixAlterCss();			
	this.callEvent("onPageChanged",this.getStateOfView());
}
/**
*  @desc: allows to set custom paging skin
*  @param: name - skin name (default,toolbar,bricks)
*  @type:  public
*/
dhtmlXGridObject.prototype.setPagingSkin = function(name){
	this._pgn_skin=this["_pgn_"+name];
	if (name=="toolbar") this._pgn_skin_tlb=arguments[1];
}
/**
*  @desc: allows to set paging templates for default skin
*  @param: a - template for zone A
*  @param: b - template for zone B
*  @type:  public
*/
dhtmlXGridObject.prototype.setPagingTemplates = function(a,b){
	this._pgn_templateA=this._pgn_template_compile(a);
	this._pgn_templateB=this._pgn_template_compile(b);
	this._page_skin_update();
}
dhtmlXGridObject.prototype._page_skin_update = function(name){
	if (!this.pagesInGroup) this.pagesInGroup=Math.ceil(Math.min(5,this.rowsBuffer.length/this.rowsBufferOutSize));
	var totalPages=Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize);
	if (totalPages && totalPages<this.currentPage)
		return this.changePage(totalPages);
	if (this.pagingOn && this._pgn_skin) this._pgn_skin.apply(this,this.getStateOfView());
}
dhtmlXGridObject.prototype._init_pgn_events = function(name){
	this.attachEvent("onXLE",this._page_skin_update)
	this.attachEvent("onClearAll",this._page_skin_update)
	this.attachEvent("onPageChanged",this._page_skin_update)
	this.attachEvent("onGridReconstructed",this._page_skin_update)
	
	this._init_pgn_events=function(){};
}

// default paging
dhtmlXGridObject.prototype._pgn_default=function(page,start,end){
	if (!this.pagingBlock){
		this.pagingBlock = document.createElement("DIV");
		this.pagingBlock.className = "pagingBlock";
		this.recordInfoBlock = document.createElement("SPAN");
		this.recordInfoBlock.className = "recordsInfoBlock";
		if (!this._pgn_parentObj) return;
		this._pgn_parentObj.appendChild(this.pagingBlock)
		if(this._pgn_recInfoParentObj && this.showRecInfo)
			this._pgn_recInfoParentObj.appendChild(this.recordInfoBlock)
		
		//this._pgn_template="{prev:} {current:-1},{current},{current:+1} {next:>}"
		if (!this._pgn_templateA){
			this._pgn_templateA=this._pgn_template_compile("[prevpages:&lt;:&nbsp;] [currentpages:,&nbsp;] [nextpages:&gt;:&nbsp;]");
			this._pgn_templateB=this._pgn_template_compile("Results <b>[from]-[to]</b> of <b>[total]</b>");
		}
	}
	
	var details=this.getStateOfView();
	this.pagingBlock.innerHTML = this._pgn_templateA.apply(this,details);
	this.recordInfoBlock.innerHTML = this._pgn_templateB.apply(this,details);
	this._pgn_template_active(this.pagingBlock);
	this._pgn_template_active(this.recordInfoBlock);
	
	this.callEvent("onPaging",[]);
}

dhtmlXGridObject.prototype._pgn_block=function(sep){ 
	var start=Math.floor((this.currentPage-1)/this.pagesInGroup)*this.pagesInGroup;
	var max=Math.min(Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize),start+this.pagesInGroup);
	var str=[];
	for (var i=start+1; i<=max; i++)
		if (i==this.currentPage)
		str.push("<a class='dhx_not_active'><b>"+i+"</b></a>");
	else
		str.push("<a onclick='this.grid.changePage("+i+"); return false;'>"+i+"</a>");
	return str.join(sep);
}
dhtmlXGridObject.prototype._pgn_link=function(mode,ac,ds){
	if (mode=="prevpages" || mode=="prev"){
		if (this.currentPage==1) return ds;
		return '<a onclick=\'this.grid.changePageRelative(-1*'+(mode=="prev"?'1':'this.grid.pagesInGroup')+'); return false;\'>'+ac+'</a>'
	}
	
	if (mode=="nextpages" || mode=="next"){
		if (this.rowsBuffer.length/this.rowsBufferOutSize <= this.currentPage ) return ds;
		if (this.rowsBuffer.length/(this.rowsBufferOutSize*(mode=="next"?'1':this.pagesInGroup)) <= 1 ) return ds;
		return '<a onclick=\'this.grid.changePageRelative('+(mode=="next"?'1':'this.grid.pagesInGroup')+'); return false;\'>'+ac+'</a>'
	}
	
	if (mode=="current"){
		var i=this.currentPage+(ac?parseInt(ac):0);
		if (i<1 || Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize) < i ) return ds;
		return '<a '+(i==this.currentPage?"class='dhx_active_page_link' ":"")+'onclick=\'this.grid.changePage('+i+'); return false;\'>'+i+'</a>'
	}
	return ac;
}

dhtmlXGridObject.prototype._pgn_template_active=function(block){
	var tags=block.getElementsByTagName("A");
	if (tags)
	for (var i=0; i < tags.length; i++) {
		tags[i].grid=this;
	};
}
dhtmlXGridObject.prototype._pgn_template_compile=function(template){
	/*
	[prev],[next]
	[currentpages]
	[from],[to],[total]
	*/
	template=template.replace(/\[([^\]]*)\]/g,function(a,b){
			b=b.split(":");
			switch (b[0]){
			case "from": 
				return '"+(arguments[1]*1+(arguments[2]*1?1:0))+"';
			case "total":
				return '"+arguments[3]+"';
			case "to":
				return '"+arguments[2]+"';
			case "current":
			case "prev":
			case "next":
			case "prevpages":
			case "nextpages":
				return '"+this._pgn_link(\''+b[0]+'\',\''+b[1]+'\',\''+b[2]+'\')+"'
			case "currentpages":
				return '"+this._pgn_block(\''+b[1]+'\')+"'
			}
			//do it here
	})
	return new Function('return "'+template+'";')
}

dhtmlXGridObject.prototype.i18n.paging={
	results:"Results",
	records:"Records from ",
	to:" to ",
	page:"Page ",
	perpage:"rows per page",
	first:"To first Page",
	previous:"Previous Page",
	found:"Found records",
	next:"Next Page",
	last:"To last Page",
	of:" of ",
	notfound:"No Records Found"
}
/**
*  @desc: configure paging with toolbar mode ( must be called BEFORE enablePaging)
*  @param: navButtons - enable/disable navigation buttons
*  @param: navLabel - enable/disable navigation label
*  @param: pageSelect - enable/disable page selector
*  @param: perPageSelect - an array of "per page" select options ([5,10,15,20,25,30] by default)
*  @type: public
*  @edition: Professional
*/
dhtmlXGridObject.prototype.setPagingWTMode = function(navButtons,navLabel,pageSelect,perPageSelect){
	this._WTDef=[navButtons,navLabel,pageSelect,perPageSelect];
}
/**
*  @desc: Bricks skin for paging
*/
dhtmlXGridObject.prototype._pgn_bricks = function(page, start, end){
	//set class names depending on grid skin
	var tmp = (this.skin_name||"").split("_")[1];
	var sfx="";
	if(tmp=="light" || tmp=="modern" || tmp=="skyblue")
		sfx = "_"+tmp;
	
	this.pagerElAr = new Array();
	this.pagerElAr["pagerCont"] = document.createElement("DIV");
	this.pagerElAr["pagerBord"] = document.createElement("DIV");
	this.pagerElAr["pagerLine"] = document.createElement("DIV");
	this.pagerElAr["pagerBox"] = document.createElement("DIV");
	this.pagerElAr["pagerInfo"] = document.createElement("DIV");
	this.pagerElAr["pagerInfoBox"] = document.createElement("DIV");
	var se = (this.globalBox||this.objBox);
	this.pagerElAr["pagerCont"].style.width = se.clientWidth+"px";
	this.pagerElAr["pagerCont"].style.overflow = "hidden";
	this.pagerElAr["pagerCont"].style.clear = "both";
	this.pagerElAr["pagerBord"].className = "dhx_pbox"+sfx;
	this.pagerElAr["pagerLine"].className = "dhx_pline"+sfx;
	this.pagerElAr["pagerBox"].style.clear = "both";
	this.pagerElAr["pagerInfo"].className = "dhx_pager_info"+sfx;
	
	//create structure
	this.pagerElAr["pagerCont"].appendChild(this.pagerElAr["pagerBord"]);
	this.pagerElAr["pagerCont"].appendChild(this.pagerElAr["pagerLine"]);
	this.pagerElAr["pagerCont"].appendChild(this.pagerElAr["pagerInfo"]);
	this.pagerElAr["pagerLine"].appendChild(this.pagerElAr["pagerBox"]);
	this.pagerElAr["pagerInfo"].appendChild(this.pagerElAr["pagerInfoBox"]);
	this._pgn_parentObj.innerHTML = "";
	this._pgn_parentObj.appendChild(this.pagerElAr["pagerCont"]);
	
	
	
	
	if(this.rowsBuffer.length>0){
		var lineWidth = 20;
		var lineWidthInc = 22;
		
		//create left arrow if needed
		if(page>this.pagesInGroup){
			var pageCont = document.createElement("DIV");
			var pageBox = document.createElement("DIV");
			pageCont.className = "dhx_page"+sfx;
			pageBox.innerHTML = "&larr;";
			pageCont.appendChild(pageBox);
			this.pagerElAr["pagerBox"].appendChild(pageCont);
			var self = this;
			pageCont.pgnum = (Math.ceil(page/this.pagesInGroup)-1)*this.pagesInGroup;
			pageCont.onclick = function(){
				self.changePage(this.pgnum);
			}
			lineWidth +=lineWidthInc;
		}
		//create pages
		for(var i=1;i<=this.pagesInGroup;i++){
			var pageCont = document.createElement("DIV");
			var pageBox = document.createElement("DIV");
			pageCont.className = "dhx_page"+sfx;
			pageNumber = ((Math.ceil(page/this.pagesInGroup)-1)*this.pagesInGroup)+i;
			if(pageNumber>Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize))
				break;
			pageBox.innerHTML = pageNumber;
			pageCont.appendChild(pageBox);
			if(page==pageNumber){
				pageCont.className += " dhx_page_active"+sfx;
				pageBox.className = "dhx_page_active"+sfx;
			}else{
				var self = this;
				pageCont.pgnum = pageNumber;
				pageCont.onclick = function(){
					self.changePage(this.pgnum);
				}
			}
			lineWidth +=(parseInt(lineWidthInc/3)*pageNumber.toString().length)+15;
			pageBox.style.width = (parseInt(lineWidthInc/3)*pageNumber.toString().length)+8+"px";
			this.pagerElAr["pagerBox"].appendChild(pageCont);
		}
		//create right arrow if needed
		if(Math.ceil(page/this.pagesInGroup)*this.pagesInGroup<Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize)){
			var pageCont = document.createElement("DIV");
			var pageBox = document.createElement("DIV");
			pageCont.className = "dhx_page"+sfx;
			pageBox.innerHTML = "&rarr;";
			pageCont.appendChild(pageBox);
			this.pagerElAr["pagerBox"].appendChild(pageCont);
			var self = this;
			pageCont.pgnum = (Math.ceil(page/this.pagesInGroup)*this.pagesInGroup)+1;
			pageCont.onclick = function(){
				self.changePage(this.pgnum);
			}
			lineWidth +=lineWidthInc;
		}
		
		this.pagerElAr["pagerLine"].style.width = lineWidth+"px";
	}
	
	//create page info
	if(this.rowsBuffer.length>0 && this.showRecInfo)
		this.pagerElAr["pagerInfoBox"].innerHTML = this.i18n.paging.records+(start+1)+this.i18n.paging.to+end+this.i18n.paging.of+this.rowsBuffer.length;
	else if(this.rowsBuffer.length==0){
		this.pagerElAr["pagerLine"].parentNode.removeChild(this.pagerElAr["pagerLine"]);
		this.pagerElAr["pagerInfoBox"].innerHTML = this.i18n.paging.notfound;
	}
	//add whitespaces where necessary
	this.pagerElAr["pagerBox"].appendChild(document.createElement("SPAN")).innerHTML = "&nbsp;";
	this.pagerElAr["pagerBord"].appendChild(document.createElement("SPAN")).innerHTML = "&nbsp;";
	this.pagerElAr["pagerCont"].appendChild(document.createElement("SPAN")).innerHTML = "&nbsp;";
	this.callEvent("onPaging",[]);			
}


/**
*  @desc: web toolbar skin for paging
*/
dhtmlXGridObject.prototype._pgn_toolbar = function(page, start, end){
	if (!this.aToolBar) this.aToolBar = this._pgn_createToolBar();
	var totalPages=Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize);
	
	if (this._WTDef[0]){
		this.aToolBar.enableItem("right");
		this.aToolBar.enableItem("rightabs");
		this.aToolBar.enableItem("left");
		this.aToolBar.enableItem("leftabs");
		if(this.currentPage>=totalPages){
			this.aToolBar.disableItem("right");
			this.aToolBar.disableItem("rightabs");
		}
		if(this.currentPage==1){
			this.aToolBar.disableItem("left");
			this.aToolBar.disableItem("leftabs");
		}
	}
	if (this._WTDef[2]){
		var that = this;
		this.aToolBar.forEachListOption("pages", function(id){
			that.aToolBar.removeListOption("pages", id);
		});
		var w = {dhx_skyblue: 4, dhx_web: 0, dhx_terrace: 14}[this.aToolBar.conf.skin];
		for (var i=0; i<totalPages; i++) {
			this.aToolBar.addListOption("pages", "pages_"+(i+1), NaN, "button", "<span style='padding: 0px "+w+"px 0px 0px;'>"+this.i18n.paging.page+(i+1)+"</span>", "paging_page.gif");
		}
		this.aToolBar.setItemText("pages", this.i18n.paging.page+page);
	}
	// pButton.setSelected(page.toString())
	
	
	if (this._WTDef[1]){
		if (!this.getRowsNum())
			this.aToolBar.setItemText('results',this.i18n.paging.notfound);
		else
			this.aToolBar.setItemText('results',"<div style='width:100%; text-align:center'>"+this.i18n.paging.records+(start+1)+this.i18n.paging.to+end+"</div>");
	}
	if (this._WTDef[3])
		this.aToolBar.setItemText("perpagenum", this.rowsBufferOutSize.toString()+" "+this.i18n.paging.perpage);
	
	this.callEvent("onPaging",[]);
}
dhtmlXGridObject.prototype._pgn_createToolBar = function(){
	this.aToolBar = new dhtmlXToolbarObject({
		parent: this._pgn_parentObj,
		skin: (this._pgn_skin_tlb||this.skin_name),
		icons_path: this.imgURL
	});
	if (!this._WTDef) this.setPagingWTMode(true, true, true, true);
	var self = this;
	this.aToolBar.attachEvent("onClick", function(val){
		val = val.split("_");
		switch (val[0]){
			case "leftabs":
				self.changePage(1);
				break;
			case "left":
				self.changePage(self.currentPage-1);
				break;
			case "rightabs":
				self.changePage(99999);
				break;
			case "right":
				self.changePage(self.currentPage+1);
				break;
			case "perpagenum":
				if (val[1]===this.undefined) return;
				self.rowsBufferOutSize = parseInt(val[1]);
				self.changePage();
				self.aToolBar.setItemText("perpagenum", val[1]+" "+self.i18n.paging.perpage);
				break;
			case "pages":
				if (val[1]===this.undefined) return;
				self.changePage(val[1]);
				self.aToolBar.setItemText("pages", self.i18n.paging.page+val[1]);
				break;
		}
	});
	// add buttons
	if (this._WTDef[0]) {
		this.aToolBar.addButton("leftabs", NaN, null, "ar_left_abs.gif", "ar_left_abs_dis.gif");
		this.aToolBar.addButton("left", NaN, null, "ar_left.gif", "ar_left_dis.gif");
	}
	if (this._WTDef[1]) {
		this.aToolBar.addText("results", NaN, this.i18n.paging.results);
		this.aToolBar.setWidth("results", "150");
		this.aToolBar.disableItem("results");
	}
	if (this._WTDef[0]) {
		this.aToolBar.addButton("right", NaN, null, "ar_right.gif", "ar_right_dis.gif");
		this.aToolBar.addButton("rightabs", NaN, null, "ar_right_abs.gif", "ar_right_abs_dis.gif");
	}
	if (this._WTDef[2]) {
		if (this.aToolBar.conf.skin == "dhx_terrace") this.aToolBar.addSeparator();
		this.aToolBar.addButtonSelect("pages", NaN, "select page", [], "paging_pages.gif", null, false, true);
	}
	var arr;
	if (arr = this._WTDef[3]) {
		if (this.aToolBar.conf.skin == "dhx_terrace") this.aToolBar.addSeparator();
		this.aToolBar.addButtonSelect("perpagenum", NaN, "select size", [], "paging_rows.gif", null, false, true);
		if (typeof arr != "object") arr = [5,10,15,20,25,30];
		var w = {dhx_skyblue: 4, dhx_web: 0, dhx_terrace: 18}[this.aToolBar.conf.skin];
		for (var k=0; k<arr.length; k++) {
			this.aToolBar.addListOption("perpagenum", "perpagenum_"+arr[k], NaN, "button", "<span style='padding: 0px "+w+"px 0px 0px;'>"+arr[k]+" "+this.i18n.paging.perpage+"</span>", "paging_page.gif");
		}
	}
	
	//var td = document.createElement("TD"); td.width = "5"; this.aToolBar.tr.appendChild(td);
	//var td = document.createElement("TD"); td.width = "100%"; this.aToolBar.tr.appendChild(td);
	
	return this.aToolBar;
}

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

	dhtmlXGridObject.prototype.post = function(url, post, call, type){
		this.callEvent("onXLS", [this]);
		if (arguments.length == 2 && typeof call != "function"){
			type=call;
			call=null;
		}
		type=type||"xml";
	
		if (!this.xmlFileUrl)
			this.xmlFileUrl=url;
		this._data_type=type;

		this.xmlLoader = this.doLoadDetails;

		var that = this;
		this.xmlLoader = function(xml){
			if (!that.callEvent) return;
			that["_process_"+type](xml.xmlDoc);
			if (!that._contextCallTimer)
				that.callEvent("onXLE", [that,0,0,xml.xmlDoc]);
	
			if (call){
				call();
				call=null;
			}
		};
		dhx4.ajax.post(url, (post||""), this.xmlLoader);
	}

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: set rowspan with specified length starting from specified cell
*   @param: rowID - row Id
*	@param: colInd - column index
*	@param: length - length of rowspan
*	@edition: professional
*   @type:  public
*/
dhtmlXGridObject.prototype.setRowspan=function(rowID,colInd,length){
    var c=this[this._bfs_cells?"_bfs_cells":"cells"](rowID,colInd).cell;    
   var r=this.rowsAr[rowID];

   if (c.rowSpan && c.rowSpan!=1){
		var ur=r.nextSibling;   
		for (var i=1; i<c.rowSpan; i++){
			var tc=ur.childNodes[ur._childIndexes[c._cellIndex+1]]
			var ti=document.createElement("TD"); 
			ti.innerHTML="&nbsp;"; 
			ti._cellIndex=c._cellIndex;
			ti._clearCell=true;
			if (tc)
				tc.parentNode.insertBefore(ti,tc);
			else
				ur.parentNode.appendChild(ti);
			this._shiftIndexes(ur,c._cellIndex,-1);
	    	ur=ur.nextSibling;
	    }
    }

    c.rowSpan=length;
    if (!this._h2)
		r=r.nextSibling||this.rowsCol[this.rowsCol._dhx_find(r)+1];
	else
		r=this.rowsAr[ this._h2.get[r.idd].parent.childs[this._h2.get[r.idd].index+1].id ];
		
	var kids=[];
	for (var i=1; i<length; i++){
	    var ct=null;
		if (this._fake && !this._realfake)
		    ct=this._bfs_cells3(r,colInd).cell;
		else
		    ct=this.cells3(r,colInd).cell;
		
		

		this._shiftIndexes(r,c._cellIndex,1);
		if (ct)
    	ct.parentNode.removeChild(ct);
    	kids.push(r);
    	
    	if (!this._h2)
			r=r.nextSibling||this.rowsCol[this.rowsCol._dhx_find(r)+1];
		else { 
			var r=this._h2.get[r.idd].parent.childs[this._h2.get[r.idd].index+1];
			if (r) r=this.rowsAr[ r.id ];
		}
    }
    
    this.rowsAr[rowID]._rowSpan=this.rowsAr[rowID]._rowSpan||{};
    this.rowsAr[rowID]._rowSpan[colInd]=kids;
    if (this._fake && !this._realfake && colInd<this._fake._cCount) 
        this._fake.setRowspan(rowID,colInd,length)
}


dhtmlXGridObject.prototype._shiftIndexes=function(r,pos,ind){
		if (!r._childIndexes){
    	r._childIndexes=new Array();
        for (var z=0; z<r.childNodes.length; z++)
            r._childIndexes[z]=z;
		}
		
		for (var z=0; z<r._childIndexes.length; z++)
			if (z>pos)
            	r._childIndexes[z]=r._childIndexes[z]-ind;
				
}

/**
*   @desc: enable rowspan in grid
*   @type:  public
*	@edition: professional
*/
dhtmlXGridObject.prototype.enableRowspan=function(){
    this._erspan=true;
	this.enableRowspan=function(){};
	this.attachEvent("onAfterSorting",function(){
		if (this._dload) return; //can't be helped
		for (var i=1; i<this.obj.rows.length; i++)	
		  if (this.obj.rows[i]._rowSpan){
		  	var master=this.obj.rows[i];
		  	for (var kname in master._rowSpan){
			  	var row=master;
				var kids=row._rowSpan[kname];
			  	for (var j=0; j < kids.length; j++) {
			  		if(row.nextSibling)
			  			row.parentNode.insertBefore(kids[j],row.nextSibling);
			  		else 
			  			row.parentNode.appendChild(kids[j]);
			  		if (this._fake){ // split mode
			  		    var frow=this._fake.rowsAr[row.idd];
			  		    var fkid=this._fake.rowsAr[kids[j].idd];
			  		    if(frow.nextSibling)
			  		  	    frow.parentNode.insertBefore(fkid,frow.nextSibling);
			  		    else 
			  			  frow.parentNode.appendChild(fkid);
			  			 this._correctRowHeight(row.idd);
			  		}
			 		row=row.nextSibling;
			  	}
		    }
	  }
	  var t = this.rowsCol.stablesort;
	  this.rowsCol=new dhtmlxArray();
	  this.rowsCol.stablesort=t;
	  
	  for (var i=1; i<this.obj.rows.length; i++)	
	  	this.rowsCol.push(this.obj.rows[i]);
	  
	}) 
	
	this.attachEvent("onXLE",function(a,b,c,xml){
		for (var i=0; i<this.rowsBuffer.length; i++){
			var row = this.render_row(i);
			var childs = row.childNodes;
			for (var j=0; j<childs.length; j++){
				if (childs[j]._attrs["rowspan"]){
					this.setRowspan(row.idd, childs[j]._cellIndex, childs[j]._attrs["rowspan"]);
				}
			}
		}
	});
}


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*
    Limitation:
        a) Width of column in px
        b) Grid not autoresizable
        c) Initialize grid in visible state
*/

dhx4.attachEvent("onGridCreated", function(grid){
    if (grid._split_later)
        grid.splitAt(grid._split_later);
});


/**
*   @desc:  split grid in two parts, with separate scrolling
*   @param:  ind - index of column to split after
*   @edition: Professional
*   @type:  public$
*/
dhtmlXGridObject.prototype.splitAt=function(ind){
    if (!this.obj.rows[0]) return this._split_later=ind;
    ind=parseInt(ind);
    
    var leftBox=document.createElement("DIV");
    this.entBox.appendChild(leftBox);
    var rightBox=document.createElement("DIV");
    this.entBox.appendChild(rightBox);
    
    for (var i=this.entBox.childNodes.length-3; i>=0; i--)
    	rightBox.insertBefore(this.entBox.childNodes[i],rightBox.firstChild);
    
    this.entBox.style.position="relative";	
    this.globalBox=this.entBox;
    this.entBox=rightBox; rightBox.grid=this;
    

    leftBox.style.cssText+="border:0px solid red !important;";
    rightBox.style.cssText+="border:0px solid red !important;";
    
	rightBox.style.top="0px";
    rightBox.style.position="absolute";
        
    leftBox.style.position="absolute";
    leftBox.style.top="0px";
    leftBox.style.left="0px";
    leftBox.style.zIndex=11;
        
    rightBox.style.height=leftBox.style.height=this.globalBox.clientHeight;
    
    
    this._fake=new dhtmlXGridObject(leftBox);
    
    this.globalBox=this._fake.globalBox=this.globalBox;
    this._fake._fake=this;
    this._fake._realfake=true;
    
	//copy properties    
    this._treeC=this.cellType._dhx_find("tree");
    this._fake.delim=this.delim;
    this._fake.customGroupFormat=this.customGroupFormat;
    
    this._fake.setImagesPath(this._imgURL);
    this._fake.iconURL = this.iconURL;
    this._fake._customSorts=this._customSorts;
	this._fake.noHeader=this.noHeader;
	this._fake._enbTts=this._enbTts;
	this._fake._drsclmW = this._drsclmW;
	this._fake._htkebl = this._htkebl;
	this._fake.clists = this.clists;
    this._fake.fldSort=new Array();
    this._fake.selMultiRows=this.selMultiRows;
    this._fake.multiLine=this.multiLine;
    this._fake._key_events = this._key_events;
    this._fake.smartTabOrder = this.smartTabOrder;
    this._fake._RaSeCol = this._RaSeCol;
   
    if (this.multiLine || this._erspan){
    	this.attachEvent("onCellChanged",this._correctRowHeight);
    	this.attachEvent("onRowAdded",this._correctRowHeight);
    	var corrector=function(){
    		this.forEachRow(function(id){
    			this._correctRowHeight(id);
			})
		};
		this.attachEvent("onPageChanged",corrector);
    	this.attachEvent("onXLE",corrector);
    	this.attachEvent("onResizeEnd",corrector);
    	if (!this._ads_count) //in case of distribute parsing - use special event instead
    		this.attachEvent("onAfterSorting",corrector);
        if (this._srnd)
            this.attachEvent("onFilterEnd", corrector);
    	this.attachEvent("onDistributedEnd",corrector);
		
    	//this._fake.attachEvent("onCellChanged",this._correctRowHeight);
    	}
    this.attachEvent("onGridReconstructed",function(){
    	this._fake.objBox.scrollTop = this.objBox.scrollTop;
	})
    
	this._fake.loadedKidsHash=this.loadedKidsHash;
	if (this._h2) this._fake._h2=this._h2;
	this._fake._dInc=this._dInc;
	
	//collect grid configuraton
    var b_ha=[[],[],[],[],[],[],[]];
    var b_ar=["hdrLabels","initCellWidth","cellType","cellAlign","cellVAlign","fldSort","columnColor"];
    var b_fu=["setHeader","setInitWidths","setColTypes","setColAlign","setColVAlign","setColSorting","setColumnColor"];

    this._fake.callEvent=function(){
    	var result = true;
    	this._fake._split_event=true;
    	var hidden = (arguments[0] == "onScroll");
    	if (arguments[0]=="onGridReconstructed" || hidden)
    		this._fake.callEvent.apply(this,arguments);
    	
    	if (!hidden) result = this._fake.callEvent.apply(this._fake,arguments);
    	this._fake._split_event=false;	
    	return result;
    }
    	
    if (this._elmn)
		this._fake.enableLightMouseNavigation(true);

    if (this._cssEven||this._cssUnEven)
        this._fake.attachEvent("onGridReconstructed",function(){
            this._fixAlterCss();
        });

	this._fake._cssSP=this._cssSP;
	this._fake.isEditable=this.isEditable;
	this._fake._edtc=this._edtc;
	if (this._sst) this._fake.enableStableSorting(true);

	this._fake._sclE=this._sclE;
	this._fake._dclE=this._dclE;
	this._fake._f2kE=this._f2kE;
	this._fake._maskArr=this._maskArr;
	this._fake._dtmask=this._dtmask;
	this._fake.combos=this.combos;

    var width=0;

	var m_w=this.globalBox.offsetWidth;
    for (var i=0; i<ind; i++){
        for (var j=0; j<b_ar.length; j++){
            if (this[b_ar[j]])
                b_ha[j][i]=this[b_ar[j]][i];
            if (typeof b_ha[j][i] == "string") b_ha[j][i]=b_ha[j][i].replace(new RegExp("\\"+this.delim,"g"),"\\"+this.delim);
        }
        if (_isFF) b_ha[1][i]=b_ha[1][i]*1;
		if ( this.cellWidthType == "%"){
			b_ha[1][i]=Math.round(parseInt(this[b_ar[1]][i])*m_w/100);
			width+=b_ha[1][i];
		} else
	        width+=parseInt(this[b_ar[1]][i]);
        	this.setColumnHidden(i,true);
        }


    for (var j=0; j<b_ar.length; j++){
        var str=b_ha[j].join(this.delim);
       
	if (b_fu[j]!="setHeader"){
		if (str!="")
    		this._fake[b_fu[j]](str);
	} else
	    this._fake[b_fu[j]](str,null,this._hstyles);
    }


	this._fake._strangeParams=this._strangeParams;
    this._fake._drsclmn=this._drsclmn;

	width = Math.min(this.globalBox.offsetWidth, width);
    rightBox.style.left=width+"px";    leftBox.style.width=width+"px";
    rightBox.style.width=Math.max(this.globalBox.offsetWidth-width,0);

    if (this._ecspn) this._fake._ecspn=true;

//    this._fake.setNoHeader(true);
    this._fake.init();
    if (this.dragAndDropOff)
		this.dragger.addDragLanding(this._fake.entBox, this);
		
    this._fake.objBox.style.overflow="hidden";
    if (!dhtmlx.$customScroll)
    	this._fake.objBox.style.overflowX="scroll";
	else    
		this._fake.objBox._custom_scroll_mode = "";

   	this._fake._srdh=this._srdh||20;
   	this._fake._srnd=this._srnd;
	this._fake._cssEven=this._cssEven;
	this._fake._cssUnEven=this._cssUnEven;
	if (this.skin_name != this._fake.skin_name)
		this._fake.setSkin(this.skin_name);

   	var selfmaster = this;
	function _on_wheel(e){
		var cont = selfmaster.objBox;
		if (cont.scrollHeight - cont.offsetHeight > 2){
			var dir  = e.wheelDelta/-40;
			if (e.wheelDelta === window.undefined)
				dir = e.detail;
			cont.scrollTop += dir*40;
			
			if (e.preventDefault)
				e.preventDefault();
		}
	}
	dhtmlxEvent(this._fake.objBox,"mousewheel",_on_wheel);
	dhtmlxEvent(this._fake.objBox,"DOMMouseScroll",_on_wheel);


//inner methods

	
		function change_td(a,b){ 
			b.style.whiteSpace="";
			var c=b.nextSibling;
			var cp=b.parentNode;
			a.parentNode.insertBefore(b,a);
			if (!c)
				cp.appendChild(a);
			else
				cp.insertBefore(a,c);
			var z=a.style.display;
			a.style.display=b.style.display;
			b.style.display=z;
				}
		function proc_hf(i,rows,mode,frows){
			var temp_header=(new Array(ind)).join(this.delim);
			var temp_rspan=[];
			if (i==2)
				for (var k=0; k<ind; k++){
					var r=rows[i-1].cells[rows[i-1]._childIndexes?rows[i-1]._childIndexes[k]:k];
					if (r.rowSpan && r.rowSpan>1){
						temp_rspan[r._cellIndex]=r.rowSpan-1;
						frows[i-1].cells[frows[i-1]._childIndexes?frows[i-1]._childIndexes[k]:k].rowSpan=r.rowSpan;
						r.rowSpan=1;
					}
				}
				
				for (i; i<rows.length; i++){
					this._fake.attachHeader(temp_header,null,mode);
					frows=frows||this._fake.ftr.childNodes[0].rows;
					var max_ind=ind;
					var r_cor=0;
					for (var j=0; j<max_ind; j++){
						
						if (temp_rspan[j]) { 
							temp_rspan[j]=temp_rspan[j]-1;
							if (_isIE || _isOpera) {
								var td=document.createElement("TD");
								if (_isFF) td.style.display="none";
								rows[i].insertBefore(td,rows[i].cells[0])
							}
							
							r_cor++;
							continue;
						}

						var a=frows[i].cells[j-r_cor];
						var b=rows[i].cells[j-(_isIE?0:r_cor)];
						var t=b.rowSpan;
						
						change_td(a,b);
						if (t>1){ 
							temp_rspan[j]=t-1;
							b.rowSpan=t;
						}
						if (frows[i].cells[j].colSpan>1){
							rows[i].cells[j].colSpan=frows[i].cells[j].colSpan;
							max_ind-=frows[i].cells[j].colSpan-1;
							for (var k=1; k < frows[i].cells[j].colSpan; k++) 
								frows[i].removeChild(frows[i].cells[j+1]);
				}
		}
	}
		}
		
		if (this.hdr.rows.length>2)
			proc_hf.call(this,2,this.hdr.rows,"_aHead",this._fake.hdr.rows);
		if (this.ftr){
			proc_hf.call(this,1,this.ftr.childNodes[0].rows,"_aFoot");
			this._fake.ftr.parentNode.style.bottom=(_isFF?2:1)+"px";
		}
		

        if (this.saveSizeToCookie){
		   this.saveSizeToCookie=function(name,cookie_param){
		   		if (this._realfake)
					return this._fake.saveSizeToCookie.apply(this._fake,arguments);

				if (!name) name=this.entBox.id;
				var z=new Array();
				var n="cellWidthPX";
		
				for (var i=0; i<this[n].length; i++)
					if (i<ind)
						z[i]=this._fake[n][i];
					else
						z[i]=this[n][i];
				z=z.join(",")
				this.setCookie(name,cookie_param,0,z);
				var z=(this.initCellWidth||(new  Array)).join(",");
				this.setCookie(name,cookie_param,1,z);

			    return true;
			}
		this.loadSizeFromCookie=function(name){
			if (!name) name=this.entBox.id;
			var z=this._getCookie(name,1);

			if (!z) return
			this.initCellWidth=z.split(",");
			var z=this._getCookie(name,0);
			var n="cellWidthPX";
			this.cellWidthType="px";
			
            var summ2=0;
			if ((z)&&(z.length)){
				z=z.split(",");
				for (var i=0; i<z.length; i++)
					if (i<ind){
					   this._fake[n][i]=z[i];
					   summ2+=z[i]*1;
					   }
					else
					   this[n][i]=z[i];
			}

    		this._fake.entBox.style.width=summ2+"px";
    		this._fake.objBox.style.width=summ2+"px";
   			var pa=this.globalBox.childNodes[1];
			    pa.style.left=summ2-(_isFF?0:0)+"px";
			if (this.ftr)
	    		this.ftr.style.left=summ2-(_isFF?0:0)+"px";
    			pa.style.width=this.globalBox.offsetWidth-summ2+"px";

			this.setSizes();
		    return true;
		}
		   	this._fake.onRSE=this.onRSE;
		}


			this.setCellTextStyleA=this.setCellTextStyle;
			this.setCellTextStyle=function(row_id,i,styleString){
				if  (i<ind) this._fake.setCellTextStyle(row_id,i,styleString);
				this.setCellTextStyleA(row_id,i,styleString);
			}
			this.setRowTextBoldA=this.setRowTextBold;
   			this.setRowTextBold = function(row_id){
				this.setRowTextBoldA(row_id);
				this._fake.setRowTextBold(row_id);
            }
            
            this.setRowColorA=this.setRowColor;
   			this.setRowColor = function(row_id,color){
				this.setRowColorA(row_id,color);
				this._fake.setRowColor(row_id,color);
            } 
                       
			this.setRowHiddenA=this.setRowHidden;
   			this.setRowHidden = function(id,state){
				this.setRowHiddenA(id,state);
				this._fake.setRowHidden(id,state);
            }

			this.setRowTextNormalA=this.setRowTextNormal;
   			this.setRowTextNormal = function(row_id){
				this.setRowTextNormalA(row_id);
				this._fake.setRowTextNormal(row_id);
            }


			this.getChangedRows = function(and_added){
				var res = new Array();
				function test(row){
						for (var j = 0; j < row.childNodes.length; j++) 
							if (row.childNodes[j].wasChanged)
								return res[res.length]=row.idd;
				}
				this.forEachRow(function(id){
					var row = this.rowsAr[id];
					var frow = this._fake.rowsAr[id];
					if (row.tagName!="TR" || !frow || frow.tagName!="TR") return;
					if (and_added && row._added)
						res[res.length]=row.idd;
					else{
						if (!test(row)) test(frow);
					}
				});
				return res.join(this.delim);
			};
			this.setRowTextStyleA=this.setRowTextStyle;
   			this.setRowTextStyle = function(row_id,styleString){
				this.setRowTextStyleA(row_id,styleString);
				if (this._fake.rowsAr[row_id])
				this._fake.setRowTextStyle(row_id,styleString);
            }

			this.lockRowA = this.lockRow;
			this.lockRow = function(id,mode){ this.lockRowA(id,mode); this._fake.lockRow(id,mode); }
			
			this.getColWidth = function(i){
				if  (i<ind) return parseInt(this._fake.cellWidthPX[i]);
				else return parseInt(this.cellWidthPX[i]);
            };
            this.getColumnLabel = function(i){
            	return this._fake.getColumnLabel.apply(((i<ind)?this._fake:this) ,arguments);
            };
			this.setColWidthA=this._fake.setColWidthA=this.setColWidth;
			this.setColWidth = function(i,value){
				i=i*1;
				if  (i<ind) this._fake.setColWidthA(i,value);
				else this.setColWidthA(i,value);
				if ((i+1)<=ind) this._fake._correctSplit(Math.min(this._fake.objBox.offsetWidth,this._fake.obj.offsetWidth));
            }
			this.adjustColumnSizeA=this.adjustColumnSize;
			this.setColumnLabelA=this.setColumnLabel;
			this.setColumnLabel=function(a,b,c,d){
				var that  = this;
				if (a<ind) that = this._fake;
				return this.setColumnLabelA.apply(that,[a,b,c,d]);
			}
			this.adjustColumnSize=function(aind,c){
				if  (aind<ind) {
					if (_isIE) this._fake.obj.style.tableLayout="";
					this._fake.adjustColumnSize(aind,c);
					if (_isIE) this._fake.obj.style.tableLayout="fixed";
				    this._fake._correctSplit();
					}
				else return this.adjustColumnSizeA(aind,c);
			}

            var zname="cells";
            this._bfs_cells=this[zname];
            this[zname]=function(){
                    if (arguments[1]<ind){
                        return this._fake.cells.apply(this._fake,arguments);
                    } else
                        return this._bfs_cells.apply(this,arguments);
                    }
            
            this._bfs_isColumnHidden=this.isColumnHidden;        
            this.isColumnHidden=function(){
				if (parseInt(arguments[0])<ind)
					return this._fake.isColumnHidden.apply(this._fake,arguments);
				else
					return this._bfs_isColumnHidden.apply(this,arguments);
            }                    


            this._bfs_setColumnHidden=this.setColumnHidden;        
            this.setColumnHidden=function(){
                    if (parseInt(arguments[0])<ind){
                        this._fake.setColumnHidden.apply(this._fake,arguments);
                        return this._fake._correctSplit();
            		}
                    else
                        return this._bfs_setColumnHidden.apply(this,arguments);
                    }                    

            var zname="cells2";
            this._bfs_cells2=this[zname];
            this[zname]=function(){
                    if (arguments[1]<ind)
                        return this._fake.cells2.apply(this._fake,arguments);
                    else
                        return this._bfs_cells2.apply(this,arguments);
                    }

            var zname="cells3";
            this._bfs_cells3=this[zname];
            this[zname]=function(a,b){
                    if (arguments[1]<ind && this._fake.rowsAr[arguments[0].idd]){
                        //fall back for totally rowspanned row
                        if (this._fake.rowsAr[a.idd] && this._fake.rowsAr[a.idd].childNodes.length==0)  return this._bfs_cells3.apply(this,arguments);
                        arguments[0]=arguments[0].idd;
                        return this._fake.cells.apply(this._fake,arguments);
                        }
                    else
                        return this._bfs_cells3.apply(this,arguments);
                    }

            var zname="changeRowId";
            this._bfs_changeRowId=this[zname];
            this[zname]=function(){
                this._bfs_changeRowId.apply(this,arguments);
                if (this._fake.rowsAr[arguments[0]])
                	this._fake.changeRowId.apply(this._fake,arguments);
            }
            this._fake.getRowById=function(id){
            	var row = this.rowsAr[id];
            	if (!row && this._fake.rowsAr[id]) row=this._fake.getRowById(id);
				
			
				if (row){
					if (row.tagName != "TR"){
						for (var i = 0; i < this.rowsBuffer.length; i++)
							if (this.rowsBuffer[i] && this.rowsBuffer[i].idd == id)
								return this.render_row(i);
						if (this._h2) return this.render_row(null,row.idd);
					}
					return row;
				}
				return null;
			}

            if (this.collapseKids){
				//tree grid
	            this._fake["_bfs_collapseKids"]=this.collapseKids;
				this._fake["collapseKids"]=function(){
					return this._fake["collapseKids"].apply(this._fake,[this._fake.rowsAr[arguments[0].idd]]);
				}
				
	            this["_bfs_collapseKids"]=this.collapseKids;
				this["collapseKids"]=function(){
					var z=this["_bfs_collapseKids"].apply(this,arguments);
					this._fake._h2syncModel();
					if (!this._cssSP) this._fake._fixAlterCss();
				}				
				
				
	            this._fake["_bfs_expandKids"]=this.expandKids;
				this._fake["expandKids"]=function(){
					this._fake["expandKids"].apply(this._fake,[this._fake.rowsAr[arguments[0].idd]]);
					if (!this._cssSP) this._fake._fixAlterCss();
				}
				

				this["_bfs_expandAll"]=this.expandAll;
				this["expandAll"]=function(){
					this._bfs_expandAll();
					this._fake._h2syncModel();
					if (!this._cssSP) this._fake._fixAlterCss();
				}

				this["_bfs_collapseAll"]=this.collapseAll;
				this["collapseAll"]=function(){
					this._bfs_collapseAll();
					this._fake._h2syncModel();
					if (!this._cssSP) this._fake._fixAlterCss();
				}								
				
	            this["_bfs_expandKids"]=this.expandKids;
				this["expandKids"]=function(){
					var z=this["_bfs_expandKids"].apply(this,arguments);
					this._fake._h2syncModel();
					if (!this._cssSP) this._fake._fixAlterCss();
				}				
				
				this._fake._h2syncModel=function(){
					if (this._fake.pagingOn) this._fake._renderSort();
					else this._renderSort();
				}
				this._updateTGRState=function(a){
					return this._fake._updateTGRState(a);
				}
			}



				//split


      if (this._elmnh){
			this._setRowHoverA=this._fake._setRowHoverA=this._setRowHover;
			this._unsetRowHoverA=this._fake._unsetRowHoverA=this._unsetRowHover;
			this._setRowHover=this._fake._setRowHover=function(){
				var that=this.grid;
				that._setRowHoverA.apply(this,arguments);
				var z=(_isIE?event.srcElement:arguments[0].target);
				z=that._fake.rowsAr[that.getFirstParentOfType(z,'TD').parentNode.idd];
				if (z){
					that._fake._setRowHoverA.apply(that._fake.obj,[{target:z.childNodes[0]},arguments[1]]);
				   	}
			};
			this._unsetRowHover=this._fake._unsetRowHover=function(){
				if (arguments[1]) var that=this;
				else	var that=this.grid;
				that._unsetRowHoverA.apply(this,arguments);
				that._fake._unsetRowHoverA.apply(that._fake.obj,arguments);
			};
		  		this._fake.enableRowsHover(true,this._hvrCss);
		  		this.enableRowsHover(false);
		  		this.enableRowsHover(true,this._fake._hvrCss);
			}

			this._updateTGRState=function(z){ 
				if (!z.update || z.id==0) return;
				if (this.rowsAr[z.id].imgTag)
					this.rowsAr[z.id].imgTag.src=this.iconTree+z.state+".gif";
				if (this._fake.rowsAr[z.id] && this._fake.rowsAr[z.id].imgTag)
					this._fake.rowsAr[z.id].imgTag.src=this.iconTree+z.state+".gif";
				z.update=false;
			}
			this.copy_row=function(row){
				    var x=row.cloneNode(true);
                    x._skipInsert=row._skipInsert;
                    var r_ind=ind;
                    x._attrs={};
                    x._css = row._css;
                    
                    if (this._ecspn){
                    	r_ind=0;
                    	for (var i=0; (r_ind<x.childNodes.length && i<ind); i+=(x.childNodes[r_ind].colSpan||1))
                    		r_ind++;
                    }
                                
                    while (x.childNodes.length>r_ind)
                        x.removeChild(x.childNodes[x.childNodes.length-1]);
                        var zm=r_ind;
                    for (var i=0; i<zm; i++){
                    	
						if (this.dragAndDropOff)
							this.dragger.addDraggableItem(x.childNodes[i], this);                        
                        x.childNodes[i].style.display=(this._fake._hrrar?(this._fake._hrrar[i]?"none":""):"");
                        x.childNodes[i]._cellIndex=i;
                        //TODO - more universal solution
                        x.childNodes[i].combo_value=arguments[0].childNodes[i].combo_value;
                        x.childNodes[i]._clearCell=arguments[0].childNodes[i]._clearCell;
                        x.childNodes[i]._cellType=arguments[0].childNodes[i]._cellType;
						x.childNodes[i]._brval=arguments[0].childNodes[i]._brval;
						x.childNodes[i].val =arguments[0].childNodes[i].val;
						x.childNodes[i]._combo =arguments[0].childNodes[i]._combo;
						x.childNodes[i]._attrs=arguments[0].childNodes[i]._attrs;
						x.childNodes[i].chstate=arguments[0].childNodes[i].chstate;
						if (row._attrs['style']) x.childNodes[i].style.cssText = row._attrs['style']+";"+x.childNodes[i].style.cssText;
						

						if(x.childNodes[i].colSpan>1) 
							x._childIndexes = arguments[0]._childIndexes;
					}
                    
                    if (this._h2 && this._treeC < ind){
						var trow=this._h2.get[arguments[0].idd];
                		x.imgTag=x.childNodes[this._treeC].childNodes[0].childNodes[trow.level];
						x.valTag=x.childNodes[this._treeC].childNodes[0].childNodes[trow.level+2];
                        }

					
                        x.idd=row.idd;
                        x.grid=this._fake;
                        
                	return x;
                        	}
                    	
            var zname="_insertRowAt";
            this._bfs_insertRowAt=this[zname];
            this[zname]=function(){ 
                        var r=this["_bfs_insertRowAt"].apply(this,arguments);
                        arguments[0]=this.copy_row(arguments[0]);

                        var r2=this._fake["_insertRowAt"].apply(this._fake,arguments);
                        if (r._fhd){
							r2.parentNode.removeChild(r2);
                            this._fake.rowsCol._dhx_removeAt(this._fake.rowsCol._dhx_find(r2));
							r._fhd=false;
						}

						return r;
            }
            /*
var quirks = (_isIE && document.compatMode=="BackCompat");
		
		var isVScroll = this.parentGrid?false:(this.objBox.scrollHeight > this.objBox.offsetHeight);
		var isHScroll = this.parentGrid?false:(this.objBox.scrollWidth > this.objBox.offsetWidth); 
		var scrfix = _isFF?20:18;
		
		var outerBorder=(this.entBox.offsetWidth-this.entBox.clientWidth)/2;
				
		var gridWidth=this.entBox.clientWidth;
		var gridHeight=this.entBox.clientHeight;
		*/
            this._bfs_setSizes=this.setSizes;
            this.setSizes=function(){
            		if (this._notresize) return;
                	this._bfs_setSizes(this,arguments);
                	
					this.sync_headers()
					if (this.sync_scroll() && this._ahgr) this.setSizes(); //if scrolls was removed - check once more to correct auto-height
					
					var height = this.dontSetSizes ? (this.entBox.offsetHeight+"px") : this.entBox.style.height;
					this._fake.entBox.style.height = height;

                    this._fake.objBox.style.height=this.objBox.style.height;
                    this._fake.hdrBox.style.height=this.hdrBox.style.height;
                    
                    this._fake.objBox.scrollTop=this.objBox.scrollTop;
                    
                    this._fake.setColumnSizes(this._fake.entBox.clientWidth);
                    
                    this.globalBox.style.width=parseInt(this.entBox.style.width)+parseInt(this._fake.entBox.style.width);
                    if (!this.dontSetSizes)
                    	this.globalBox.style.height = height;
                    
            }
            
            this.sync_scroll=this._fake.sync_scroll=function(end){
            		var old=this.objBox.style.overflowX;
            	    if (this.obj.offsetWidth<=this.objBox.offsetWidth)
                    {
                    	if (!end) return this._fake.sync_scroll(true);
                        this.objBox.style.overflowX="hidden";
                        this._fake.objBox.style.overflowX="hidden";
                    }
                    else if (!dhtmlx.$customScroll){
                        this.objBox.style.overflowX="scroll";
                        this._fake.objBox.style.overflowX="scroll";
                    }
                    return old!=this.objBox.style.overflowX;
        	}
            this.sync_headers=this._fake.sync_headers=function(){
            	if (this.noHeader || (this._fake.hdr.scrollHeight==this.hdr.offsetHeight) || this.noHeaderResize) return;
            //	if (this.hdr.rows.length!=2){
            		for (var i=1; i<this.hdr.rows.length; i++){
            			var td = ind;
            			while (!this.hdr.rows[i].childNodes[td]) td--;
            			var ha=Math.min(this.hdr.rows[i].childNodes[td].scrollHeight+2, this.hdr.rows[i].scrollHeight);
						var hb=this._fake.hdr.rows[i].scrollHeight;
						if (ha!=hb)
							this._fake.hdr.rows[i].style.height=this.hdr.rows[i].style.height=Math.max(ha,hb)+"px";
						if (window._KHTMLrv) {
							var lindex = 0;
							while (this._fake._hrrar[lindex]) lindex++;
							this._fake.hdr.rows[i].childNodes[lindex].style.height=this.hdr.rows[i].childNodes[td].style.height=Math.max(ha,hb)+"px";
						}
					}
					this._fake.sync_headers;
			//	} else this._fake.hdr.style.height=this.hdr.offsetHeight+"px";
        	}
        	this._fake._bfs_setSizes=this._fake.setSizes;
            this._fake.setSizes=function(){
            		if (this._fake._notresize) return;
            		this._fake.setSizes();
            }

            var zname="_doOnScroll";
            this._bfs__doOnScroll=this[zname];
            this[zname]=function(){
                    this._bfs__doOnScroll.apply(this,arguments);
                    this._fake.objBox.scrollTop=this.objBox.scrollTop;
                    this._fake["_doOnScroll"].apply(this._fake,arguments);
            }
            
            var zname="selectAll";
            this._bfs__selectAll=this[zname];
            this[zname]=function(){
                    this._bfs__selectAll.apply(this,arguments);
                    this._bfs__selectAll.apply(this._fake,arguments);
            }
            
            



            var zname="doClick";
            this._bfs_doClick=this[zname];
            this[zname]=function(){
                    this["_bfs_doClick"].apply(this,arguments);
                        if (arguments[0].tagName=="TD"){
                            var fl=(arguments[0]._cellIndex>=ind);
							if (!arguments[0].parentNode.idd) return;
							if (!fl)
                            	arguments[0].className=arguments[0].className.replace(/cellselected/g,"");
                            //item selected but it left part not rendered yet
							if (!this._fake.rowsAr[arguments[0].parentNode.idd])
								this._fake.render_row(this.getRowIndex(arguments[0].parentNode.idd));
                            arguments[0]=this._fake.cells(arguments[0].parentNode.idd,(fl?0:arguments[0]._cellIndex)).cell;
                            if (fl) this._fake.cell=null;
                            this._fake["_bfs_doClick"].apply(this._fake,arguments);
                            if (fl) this._fake.cell=this.cell;
                            else this.cell=this._fake.cell;
                            if (this._fake.onRowSelectTime) clearTimeout(this._fake.onRowSelectTime)
                            if (fl) {
                                arguments[0].className=arguments[0].className.replace(/cellselected/g,"");
                                globalActiveDHTMLGridObject=this;
                                this._fake.cell=this.cell;                                
                                }
                            else{
                                this.objBox.scrollTop=this._fake.objBox.scrollTop;
	                            }
                        }
            }
            this._fake._bfs_doClick=this._fake[zname];
            this._fake[zname]=function(){
                    this["_bfs_doClick"].apply(this,arguments);
                        if (arguments[0].tagName=="TD"){
                            var fl=(arguments[0]._cellIndex<ind);
							if (!arguments[0].parentNode.idd) return;
                            arguments[0]=this._fake._bfs_cells(arguments[0].parentNode.idd,(fl?ind:arguments[0]._cellIndex)).cell;
                            this._fake.cell=null;
this._fake["_bfs_doClick"].apply(this._fake,arguments);
							this._fake.cell=this.cell;
                            if (this._fake.onRowSelectTime) clearTimeout(this._fake.onRowSelectTime)
                            if (fl) {
                                arguments[0].className=arguments[0].className.replace(/cellselected/g,"");
                                globalActiveDHTMLGridObject=this;
								this._fake.cell=this.cell;                                
								this._fake.objBox.scrollTop=this.objBox.scrollTop;
                                }
                        }
            }


this.clearSelectionA = this.clearSelection;
this.clearSelection = function(mode){
    if (mode) this._fake.clearSelection();
    this.clearSelectionA();
}


this.moveRowUpA = this.moveRowUp;
this.moveRowUp = function(row_id){
	if (!this._h2)
    	this._fake.moveRowUp(row_id);
    this.moveRowUpA(row_id);
    if (this._h2) this._fake._h2syncModel();
}
this.moveRowDownA = this.moveRowDown;
this.moveRowDown = function(row_id){
	if (!this._h2)
    	this._fake.moveRowDown(row_id);
    this.moveRowDownA(row_id);
    if (this._h2) this._fake._h2syncModel();
}



this._fake.getUserData=function(){	return this._fake.getUserData.apply(this._fake,arguments); }
this._fake.setUserData=function(){	return this._fake.setUserData.apply(this._fake,arguments); }

this.getSortingStateA=this.getSortingState;
this.getSortingState = function(){
	var z=this.getSortingStateA();
	if (z.length!=0) return z;
	return this._fake.getSortingState();
}

this.setSortImgStateA=this._fake.setSortImgStateA=this.setSortImgState;
this.setSortImgState = function(a,b,c,d){
	this.setSortImgStateA(a,b,c,d);
	if (b*1<ind) {
		this._fake.setSortImgStateA(a,b,c,d);
		this.setSortImgStateA(false);
	} else 
		this._fake.setSortImgStateA(false);
}


this._fake.doColResizeA = this._fake.doColResize;
this._fake.doColResize = function(ev,el,startW,x,tabW){ 
    var a=-1;
    var z=0;
    if (arguments[1]._cellIndex==(ind-1)){
            a = this._initalSplR + (ev.clientX-x);
            if (!this._initalSplF) this._initalSplF=arguments[3]+this.objBox.scrollWidth-this.objBox.offsetWidth;
            if (this.objBox.scrollWidth==this.objBox.offsetWidth && (this._fake.alter_split_resize || (ev.clientX-x)>0 )){
            	arguments[3]=(this._initalSplF||arguments[3]);
            	z=this.doColResizeA.apply(this,arguments);
            } 
            else
            	z=this.doColResizeA.apply(this,arguments);
    }
    else{
        if (this.obj.offsetWidth<this.entBox.offsetWidth)
    		a=this.obj.offsetWidth;
    	z=this.doColResizeA.apply(this,arguments);
	}
	
	if (z !== false){
		this._correctSplit(a);
		this.resized=this._fake.resized=1;
	}
    return z;
}

		this._fake.changeCursorState = function(ev){
                     var el = ev.target||ev.srcElement;
                     if(el.tagName!="TD")
                           el = this.getFirstParentOfType(el,"TD")
                           if ((el.tagName=="TD")&&(this._drsclmn)&&(!this._drsclmn[el._cellIndex])) return;
                           var check = (ev.layerX||0)+(((!_isIE)&&(ev.target.tagName=="DIV"))?el.offsetLeft:0);
                           var pos = parseInt(this.getPosition(el,this.hdrBox)); 
                           
                           if(((el.offsetWidth - (ev.offsetX||(pos-check)*-1))<(_isOpera?20:10))||((this.entBox.offsetWidth - (ev.offsetX?(ev.offsetX+el.offsetLeft):check) + this.objBox.scrollLeft - 0)<(_isOpera?20:10))){
                              el.style.cursor = "E-resize";
                           }else
                              el.style.cursor = "default";
                       if (_isOpera) this.hdrBox.scrollLeft = this.objBox.scrollLeft;
                        }
			
		this._fake.startColResizeA = this._fake.startColResize;
		this._fake.startColResize = function(ev){
                                    var z=this.startColResizeA(ev);
                                    this._initalSplR=this.entBox.offsetWidth;
                                    this._initalSplF=null;
                                    if (this.entBox.onmousemove){
                                        var m=this.entBox.parentNode;   
                                        if (m._aggrid) return z;
										m._aggrid=m.grid;   m.grid=this;
                                        this.entBox.parentNode.onmousemove=this.entBox.onmousemove;
                                        this.entBox.onmousemove=null;
                                        }
                                    return z;
								}

		this._fake.stopColResizeA = this._fake.stopColResize;
		this._fake.stopColResize = function(ev){
                                    if (this.entBox.parentNode.onmousemove){
                                        var m=this.entBox.parentNode;   m.grid=m._aggrid;   m._aggrid=null;
                                        this.entBox.onmousemove=this.entBox.parentNode.onmousemove;
                                        this.entBox.parentNode.onmousemove=null;
                                        if (this.obj.offsetWidth<this.entBox.offsetWidth)
                                        	this._correctSplit(this.obj.offsetWidth);
                                        }
                                    return this.stopColResizeA(ev);
								}



this.doKeyA = this.doKey;
this._fake.doKeyA = this._fake.doKey;

function inner_runner(index, rindex, master, ev){
	var dir = ev.shiftKey ? -1 : 1;
	var end = ev.shiftKey ? -1 : master._cCount;
	var next = false;

	for (var i=index+dir; i!=end; i+=dir){
		if (master.smartTabOrder){
			next = master.cells2(rindex, i).isDisabled() ? false : i;
		} else 
			next = i;

		if (next !== false){
			var editmode = !master._key_events.k_other;
			master.selectCell( rindex, next, false, false, editmode, true);
			ev.cancelBubble = true;
			if (ev.preventDefault) ev.preventDefault();
			return true;
		}
	}
}

this._fake.doKey=this.doKey=function(ev){
                            if (!ev) return true;
                            if (this._htkebl) return true;
		if ((ev.target||ev.srcElement).value !== window.undefined){
			var zx = (ev.target||ev.srcElement);

			if ((!zx.parentNode)||(zx.parentNode.className.indexOf("editable") == -1))
				return true;
		}
		                            
    switch (ev.keyCode){
        case 9:
        	var master = this._realfake ? this._fake : this;
        	if (!master.callEvent("onTab",[true])) return true;

                    if (this.cell){
        		var index = this.cell._cellIndex;
							
				var rindex = master.getRowIndex(this.cell.parentNode.idd);
				while (!inner_runner(index, rindex, master, ev)){
					rindex += (ev.shiftKey ? -1 : 1);
					if (rindex < 0 || rindex >= master.rowsBuffer.length) return;
					index = ev.shiftKey ? master._cCount : -1;					
                }
				return;
            }
       break;
    }
    return  this.doKeyA(ev);
}


this.editCellA=this.editCell;
this.editCell=function(){
	if (this.cell && this.cell.parentNode.grid != this) return this._fake.editCell();
	return this.editCellA();
}

this.deleteRowA = this.deleteRow;
this.deleteRow=function(row_id,node){
/*	if (!this._realfake)
		this._fake.loadedKidsHash=this.loadedKidsHash;*/

    if (this.deleteRowA(row_id,node)===false) return false;
    if (this._fake.rowsAr[row_id])
    	this._fake.deleteRow(row_id);
}

this.clearAllA = this.clearAll;
this.clearAll=function(){
    this.clearAllA();
    this._fake.clearAll();
}
this.editStopA = this.editStop;
this.editStop=function(mode){
	if (this._fake.editor)
		this._fake.editStop(mode);
	else 
    	this.editStopA(mode);
};


this.attachEvent("onAfterSorting",function(i,b,c){
	if (i>=ind) 
		this._fake.setSortImgState(false)
});



this._fake.sortField = function(a,b,c){ 
	this._fake.sortField.call(this._fake,a,b,this._fake.hdr.rows[0].cells[a]);
	if (this.fldSort[a]!="na" && this._fake.fldSorted){
		var mem = this._fake.getSortingState()[1];
		this._fake.setSortImgState(false);
		this.setSortImgState(true,arguments[0],mem)
	}
}

this.sortTreeRowsA = this.sortTreeRows;
this._fake.sortTreeRowsA = this._fake.sortTreeRows;
this.sortTreeRows=this._fake.sortTreeRows=function(col,type,order,ar){
    if (this._realfake) return this._fake.sortTreeRows(col,type,order,ar)

    this.sortTreeRowsA(col,type,order,ar);
    this._fake._h2syncModel();

                this._fake.setSortImgStateA(false);
	this._fake.fldSorted=null;
    }

/* SRND mode */
this._fake._fillers=[];
this._fake.rowsBuffer=this.rowsBuffer;
this.attachEvent("onClearAll",function(){
	this._fake.rowsBuffer=this.rowsBuffer;	
})
this._add_filler_s=this._add_filler;
this._add_filler=function(a,b,c,e){
	if (!this._fake._fillers) this._fake._fillers=[];
	if (this._realfake || !e){
		var d;
		if (c && c.idd) d=this._fake.rowsAr[c.idd];
		else if (c && c.nextSibling) {
			d = {};
			d.nextSibling=this._fake.rowsAr[c.nextSibling.idd];
			d.parentNode=d.nextSibling.parentNode;
		} else if (this._fake._fillers.length){
			d = this._fake._fillers[this._fake._fillers.length-1][2];
		}
		this._fake._fillers.push(this._fake._add_filler(a,b,d));	
	}
	
	return this._add_filler_s.apply(this,arguments);
}
this._add_from_buffer_s=this._add_from_buffer;
this._add_from_buffer=function() { 
	var res=this._add_from_buffer_s.apply(this,arguments);
	if (res!=-1){
		this._fake._add_from_buffer.apply(this._fake,arguments);
		if (this.multiLine) this._correctRowHeight(this.rowsBuffer[arguments[0]].idd);
	}
	return res;
    }
this._fake.render_row=function(ind){
	var row=this._fake.render_row(ind);

	if (row == -1) return -1;
	if (row) {
		return this.rowsAr[row.idd]=this.rowsAr[row.idd]||this._fake.copy_row(row);
    }
	return null;
        }
this._reset_view_s=this._reset_view;
this._reset_view=function(){
	this._fake._reset_view(true);
	this._fake._fillers=[];
	this._reset_view_s();
    }

this.moveColumn_s=this.moveColumn;
this.moveColumn=function(a,b){
	if (b>=ind) return this.moveColumn_s(a,b);
}

    
this.attachEvent("onCellChanged",function(id,i,val){
	if (this._split_event && i<ind && this.rowsAr[id]){
		
		var cell=this._fake.rowsAr[id];
		if (!cell) return;
		if (cell._childIndexes)
			cell=cell.childNodes[cell._childIndexes[i]];
		else
			cell=cell.childNodes[i];
		var tcell = this.rowsAr[id].childNodes[i];
	
		if (tcell._treeCell && tcell.firstChild.lastChild)
			tcell.firstChild.lastChild.innerHTML = val;
		else
			tcell.innerHTML=cell.innerHTML;
		tcell._clearCell=false;
		tcell.combo_value = cell.combo_value;
		tcell.chstate=cell.chstate;	//TODO - more universal solution
	}
})





    this._fake.combos=this.combos;
	this.setSizes();
	if (this.rowsBuffer[0]) this._reset_view();
	this.attachEvent("onXLE",function(){this._fake._correctSplit()})
	this._fake._correctSplit();
}

dhtmlXGridObject.prototype._correctSplit=function(a){ 
    a=a||(this.obj.scrollWidth-this.objBox.scrollLeft);
    a=Math.min(this.globalBox.offsetWidth, a);
    if (a>-1){
	    this.entBox.style.width=a+"px";
	    this.objBox.style.width=a+"px";
	
		var outerBorder=(this.globalBox.offsetWidth-this.globalBox.clientWidth)/2;
	    this._fake.entBox.style.left=a+"px";
	    this._fake.entBox.style.width=Math.max(0,this.globalBox.offsetWidth-a-(this.quirks?0:2)*outerBorder)+"px";
	    if (this._fake.ftr)
	    	this._fake.ftr.parentNode.style.width=this._fake.entBox.style.width;
	    if (_isIE){
		    var quirks=_isIE && !window.xmlHttpRequest;
			var outerBorder=(this.globalBox.offsetWidth-this.globalBox.clientWidth);
			this._fake.hdrBox.style.width=this._fake.objBox.style.width=Math.max(0,this.globalBox.offsetWidth-(quirks?outerBorder:0)-a)+"px";
		}
	}
}

dhtmlXGridObject.prototype._correctRowHeight=function(id,ind){
	if (!this.rowsAr[id] || !this._fake.rowsAr[id]) return;

	var h=parseInt(this.rowsAr[id].style.height) || this.rowsAr[id].offsetHeight;
	var h2=parseInt(this._fake.rowsAr[id].style.height) || this._fake.rowsAr[id].offsetHeight;
	var max = Math.max(h,h2) - (this.rowsAr[id].delta_fix || 0);
	if (!max) return;
	this.rowsAr[id].style.height=this._fake.rowsAr[id].style.height=Math.round(max+1)+"px";
	this.rowsAr[id].delta_fix = 1;
	if (window._KHTMLrv) {
		var j = this._fake._cCount;
		var td;
		while (!td && j>=0){
			td = this.rowsAr[id].childNodes[j];
			j-=1;
		}
		var td2 = this._fake.rowsAr[id].firstChild;
		if (td && td2){
			td.style.height=td2.style.height=max+"px";
		}
	}
}
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: enable automatic size saving to cookie
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableAutoSizeSaving = function(name,cookie_param){
		this.attachEvent("onResizeEnd",function(){ this.saveSizeToCookie(name,cookie_param) });
}

/**
*   @desc: store opene state of TreeGrid in cookie
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.saveOpenStates = function(name,cookie_param){
	if (!name) name=this.entBox.id;
	var t=[];
	this._h2.forEachChild(0,function(el){
		if (el.state=="minus") t.push(el.id);
	});
	var str = "gridOpen"+(name||"") + "=" + t.join("|") +  (cookie_param?("; "+cookie_param):"");
	document.cookie = str;
}


/**
*   @desc: load open state of TreeGrid in cookie
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.loadOpenStates = function(name,cookie_param){
	var val=this.getCookie(name,"gridOpen");
	if (!val) return;
	val=val.split("|");
	for (var i = 0; i < val.length; i++) {
		var pid = this.getParentId(val[i]);
		if (!this.getOpenState(pid)) continue;
		this.openItem(val[i]);
	}
}

/**
*   @desc: enable automatic saving column state ( hidden | shown )
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableAutoHiddenColumnsSaving = function(name,cookie_param){
		this.attachEvent("onColumnHidden",function(){ 
				this.saveHiddenColumnsToCookie(name,cookie_param); 
		});
}

/**
*   @desc: enable automatic sorting state saving to cookie
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableSortingSaving = function(name,cookie_param){
	this.attachEvent("onBeforeSorting",function(){ 
		var that=this;
		window.setTimeout(function(){
			that.saveSortingToCookie(name,cookie_param);
			},1);
		return true;
		});	
}

/**
*   @desc: enable automatic column order saving to cookie
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableOrderSaving = function(name,cookie_param){
	this.attachEvent("onAfterCMove",function(){ 
		this.saveOrderToCookie(name,cookie_param);  
		this.saveSizeToCookie(name,cookie_param);
	});
}

/**
*   @desc: enable automatic saving of all possible params
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableAutoSaving = function(name,cookie_param){
		this.enableOrderSaving(name,cookie_param);
		this.enableAutoSizeSaving(name,cookie_param);
		this.enableSortingSaving(name,cookie_param);
}


/**   @desc: save grid layout to cookie
*     @type: public
*     @param: name - optional, cookie name
*     @param: cookie_param - additional parameters added to cookie
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.saveSizeToCookie=function(name,cookie_param){
	if (this.cellWidthType=='px')
		var z=this.cellWidthPX;
	else
		var z=this.cellWidthPC;

	var z2=(this.initCellWidth||[]).join(",");

	if (this._hrrar)
		for (var i = 0; i < this._hrrar.length; i++)
			if (this._hrrar[i]) z[i] = "";
		
	this.setCookie(name,cookie_param,0,z.join(","));
	this.setCookie(name,cookie_param,1,z2);
}

/**   @desc: save hidden columns to cookie
*     @type: public
*     @param: name - optional, cookie name
*     @param: cookie_param - additional parameters added to cookie
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.saveHiddenColumnsToCookie=function(name,cookie_param){

    var hs=[].concat(this._hrrar||[]);
    if (this._fake && this._fake._hrrar)
        for (var i=0; i < this._fake._cCount; i++)
            hs[i]=this._fake._hrrar[i]?"1":"";
	this.setCookie(name,cookie_param,4,hs.join(",").replace(/display:none;/g,"1"));
}

/**   @desc: load sorting order from cookie
*     @type: public
*     @param: name - optional,cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.loadHiddenColumnsFromCookie=function(name){
	var z=this._getCookie(name,4);
	var ar=(z||"").split(",");
	for (var i=0; i < this._cCount; i++) 
		this.setColumnHidden(i,(ar[i]?true:false));
}



/**   @desc: save sorting order to cookie
*     @type: public
*     @param: name - optional, cookie name
*     @param: cookie_param - additional parameters added to cookie
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.saveSortingToCookie=function(name,cookie_param){
	this.setCookie(name,cookie_param,2,(this.getSortingState()||[]).join(","));
}


/**   @desc: load sorting order from cookie
*     @type: public
*     @param: name - optional,cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.loadSortingFromCookie=function(name){
	var z=this._getCookie(name,2);
	z=(z||"").split(",");
	if (z.length>1 && z[0]<this._cCount){
		this.sortRows(z[0],null,z[1]);
		this.setSortImgState(true,z[0],z[1]);
	}
}



/**   @desc: save sorting order to cookie
*     @type: public
*     @param: name - optional, cookie name
*     @param: cookie_param - additional parameters added to cookie
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.saveOrderToCookie=function(name,cookie_param){
	if (!this._c_order) {
		this._c_order=[];
		var l=this._cCount;
		for (var i=0; i<l; i++)
			this._c_order[i]=i;
	}
	this.setCookie(name,cookie_param,3,((this._c_order||[]).slice(0,this._cCount)).join(","));
	this.saveSortingToCookie(name, cookie_param);
}


/**   @desc: load sorting order from cookie
*     @type: public
*     @param: name - optional,cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.loadOrderFromCookie=function(name){
	var z=this._getCookie(name,3);
	z=(z||"").split(",");
	if (z.length>1 && z.length<=this._cCount){
			//code below probably may be optimized
			for (var i=0; i<z.length; i++)
				if ((!this._c_order && z[i]!=i)||(this._c_order && z[i]!=this._c_order[i])){
					var t=z[i];
					if (this._c_order)
						for (var j=0; j<this._c_order.length; j++) {
							if (this._c_order[j]==z[i]) {
								t=j; break;
								}
						}
					this.moveColumn(t*1,i);
				}
	}
}


/**   @desc: load grid layout from cookie
*     @type: public
*     @param: name - optional,cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.loadSizeFromCookie=function(name){ 
	var z=this._getCookie(name,1);
	if (z)
		this.initCellWidth=z.split(",");
	var z=this._getCookie(name,0);
	if ((z)&&(z.length)){
		z = z.split(",");

		if (!this._fake && this._hrrar) 
			for (var i=0; i<z.length; i++) 
				if (this._hrrar[i]) z[i]=0;

		if (this.cellWidthType=='px')
			this.cellWidthPX=z;
		else
			this.cellWidthPC=z;
		}

	for (var i=0; i<z.length; i++)
		if (z[i] === ""){
			z[i] = this.initCellWidth[i];
			this.setColumnHidden(i, true);
		}

	this.setSizes();
    return true;
}

/**   @desc: clear cookie with grid config details
*     @type: public
*     @param: name - optional,cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.clearConfigCookie=function(name){
	if (!name) name=this.entBox.id;
	var str = "gridSettings"+name + "=||||";
	document.cookie = str;
}
dhtmlXGridObject.prototype.clearSizeCookie=dhtmlXGridObject.prototype.clearConfigCookie;


/**   @desc: save cookie
*     @type: private
*     @param: name - cookie name
*     @param: value - cookie value
*     @param: cookie_param - additional parameters added to cookie
*     @edition: Professional
*     @topic: 0
*/

dhtmlXGridObject.prototype.setCookie=function(name,cookie_param,pos,value) {
	if (!name) name=this.entBox.id;
	var t=this.getCookie(name);
	t=(t||"||||").split("|");
	t[pos]=value;
	var str = "gridSettings"+name + "=" + t.join("|").replace(/,/g,"-") +  (cookie_param?("; "+cookie_param):"");
//	console.log("save",str)
	document.cookie = str;
}

/**   @desc: get cookie
*     @type: private
*     @param: name - cookie name
*     @edition: Professional
*     @topic: 0
*/
dhtmlXGridObject.prototype.getCookie=function(name,surname) { 
	if (!name) name=this.entBox.id;
	name=(surname||"gridSettings")+name;
	var search = name + "=";
	if (document.cookie.length > 0) {
		var offset = document.cookie.indexOf(search);
		if (offset != -1) {
			offset += search.length;
			var end = document.cookie.indexOf(";", offset);
			if (end == -1)
				end = document.cookie.length;
			return document.cookie.substring(offset, end);
						}		}
};
dhtmlXGridObject.prototype._getCookie=function(name,pos) {
//	console.log("get",this.getCookie(name))
	return ((this.getCookie(name)||"||||").replace(/-/g,",").split("|"))[pos];
}
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*	@desc: enable Undo/Redo functionality in grid
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.enableUndoRedo = function()
{ 
	var self = this;
	var func = function() {return self._onEditUndoRedo.apply(self,arguments);}
	this.attachEvent("onEditCell", func);
	var func2 = function(a,b,c) {return self._onEditUndoRedo.apply(self,[2,a,b,(c?1:0),(c?0:1)]);}		
	this.attachEvent("onCheckbox", func2);
	this._IsUndoRedoEnabled = true;
	this._UndoRedoData = [];
	this._UndoRedoPos = -1;
}
/**
*	@desc: disable Undo/Redo functionality in grid
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.disableUndoRedo = function()
{
	this._IsUndoRedoEnabled = false;
	this._UndoRedoData = [];
	this._UndoRedoPos = -1;
}

dhtmlXGridObject.prototype._onEditUndoRedo = function(stage, row_id, cell_index, new_value, old_value)
{
	if (this._IsUndoRedoEnabled && stage == 2 && old_value != new_value) {
	    if (this._UndoRedoPos !== -1 && this._UndoRedoPos != ( this._UndoRedoData.length-1 ) ) {
	        this._UndoRedoData = this._UndoRedoData.slice(0, this._UndoRedoPos+1);
	    } else if (this._UndoRedoPos === -1 && this._UndoRedoData.length > 0) {
	        this._UndoRedoData = [];
	    }

	    var obj = { old_value:old_value,
	                new_value:new_value,
	                row_id:row_id,
	                cell_index:cell_index
	    };
	    this._UndoRedoData.push(obj);
	    this._UndoRedoPos++;
	}
	return true;
}
/**
*	@desc: UnDo
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.doUndo = function()
{
	if (this._UndoRedoPos === -1)
		return false;
	var obj = this._UndoRedoData[this._UndoRedoPos--];
	var c=this.cells(obj.row_id, obj.cell_index);
	if (this.getColType(obj.cell_index)=="tree")
		c.setLabel(obj.old_value);
	else
		c.setValue(obj.old_value);

	this.callEvent("onUndo", [obj.row_id]);
}
/**
*	@desc: ReDo
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.doRedo = function()
{
	if (this._UndoRedoPos == this._UndoRedoData.length-1)
		return false;
	var obj = this._UndoRedoData[++this._UndoRedoPos];
	this.cells(obj.row_id, obj.cell_index).setValue(obj.new_value);

	this.callEvent("onUndo", [obj.row_id]);
}
/**
*	@desc: get length of available ReDo operations
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.getRedo = function()
{
	if (this._UndoRedoPos == this._UndoRedoData.length-1)
		return [];
	return this._UndoRedoData.slice(this._UndoRedoPos+1);
}
/**
*	@desc: get length of available UnDo operations
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.getUndo = function()
{
	if (this._UndoRedoPos == -1)
		return [];
	return this._UndoRedoData.slice(0, this._UndoRedoPos+1);
}
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype.enableAccessKeyMap = function(){
/*
	keymap like MS Access offers
*/
this._select_ifpossible=function(){
	if (this.editor && this.editor.obj && this.editor.obj.select) this.editor.obj.select();
};
this._key_events={
			//ctrl-enter
			k13_1_0:function(){
				this.editStop();
			},
			//shift-enter
			k13_0_1:function(){
				this._key_events.k9_0_1.call(this);
			},
			//enter
			k13_0_0:function(){
				this._key_events.k9_0_0.call(this);
            },
            //tab
            k9_0_0:function(){
					this.editStop();
				if (!this.callEvent("onTab",[true])) return true;
				var z=this._getNextCell(null,1);
				if (z) {
					if (this.pagingOn) this.showRow(z.parentNode.idd);
					this.selectCell(z.parentNode,z._cellIndex,(this.row!=z.parentNode),false,true);
					this._still_active=true;
				}
				this._select_ifpossible();
            },
            //shift-tab
			k9_0_1:function(){
				this.editStop();
				if (!this.callEvent("onTab",[false])) return true;
				var z=this._getNextCell(null,-1);
				if (z) {
					this.selectCell(z.parentNode,z._cellIndex,(this.row!=z.parentNode),false,true);
					this._still_active=true;
				}
				this._select_ifpossible();
            },
            //f2 key
            k113_0_0:function(){
            	if (this._f2kE) this.editCell();
            },
            //space
            k32_0_0:function(){
            	var c=this.cells4(this.cell);
            	if (!c.changeState || (c.changeState()===false)) return false;
            },
            //escape
            k27_0_0:function(){
            	this.editStop(true);
            },
            //pageUp
            k33_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage-1);
            	else this.scrollPage(-1);            		
	        },
	        //pageDown
			k34_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage+1);
            	else this.scrollPage(1);
	        },
	        //left
			k37_0_0:function(){
				if (this.editor) return false;
            	if(this.isTreeGrid())
            		this.collapseKids(this.row);
            	else this._key_events.k9_0_1.call(this);
	        },
	        //right
			k39_0_0:function(){
				if (this.editor) return false;
				if(!this.editor && this.isTreeGrid())
            		this.expandKids(this.row);
            	else this._key_events.k9_0_0.call(this);
            },
            //ctrl left
			k37_1_0:function(){
				if (this.editor) return false;
				this.selectCell(this.row,0,false,false,true);
				this._select_ifpossible();
	        },
	        //ctrl right
			k39_1_0:function(){
				if (this.editor) return false;
				this.selectCell(this.row,this._cCount-1,false,false,true);
				this._select_ifpossible();
            },
            //ctrl up
			k38_1_0:function(){
			
				this.selectCell(this.rowsCol[0],this.cell._cellIndex,true,false,true);
				this._select_ifpossible();
	        },
	        //ctrl down
			k40_1_0:function(){
				this.selectCell(this.rowsCol[this.rowsCol.length-1],this.cell._cellIndex,true,false,true);
				this._select_ifpossible();
            },
            //shift up
			k38_0_1:function(){
				var rowInd = this.getRowIndex(this.row.idd);
				var nrow=this._nextRow(rowInd,-1);
				if (!nrow || nrow._sRow || nrow._rLoad) return false;
                this.selectCell(nrow,this.cell._cellIndex,true,false,true);
				this._select_ifpossible();
	        },
	        //shift down
			k40_0_1:function(){
				var rowInd = this.getRowIndex(this.row.idd);
				var nrow=this._nextRow(rowInd,1);
				if (!nrow || nrow._sRow || nrow._rLoad) return false;
                this.selectCell(nrow,this.cell._cellIndex,true,false,true);
                this._select_ifpossible();
            },   
            //ctrl shift up  
			k38_1_1:function(){
				var rowInd = this.getRowIndex(this.row.idd);
				for (var i = rowInd; i >= 0; i--){
					this.selectCell(this.rowsCol[i],this.cell._cellIndex,true,false,true);
				}
	        },
	        //ctrl shift down
			k40_1_1:function(){
				var rowInd = this.getRowIndex(this.row.idd);
				for (var i = rowInd+1; i <this.rowsCol.length; i++){
					this.selectCell(this.rowsCol[i],this.cell._cellIndex,true,false,true);
				}
            },    
            //down               
			k40_0_0:function(){
				if (this.editor && this.editor.combo)
					this.editor.shiftNext();
				else{
					if (!this.row.idd) return;
					var rowInd = rowInd=this.getRowIndex(this.row.idd)+1;
					if (this.rowsBuffer[rowInd]){
						var nrow=this._nextRow(rowInd-1,1);
						if (this.pagingOn && nrow) this.showRow(nrow.idd);
						this._Opera_stop=0;
                        this.selectCell(nrow,this.cell._cellIndex,true,false,true);
                    }
                    else {
                    	if (!this.callEvent("onLastRow", [])) return false;
                    	this._key_events.k34_0_0.apply(this,[]);
                	}
				}
				this._still_active=true;								
            },
            //home
            k36_0_0:function(){ 
            	return this._key_events.k37_1_0.call(this);
            },
            //end
            k35_0_0:function(){ 
            	return this._key_events.k39_1_0.call(this);
            },            
            //ctrl-home
            k36_1_0:function(){ 
            	if (this.editor || !this.rowsCol.length) return false;
				this.selectCell(this.rowsCol[0],0,true,false,true);
				this._select_ifpossible();
            },
            //ctrl-end
            k35_1_0:function(){ 
            	if (this.editor || !this.rowsCol.length) return false;
				this.selectCell(this.rowsCol[this.rowsCol.length-1],this._cCount-1,true,false,true);
				this._select_ifpossible();
            },  
            //padeup
            k33_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage-1);
            	else this.scrollPage(-1);            		
	        },
	        //pagedown
			k34_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage+1);
            	else this.scrollPage(1);
	        },  
	        //up                                
			k38_0_0:function(){
				if (this.editor && this.editor.combo)
					this.editor.shiftPrev();
				else{
				
					if (!this.row.idd) return;
					var rowInd = rowInd=this.getRowIndex(this.row.idd)+1;
					if (rowInd!=-1){
						var nrow=this._nextRow(rowInd-1,-1);
                        this._Opera_stop=0;
                        if (this.pagingOn && nrow) this.showRow(nrow.idd);
                        this.selectCell(nrow,this.cell._cellIndex,true,false,true);
                    }
					else this._key_events.k33_0_0.apply(this,[]);
				}
				this._still_active=true;
            }
		};

};
dhtmlXGridObject.prototype.enableExcelKeyMap = function(){
/*
	keymap like MS Excel offers
*/
this._key_events={
			k13_1_0:function(){
				this.editStop();
			},
			k13_0_1:function(){
				this.editStop();
				this._key_events.k38_0_0.call(this);
			},
			k13_0_0:function(){
				this.editStop();
				this.callEvent("onEnter",[(this.row?this.row.idd:null),(this.cell?this.cell._cellIndex:null)]);
				this._still_active=true;
				this._key_events.k40_0_0.call(this);
            },
            k9_0_0:function(){
				this.editStop();
				if (!this.callEvent("onTab",[true])) return true;
				if (this.cell && (this.cell._cellIndex+1)>=this._cCount) return;
				var z=this._getNextCell(null,1);
				if (z && this.row==z.parentNode){
					this.selectCell(z.parentNode,z._cellIndex,true);
					this._still_active=true;
				}
			},
			k9_0_1:function(){
				this.editStop();
				if (!this.callEvent("onTab",[false])) return true;
				if (this.cell && (this.cell._cellIndex==0)) return;
				var z=this._getNextCell(null,-1);
				if (z && this.row==z.parentNode) {
					this.selectCell(z.parentNode,z._cellIndex,true);
					this._still_active=true;
				}
            },
            k113_0_0:function(){
            	if (this._f2kE) this.editCell();
            },
            k32_0_0:function(){
            	var c=this.cells4(this.cell);
            	if (!c.changeState || (c.changeState()===false)) return false;
            },
            k27_0_0:function(){
            	this.editStop(true);
            	this._still_active=true;
            },
            k33_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage-1);
            	else this.scrollPage(-1);            		
	        },
			k34_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage+1);
            	else this.scrollPage(1);
	        },
			k37_0_0:function(){
				if (this.editor) return false;
            	if(this.isTreeGrid())
            		this.collapseKids(this.row);
            	else this._key_events.k9_0_1.call(this);
	        },
			k39_0_0:function(){
				if (this.editor) return false;
				if(!this.editor && this.isTreeGrid())
            		this.expandKids(this.row);
            	else this._key_events.k9_0_0.call(this);
            },
			k37_1_0:function(){
				if (this.editor) return false;
				this.selectCell(this.row,0,true);
	        },
			k39_1_0:function(){
				if (this.editor) return false;
				this.selectCell(this.row,this._cCount-1,true);
            }, 
			k38_1_0:function(){
				if (this.editor || !this.rowsCol.length) return false;
				this.selectCell(this.rowsCol[0],this.cell._cellIndex,true);
	        },
			k40_1_0:function(){
				if (this.editor || !this.rowsCol.length) return false;
				this.selectCell(this.rowsCol[this.rowsCol.length-1],this.cell._cellIndex,true);
            },
			k38_0_1:function(){
				if (this.editor || !this.rowsCol.length) return false;
				var rowInd = this.row.rowIndex;
				var nrow=this._nextRow(rowInd-1,-1);
				if (!nrow || nrow._sRow || nrow._rLoad) return false;
                this.selectCell(nrow,this.cell._cellIndex,true,true);
	        },
			k40_0_1:function(){
				if (this.editor || !this.rowsCol.length) return false;
				var rowInd = this.row.rowIndex;
				var nrow=this._nextRow(rowInd-1,1);
				if (!nrow || nrow._sRow || nrow._rLoad) return false;
                this.selectCell(nrow,this.cell._cellIndex,true,true);
            },     
			k38_1_1:function(){
				if (this.editor || !this.rowsCol.length) return false;
				var rowInd = this.row.rowIndex;
				for (var i = rowInd - 1; i >= 0; i--){
					this.selectCell(this.rowsCol[i],this.cell._cellIndex,true,true);
				}
	        },
			k40_1_1:function(){
				if (this.editor || !this.rowsCol.length) return false;
				var rowInd = this.row.rowIndex;
				for (var i = rowInd; i <this.rowsCol.length; i++){
					this.selectCell(this.rowsCol[i],this.cell._cellIndex,true,true);
				}
            },                   
			k40_0_0:function(){
				var master = this._realfake?this._fake:this;
				if (this.editor && this.editor.combo)
					this.editor.shiftNext();
				else{
					if (this.editor) return false;
					var rowInd = Math.max((master._r_select||0),this.getRowIndex(this.row.idd));
					var row = this._nextRow(rowInd, 1);

					if (row){
						master._r_select=null;
						this.selectCell(row, this.cell._cellIndex, true);
						if (master.pagingOn) master.showRow(row.idd);
					} else {
                    	if (!this.callEvent("onLastRow", [])) return false;
                    	this._key_events.k34_0_0.apply(this,[]);
                	}
				}
            },
            k36_0_0:function(){ //home
            	return this._key_events.k37_1_0.call(this);
            },
            k35_0_0:function(){ //ctrl-home
            	return this._key_events.k39_1_0.call(this);
            },            
            k36_1_0:function(){ //home
            	if (this.editor || !this.rowsCol.length) return false;
				this.selectCell(this.rowsCol[0],0,true);
            },
            k35_1_0:function(){ //ctrl-end
            	if (this.editor || !this.rowsCol.length) return false;
				this.selectCell(this.rowsCol[this.rowsCol.length-1],this._cCount-1,true);
            },  
            k33_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage-1);
            	else this.scrollPage(-1);            		
	        },
			k34_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage+1);
            	else this.scrollPage(1);
	        },                                  
			k38_0_0:function(){	
				var master = this._realfake?this._fake:this;
				if (this.editor && this.editor.combo)
					this.editor.shiftPrev();
				else{
					if (this.editor) return false;
					if (!this.row.idd) return;
					var rowInd = this.getRowIndex(this.row.idd)+1;
					if (rowInd != -1 && (!this.pagingOn || (rowInd!=1))){
						var nrow = this._nextRow(rowInd-1, -1);
						this.selectCell(nrow, this.cell._cellIndex, true);
						if (master.pagingOn && nrow) master.showRow(nrow.idd);
					} else {
						this._key_events.k33_0_0.apply(this,[]);
					}
				}
            },
            k_other:function(ev){ 
            	if (this.editor) return false;
            	if (!ev.ctrlKey && ev.keyCode>=40 && (ev.keyCode < 91 || (ev.keyCode >95 && ev.keyCode <111) || ev.keyCode > 187))
            		if (this.cell){
            			var c=this.cells4(this.cell);
            			if (c.isDisabled()) return false;
            			var t=c.getValue();
            			if (c.editable!==false) c.setValue("");
            			this.editCell();
            			if (this.editor) {
            				this.editor.val=t;
            				if (this.editor.obj && this.editor.obj.select)
            					this.editor.obj.select();
        				}
            			else c.setValue(t);
            		}
            }
		};

};

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function eXcell_time(cell){

		this.base = eXcell_ed;
		this.base(cell)
		this.getValue = function(){
				return this.cell.innerHTML.toString();
		}
		this.setValue = function(val){
		var re = new RegExp(" ","i")
		val = val.replace(re,":")
		if((val=="")) val = "00:00"
		else
		{
			var re = new RegExp("[a-zA-Z]","i")
			var res = val.match(re)
			
			if(res) val = "00:00";
			else{
				var re = new RegExp("[0-9]+[\\.\\/;\\-,_\\]\\[\\?\\: ][0-9]+","i")
				var res = val.search(re)
				if(res!=-1){
					var re = new RegExp("[\\./\\;\\-\\,\\_\\]\\[ \\?]","i")
					val = val.replace(re,":")
				}
				else
				{
					var re = new RegExp("[^0-9]","i")
					res1 = val.search(re)
					if(res = val.match(re) ) { val = "00:00";}
					else
					{
					if(val.length == 1)
					{
						val = "00:0"+val;
					}
					else
					{
						if(parseInt(val) < 60) val = "00:"+val;
						else
						if(val.length < 5)
						{
							var minutes = parseInt(val);
							var hours =  Math.floor(minutes/60);
							minutes = minutes - 60*hours;
							var hours = hours.toString();
							var minutes = minutes.toString();
							while(hours.length < 2){
								hours = "0" + hours;
							}
							while(minutes.length < 2){
								minutes = "0" + minutes;
							}
							val = hours+":"+minutes;
						}
					}
					}
						
				}
			}
		}
		this.cell.innerHTML = val;
		}

		
	}
	   eXcell_time.prototype = new eXcell_ed;
	   //(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function eXcell_sub_row(cell){
	if (cell){
		this.cell = cell;
    	this.grid = this.cell.parentNode.grid;
	}
	
	this.getValue = function(){
		return this.grid.getUserData(this.cell.parentNode.idd,"__sub_row");
	}
	this._setState = function(m,v){
		(v||this.cell).innerHTML="<img src='"+this.grid.imgURL+m+"' width='18' height='18' />";
		(v||this.cell).firstChild.onclick=this.grid._expandMonolite;
	}
	this.open = function (){
		this.cell.firstChild.onclick(null,true)
	}
	this.close = function (){
		this.cell.firstChild.onclick(null,false,true)
	}
	this.isOpen = function(){
		return !!this.cell.parentNode._expanded;
	}
	this.setValue = function(val){
		if (val)
			this.grid.setUserData(this.cell.parentNode.idd,"__sub_row",val);
		this._setState(val?"plus.gif":"blank.gif");
	}
	this.setContent = function(val){
		if (this.cell.parentNode._expanded){
			this.cell.parentNode._expanded.innerHTML=val;
			this.resize();
		}
		else{
			this.cell._previous_content=null;
			this.setValue(val);
			this.cell._sub_row_type=null
		}
			
	}
	this.resize = function(){
		this.grid._detectHeight(this.cell.parentNode._expanded,this.cell,this.cell.parentNode._expanded.scrollHeight);
	},
	this.isDisabled = function(){ return true; }
	this.getTitle = function(){ return this.grid.getUserData(this.cell.parentNode.idd,"__sub_row")?"click to expand|collapse":""; }
}
eXcell_sub_row.prototype = new eXcell;

function eXcell_sub_row_ajax(cell){
	this.base=eXcell_sub_row;
	this.base(cell);
	
	this.setValue = function(val){
		if (val)
			this.grid.setUserData(this.cell.parentNode.idd,"__sub_row",val);
			this.cell._sub_row_type="ajax";
			this.cell._previous_content = null;
		this._setState(val?"plus.gif":"blank.gif");
	}
}
eXcell_sub_row_ajax.prototype = new eXcell_sub_row;

function eXcell_sub_row_grid(cell){
	this.base=eXcell_sub_row;
	this.base(cell);
	
	this.setValue = function(val){
		if (val)
			this.grid.setUserData(this.cell.parentNode.idd,"__sub_row",val);
			this.cell._sub_row_type="grid";
		this._setState(val?"plus.gif":"blank.gif");
	}
	this.getSubGrid = function(){
		if (!cell._sub_grid) return null;
		return cell._sub_grid;
	}
}
eXcell_sub_row_grid.prototype = new eXcell_sub_row;

dhtmlXGridObject.prototype._expandMonolite=function(n,show,hide){
	var td=this.parentNode;
	var row=td.parentNode;
	var that=row.grid;
	
	if (n||window.event){
		if (!hide && !row._expanded) that.editStop();
		(n||event).cancelBubble=true;
	}
	
	var c=that.getUserData(row.idd,"__sub_row");
	
	if (!that._sub_row_editor)
    	that._sub_row_editor=new eXcell_sub_row(td);
	
	if (!c) return;
	
	if (row._expanded && !show){
		that._sub_row_editor._setState("plus.gif",td);
		td._previous_content=row._expanded;
		that.objBox.removeChild(row._expanded);
		row._expanded=false;
		row.style.height=(row.oldHeight||20)+"px";
		td.style.height=(row.oldHeight||20)+"px";	
		
		if (that._fake){
			that._fake.rowsAr[row.idd].style.height=(row.oldHeight||20)+"px";
			that._fake.rowsAr[row.idd].firstChild.style.height=(row.oldHeight||20)+"px";
		}
			
		for (var i=0; i<row.cells.length; i++)
			row.cells[i].style.verticalAlign="middle";
			
		delete that._flow[row.idd];
		that._correctMonolite();
		row._expanded.ctrl=null;
	}else if (!row._expanded && !hide){
		that._sub_row_editor._setState("minus.gif",td);
		row.oldHeight=td.offsetHeight-4;
		if (td._previous_content){
			var d=td._previous_content;
			d.ctrl=td;
			that.objBox.appendChild(d);
			that._detectHeight(d,td,parseInt(d.style.height))	
		}
		else {
			var d=document.createElement("DIV");
			d.ctrl=td;
			if (td._sub_row_type)
				that._sub_row_render[td._sub_row_type](that,d,td,c);
			else
				d.innerHTML=c;
			d.style.cssText="position:absolute; left:0px; top:0px; overflow:auto; font-family:Tahoma; font-size:8pt; margin-top:2px; margin-left:4px;";
			d.className="dhx_sub_row";
			that.objBox.appendChild(d);
			that._detectHeight(d,td)			
		}
		

			
		
		if (!that._flow) {
			that.attachEvent("onGridReconstructed",function(){ 
				if ((this.pagingOn && !this.parentGrid) || this._srnd) this._collapsMonolite();
				else this._correctMonolite(); 
			});
			that.attachEvent("onResizeEnd",function(){ this._correctMonolite(true); });
			that.attachEvent("onAfterCMove",function(){ this._correctMonolite(true); });
			that.attachEvent("onDrop",function(){ this._correctMonolite(true); });
			that.attachEvent("onBeforePageChanged",function(){ this._collapsMonolite(); return true; });
			that.attachEvent("onGroupStateChanged",function(){ this._correctMonolite(); return true; });
			that.attachEvent("onFilterEnd",function(){ this._collapsMonolite(); });
			that.attachEvent("onUnGroup",function(){ this._collapsMonolite(); });
			that.attachEvent("onPageChanged",function(){ this._collapsMonolite(); });
			
			that.attachEvent("onXLE",function(){ this._collapsMonolite(); });
			that.attachEvent("onClearAll",function(){ for (var i in this._flow) {
				if (this._flow[i] && this._flow[i].parentNode) this._flow[i].parentNode.removeChild(this._flow[i]);
			}; this._flow=[]; });
			that.attachEvent("onEditCell",function(a,b,c){  if ((a!==2) && this._flow[b] && this.cellType[c]!="ch" && this.cellType[c]!="ra") this._expandMonolite.apply(this._flow[b].ctrl.firstChild,[0,false,true]);  return true; });
			that.attachEvent("onCellChanged",function(id,ind){ if (!this._flow[id]) return; 
				var c=this.cells(id,ind).cell;
				c.style.verticalAlign="top";
			});
			
			that._flow=[];
		}
		that._flow[row.idd]=d;
		that._correctMonolite();
		//d.style.top=row.offsetTop+20+"px";
		
		var padtop = that._srdh > 30 ? 11:3;
		if (that.multiLine) padtop = 0;

		for (var i=0; i<row.cells.length; i++)
			row.cells[i].style.verticalAlign="top";
		if (that._fake){
			var frow=that._fake.rowsAr[row.idd];
			for (var i=0; i<frow.cells.length; i++){
				frow.cells[i].style.verticalAlign="top";
			}
		}
		row._expanded=d;
	}
	if (that._ahgr)
		that.setSizes()
	if (that.parentGrid)
		that.callEvent("onGridReconstructed",[]);
	that.callEvent("onSubRowOpen",[row.idd,(!!row._expanded)]);
}
dhtmlXGridObject.prototype._sub_row_render={
    "ajax":function(that,d,td,c){
        d.innerHTML="Loading...";
        //d.innerHTML=that.i18n.loading;
        dhx4.ajax.get(c, function(xml){
            d.innerHTML=xml.xmlDoc.responseText;
            var z=xml.xmlDoc.responseText.match(/<script[^>]*>([^\f]+?)<\/script>/g);
            if (z)
                for (var i=0; i<z.length; i++)
                    eval(z[i].replace(/<([\/]{0,1})s[^>]*>/g,""));

			that._detectHeight(d,td)
			that._correctMonolite();
			that.setUserData(td.parentNode.idd,"__sub_row",xml.xmlDoc.responseText);
			td._sub_row_type=null;
			if (that._ahgr)
				that.setSizes()
			that.callEvent("onSubAjaxLoad",[td.parentNode.idd,xml.xmlDoc.responseText]);
		});
	},
	"grid":function(that,d,td,c){
		   td._sub_grid= new dhtmlXGridObject(d);
		   if (that.skin_name)
				td._sub_grid.setSkin(that.skin_name);
				
		   td._sub_grid.parentGrid=that;
		   td._sub_grid.imgURL = that.imgURL;
		   td._sub_grid.iconURL = that.iconURL;
		   td._sub_grid.enableAutoHeight(true);
		   td._sub_grid._delta_x = td._sub_grid._delta_y = null;
		   td._sub_grid.attachEvent("onGridReconstructed",function(){
		   		that._detectHeight(d,td,td._sub_grid.objBox.scrollHeight+td._sub_grid.hdr.offsetHeight+(this.ftr?this.ftr.offsetHeight:0));
		   		that._correctMonolite();
		   		this.setSizes();
		   		if (that.parentGrid) that.callEvent("onGridReconstructed",[]);
	   	   })
		   if (!that.callEvent("onSubGridCreated",[td._sub_grid,td.parentNode.idd,td._cellIndex,c])){
		   		td._sub_grid.objBox.style.overflow="hidden";
				td._sub_row_type=null;
		   } else {
			   td._sub_grid.load(c,function(){
					that._detectHeight(d,td,td._sub_grid.objBox.scrollHeight+td._sub_grid.hdr.offsetHeight+(td._sub_grid.ftr?td._sub_grid.ftr.offsetHeight:0));
					td._sub_grid.objBox.style.overflow="hidden";
					that._correctMonolite();
					td._sub_row_type=null;
					if (!that.callEvent("onSubGridLoaded",[td._sub_grid,td.parentNode.idd,td._cellIndex,c])) return;
					if (that._ahgr) that.setSizes();
					if (that.parentGrid) that.callEvent("onGridReconstructed",[]);
			  	});		   
			}
	}
}

dhtmlXGridObject.prototype._detectHeight=function(d,td,h){
	var l=td.offsetLeft+td.offsetWidth;
		d.style.left=l+"px";
		d.style.width=Math.max(0,td.parentNode.offsetWidth-l-4)+"px"
		var h=h||d.scrollHeight;
		d.style.overflow="hidden";
		d.style.height=h+"px";		
		var row=td.parentNode;
		td.parentNode.style.height=(row.oldHeight||20)+h*1+"px";	
		td.style.height=(row.oldHeight||20)+h*1+"px";	
		if (this._fake){
			var tr=this._fake.rowsAr[td.parentNode.idd];
			tr.style.height=(row.oldHeight||20)+h*1+"px";	
			tr.firstChild.style.height=(row.oldHeight||20)+h*1+"px";	
		}
}
dhtmlXGridObject.prototype._correctMonolite=function(mode){
	if (this._in_correction) return;
	this._in_correction=true;
	
	for (var a in this._flow)
		if (this._flow[a] && this._flow[a].tagName=="DIV")
			if (this.rowsAr[a]){			
				if (this.rowsAr[a].style.display=="none") {
					this.cells4(this._flow[a].ctrl).close();
					continue;
				}
				this._flow[a].style.top=this.rowsAr[a].offsetTop+(this.rowsAr[a].oldHeight||20)+"px";
				if (mode) {
					var l=this._flow[a].ctrl.offsetLeft+this._flow[a].ctrl.offsetWidth;
					this._flow[a].style.left=l+"px";
					this._flow[a].style.width=this.rowsAr[a].offsetWidth-l-4+"px"
				}
			}
			else{
				this._flow[a].ctrl=null;
				this.objBox.removeChild(this._flow[a]);
				delete this._flow[a];
			}

	this._in_correction=false;
}
dhtmlXGridObject.prototype._collapsMonolite=function(){
		for (var a in this._flow)
			if (this._flow[a] && this._flow[a].tagName=="DIV")
				if (this.rowsAr[a])
					this.cells4(this._flow[a].ctrl).close();
}
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: radio editor
*   @returns: dhtmlxGrid cell editor object
*   @type: public
*/
function eXcell_ra_str(cell){
   if (cell){
   this.base = eXcell_ra;
   this.base(cell)
   this.grid = cell.parentNode.grid;
	}
}
eXcell_ra_str.prototype = new eXcell_ch;
eXcell_ra_str.prototype.setValue = function(val){
                  this.cell.style.verticalAlign = "middle";//nb:to center checkbox in line
                  if (val){
                           val=val.toString()._dhx_trim();
                     if ((val=="false")||(val=="0")) val="";
                     }
                  if(val){
		    if (this.grid.rowsAr[this.cell.parentNode.idd])
                     for (var i=0;i<this.grid._cCount;i++) {
			if (i!==this.cell._cellIndex) {
                            var cell = this.grid.cells(this.cell.parentNode.idd,i);
                            if ((cell.cell._cellType||this.grid.cellType[cell.cell._cellIndex])!="ra_str") continue;
                            if (cell.getValue())
                               cell.setValue("0");
			}
                     }
                     val = "1";
                     this.cell.chstate = "1";
                  }else{
                     val = "0";
                     this.cell.chstate = "0"
                  }
                  this.setCValue("<img src='"+this.grid.imgURL+"radio_chk"+val+".gif' onclick='new eXcell_ra_str(this.parentNode).changeState()'>",this.cell.chstate);
               }
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhx4.attachEvent("onGridCreated", function(grid){
	if (!window.dhx_globalImgPath) window.dhx_globalImgPath = grid.imgURL;
	
	grid._col_combos = [];
	for (var i=0; i<grid._cCount; i++) {
		if(grid.cellType[i].indexOf("combo") == 0) {
			grid._col_combos[i] = eXcell_combo.prototype.initCombo.call({grid:grid},i);
		}
	}
	
	if (!grid._loading_handler_set) {
		grid._loading_handler_set = grid.attachEvent("onXLE", function(a,b,c,xml,type){
				if (type != "xml") return;
				eXcell_combo.prototype.fillColumnCombos(this,xml);
				this.detachEvent(this._loading_handler_set);
				this._loading_handler_set = null;
		});
	}
});


function eXcell_combo(cell) {
	
	if (!cell) return;
	
	this.cell = cell;
	this.grid = cell.parentNode.grid;
	this._combo_pre = "";
	
	this.edit = function(){
		
		if (!window.dhx_globalImgPath) window.dhx_globalImgPath = this.grid.imgURL;
		
		this.val = this.getValue();
		var val = this.getText();
		if (this.cell._clearCell) val="";
		this.cell.innerHTML = "";
		
		if (!this.cell._brval) {
			this.combo = (this.grid._realfake?this.grid._fake:this.grid)._col_combos[this.cell._cellIndex];
		} else {
			this.combo = this.cell._brval;
		}
		this.cell.appendChild(this.combo.DOMParent);

		this.combo.DOMParent.style.margin = "0";
		
		this.combo.DOMelem_input.focus();
		this.combo.setSize(this.cell.offsetWidth-2);
		if (!this.combo._xml) {
			if (this.combo.getIndexByValue(this.cell.combo_value)!=-1) {
				this.combo.selectOption(this.combo.getIndexByValue(this.cell.combo_value));
			} else {
				if (this.combo.getOptionByLabel(val)) {
					this.combo.selectOption(this.combo.getIndexByValue(this.combo.getOptionByLabel(val).value));
				} else {
					this.combo.setComboText(val);
				}
			}
		} else {
			this.combo.setComboText(val);
		}
		this.combo.openSelect();
	}
	
	this.selectComboOption = function(val,obj){
		obj.selectOption(obj.getIndexByValue(obj.getOptionByLabel(val).value));
	}
	
	this.getValue = function(val){
		return this.cell.combo_value||"";
	}
	
	this.getText = function(val){
		var c = this.cell;
		if (this._combo_pre == "" && c.childNodes[1]) {
			c = c.childNodes[1];
		} else {
			c.childNodes[0].childNodes[1];
		}
		return (_isIE ? c.innerText : c.textContent);
	}
	
	this.setValue = function(val){
		
		if (typeof(val) == "object"){
			
			this.cell._brval = this.initCombo();
			var index = this.cell._cellIndex;
			var idd = this.cell.parentNode.idd;
			if (!val.firstChild) {
				this.cell.combo_value = "&nbsp;";
				this.cell._clearCell = true;
			} else {
				this.cell.combo_value = val.firstChild.data;
			}
			this.setComboOptions(this.cell._brval, val, this.grid, index, idd);
			
		} else {
			this.cell.combo_value = val;
			var cm = null;
			if ((cm = this.cell._brval) && (typeof(this.cell._brval) == "object")) {
				val = (cm.getOption(val)||{}).text||val;
			} else if (cm = this.grid._col_combos[this.cell._cellIndex]||((this.grid._fake) && (cm = this.grid._fake._col_combos[this.cell._cellIndex]))) {
				val = (cm.getOption(val)||{}).text||val;
			}
			
			if ((val||"").toString()._dhx_trim()=="") val = null;
			
			if (val !== null) {
				this.setComboCValue(val);
			} else {
				this.setComboCValue("&nbsp;", "");
				this.cell._clearCell = true;
			}
		}
	}
	
	this.detach = function(){
		var p = this.combo.getParent();
		if (p.parentNode == this.cell) {
			this.cell.removeChild(p);
		} else {
			return false;
		}
		var val = this.cell.combo_value;
		this.combo._confirmSelect("blur");
		
		if (!this.combo.getComboText() || this.combo.getComboText().toString()._dhx_trim()=="") {
			this.setComboCValue("&nbsp;");
			this.cell._clearCell=true;
		} else {
			this.setComboCValue(this.combo.getComboText().replace(/\&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"),this.combo.getActualValue());
			this.cell._clearCell = false;
		}
		
		this.cell.combo_value = this.combo.getActualValue();
		this.combo.closeAll();
		this.grid._still_active=true;
		this.grid.setActive(1);
		return val!=this.cell.combo_value;
	}
}


eXcell_combo.prototype = new eXcell;
eXcell_combo_v = function(cell){
	var combo = new eXcell_combo(cell);
	combo._combo_pre = "<img src='"+(window.dhx_globalImgPath?window.dhx_globalImgPath:this.grid.imgURL)+"combo_select"+(dhtmlx.skin?"_"+dhtmlx.skin:"")+".gif' class='dhxgrid_combo_icon'/>";
	return combo;
};

eXcell_combo.prototype.initCombo = function(index){
	
	var container = document.createElement("DIV");
	container.className = "dhxcombo_in_grid_parent";
	var type = this.grid.defVal[arguments.length?index:this.cell._cellIndex];
	var combo = new dhtmlXCombo(container, "combo", 0, type);
	this.grid.defVal[arguments.length?index:this.cell._cellIndex] = "";
	
	var grid = this.grid;
	combo.DOMelem.onmousedown = combo.DOMelem.onclick = function(e){
		e = e||event;
		e.cancelBubble = true;
	};
	combo.DOMelem.onselectstart = function(e){
		e = e||event;
		e.cancelBubble = true;
		return true;
	};
	
	this.grid.attachEvent("onScroll", function(){
		if (combo._isListVisible()) combo._hideList();
	});
	
	combo.attachEvent("onKeyPressed",function(ev){
		if (ev==13 || ev==27) {
			grid.editStop();
			if (grid._fake) grid._fake.editStop();
		}
	});
	
	return combo;
	
};

eXcell_combo.prototype.fillColumnCombos = function(grid,xml){
	if (!xml) return;
	var top  = dhx4.ajax.xmltop("rows", xml, -1);
	if (top && top.tagName !== "DIV"){
		grid.combo_columns = grid.combo_columns||[];
		columns = dhx4.ajax.xpath("//column", top);
		for (var i=0; i<columns.length; i++) {
			if ((columns[i].getAttribute("type")||"").indexOf("combo") == 0) {
				grid.combo_columns[grid.combo_columns.length] = i;
				this.setComboOptions(grid._col_combos[i], columns[i], grid, i);
			}
		}
	}
};

eXcell_combo.prototype.setComboCValue = function(value, value2) {
   	if (this._combo_pre != "") {
		var height = (this.cell.offsetHeight?this.cell.offsetHeight+"px":0);
   		value = "<div style='width:100%;position:relative;height:100%;overflow:hidden;'>"+this._combo_pre+"<span>"+value+"</span></div>";
   	}
   	if (arguments.length > 1) {
  		this.setCValue(value,value2);
	} else {
		this.setCValue(value);
	}
};

eXcell_combo.prototype.setComboOptions = function(combo, obj, grid, index, idd) {
	
	if (window.dhx4.s2b(obj.getAttribute("xmlcontent"))) {
		
		if (!obj.getAttribute("source")) {
			options = obj.childNodes;
			var _optArr = [];
			for (var i=0; i < options.length; i++){
				if(options[i].tagName =="option"){
					var text_opt = options[i].firstChild? options[i].firstChild.data:"";
					_optArr[_optArr.length]= [options[i].getAttribute("value"),text_opt, (options[i].getAttribute("css")||"")];
				}
			}
			combo.addOption(_optArr)
			if(arguments.length == 4){
				grid.forEachRowA(function(id){
						var c = grid.cells(id,index);
						if(!c.cell._brval&&!c.cell._cellType&&(c.cell._cellIndex==index)){
							if(c.cell.combo_value=="") c.setComboCValue("&nbsp;","");
							else{
								if(!combo.getOption(c.cell.combo_value))
									c.setComboCValue(c.cell.combo_value);
								else c.setComboCValue(combo.getOption(c.cell.combo_value).text, c.cell.combo_value);
							}
						}
				});	
			}
			else {
				var c = (this.cell)?this:grid.cells(idd,index);
				if(obj.getAttribute("text")) {
					if(obj.getAttribute("text")._dhx_trim()=="") c.setComboCValue("&nbsp;",""); 
					else c.setComboCValue(obj.getAttribute("text")); 
				}
				else{
					if((!c.cell.combo_value)||(c.cell.combo_value._dhx_trim()=="")) c.setComboCValue("&nbsp;","");
					else{
						if(!combo.getOption(c.cell.combo_value))
							c.setComboCValue(c.cell.combo_value);
						else c.setComboCValue(combo.getOption(c.cell.combo_value).text, c.cell.combo_value);
					}
				}
			}
			
		}
	}
	
	if (obj.getAttribute("source")) {
		if (obj.getAttribute("auto") && window.dhx4.s2b(obj.getAttribute("auto"))) {
			
			if (obj.getAttribute("xmlcontent")) {
				var c = (this.cell)?this:grid.cells(idd,index);
				if (obj.getAttribute("text")) c.setComboCValue(obj.getAttribute("text"));
			} else {
				grid.forEachRowA(function(id){
					var c = grid.cells(id,index);
					if (!c.cell._brval && !c.cell._cellType) {
						var str = c.cell.combo_value.toString();
						if (str.indexOf("^") != -1) {
							var arr = str.split("^");
							c.cell.combo_value = arr[0];
							c.setComboCValue(arr[1]);
						}
					}
				});
			}
			combo.enableFilteringMode(true, obj.getAttribute("source"), window.dhx4.s2b(obj.getAttribute("cache")||true), window.dhx4.s2b(obj.getAttribute("sub")||false));
			
		} else {
			
			var that = this;
			var length = arguments.length; 
			combo.load(obj.getAttribute("source"), function(){
				if (length == 4) {
					grid.forEachRow(function(id){
						var c = grid.cells(id,index);
						if (!c.cell._brval && !c.cell._cellType) {
							if (combo.getOption(c.cell.combo_value)) {
								c.setComboCValue(combo.getOption(c.cell.combo_value).text, c.cell.combo_value);
							} else {
								if ((c.cell.combo_value||"").toString()._dhx_trim() == "") {
									c.setComboCValue("&nbsp;","");
									c.cell._clearCell=true;
								} else {
									c.setComboCValue(c.cell.combo_value);
								}
							}
						}
					});
				} else {
					//var c = (that.cell)? that : grid.cells(idd,index);
					var c = grid.cells(idd,index);
					//c.setCValue(obj.getAttribute("text"));
					if (combo.getOption(c.cell.combo_value)) {
						c.setComboCValue(combo.getOption(c.cell.combo_value).text, c.cell.combo_value);
					} else {
						c.setComboCValue(c.cell.combo_value);
					}
				}
			});
			
		}
	}
	if (!obj.getAttribute("auto") || !window.dhx4.s2b(obj.getAttribute("auto"))) {
		if (obj.getAttribute("editable") && !window.dhx4.s2b(obj.getAttribute("editable"))) combo.readonly(true);
		if (obj.getAttribute("filter") && window.dhx4.s2b(obj.getAttribute("filter"))) combo.enableFilteringMode(true);
	}
	
};

eXcell_combo.prototype.getCellCombo = function() {
	
	if (this.cell._brval) return this.cell._brval;
	
	this.cell._brval = this.initCombo();
	return this.cell._brval;
	
};

eXcell_combo.prototype.refreshCell = function() {
	this.setValue(this.getValue());
};

dhtmlXGridObject.prototype.getColumnCombo = function(index) {
	if (this._col_combos && this._col_combos[index]) return this._col_combos[index];
	
	if (!this._col_combos) this._col_combos = [];
	this._col_combos[index] = eXcell_combo.prototype.initCombo.call({grid:this},index);
	return this._col_combos[index];
	
};

dhtmlXGridObject.prototype.refreshComboColumn = function(index) {
	this.forEachRow(function(id){
		if (this.cells(id,index).refreshCell) this.cells(id,index).refreshCell();
	});
};


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*	@desc: multi select list editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_clist(cell){
	try{
		this.cell = cell;
		this.grid = this.cell.parentNode.grid;
	}catch(er){}
	this.edit = function(){
					this.val = this.getValue();
                    var a=(this.cell._combo||this.grid.clists[this.cell._cellIndex]);
                    if (!a) return;
					this.obj = document.createElement("DIV");
                    var b=this.val.split(",");
                    var text="";

                    for (var i=0; i<a.length; i++){
                        var fl=false;
                        for (var j=0; j<b.length; j++)
                            if (a[i]==b[j]) fl=true;
                        if (fl)
                         text+="<div><input type='checkbox' id='dhx_clist_"+i+"' checked='true' /><label for='dhx_clist_"+i+"'>"+a[i]+"</label></div>";
                        else
                         text+="<div><input type='checkbox' id='dhx_clist_"+i+"'/><label for='dhx_clist_"+i+"'>"+a[i]+"</label></div>";
                    }
                    text+="<div><input type='button' value='"+(this.grid.applyButtonText||"Apply")+"' style='width:100px; font-size:8pt;' onclick='this.parentNode.parentNode.editor.grid.editStop();'/></div>"

                    this.obj.editor=this;
                    this.obj.innerHTML=text;
                    document.body.appendChild(this.obj);
                    this.obj.style.position="absolute";
					this.obj.className="dhx_clist";
					this.obj.onclick=function(e){  (e||event).cancelBubble=true; return true; };
					var arPos = this.grid.getPosition(this.cell);
                    this.obj.style.left=arPos[0]+"px";
                    this.obj.style.top=arPos[1]+this.cell.offsetHeight+"px";

                    this.obj.getValue=function(){
                        var text="";
                        for (var i=0; i<this.childNodes.length-1; i++)
                            if (this.childNodes[i].childNodes[0].checked){
                                if (text) text+=", ";
                                    text+=this.childNodes[i].childNodes[1].innerHTML;
                                }
                        return text.replace(/&amp;/g,"&");
                    }
				}
	this.getValue = function(){
		//this.grid.editStop();
		if (this.cell._clearCell) return "";
		return this.cell.innerHTML.toString()._dhx_trim().replace(/&amp;/g,"&").replace(/, /g, ",");
	}

	this.detach = function(val){
                    if (this.obj){
    					this.setValue(this.obj.getValue());
                        this.obj.editor=null;
                        this.obj.parentNode.removeChild(this.obj);
                        this.obj=null;
                        }
					return this.val!=this.getValue();
				}
}
eXcell_clist.prototype = new eXcell;

eXcell_clist.prototype.setValue = function(val){
						if (typeof(val)=="object"){
							var optCol=dhx4.ajax.xpath("./option",val);
                            if (optCol.length)
                            	this.cell._combo=[];
                                for (var j=0;j<optCol.length; j++)
									this.cell._combo.push(optCol[j].firstChild?optCol[j].firstChild.data:"");
							val=val.firstChild.data;
						}
						if (val==="" || val === this.undefined){
							this.setCTxtValue(" ",val);
							this.cell._clearCell=true;
						}
						else{
                            val = val.replace(/,[ ]*/g, ", ");
                        	this.setCTxtValue(val);
                        	this.cell._clearCell=false;
                        }
					}

/**
*	@desc: register list of values for CList cell
*	@param: col - index of CList collumn
*	@param: list - array of list data
*	@type:  public
*   @edition: Professional
*/
dhtmlXGridObject.prototype.registerCList=function(col,list){
    if (!this.clists) this.clists=new Array();
	if (typeof(list)!="object") list=list.split(",");
    this.clists[col]=list;
    }

//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*	@desc: calculator editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_calck(cell){
	try{
		this.cell = cell;
		this.grid = this.cell.parentNode.grid;
	}catch(er){}
	this.edit = function(){
					this.val = this.getValue();

					var arPos = this.grid.getPosition(this.cell);
					this.obj = new calcX(arPos[0],arPos[1]+this.cell.offsetHeight,this,this.val);

				}
	this.getValue = function(){
		//this.grid.editStop();
    	return this.grid._aplNFb(this.cell.innerHTML.toString()._dhx_trim(),this.cell._cellIndex);
	}
	this.detach = function(){
                    if (this.obj) {
						this.setValue(this.obj.inputZone.value);
						this.obj.removeSelf();
						}
                    this.obj=null;
					return this.val!=this.getValue();
				}
}
eXcell_calck.prototype = new eXcell;
eXcell_calck.prototype.setValue = function(val){
      if(!val || val.toString()._dhx_trim()=="")
          val="0"
      this.setCValue(this.grid._aplNF(val,this.cell._cellIndex),val);
}

function calcX(left,top,onReturnSub,val){
	this.top=top||0;
	this.left=left||0;
	this.onReturnSub=onReturnSub||null;

	this.operandA=0;
	this.operandB=0;
	this.operatorA="";
	this.state=0;
	this.dotState=0;


this.calckGo=function(){
	return (eval(this.operandA+"*1"+this.operatorA+this.operandB+"*1"));
};

this.isNumeric=function(str){
	return ((str.search(/[^1234567890]/gi)==-1)?(true):(false));
};
this.isOperation=function(str){
	return ((str.search(/[^\+\*\-\/]/gi)==-1)?(true):(false));
}
	this.onCalcKey=function(e)
	{
		that=this.calk;
		var z=this.innerHTML;
		var rZone=that.inputZone;
		if (((that.state==0)||(that.state==2))&&(that.isNumeric(z)))  	if (rZone.value!="0") rZone.value+=z; else rZone.value=z;
		if ((((that.state==0)||(that.state==2))&&(z=='.'))&&(that.dotState==0)) { that.dotState=1; rZone.value+=z; }
		if ((z=="C"))  { rZone.value=0; that.dotState=0; that.state=0; }
		if ((that.state==0)&&(that.isOperation(z)))  { that.operatorA=z;  that.operandA=rZone.value; that.state=1; }
		if ((that.state==2)&&(that.isOperation(z)))  { that.operandB=rZone.value; rZone.value=that.calckGo(); that.operatorA=z;  that.operandA=rZone.value; that.state=1; }
		if ((that.state==2)&&(z=="="))  { that.operandB=rZone.value; rZone.value=that.calckGo(); that.operatorA=z;  that.operandA=rZone.value; that.state=3; }
		if ((that.state==1)&&(that.isNumeric(z))) { rZone.value=z; that.state=2;  that.dotState=0 }
		if ((that.state==3)&&(that.isNumeric(z))) { rZone.value=z; that.state=0; }
		if ((that.state==3)&&(that.isOperation(z))) { that.operatorA=z;  that.operandA=rZone.value; that.state=1; }
		if (z=="e") { rZone.value=Math.E;  if (that.state==1) that.state=2; that.dotState=0   }
		if (z=="p") { rZone.value=Math.PI; if (that.state==1) that.state=2; that.dotState=0  }
		if (z=="Off") that.topNod.parentNode.removeChild(that.topNod);

		if (e||event) (e||event).cancelBubble=true;
	}
	this.sendResult=function(){
		that=this.calk;
		if (that.state==2){
            var rZone=that.inputZone;
            that.operandB=rZone.value;
            rZone.value=that.calckGo();
            that.operatorA=z;
            that.operandA=rZone.value;
            that.state=3; }
		var z=that.inputZone.value;

		that.topNod.parentNode.removeChild(that.topNod);
		that.onReturnSub.grid.editStop(false);
	};
    this.removeSelf=function(){
        if (this.topNod.parentNode)
        	this.topNod.parentNode.removeChild(this.topNod);
    }
	this.keyDown=function(){ this.className="calcPressed"; };
	this.keyUp=function(){ this.className="calcButton"; };
	this.init_table=function(){
		var table=this.topNod.childNodes[0];
		if ((!table)||(table.tagName!="TABLE")) return;
		for (i=1; i<table.childNodes[0].childNodes.length; i++)
			for (j=0; j<table.childNodes[0].childNodes[i].childNodes.length; j++)
			{
				table.childNodes[0].childNodes[i].childNodes[j].onclick=this.onCalcKey;
				table.childNodes[0].childNodes[i].childNodes[j].onmousedown=this.keyDown;
				table.childNodes[0].childNodes[i].childNodes[j].onmouseout=this.keyUp;
				table.childNodes[0].childNodes[i].childNodes[j].onmouseup=this.keyUp;
				table.childNodes[0].childNodes[i].childNodes[j].calk=this;
			}
		this.inputZone=this.topNod.childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0];
		if (this.onReturnSub)
		{
			this.topNod.childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[1].onclick=this.sendResult;
			this.topNod.childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[1].calk=this;
		}
		else this.topNod.childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[1].innerHTML="";
	}
	this.drawSelf=function(){
		var div=document.createElement("div");
		div.className="calcTable";
		div.style.position="absolute";
		div.style.top=this.top+"px";
		div.style.left=this.left+"px";
		div.innerHTML="<table cellspacing='0' id='calc_01' class='calcTable'><tr><td colspan='4'><table cellpadding='1' cellspacing='0' width='100%'><tr><td width='100%' style='overflow:hidden;'><input style='width:100%' class='calcInput' value='0' align='right' readonly='true' style='text-align:right'></td><td class='calkSubmit'>=</td></tr></table></td></tr><tr><td class='calcButton' width='25%'>Off</td><td class='calcButton' width='25%'>p</td><td class='calcButton' width='25%'>e</td><td class='calcButton' width='25%'>/</td></tr><tr><td class='calcButton'>7</td><td class='calcButton'>8</td><td class='calcButton'>9</td><td class='calcButton'>*</td></tr><tr><td class='calcButton'>4</td><td class='calcButton'>5</td><td class='calcButton'>6</td><td class='calcButton'>+</td></tr><tr><td class='calcButton'>1</td><td class='calcButton'>2</td><td class='calcButton'>3</td><td class='calcButton'>-</td></tr><tr><td class='calcButton'>0</td><td class='calcButton'>.</td><td class='calcButton'>C</td><td class='calcButton'>=</td></tr></table>";
		div.onclick=function(e){ (e||event).cancelBubble=true; };
		document.body.appendChild(div);
		this.topNod=div;
	}

	this.drawSelf();
	this.init_table();

    if (val){
            var rZone=this.inputZone;
            rZone.value=val*1;
            this.operandA=val*1;
            this.state=3;
            }
	return this;
};
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: switch current row state (collapse/expand) tree grid row
*   @param: obj - row object
*   @type: private
*/
dhtmlXGridObject.prototype._updateTGRState=function(z){ 
	if (!z.update || z.id==0) return;
	if (this.rowsAr[z.id].imgTag)
	this.rowsAr[z.id].imgTag.src=this.iconTree+z.state+".gif";
	z.update=false;
}


dhtmlXGridObject.prototype.doExpand=function(obj){  
	this.editStop();
    var row = obj.parentNode.parentNode.parentNode;
	var r=this._h2.get[row.idd];
	if (!this.callEvent("onOpen",[row.idd,(r.state=="plus"?-1:1)])) return;
    if(r.state=="plus")
      this.expandKids(row)
    else
   	  if((r.state=="minus")&&(!r._closeable))
          this.collapseKids(row)
}


dhtmlXGridObject.prototype._createHierarchy=function(){  
	if (!this._emptyLineImg)
		this._emptyLineImg =  "blank";

	return new dhtmlxHierarchy({ _emptyLineImg : this._emptyLineImg });
}

function dhtmlxHierarchy(config){
		var z={id:0, childs:[], level:-1, parent:null, index:0, state:config._emptyLineImg};
		this.order=[z];
		this.get={"0":z};

		this.swap=function(a,b){
			var p=a.parent;
			var z=a.index;
			p.childs[z]=b;
			p.childs[b.index]=a;
			a.index=b.index; b.index=z;
		}
		this.forEachChildF=function(id,funct,that,funct2){
			var z=this.get[id];
			for (var i=0; i<z.childs.length; i++){
				if (!funct.apply((that||this),[z.childs[i]])) continue;
				if (z.childs[i].childs.length) this.forEachChildF(z.childs[i].id,funct,that,funct2);
				if (funct2) funct2.call((that||this),z.childs[i]);
			}
		}
		this.forEachChild=function(id,funct,that){
				var z=this.get[id];
				for (var i=0; i<z.childs.length; i++){
					funct.apply((that||this),[z.childs[i]]);
					if (z.childs[i].childs.length) this.forEachChild(z.childs[i].id,funct,that);
				}
		}
		this.change=function(id,name,val){
			var z=this.get[id];
			if (z[name]==val) return;
				z[name]=val;
				z.update=true;
		}
		this.add=function(id,parentId){ 
			return this.addAfter(id,parentId);
		}
		this.addAfter=function(id,parentId,afterId,fix){  
			var z=this.get[parentId||0];
			if (afterId)
				var ind=this.get[afterId].index+(fix?0:1);
			else var ind=z.childs.length;
			
			var x={id:id, childs:[], level:z.level+1, parent:z, index:ind, state:config._emptyLineImg}
			if (z.state==config._emptyLineImg)  this.change(parentId,"state",(parentId==0?"minus":"plus"));
			
			if (afterId){
				for (var i=ind; i<z.childs.length; i++) z.childs[i].index++;
				z.childs=z.childs.slice(0,ind).concat([x]).concat(z.childs.slice(ind,z.childs.length));
			}else
				z.childs.push(x);
			this.get[id]=x;
			return x;
		}
		this.addBefore=function(id,parentId,beforeId){
			return this.addAfter(id,parentId,beforeId,true)
		}		
		this.remove=function(id){  
			var z=this.get[id||0];
			for (var i=0; i<z.childs.length; i++)
				this.deleteAll(z.childs[i].id)
			z.childs=[];	
			z.parent.childs=z.parent.childs.slice(0,z.index).concat(z.parent.childs.slice(z.index+1));				
			for (var i=z.index; i<z.parent.childs.length; i++)
				z.parent.childs[i].index--;
			delete this.get[id];
		}
		this.deleteAll=function(id){
			var z=this.get[id||0];
			for (var i=0; i<z.childs.length; i++)
				this.deleteAll(z.childs[i].id)
				
			z.childs=[];				
			delete this.get[id];
		}		
		
		return this;
	}

dhtmlXGridObject.prototype._getOpenLenght=function(id,start){
	
	var z=this._h2.get[id].childs;
	start+=z.length;
	for (var i=0; i<z.length; i++)
		if (z[i].childs.length && z[i].state=='minus')
			start+=this._getOpenLenght(z[i].id,0);
	return start;
}
/**
*   @desc: close row of treegrid (removes kids from dom)
*   @param: curRow - row to process kids of
*   @type: private
*/
dhtmlXGridObject.prototype.collapseKids=function(curRow){ 
	var r=this._h2.get[curRow.idd];
    if (r.state!="minus") return;
    if (!this.callEvent("onOpenStart",[curRow.idd,1])) return;

    var start = curRow.rowIndex;
    //why Safari doesn't support standards?
    if (start<0) start=this.rowsCol._dhx_find(curRow)+1;

   	this._h2.change(r.id,"state","plus");
   	this._updateTGRState(r);

    if (this._srnd || this.pagingOn){
    	this._h2_to_buff();
    	this._renderSort();
    } else {
    var len=this._getOpenLenght(this.rowsCol[start-1].idd,0);
    for (var i=0; i<len; i++)
    	this.rowsCol[start+i].parentNode.removeChild(this.rowsCol[start+i]);
    this.rowsCol.splice(start,len);
	}

    //if (this._cssEven && !this._cssSP)
    this.callEvent("onGridReconstructed",[]);

    this.setSizes();
    this._h2_to_buff();
    this.callEvent("onOpenEnd",[curRow.idd,-1]);
}



dhtmlXGridObject.prototype._massInsert=function(r,start,ind,skip){  
	var anew=[];
	var par=(_isKHTML?this.obj:this.obj.rows[0].parentNode)
	this._h2_to_buff();
	if (this._srnd || this.pagingOn) return this._renderSort();
	var len=this._getOpenLenght(r.id,0);
	for(var i=0;i<len;i++){
		var ra=this.render_row(ind+i);
		if (start)
			start.parentNode.insertBefore(ra,start);
		else
			par.appendChild(ra);
		anew.push(ra)
		}
	this.rowsCol=dhtmlxArray(this.rowsCol.slice(0,ind).concat(anew).concat(this.rowsCol.slice(ind)));
	
	return r.childs.length+anew.length;
}
/**
*   @desc: change parent of row, correct kids collections
*   @param: curRow - row to process
*   @type: private
*/
dhtmlXGridObject.prototype.expandKids=function(curRow,sEv){

	var r=this._h2.get[curRow.idd];
	if ((!r.childs.length)&&(!r._xml_await)) return;
	if (r.state!="plus") return;
    
    
    if (!r._loading && !sEv)
    	if (!this.callEvent("onOpenStart",[r.id,-1])) return;
        


   var start = this.getRowIndex(r.id)+1;
   if(r.childs.length){
        r._loading=false;
        this._h2.change(r.id,"state","minus")
        this._updateTGRState(r);
		var len=this._massInsert(r,this.rowsCol[start],start);
		
		//if (this._cssEven && !this._cssSP)
		this.callEvent("onGridReconstructed",[]);
			

   }else{	
        if (r._xml_await){
			r._loading=true;
			if (this.callEvent("onDynXLS",[r.id]))
				this.load(this.kidsXmlFile+""+(this.kidsXmlFile.indexOf("?")!=-1?"&":"?")+"id="+encodeURIComponent(r.id), this._data_type);
        }
   }
    this.setSizes();
    if (!r._loading)
    this.callEvent("onOpenEnd",[r.id,1]);
    this._fixAlterCss();
}

dhtmlXGridObject.prototype.kidsXmlFile = "";



/**
*   @desc: sorts treegrid by specified column
*   @param: col - column index
*   @param:   type - str.int.date
*   @param: order - asc.desc
*   @type: public
*   @edition: Professional
*   @topic: 2,3,5,9
*/
dhtmlXGridObject.prototype.sortTreeRows = function(col,type,order){
				var amet="getValue";
				if (this.cells5({parentNode:{grid:this}},this.getColType(col)).getDate){ //FIXME! move inside cells5 in 2.2
					amet="getDate";
					type="str";
				}		
					

	            this.forEachRow(function(id){
                	var z=this._h2.get[id];
                	if (!z) return;
                	
                	var label=this._get_cell_value(z.buff,col,amet);
                	if(type=='int'){
						   z._sort=parseFloat(label);
						   z._sort=isNaN(z._sort)?-99999999999999:z._sort;
                     }else
                        z._sort=label;
                	});
                	
				var self=this;
				var pos=1; var neg=-1;
				if (order=="des") { pos=-1; neg=1; }
					
				var funct=null;
				if (typeof type == "function")
					funct = function(a,b){
						return type(a._sort, b._sort, order, a.id, b.id);
					}
				else {
	                if(type=='cus')
    	                 funct=function(a,b){
                            return self._customSorts[col](a._sort,b._sort,order,a.id,b.id);
                         };
     	
                   if(type=='str')
                     funct=function(a,b){return (a._sort<b._sort?neg:(a._sort==b._sort?0:pos))}

                  if(type=='int')
                     funct=function(a,b){return (a._sort<b._sort?neg:(a._sort==b._sort?0:pos))}

                  if(type=='date')
                     funct=function(a,b){return (Date.parse(new Date(a._sort||"01/01/1900"))-Date.parse(new Date(b._sort||"01/01/1900")))*pos}
                  }
                  this._sortTreeRows(funct,0);
                  this._renderSort(0,true);

            this.callEvent("onGridReconstructed",[]);
               
}

dhtmlXGridObject.prototype._sortTreeRows = function(funct,id){
				var ar=this._h2.get[id].childs;
				if (this.rowsCol.stablesort)
					this.rowsCol.stablesort.call(ar,funct);
				else
					ar.sort(funct);
					
				for (var i=0; i<ar.length; i++){
					if (ar[i].childs.length) 
						this._sortTreeRows(funct,ar[i].id);
					ar[i].index=i;
				}
};
dhtmlXGridObject.prototype._renderSort = function(id,mode){ 
	this._h2_to_buff();
	var top=this.objBox.scrollTop;
	this._reset_view();
	this.objBox.scrollTop=top;
};

dhtmlXGridObject.prototype._fixAlterCssTGR = function(){ 
if (!this._realfake)	
	this._h2.forEachChild(0,function(x){
		if (x.buff.tagName=="TR"){
			var cs=(this._cssSP?(x.level%2):(x.index%2))?this._cssUnEven:this._cssEven;
			this.rowsAr[x.id].className=(cs + (this._cssSU?(" "+cs+"_"+x.level):""))+" "+(this.rowsAr[x.id]._css||"")+((this.rowsAr[x.id].className.indexOf("rowselected") != -1)?" rowselected":"");
		}
	},this);
}
dhtmlXGridObject.prototype.moveRowUDTG = function(id,dir){ 
	var x=this._h2.get[id];
	var p=x.parent.childs[x.index+dir]
	if ((!p) || (p.parent!=x.parent)) return;
	var state=[x.state,p.state];
	this.collapseKids(this.rowsAr[x.id]);
	this.collapseKids(this.rowsAr[p.id]);	
	var ind = this.rowsCol._dhx_find(this.rowsAr[id]);
	var bInd = this.rowsBuffer._dhx_find(this.rowsAr[id]);
	
	var nod=this.obj.rows[0].parentNode.removeChild(this.rowsCol[ind]);	
	var tar=this.rowsCol[ind+((dir==1)?2:dir)];
	if (tar)
		tar.parentNode.insertBefore(nod,tar);
	else
		this.obj.rows[0].parentNode.appendChild(nod);
	this.rowsCol._dhx_swapItems(ind,ind+dir)
	this.rowsBuffer._dhx_swapItems(bInd,bInd+dir);
	this._h2.swap(p,x);
	
	
	if (state[0]=="minus") this.expandKids(this.rowsAr[x.id]);
	if (state[1]=="minus") this.expandKids(this.rowsAr[p.id]);	
	
	this._fixAlterCss(Math.min(ind,ind+dir));
}

/**
*   @desc: TreeGrid cell constructor (only for TreeGrid package)
*   @param: cell - cell object
*   @type: public
*/
function eXcell_tree(cell){
   if (cell){
      this.cell = cell;
      this.grid = this.cell.parentNode.grid;
   }
   this.isDisabled = function(){ return this.cell._disabled||this.grid._edtc; }
   this.edit = function(){
        if ((this.er)||(this.grid._edtc)) return;
        this.er=this.cell.parentNode.valTag;
        this.val=this.getLabel();
        this.cell.atag=((!this.grid.multiLine)&&(_isKHTML||_isMacOS||_isFF)) ? "INPUT" : "TEXTAREA";
        this.er.innerHTML="<"+this.cell.atag+" class='dhx_combo_edit' type='text' style='height:"+(this.cell.offsetHeight-4)+"px;line-height:"+(this.cell.offsetHeight-6)+"px; width:100%; border:0px; margin:0px; padding:0px; overflow:hidden;'></"+this.cell.atag+">";
        this.er.childNodes[0].onmousedown = function(e){(e||event).cancelBubble = true}
        this.er.childNodes[0].onselectstart=function(e){  if (!e) e=event; e.cancelBubble=true; return true;  };
        this.er.className+=" editable";
        this.er.firstChild.onclick = function(e){(e||event).cancelBubble = true};
        this.er.firstChild.value=this.val;
        this.obj=this.er.firstChild;
		this.er.firstChild.style.width=Math.max(0,this.cell.offsetWidth-this.er.offsetLeft-2)+"px";
        this.er.firstChild.focus();
        if (_isIE)
			this.er.firstChild.focus();
    }
   this.detach = function(){
        if (!this.er) return;
            this.setLabel(this.er.firstChild.value);
            this.er.className=this.er.className.replace("editable","");
            var z=(this.val!=this.er.innerHTML);

			this.obj=this.er=null;
        return (z);
    }
   this.getValue = function(){
   		return this.getLabel();
   }

    
    /**
    *   @desc: get image of treegrid item
    *   @param: content - new text of label
    *   @type: private
    */
   this.setImage = function(url){
        this.cell.parentNode.imgTag.nextSibling.src=this.grid.iconURL+url;
        this.grid._h2.get[this.cell.parentNode.idd].image=url;
   }
   this.setIcon = function(icon){
		this.grid._h2.get[this.cell.parentNode.idd].icon = icon;
		this.cell.parentNode.imgTag.nextSibling.className = "dhx_treegrid_icon fa fa-"+icon;
   }
    /**
    *   @desc: set image of treegrid item
    *   @param: content - new text of label
    *   @type: private
    */
   this.getImage = function(){
   		return this.grid._h2.get[this.cell.parentNode.idd].image;
   }
   this.getIcon = function(){
   		return this.grid._h2.get[this.cell.parentNode.idd].icon;
   }

   /**
   *   @desc: sets text representation of cell ( setLabel doesn't triger math calculations as setValue do)
   *   @param: val - new value
   *   @type: public
   */
   this.setLabel = function(val){
                  this.setValueA(val);
            }

   /**
   *   @desc: sets text representation of cell ( setLabel doesn't triger math calculations as setValue do)
   *   @param: val - new value
   *   @type: public
   */
   this.getLabel = function(val){
     return this.cell.parentNode.valTag.innerHTML;
    }
}
    /**
    *   @desc: set value of grid item
    *   @param: val  - new value (for treegrid this method only used while adding new rows)
    *   @type: private
    */
	
eXcell_tree.prototype = new eXcell;
    /**
    *   @desc: set label of treegrid item
    *   @param: content - new text of label
    *   @type: private
    */
   eXcell_tree.prototype.setValueA = function(content){
   		this.cell.parentNode.valTag.innerHTML=content;
		this.grid.callEvent("onCellChanged",[this.cell.parentNode.idd,this.cell._cellIndex,content])
    }
	eXcell_tree.prototype.setValue = function(valAr){
		if (this.cell.parentNode.imgTag)
			return this.setLabel(valAr);
			
			
		if ((this.grid._tgc.iconTree==null)||(this.grid._tgc.iconTree!=this.grid.iconTree)){
			var _tgc={};
			_tgc.spacer="<img src='"+this.grid.iconTree+"blank.gif'  align='top' class='space'>";
			_tgc.imst="<img class='grid_collapse_icon' src='"+this.grid.iconTree;
			_tgc.imsti="<img style='padding-top:2px;'  src='"+(this.grid.iconURL||this.grid.iconTree);
			_tgc.imact="' align='top' onclick='this."+(_isKHTML?"":"parentNode.")+"parentNode.parentNode.parentNode.parentNode.grid.doExpand(this);event.cancelBubble=true;'>"
			_tgc.plus=_tgc.imst+"plus.gif"+_tgc.imact;
			_tgc.minus=_tgc.imst+"minus.gif"+_tgc.imact;
			_tgc.blank=_tgc.imst+"blank.gif"+_tgc.imact;
			_tgc.start="<div class='treegrid_cell' style='overflow:hidden; white-space : nowrap; line-height:23px; height:"+(_isIE?21:23)+"px;'>";
			
			_tgc.itemim="' align='top' "+(this.grid._img_height?(" height=\""+this.grid._img_height+"\""):"")+(this.grid._img_width?(" width=\""+this.grid._img_width+"\""):"")+" >";
			_tgc.itemne="<span id='nodeval'>";
			_tgc.close="</span></div>";
			this.grid._tgc=_tgc;
		}
		var _h2=this.grid._h2;
		var _tgc=this.grid._tgc;
				
		var rid=this.cell.parentNode.idd;
		var row=this.grid._h2.get[rid];
		
		if (this.grid.kidsXmlFile || this.grid._slowParse) { 
			row.has_kids=(row.has_kids||(this.cell.parentNode._attrs["xmlkids"]&&(row.state!="minus")));
			row._xml_await=!!row.has_kids;
		}
		
		
		row.image=row.image||(this.cell._attrs["image"]||"leaf.gif");
		row.icon=row.icon||(this.cell._attrs["icon"]||(this.grid.iconset?"file-o":""));

		row.label=valAr;
               
        var html=[_tgc.start];
		
        for(var i=0;i<row.level;i++)
        	html.push(_tgc.spacer);
        
       //if has children
        if(row.has_kids){
        	html.push(_tgc.plus);
        	row.state="plus"
        	}
        else
        	html.push(_tgc.imst+row.state+".gif"+_tgc.imact);
                        
		if (!row.icon){
			html.push(_tgc.imsti);
			html.push(row.image);
			html.push(_tgc.itemim);
		} else {
			html.push("<i class='dhx_treegrid_icon fa fa-"+row.icon+"'></i>");
		}
		html.push(_tgc.itemne);
		html.push(row.label);
		html.push(_tgc.close);
		
                    

		this.cell.innerHTML=html.join("");
		this.cell._treeCell=true;
		this.cell.parentNode.imgTag=this.cell.childNodes[0].childNodes[row.level];
		this.cell.parentNode.valTag=this.cell.childNodes[0].childNodes[row.level+2];
		if (_isKHTML) this.cell.vAlign="top";
		if (row.parent.id!=0 && row.parent.state=="plus") {
				this.grid._updateTGRState(row.parent,false);
				this.cell.parentNode._skipInsert=true;		
			}

		this.grid.callEvent("onCellChanged",[rid,this.cell._cellIndex,valAr]);
	}
    
dhtmlXGridObject.prototype._process_tree_xml=function(top,pid){
	this._parsing=true;
	var main=false;
	if (!pid){
		this.render_row=this.render_row_tree;
		main=true;
		
		pid=top.getAttribute("parent")||0;
		if (pid=="0") pid=0;
		if (!this._h2)	 this._h2= this._createHierarchy();
		if (this._fake) this._fake._h2=this._h2;
	} 

	var rows=dhx4.ajax.xpath(this.xml.row, top);
	this._open=this._open||[];
	for (var i=0; i < rows.length; i++) {
		var id=rows[i].getAttribute("id");
		if (!id) {
			id=this.uid();
			rows[i].setAttribute("id",id);
		}
		var row=this._h2.add(id,pid);
		row.buff={ idd:id, data:rows[i], _parser: this._process_xml_row, _locator:this._get_xml_data };
		if (rows[i].getAttribute("open")){
			row.state="minus";
			this._open.push(id);
		}
		
		this.rowsAr[id]=row.buff;
		this._process_tree_xml(rows[i],id);
	}
	if (main){ 
		if (!rows.length) this._h2.change(pid,"state",this._emptyLineImg);
		else if (pid!=0 && !this._srnd) {
			this._h2.change(pid,"state","minus");
		}
		for (var i=0; i < this._open.length; i++) {
			var r=this._h2.get[this._open[i]];
			if (!r.childs.length)
				r.state=this._emptyLineImg;
		};
		
		this._updateTGRState(this._h2.get[pid]);
		this._h2_to_buff();
		if (pid!=0 && this._srnd) this.openItem(pid);
		else {
			if (this.pagingOn)
				this._renderSort();
			else
				this.render_dataset();
		}

		if (this.kidsXmlFile){
			for (var i=0; i < this._open.length; i++) {
				var r=this._h2.get[this._open[i]];
				if (r._xml_await) 
					this.expandKids({idd:r.id});
			}
		}
		this._open=[];

		if (this._slowParse===false){
			this.forEachRow(function(id){
				this.render_row_tree(0,id)
			})
		}
		this._parsing=false;
		if (pid!=0 && !this._srnd) {
		    this.callEvent("onOpenEnd",[pid,1]);
		}
	}
}	
dhtmlXGridObject.prototype._h2_to_buff=function(top){
	if (!top){
		top=this._h2.get[0];
		this.rowsBuffer = new dhtmlxArray();
		if (this._fake && !this._realfake) this._fake.rowsBuffer = this.rowsBuffer;
	}
	for (var i=0; i < top.childs.length; i++) {
		this.rowsBuffer.push(top.childs[i].buff);
		if (top.childs[i].state == "minus")
			this._h2_to_buff(top.childs[i]);
	}
};
dhtmlXGridObject.prototype.render_row_tree=function(ind,id){ 
	if (id){
		var r=this._h2.get[id];
		r=r?r.buff:r;
	} else
	var r=this.rowsBuffer[ind];
	if (!r) 
		return -1;
	
	if (r._parser){
		if (this.rowsAr[r.idd] && this.rowsAr[r.idd].tagName=="TR")
			return this._h2.get[r.idd].buff=this.rowsBuffer[ind]=this.rowsAr[r.idd];
		var row=this._prepareRow(r.idd);
		this.rowsAr[r.idd]=row;

		if (!id)
			this.rowsBuffer[ind]=row;
		this._h2.get[r.idd].buff=row;	//treegrid specific
		
		r._parser.call(this,row,r.data);
		this._postRowProcessing(row);		
		
		return row;
		}
	return r;
}
    
    /**
    *   @desc: remove row from treegrid
    *   @param: node  - row object
    *   @type: private
    */
dhtmlXGridObject.prototype._removeTrGrRow=function(node,x){ 
		 if(x){
		     this._h2.forEachChild(x.id,function(x){
		     	this._removeTrGrRow(null,x);
	    		delete this.rowsAr[x.id];
    		},this);
    		return;
		 }
		 
		 var ind=this.getRowIndex(node.idd);
		 var x=this._h2.get[node.idd];
		 
		 
		 if (ind!=-1 && ind!==this.undefined){// in case of dnd we can receive delete command for some child item, which was not rendered yet
		 	var len=1;
		 	if (x && x.state=="minus") len+=this._getOpenLenght(x.id,0)
		 	for (var i=0; i<len; i++)
		 		if (this.rowsCol[i+ind])
            		this.rowsCol[i+ind].parentNode.removeChild(this.rowsCol[i+ind]);
            if (this._fake){
            	for (var i=0; i<len; i++)
            		if (this._fake.rowsCol[i+ind])
            			this._fake.rowsCol[i+ind].parentNode.removeChild(this._fake.rowsCol[i+ind]);
            	if (len>1)
            		this._fake.rowsCol.splice(ind+1,len-1);
        	}
            	
	         this.rowsCol.splice(ind,len);
	         this.rowsBuffer.splice(ind,len);
	         
	    }
	    
	    if (!x) return;
	    this._removeTrGrRow(null,x);
    		
    	delete this.rowsAr[x.id];
	
    	if (x.parent.childs.length==1){
    		this._h2.change(x.parent.id,"state",this._emptyLineImg);
    		this._updateTGRState(x.parent);
    	}
    	this._h2.remove(x.id);
      }




/**
*   @desc: expand row
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.openItem=function(rowId){
		var y=this._h2.get[rowId||0];
        var x=this.getRowById(rowId||0);
		if (!x) return;
        if (y.parent && y.parent.id!=0)
        	this.openItem(y.parent.id);
        this.expandKids(x);
}

dhtmlXGridObject.prototype._addRowClassic=dhtmlXGridObject.prototype.addRow;

    /**
    *   @desc: add new row to treeGrid
    *   @param: new_id  - new row id
    *   @param: text  - array of row label
    *   @param: ind  - position of row (set to null, for using parentId)
    *   @param: parent_id  - id of parent row
    *   @param: img  - img url for new row
    *   @param: child - child flag [optional]
    *   @type: public
    *   @edition: Professional
    */
dhtmlXGridObject.prototype.addRow=function(new_id,text,ind,parent_id,img,child){ 
	if (!this._h2) return this._addRowClassic(new_id,text,ind);
	parent_id=parent_id||0;
	var trcol=this.cellType._dhx_find("tree");
    if (typeof(text)=="string") text=text.split(this.delim);
    var row=this._h2.get[new_id];
    if (!row){
	    if (parent_id==0) ind=this.rowsBuffer.length;
	    else{
	    	ind=this.getRowIndex(parent_id)+1;
			if (this._h2.get[parent_id].state=="minus") 
				ind+=this._getOpenLenght(parent_id,0);
            else
				this._skipInsert=true;
            }
}
	row=row||this._h2.add(new_id,parent_id);
	row.image=img;
	row.has_kids=child;
    return row.buff=this._addRowClassic(new_id,text,ind);
}
    /**
    *   @desc: add new row to treeGrid, before some other row
    *   @param: new_id  - new row id
    *   @param: text  - array of row label
    *   @param: sibl_id  - id of row, related to which new one will be added
    *   @param: img  - img url for new row
    *   @param: child - child flag [optional]
    *   @type: public
    *   @edition: Professional
    */
dhtmlXGridObject.prototype.addRowBefore=function(new_id,text,sibl_id,img,child){
	var sb=this.rowsAr[sibl_id];
	if (!sb) return;
	if (!this._h2) return this.addRow(new_id,text,this.getRowIndex(sibl_id));
	var pid=this._h2.get[sibl_id].parent.id;

	var ind=this.getRowIndex(sibl_id);
	if (ind==-1) this._skipInsert=true;
	this._h2.addBefore(new_id,pid,sibl_id);
	return this.addRow(new_id,text,ind,this._h2.get[sibl_id].parent.id,img,child);
}
    /**
    *   @desc: add new row to treeGrid, after some other row
    *   @param: new_id  - new row id
    *   @param: text  - array of row label
    *   @param: sibl_id  - id of row, related to which new one will be added
    *   @param: img  - img url for new row
    *   @param: child - child flag [optional]
    *   @type: public
    *   @edition: Professional
    */
dhtmlXGridObject.prototype.addRowAfter=function(new_id,text,sibl_id,img,child){
	var sb=this.rowsAr[sibl_id];
	if (!sb) return;
	if (!this._h2) return this.addRow(new_id,text,this.getRowIndex(sibl_id)+1);
	var pid=this._h2.get[sibl_id].parent.id;

	var ind=this.getRowIndex(sibl_id);
	if (ind==-1) this._skipInsert=true;
	if (this._h2.get[sibl_id].state=="minus") ind+=this._getOpenLenght(sibl_id,0)+1;	
	else	ind++;
	
	this._h2.addAfter(new_id,pid,sibl_id);
	return this.addRow(new_id,text,ind,pid,img,child);
}





dhtmlXGridObject.prototype.enableSmartXMLParsing=function(mode) {
	this._slowParse=dhx4.s2b(mode);
};



    /**
    *   @desc: copy content between different rows
    *   @param: frRow  - source row object
    *   @param: from_row_id  - source row id
    *   @param: to_row_id  - target row id
    *   @type: private
    */
dhtmlXGridObject.prototype._copyTreeGridRowContent=function(frRow,from_row_id,to_row_id){
    var z=this.cellType._dhx_find("tree");
    for(i=0;i<frRow.cells.length;i++){
        if (i!=z)
           this.cells(to_row_id,i).setValue(this.cells(from_row_id,i).getValue())
        else
            this.cells(to_row_id,i).setValueA(this.cells(from_row_id,i).getValue())

    }
}

/**
*   @desc: collapse row
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.closeItem=function(rowId){
        var x=this.getRowById(rowId);
        if (!x) return;
        this.collapseKids(x);
}
/**
*   @desc: delete all childs of row in question
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.deleteChildItems=function(rowId){
        var z=this._h2.get[rowId];
        if (!z) return;
        while (z.childs.length)
            this.deleteRow(z.childs[0].id);
            
}
/**
*   @desc: get list of id of all nested rows
*   @param: rowId - id of row
*   @type:  public
*   @returns: list of id of all nested rows
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.getAllSubItems=function(rowId){
        var str=[];
        var z=this._h2.get[rowId||0];
        if (z)
        for (var i=0; i<z.childs.length; i++){
            str.push(z.childs[i].id);
            if (z.childs[i].childs.length)
            str=str.concat(this.getAllSubItems(z.childs[i].id).split(this.delim));
            }

        return str.join(this.delim);
}

/**
*   @desc: get id of child item at specified position
*   @param: rowId - id of row
*   @param: ind - child node index
*   @type:  public
*   @returns: id of child item at specified position
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.getChildItemIdByIndex=function(rowId,ind){
		var z=this._h2.get[rowId||0];
        if (!z) return null;
        return (z.childs[ind]?z.childs[ind].id:null);
}

/**
*   @desc: get real caption of tree col
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @returns: real caption of tree col
*   @topic: 7
*/
dhtmlXGridObject.prototype.getItemText=function(rowId){
        return this.cells(rowId,this.cellType._dhx_find("tree")).getLabel();
}

/**
*   @desc: return open/close state of row
*   @param: rowId - id of row
*   @type:  public
*   @returns: open/close state of row
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.getOpenState=function(rowId){
        var z=this._h2.get[rowId||0];
        if (!z) return;
        if (z.state=="minus") return true;
        return false;
}
/**
*   @desc: return id of parent row
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @returns: id of parent row
*   @topic: 7
*/
dhtmlXGridObject.prototype.getParentId=function(rowId){
        var z=this._h2.get[rowId||0];
        if ((!z) || (!z.parent)) return null;
        return z.parent.id;
}
/**
*   @desc: return list of child row id, sparated by comma
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @returns: list of child rows
*   @topic: 7
*/
dhtmlXGridObject.prototype.getSubItems=function(rowId){
      var str=[];
      var z=this._h2.get[rowId||0];
      if (z)
      	for (var i=0; i<z.childs.length; i++)
      		str.push(z.childs[i].id);
      return str.join(this.delim);
}


/**
*   @desc: expand all tree structure
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.expandAll=function(rowId){
	this._renderAllExpand(rowId||0);
	this._h2_to_buff();
	this._reset_view();
	this.setSizes();
	this.callEvent("onGridReconstructed",[]);
	if (this._redrawLines) this._redrawLines();
}
	
dhtmlXGridObject.prototype._renderAllExpand=function(z){
	var x=this._h2.get[z].childs;
	for (var i=0; i<x.length; i++){
		if (x[i].childs.length){
			this._h2.change(x[i].id,"state","minus")
			this._updateTGRState(x[i]);
			this._renderAllExpand(x[i].id)
		}
	}
}
/**
*   @desc: collapse all tree structure
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.collapseAll=function(rowId){
	this._h2.forEachChild((rowId||0),function(z){
		if (z && z.state=="minus"){
			z.state="plus";
			z.update=true;
			this._updateTGRState(z);
		}
	},this);
	this._h2_to_buff();
	this._reset_view();
	this.setSizes();
	this.callEvent("onGridReconstructed",[]);
	if (this._redrawLines) this._redrawLines();
}

/**
*   @desc: return children count
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @returns: children count
*   @topic: 7
*/
dhtmlXGridObject.prototype.hasChildren=function(rowId){
        var x=this._h2.get[rowId];
        if (x && x.childs.length) return x.childs.length;
        if (x._xml_await) return -1;
        return 0;
}


/**
*   @desc: enable/disable closing of row
*   @param: rowId - id of row
*   @param: status - true/false
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/

dhtmlXGridObject.prototype.setItemCloseable=function(rowId,status){
        var x=this._h2.get[rowId];
        if (!x) return;
        x._closeable=(!dhx4.s2b(status));
}
/**
*   @desc: set real caption of tree col
*   @param: rowId - id of row
*   @param: newtext - new text
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.setItemText=function(rowId,newtext){
	return this.cells(rowId,this.cellType._dhx_find("tree")).setLabel(newtext);
}


/**
*   @desc: set image of tree col
*   @param: rowId - id of row
*   @param: url - image url
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.setItemImage=function(rowId,url){
	this._h2.get[rowId].image=url; 
	this.rowsAr[rowId].imgTag.nextSibling.src=(this.iconURL||"")+url; 
}
dhtmlXGridObject.prototype.setItemIcon=function(rowId,icon){
	this._h2.get[rowId].icon = icon;
	this.rowsAr[rowId].imgTag.nextSibling.className = "dhx_treegrid_icon fa fa-"+icon;
}

/**
*   @desc: get image of tree col
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.getItemImage=function(rowId){
	this.getRowById(rowId);
	return this._h2.get[rowId].image;  
}
dhtmlXGridObject.prototype.getItemIcon=function(rowId){
	this.getRowById(rowId);
	return this._h2.get[rowId].icon;
}


/**
*   @desc: set size of treegrid images
*   @param: width -  width of image
*   @param: height - height of image
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.setImageSize=function(width,height){
        this._img_width=width;
        this._img_height=height;
}


dhtmlXGridObject.prototype._getRowImage=function(row){
	return this._h2.get[row.idd].image;    
        }


/**
*     @desc: set function called before tree node opened/closed
*     @param: func - event handling function
*     @type: public
*     @topic: 0,10
*     @event:  onOpenStart
*     @eventdesc: Event raised immideatly after item in tree got command to open/close , and before item was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
            Event not raised if node opened by dhtmlXtree API.
*     @eventparam: ID of node which will be opened/closed
*     @eventparam: Current open state of tree item. -1 - item closed, 1 - item opened.
*     @eventreturn: true - confirm opening/closing; false - deny opening/closing;
*/
   dhtmlXGridObject.prototype.setOnOpenStartHandler=function(func){  this.attachEvent("onOpenStart",func); };
   
/**
*     @desc: set function called after tree node opened/closed
*     @param: func - event handling function
*     @type: public
*     @topic: 0,10
*     @event:  onOpenEnd
*     @eventdesc: Event raised immideatly after item in tree got command to open/close , and before item was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
            Event not raised if node opened by dhtmlXtree API.
*     @eventparam: ID of node which will be opened/closed
*     @eventparam: Current open state of tree item. -1 - item closed, 1 - item opened.
*/
   dhtmlXGridObject.prototype.setOnOpenEndHandler=function(func){  this.attachEvent("onOpenEnd",func);   };


    /**
*     @desc: enable/disable editor of tree cell ; enabled by default
*     @param: mode -  (boolean) true/false
*     @type: public
*     @topic: 0
*/
   dhtmlXGridObject.prototype.enableTreeCellEdit=function(mode){
        this._edtc=!dhx4.s2b(mode);
    };



/**
*   @desc: return level of treeGrid row
*   @param: rowId - id of row
*   @type:  public
*   @returns: level of treeGrid row
*   @topic: 7
*/
dhtmlXGridObject.prototype.getLevel=function(rowId){      
        var z=this._h2.get[rowId||0];
        if (!z) return -1;
        return z.level;
}

dhtmlXGridObject.prototype._fixHiddenRowsAllTG=function(ind,state){
  for (i in this.rowsAr){
     if ((this.rowsAr[i])&&(this.rowsAr[i].childNodes))
        this.rowsAr[i].childNodes[ind].style.display=state;
  }
}
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype._updateLine=function(z,row){ 
	row=row||this.rowsAr[z.id];
	if (!row) return;
	var im=row.imgTag;
	if (!im) return;
	if (z.state=="blank") return im.src=this.iconTree+"blank.gif";
	
		var n=1;
		if (z.index==0){
			if (z.level==0){
				if ((z.parent.childs.length-1)>z.index)
					n=3;
				else n=1;
			}
			else
			{
				if ((z.parent.childs.length-1)>z.index)
					n=3;
				else
					n=2;
			}
		}
		else
			if ((z.parent.childs.length-1)>z.index)
				n=3;
			else
				n=2;
			
		
		im.src=this.iconTree+z.state+n+".gif";
}
dhtmlXGridObject.prototype._updateParentLine=function(z,row){
		row=row||this.rowsAr[z.id];
		if (!row) return;
		var im=row.imgTag;
		if (!im) return;
		for (var i=z.level; i>0; i--){
			if (z.id==0) break;
			im=im.previousSibling;
			z=z.parent;
			if ((z.parent.childs.length-1)>z.index)
				im.src=this.iconTree+"line1.gif";
			else
				im.src=this.iconTree+"blank.gif";
		}
}

dhtmlXGridObject.prototype._renderSortA=dhtmlXGridObject.prototype._renderSort;
dhtmlXGridObject.prototype._renderSort=function(){
	this._renderSortA.apply(this,arguments);
	this._redrawLines(0)	
} 
dhtmlXGridObject.prototype._redrawLines=function(id){
		if (this._tgle)
			this._h2.forEachChild((id||0),function(z){
					this._updateLine(z);
					this._updateParentLine(z);
			},this);
	}
/**
*   @desc: enable lines in treeGrid 
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableTreeGridLines=function(){
	this._emptyLineImg="line";

	
	this._updateTGRState=function(z,force){ 
		if (force || !z.update || z.id==0) return;
		if (this._tgle)
			this._updateLine(z,this.rowsAr[z.id]);
		z.update=false;
	}

	this._tgle=true;
	this.attachEvent("onXLE",function(a,b,id){
		this._redrawLines(id)
	});    
	
	this.attachEvent("onOpenEnd",function(id){
		this._redrawLines(id)
	});    
	
	
	this.attachEvent("onRowAdded",function(id){ 
		var z=this._h2.get[id];
		this._updateLine(z); 
		this._updateParentLine(z);
		if (z.index<(z.parent.childs.length-1)){
			z=z.parent.childs[z.index+1];
			this._updateLine(z);
			this._updateParentLine(z);
		}
		else if (z.index!=0){
			z=z.parent.childs[z.index-1];
			this._updateLine(z);
			this._updateParentLine(z);
			if (z.childs.length)
				this._h2.forEachChild(z.id,function(c_el){
					this._updateParentLine(c_el)
				},this)
		}
	});
	this.attachEvent("onOpen",function(id,state){ 
		if (state){ 
			var z=this._h2.get[id];
			for (var i=0; i < z.childs.length; i++) 
				this._updateParentLine(z.childs[i]);
		}
		return true;
	});
	this.attachEvent("onBeforeRowDeleted",function(id){
		var self=this;
		var z=this._h2.get[id];
		var w=null;
		if (z.index!=0)
			w=z.parent.childs[z.index-1];
		z=z.parent;
			
		window.setTimeout(function(){
			z  = self._h2.get[z.id];
			if (!z) return;
						
			self._updateLine(z);
			self._updateParentLine(z);
			
			if (w){
				self._updateLine(w);
				if (w.state=="minus")
				self._h2.forEachChild(w.id,function(z){
					self._updateParentLine(z);
				},self);
			}
		},1);
		return true;
	});
} 

//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

//beware that function started from _in_header_ must not be obfuscated


/**
*   @desc: allows to define , which level of tree must be used for filtering
*   @type: public
*   @param: level - level value, -1 value means last one
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.setFiltrationLevel=function(level,show_lower,show_upper){
	this._tr_strfltr=level;
	this._tr_fltr_c=show_lower;
	this._tr_fltr_d=show_upper;
	this.refreshFilters();
}


/**
*   @desc: filter grid by mask
*   @type: public
*   @param: column - {number} zero based index of column
*   @param: value - {string} filtering mask
*   @param: preserve - {bool} filter current or initial state ( false by default )
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.filterTreeBy=function(column, value, preserve){
	var origin = this._h2;
	if (typeof this._tr_strfltr == "undefined") this._tr_strfltr=-1;
	if (this._f_rowsBuffer){
		if (!preserve){
			this._h2=this._f_rowsBuffer;
			if (this._fake) this._fake._h2=this._h2;
		}
	} else
		this._f_rowsBuffer=this._h2;	//backup copy
	
	//if (!this.rowsBuffer.length && preserve) return;
	var d=true;
	this.dma(true)
	this._fbf={};
	if (typeof(column)=="object")
		for (var j=0; j<value.length; j++)
			this._filterTreeA(column[j],value[j]);
	else
			this._filterTreeA(column,value);
	this._fbf=null;
	this.dma(false)
	this._fix_filtered_images(this._h2,origin);
	this._renderSort()
	this.callEvent("onGridReconstructed",[])
}
dhtmlXGridObject.prototype._filterTreeA=function(column,value){ 
	if (value=="") return;
	var d=true;
	if (typeof(value)=="function") d=false;
	else value=(value||"").toString().toLowerCase();
	
	var add_line=function(el,s,t){
			var z=t.get[el.parent.id];
			if (!z) z=add_line(el.parent,s,t)
			var t=temp.get[el.id];
			if (!t){
				t={id:el.id, childs:[], level:el.level, parent:z, index:z.childs.length, image:el.image, state:el.state, buff:el.buff, has_kids:el.has_kids, _xml_await:el._xml_await};
			z.childs.push(t);
			temp.get[t.id]=t;
			}
			return t;
	}
	var fbf=this._fbf;
	var temp = this._createHierarchy();
	var check; 
	var mode = this._tr_strfltr;
	var that=this;	
	var temp_c=function(el){
		for (var i=0; i < el.childs.length; i++) 
			that.temp(el.childs[i]);
	}
	switch(mode.toString()){
		case "-2": check=function(el){ if (fbf[el.id]) return false; temp_c(el); return true;}; break;
		case "-1": check=function(el){return !el.childs.length;}; break;
		default: check=function(el){return mode==el.level}; break;
	}
	this.temp=function(el){
		if (el.id!=0 && check(el)){
			if (d?(this._get_cell_value(el.buff,column).toString().toLowerCase().indexOf(value)==-1):(!value(this._get_cell_value(el.buff,column),el.id))){
				fbf[el.id]=true;
				if (this._tr_fltr_c) add_line(el.parent,this._h2,temp);
				return false;
			} else {
				add_line(el,this._h2,temp);
				if (el.childs && mode!=-2)
					this._h2.forEachChild(el.id,function(cel){
						add_line(cel,this._h2,temp);
					},this)
				return true;
			}
		} else {
			if (this._tr_fltr_d && this._tr_strfltr > el.level && el.id!=0) add_line(el,this._h2,temp);
			temp_c(el);
		}
	}

	
	this.temp(this._h2.get[0]);
	this._h2=temp;	
	if (this._fake) this._fake._h2=this._h2;
}

dhtmlXGridObject.prototype._fix_filtered_images=function(temp,origin){
		temp.forEachChild(0,function(el){
		if (!el.childs.length && !el.has_kids){
			if (el.state!=this._emptyLineImg){
				el.state=this._emptyLineImg;
				el.update=true;
				this._updateTGRState(el);
			}
		} else {
			if (el.buff.tagName=="TR"){
				var prev=origin.get[el.id];
				if (prev && prev.state!=this._emptyLineImg)
					el.state=prev.state;
				el.update=true;
				this._updateTGRState(el);
			}
		}
	},this)
}
/**
*   @desc: get all possible values in column
*   @type: public
*   @param: column - {number} zero based index of column
*   @returns: {array} array of all possible values in column
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.collectTreeValues=function(column){
	if (typeof this._tr_strfltr == "undefined") this._tr_strfltr=-1;
	this.dma(true)
	this._build_m_order();		
	column=this._m_order?this._m_order[column]:column;
	var c={}; var f=[];
	var col=this._f_rowsBuffer||this._h2;
	col.forEachChild(0,function(el){
		if (this._tr_strfltr==-2 || (this._tr_strfltr==-1 && !el.childs.length) || (this._tr_strfltr==el.level)){
			var val=this._get_cell_value(el.buff,column);
			if (val) c[val]=true;
    	}
	},this);
	this.dma(false)
	
	var vals=this.combos[column];
	for (var d in c) 
		if (c[d]===true) f.push(vals?(vals.get(d)||d):d);
	
	return f.sort();			
}




dhtmlXGridObject.prototype._in_header_stat_tree_total=function(t,i,c){
	var calck=function(){
		var summ=0;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		this._h2.forEachChild(0,function(el){
			var v=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			summ+=isNaN(v)?0:v;
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ*100)/100);
	}
	this._stat_in_header(t,calck,i,c,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_total_leaf=function(t,i,c){
	var calck=function(){
		var summ=0;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		this._h2.forEachChild(0,function(el){
			if (el.childs.length) return;
			var v=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			summ+=isNaN(v)?0:v;
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ*100)/100);
	}
	this._stat_in_header(t,calck,i,c,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_multi_total=function(t,i,c){
	var cols=c[1].split(":"); c[1]="";
	var calck=function(){
		var summ=0;
		this._h2.forEachChild(0,function(el){
			var v=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),cols[0]))*parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),cols[1]));
			summ+=isNaN(v)?0:v;
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ*100)/100);
	}
	this._stat_in_header(t,calck,i,c,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_multi_total_leaf=function(t,i,c){
	var cols=c[1].split(":"); c[1]="";
	var calck=function(){
		var summ=0;
		this._h2.forEachChild(0,function(el){
			if (el.childs.length) return;
			var v=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),cols[0]))*parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),cols[1]));
			summ+=isNaN(v)?0:v;
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ*100)/100);
	}
	this._stat_in_header(t,calck,i,c,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_max=function(t,i,c){
	var calck=function(){
		var summ=-999999999;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		if (this.getRowsNum()==0) return "";
		this._h2.forEachChild(0,function(el){
			var d=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			if (!isNaN(d))
				summ=Math.max(summ,d);
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):summ;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_min=function(t,i,c){
	var calck=function(){
		var summ=999999999;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		if (this.getRowsNum()==0) return "";
		this._h2.forEachChild(0,function(el){
			var d=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			if (!isNaN(d))
				summ=Math.min(summ,d);
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):summ;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_average=function(t,i,c){
	var calck=function(){
		var summ=0; var count=0;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		this._h2.forEachChild(0,function(el){
			var v=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			summ+=isNaN(v)?0:v;
			count++;
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ/count*100)/100);
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_max_leaf=function(t,i,c){
	var calck=function(){
		var summ=-999999999;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		if (this.getRowsNum()==0) return "";
		this._h2.forEachChild(0,function(el){
			if (el.childs.length) return;
			var d=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			if (!isNaN(d))
				summ=Math.max(summ,d);
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):summ;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_min_leaf=function(t,i,c){
	var calck=function(){
		var summ=999999999;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		if (this.getRowsNum()==0) return "";
		this._h2.forEachChild(0,function(el){
			if (el.childs.length) return;
			var d=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			if (!isNaN(d))
				summ=Math.min(summ,d);
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):summ;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_average_leaf=function(t,i,c){
	var calck=function(){
		var summ=0; var count=0;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		this._h2.forEachChild(0,function(el){
			if (el.childs.length) return;
			var v=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			summ+=isNaN(v)?0:v;
			count++;
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ/count*100)/100);
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_count=function(t,i,c){
	var calck=function(){
		var count=0;
		this._h2.forEachChild(0,function(el){
			count++;
		},this)
		return count;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_count_leaf=function(t,i,c){
	var calck=function(){
		var count=0;
		this._h2.forEachChild(0,function(el){
			if (!el.childs.length) count++;
		},this)
		return count;
	}
	this._stat_in_header(t,calck,i,c);
}

dhtmlXGridObject.prototype._stat_in_header=function(t,calck,i,c){
//	if (this._realfake) return this._fake._stat_in_header(t,calck,i,c);
	var that=this;
	var f=function(){
		this.dma(true)
		t.innerHTML=(c[0]?c[0]:"")+calck.call(this)+(c[1]?c[1]:"");
		this.dma(false)
		this.callEvent("onStatReady",[])
	}
	if (!this._stat_events) {
		this._stat_events=[];
		this.attachEvent("onClearAll",function(){ 
			if (!this.hdr.rows[1]){
				for (var i=0; i<this._stat_events.length; i++)
					for (var j=0; j < 4; j++) 
						this.detachEvent(this._stat_events[i][j]);
				this._stat_events=[];	
			}
		})
	}
	
	this._stat_events.push([
	this.attachEvent("onGridReconstructed",f),
	this.attachEvent("onXLE",f),
	this.attachEvent("onFilterEnd",f),
	this.attachEvent("onEditCell",function(stage,id,ind){
		if (stage==2 && ind==i) f.call(this);
		return true;
		})]);
	t.innerHTML="";
}
dhtmlXGridObject.prototype._build_m_order=function(){
	if (this._c_order){
		this._m_order=[]
		for (var i=0; i < this._c_order.length; i++) {
			this._m_order[this._c_order[i]]=i;
		};
	}
}


//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXForm(parentObj, data, skin) {
	
	this.idef = {
		position:	"label-left",
		labelWidth:	"auto",
		labelHeight:	"auto",
		inputWidth:	"auto",
		inputHeight:	"auto",
		labelAlign:	"left",
		noteWidth:	"auto",
		offsetTop:	0,
		offsetLeft:	0,
		blockOffset:	20 // block only
	};
	this.idef_const = {
		offsetNested:	20 // sub_level
	};
	this.apos_css = {
		"label-left":	"dhxform_item_label_left",
		"label-right":	"dhxform_item_label_right",
		"label-top":	"dhxform_item_label_top",
		"label-bottom":	"dhxform_item_label_bottom", // new
		"absolute":	"dhxform_item_absolute"
	};
	this.align_css = {
		left:		"dhxform_label_align_left",
		center:		"dhxform_label_align_center",
		right:		"dhxform_label_align_right"
	};
	
	var that = this;
	
	// define skin
	
	// 1) skin 3rd arg [new]
	// 2) dhtmlx.skin
	// 3) autodetect skin
	// 4) default skyblue
	
	this.setSkin = function(skin) {
		this.skin = skin;
		this.cont.className = "dhxform_obj_"+this.skin;
		this.cont.style.fontSize = (skin=="material"?"14px":(skin=="dhx_terrace"?"13px":"12px"));
		this._updateBlocks();
		// update calendar skin
		this.forEachItem(function(id){
			var t = that.getItemType(id);
			if (typeof(that.items[t]) != "undefined" && typeof(that.items[t].setSkin) == "function") {
				that.doWithItem(id, "setSkin", skin);
			}
		});
	}
	
	this.skin = (skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhx_form")||"material");
	
	this.separator = ",";
	this.live_validate = false;
	
	this._type = "checkbox";
	this._rGroup = "default";
	
	this._idIndex = {};
	this._indexId = [];
	
	this.cont = (typeof(parentObj)=="object"?parentObj:document.getElementById(parentObj));
	
	if (!parentObj._isNestedForm) {
		
		this._parentForm = true;
		
		this.cont.style.fontSize = (this.skin=="material"?"14px":(this.skin=="dhx_terrace"?"13px":"12px"));
		this.cont.className = "dhxform_obj_"+this.skin;
		
		this.setFontSize = function(fs) {
			this.cont.style.fontSize = fs;
			this._updateBlocks();
		}
		
		this.getForm = function() {
			return this;
		}
		
		this.cont.onkeypress = function(e) {
			e = (e||event);
			if (e.keyCode == 13) {
				var t = (e.target||e.srcElement);
				if (typeof(t.tagName) != "undefined" && String(t.tagName).toLowerCase() == "textarea" && !e.ctrlKey) return;
				that.callEvent("onEnter",[]);
			}
		}
		
	}
	
	this.b_index = null;
	this.base = [];
	this._prepare = function(ofsLeft, pos) {
		
		if (this.b_index == null) this.b_index = 0; else this.b_index++;
		
		// if pos specified, check all items inside all bases,
		var insBeforeBase = null; // base
		var insBeforeItem = null; // items from start to move next-items within single base
		
		if (pos != null) {
			if (pos < 0) pos = 0;
			var i = 0;
			for (var w=0; w<this.cont.childNodes.length; w++) { // bases sit here, 1 base = 1 newcolumn
				for (var q=0; q<this.cont.childNodes[w].childNodes.length; q++) { // items inside single base, i.e.between two nearest newcolumns/form_start/form_end
					if (insBeforeItem == null && this.cont.childNodes[w].childNodes[q]._isNestedForm != true) {
						if (i == pos) {
							insBeforeBase = this.cont.childNodes[w].nextSibling; // insert new column before this base
							insBeforeItem = this.cont.childNodes[w].childNodes[q]; // move all items within single base from this item to end of base to new column
						}
						i++;
					}
				}
			}
		}
		
		this.base[this.b_index] = document.createElement("DIV");
		this.base[this.b_index].className = "dhxform_base";
		
		if (typeof(ofsLeft) != "undefined") this.base[this.b_index].style.cssText += " margin-left:"+ofsLeft+"px!important;";
		
		// add block
		if (insBeforeBase != null) {
			this.cont.insertBefore(this.base[this.b_index], insBeforeBase);
			insBeforeBase = null;
		} else {
			this.cont.appendChild(this.base[this.b_index]);
		}
		
		// move items if any
		if (insBeforeItem != null) {
			while (insBeforeItem != null) {
				var t = insBeforeItem;
				insBeforeItem = insBeforeItem.nextSibling;
				this.base[this.b_index].appendChild(t);
				t = null;
			}
		}
	}
	
	
	this.setSizes = function() {
		/*
		for (var q=0; q<this.base.length; q++) {
			this.base.style.height = this.cont.offsetHeight+"px";
			this.base.style.overflow = "auto";
		}
		*/
	}
	
	this._mergeSettings = function(data) {
		
		var u = -1;
		var i = {type: "settings"};
		for (var a in this.idef) i[a] = this.idef[a];
		
		for (var q=0; q<data.length; q++) {
			if (typeof(data[q]) != "undefined" && data[q].type == "settings") {
				for (var a in data[q]) i[a] = data[q][a];
				u = q;
			}
		}
		data[u>=0?u:data.length] = i;
		return data;
	}
	
	this._genStr = function(w) {
		var s = "dhxId_";
		var z = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
		for (var q=0; q<w; q++) s += z.charAt(Math.floor(Math.random() * z.length));
		return s;
	}
	
	this.idPrefix = "dhxForm_"+this._genStr(12)+"_";
	
	this._rId = (this._parentForm?this._genStr(12)+"_":parentObj._rId);
	
	this.objPull = {};
	this.itemPull = {};
	this._ic = 0;
	
	this._addItem = function(type, id, data, sId, lp, pos, insertAfter) {
		
		// id-index
		if (this.items[type]._index) {
			this.getForm()._indexId.push(id);
			this.getForm()._idIndex[id] = {ind: this.getForm()._indexId.length-1};
		}
		
		if (!type) type = this._type;
		
		if (type == "list" && lp != null && this.itemPull[this.idPrefix+lp] != null && typeof(this.itemPull[this.idPrefix+lp]._addSubListNode) == "function") {
			var tr = this.itemPull[this.idPrefix+lp]._addSubListNode();
		} else {
			if (type == "newcolumn") {
				var tr = {};
			} else {
				if (this.b_index == null) this._prepare(); // form wasn't inited and item added via dyn funcs
				var insBeforeBase = this.base[this.b_index];
				var insBeforeItem = null;
				if (typeof(pos) != "undefined" && !isNaN(pos) && type != "list") {
					pos = Math.max(parseInt(pos), 0)+1;
					for (var w=0; w<this.cont.childNodes.length; w++) {
						for (var q=0; q<this.cont.childNodes[w].childNodes.length; q++) {
							if (insBeforeItem == null && this.cont.childNodes[w].childNodes[q]._isNestedForm != true) {
								pos--;
								if (pos == 0) {
									insBeforeItem = this.cont.childNodes[w].childNodes[q];
									insBeforeBase = this.cont.childNodes[w];
								}
							}
						}
					}
				} else if (type == "list") { //??
					for (var a in this.itemPull) {
						if (a == this.idPrefix+id) {
							insBeforeItem = this.itemPull[a].nextSibling;
							if (this.itemPull[a]._listBase != null && this.itemPull[a]._listBase.length > 0) {
								insBeforeItem = this.itemPull[a]._listBase[this.itemPull[a]._listBase.length-1];
							}
							
						}
					}
				}
				var tr = document.createElement("DIV");
				if (insertAfter == true && insBeforeItem != null) insBeforeItem = insBeforeItem.nextSibling;
				if (insBeforeItem != null) {
					insBeforeBase.insertBefore(tr, insBeforeItem);
				} else {
					insBeforeBase.appendChild(tr);
				}
			}
		}
		
		tr._idd = id;
		tr._rId = this._rId;
		
		if (typeof(tr.style) != "undefined") {
			// read from settings if not set
			if (typeof(data.offsetLeft) == "undefined" && this.idef.offsetLeft > 0) data.offsetLeft = this.idef.offsetLeft;
			if (typeof(data.offsetTop) == "undefined" && this.idef.offsetTop > 0) data.offsetTop = this.idef.offsetTop;
			//
			var k = "";
			if (typeof(data.offsetLeft) != "undefined") k += " padding-left:"+data.offsetLeft+"px!important;";
			if (typeof(data.offsetTop) != "undefined") k += " padding-top:"+data.offsetTop+"px!important;";
			tr.style.cssText += k;
		}
		
		if (type == "block") {
			if (isNaN(data.blockOffset)) data.blockOffset = this.idef.blockOffset;
		}
		
		if (type == "list") {
			
			if (typeof(tr._ofsNested) == "undefined") tr._ofsNested = this.idef_const.offsetNested;
			
			if (sId != null) tr._sId = sId;
			
			var listData = this.items[type].render(tr, this.skin);
			
			if (!this.itemPull[this.idPrefix+id]._listObj) this.itemPull[this.idPrefix+id]._listObj = [];
			if (!this.itemPull[this.idPrefix+id]._list) this.itemPull[this.idPrefix+id]._list = [];
			if (!this.itemPull[this.idPrefix+id]._listBase) this.itemPull[this.idPrefix+id]._listBase = [];
			
			(this.itemPull[this.idPrefix+id]._listObj).push(listData[0]);
			(this.itemPull[this.idPrefix+id]._list).push(listData[1]);
			(this.itemPull[this.idPrefix+id]._listBase).push(tr);
			
			listData[1].checkEvent = function(evName) {
				return that.checkEvent(evName);
			}
			listData[1].callEvent = function(evName, evData) {
				return that.callEvent(evName, evData);
			}
			listData[1].getForm = function() {
				return that.getForm();
			}
			listData[1]._initObj(this._mergeSettings(data));
			
			if (tr._inBlcok) tr.className += " in_block";
			
			return listData[1];
			
		}
		
		if (type == "newcolumn") {
			this._prepare(data.offset, pos);
			return;
		}
		
		if (type == "label" && this._ic++ == 0) data._isTopmost = true;
		
		data.position = this.apos_css[(!data.position||!this.apos_css[data.position]?this.idef.position:data.position)];
		tr.className = data.position+(typeof(data.className)=="string"?" "+data.className:"");
		
		if (!data.labelWidth) data.labelWidth = this.idef.labelWidth;
		if (!data.labelHeight) data.labelHeight = this.idef.labelHeight;
		
		if (typeof(data.wrap) != "undefined") data.wrap = window.dhx4.s2b(data.wrap);
			
		data.labelAlign = (this.align_css[data.labelAlign]?this.align_css[data.labelAlign]:this.align_css[this.idef.labelAlign]);
		
		data.inputWidth = (data.width?data.width:(data.inputWidth?data.inputWidth:this.idef.inputWidth));
		if (!data.inputHeight) data.inputHeight = this.idef.inputHeight;
		
		if (typeof(data.note) != "undefined") {
			if (data.note.length != null && data.note[0] != null) data.note = data.note[0]; // probably array from xml conversion
			if (typeof(data.note.width) == "undefined") data.note.width = this.idef.noteWidth;
			if (data.note.width == "auto") data.note.width = data.inputWidth;
		}
		
		tr.checkEvent = function(evName) {
			return that.checkEvent(evName);
		}
		tr.callEvent = function(evName, evData) {
			return that.callEvent(evName, evData);
		}
		tr.getForm = function() {
			return that.getForm();
		}
		tr._autoCheck = function(t) {
			that._autoCheck(t);
		}
		
		// convert r/o
		if (typeof(data.readonly) == "string") data.readonly = window.dhx4.s2b(data.readonly);
		if (typeof(data.autoStart) == "string") data.autoStart = window.dhx4.s2b(data.autoStart);
		if (typeof(data.autoRemove) == "string") data.autoRemove = window.dhx4.s2b(data.autoRemove);
		if (typeof(data.titleScreen) == "string") data.titleScreen = window.dhx4.s2b(data.titleScreen);
		if (typeof(data.info) == "string") data.info = window.dhx4.s2b(data.info);
		if (typeof(data.hidden) == "string") data.hidden = window.dhx4.s2b(data.hidden);
		if (typeof(data.checked) == "string") data.checked = window.dhx4.s2b(data.checked);
		
		// userdata
		if (typeof(data.userdata) != "undefined") {
			for (var a in data.userdata) this.getForm().setUserData(id,a,data.userdata[a]);
		}
		
		// validate
		if (data.validate) {
			if (typeof(data.validate != "undefined") && (typeof(data.validate) == "function" || typeof(window[data.validate]) == "function")) {
				tr._validate = [data.validate];
			} else {
				tr._validate = String(data.validate).split(this.separator);
			}
		}
		if (typeof(data.required) != "undefined") {
			if (typeof(data.required) == "string") data.required = window.dhx4.s2b(data.required);
			tr._required = (data.required==true);
		}
		if (tr._required) {
			if (!tr._validate) tr._validate = [];
			var p = false;
			for (q=0; q<tr._validate.length; q++) p = (p||(tr._validate[q]=="NotEmpty"));
			if (!p) tr._validate.push("NotEmpty");
		}
		
		tr._ll = (data.position == this.apos_css["label-left"] || data.position == this.apos_css["label-top"]);
		
		this.objPull[this.idPrefix+id] = this.items[type].render(tr, data);
		this.itemPull[this.idPrefix+id] = tr;
		
	}
	
	/*********************************************************************************************************************************************
		OBJECT INIT
	*********************************************************************************************************************************************/
	
	this._initObj = function(data, url) {
		
		if (typeof(data.data) != "undefined") {
			// data loading
			var id = null;
			if (typeof(url) != "undefined") {
				id = url.match(/(\?|\&)id\=([a-z0-9_\-]*)/i);
				if (id != null && id[0] != null) id = id[0].split("=")[1];
			}
			if (this.callEvent("onBeforeDataLoad", [id, window.dhx4._copyObj(data.data)]) === true) {
				this.formId = id;
				this._last_load_data = data;
				this.setFormData(data.data);
				this.resetDataProcessor("updated");
			}
			
			return;
		}
		
		// struct
		this._prepare();
		
		// search form settings
		for (var q=0; q<data.length; q++) {
			// add check for incorrect values:
			// position - allow only predefined, this.apos_css
			// labelAlign - allow only predefined, this.align_css
			// input/label top/left/width/height - numeric or auto
			if (typeof(data[q]) != "undefined" && data[q].type == "settings") for (var a in data[q]) this.idef[a] = data[q][a];
		}
		
		for (var q=0; q<data.length; q++) this._prepareItem(data[q]);
		
		this._autoCheck();
	}
	
	this._prepareItem = function(data, pos, insertAfter) {
		
		var type = (data!=null && data.type!=null ? data.type : "");
		
		if (this.items[type]) {
			
			if (!data.name) data.name = this._genStr(12);
			var id = data.name;
			if (this.objPull[this.idPrefix+id] != null || type=="radio") id = this._genStr(12);
			
			var obj = data;
			obj.label = obj.label||"";
			//obj.value = obj.value||"";
			obj.value = obj.value;
			obj.checked = window.dhx4.s2b(obj.checked);
			obj.disabled = window.dhx4.s2b(obj.disabled);
			obj.name = obj.name||this._genStr(12);
			obj.options = obj.options||[];
			obj.rows = obj.rows||"none";
			obj.uid = this._genStr(12);
			
			this._addItem(type, id, obj, null, null, pos, insertAfter);
			pos = null;
			
			if (this._parentEnabled === false) this._disableItem(id);
			
			for (var w=0; w<obj.options.length; w++) {
				if (obj.options[w].list != null) {
					if (!obj.options[w].value) obj.options[w].value = this._genStr();
					var subList = this._addItem("list", id, obj.options[w].list, obj.options[w].value, null);
					subList._subSelect = true;
					subList._subSelectId = obj.options[w].value;
				}
			}
			
			
			if (data.list != null) {
				if (!data.listParent) data.listParent = obj.name;//data[q].name;
				var subList = this._addItem("list", id, data.list, null, data.listParent);
			}
		}
	}
	
	/*********************************************************************************************************************************************
		XML
	*********************************************************************************************************************************************/
	
	this._xmlSubItems = {item: "list", option: "options", note: "note", userdata: "_userdata"};
	
	this._xmlToObject = function(xml, rootLevel) {
		
		if (typeof(rootLevel) == "undefined") rootLevel = true;
		
		if (rootLevel) {
			
			// try struct
			var xmlStruct = xml.getElementsByTagName("items");
			xmlStruct = (xmlStruct != null && xmlStruct[0] != null ? xmlStruct[0] : null);
			// try data
			var xmlData = xml.getElementsByTagName("data");
			xmlData = (xmlData != null && xmlData[0] != null ? xmlData[0] : null);
			
		} else {
			xmlStruct = xml;
		}
		
		var data = (rootLevel?[]:{});
		
		if (xmlStruct != null) {
			
			for (var q=0; q<xmlStruct.childNodes.length; q++) {
				
				if (typeof(xmlStruct.childNodes[q].tagName) != "undefined") {
					
					var tg = xmlStruct.childNodes[q].tagName;
					
					if (this._xmlSubItems[tg] != null) {
						
						var node = this._xmlSubItems[tg];
						if (typeof(data[node]) == "undefined") data[node] = [];
						
						var xn = xmlStruct.childNodes[q];
						
						// parse attributes
						var k = {};
						for (var w=0; w<xn.attributes.length; w++) {
							var attrName = xn.attributes[w].name;
							var attrValue = xn.attributes[w].value;
							k[attrName] = attrValue;
						}
						
						// parse custom data
						if (node == "note") k.text = xn.firstChild.nodeValue;
						
						// pasrse userdata value
						if (node == "_userdata") k.value = (xn.firstChild != null && xn.firstChild.nodeValue != null ? xn.firstChild.nodeValue : "");
						
						// parse nested items, merge with current
						var data2 = this._xmlToObject(xn, false);
						for (var a in data2) {
							if (a == "_userdata") {
								if (!k.userdata) k.userdata = {};
								for (var w=0; w<data2[a].length; w++) k.userdata[data2[a][w].name] = data2[a][w].value;
							} else {
								k[a] = data2[a];
							}
						}
						xn = null;
						if (rootLevel) data.push(k); else data[node].push(k);
						
					}
				}
			}
		}
		
		if (xmlData != null) {
			data = {data:{}};
			for (var q=0; q<xmlData.childNodes.length; q++) {
				if (typeof(xmlData.childNodes[q].tagName) != "undefined") {
					var name = xmlData.childNodes[q].tagName;
					var value = (xmlData.childNodes[q].firstChild!=null?xmlData.childNodes[q].firstChild.nodeValue:"");
					data.data[name] = value;
				}
			}
		}
		
		return data;
		
	}
	
	/*********************************************************************************************************************************************
		AUTOCHECK (Global enable/disable functionality)
	*********************************************************************************************************************************************/
	
	this._autoCheck = function(enabled) {
		if (this._locked === true) {
			enabled = false;
		} else {
			if (typeof(enabled) == "undefined") enabled = true;
		}
		for (var a in this.itemPull) {
			var isEnabled = (enabled&&(this.itemPull[a]._udis!==true));
			this[isEnabled?"_enableItem":"_disableItem"](this.itemPull[a]._idd);
			
			// id-index state
			if (this.getForm()._idIndex[this.itemPull[a]._idd] != null) {
				this.getForm()._idIndex[this.itemPull[a]._idd].enabled = isEnabled;
			}
			
			// nested forms
			var pEnabled = (isEnabled&&(typeof(this.itemPull[a]._checked)=="boolean"?this.itemPull[a]._checked:true));
			if (this.itemPull[a]._list) {
				for (var q=0; q<this.itemPull[a]._list.length; q++) {
					var f = true;
					if (this.itemPull[a]._list[q]._subSelect == true) {
						f = false
						var v = this.getItemValue(this.itemPull[a]._idd);
						if (!(typeof(v) == "object" && typeof(v.length) == "number")) v = [v];
						for (var w=0; w<v.length; w++) f = (v[w]==this.itemPull[a]._list[q]._subSelectId)||f;
						this.itemPull[a]._listObj[q][f?"show":"hide"](this.itemPull[a]._listBase[q]);
					}
					this.itemPull[a]._list[q]._autoCheck(pEnabled&&f);
				}
			}
		}
	}
	
	/*********************************************************************************************************************************************
		PUBLIC API
	*********************************************************************************************************************************************/
	
	this.doWithItem = function(id, method, a, b, c, d) {
		// radio
		//console.log(method)
		
		if (typeof(id) == "object") {
			var group = id[0];
			var value = id[1];
			var item = null;
			var res = null;
			for (var k in this.itemPull) {
				if ((this.itemPull[k]._value == value || value === null) && this.itemPull[k]._group == group) return this.objPull[k][method](this.itemPull[k], a, b, c, d);
				if (this.itemPull[k]._list != null && !res) {
					for (var q=0; q<this.itemPull[k]._list.length; q++) {
						res = this.itemPull[k]._list[q].doWithItem(id, method, a, b, c);
					}
				}
			}
			if (res != null) {
				return res;
			} else {
				if (method == "getType") return this.doWithItem(id[0], "getType");
			}
		// checkbox, input, select, label
		} else {
			if (!this.itemPull[this.idPrefix+id]) {
				var res = null;
				for (var k in this.itemPull) {
					if (this.itemPull[k]._list && !res) {
						for (var q=0; q<this.itemPull[k]._list.length; q++) {
							if (res == null) res = this.itemPull[k]._list[q].doWithItem(id, method, a, b, c, d);
						}
					}
				}
				return res;
			} else {
				return this.objPull[this.idPrefix+id][method](this.itemPull[this.idPrefix+id], a, b, c, d);
			}
		}
	}
	
	this._removeItem = function(id, value) {
		if (value != null) id = this.doWithItem([id, value], "destruct"); else this.doWithItem(id, "destruct");
		this._clearItemData(id);
	}
	
	this._clearItemData = function(id) {
		if (this.itemPull[this.idPrefix+id]) {
			id = this.idPrefix+id;
			try {
				this.objPull[id] = null;
				this.itemPull[id] = null;
				delete this.objPull[id];
				delete this.itemPull[id];
			} catch(e) {}
		} else {
			for (var k in this.itemPull) {
				if (this.itemPull[k]._list) {
					for (var q=0; q<this.itemPull[k]._list.length; q++) this.itemPull[k]._list[q]._clearItemData(id);
				}
			}
		}
	}
	
	this.isItem = function(id, value) {
		if (value != null) id = [id, value];
		return this.doWithItem(id, "isExist");
	}
	
	this.getItemType = function(id, value) {
		id = [id, (value||null)];
		return this.doWithItem(id, "getType");
	}

	/* iterator */
	this.forEachItem = function(handler) {
		for (var a in this.objPull) {
			if (this.objPull[a].t == "radio") {
				handler(this.itemPull[a]._group, this.itemPull[a]._value);
			} else {
				handler(String(a).replace(this.idPrefix,""));
			}
			if (this.itemPull[a]._list) {
				for (var q=0; q<this.itemPull[a]._list.length; q++) this.itemPull[a]._list[q].forEachItem(handler);
			}
		}
	}
	
	/* text */
	this.setItemLabel = function(id, value, text) {
		if (text != null) id = [id, value]; else text = value;
		this.doWithItem(id, "setText", text);
	}
	
	this.getItemLabel = function(id, value) {
		if (value != null) id = [id, value];
		return this.doWithItem(id, "getText");
	}
	
	/* state */
	this._enableItem = function(id) {
		this.doWithItem(id, "enable");
	}
	
	this._disableItem = function(id) {
		this.doWithItem(id, "disable");
	}
	
	this._isItemEnabled = function(id) {
		return this.doWithItem(id, "isEnabled");
	}
	
	/* selection */
	this.checkItem = function(id, value) {
		if (value != null) id = [id, value];
		this.doWithItem(id, "check");
		this._autoCheck();
	}
	
	this.uncheckItem = function(id, value) {
		if (value != null) id = [id, value];
		this.doWithItem(id, "unCheck");
		this._autoCheck();
	}
	
	this.isItemChecked = function(id, value) {
		if (value != null) id = [id, value];
		return this.doWithItem(id, "isChecked");
	}
	
	this.getCheckedValue = function(id) {
		return this.doWithItem([id, null], "getChecked");
	}
	
	/* value */
	
	// get radio group by id
	this._getRGroup = function(id, val) {
		for (var a in this.itemPull) {
			if (this.itemPull[a]._group == id && (val == null || this.itemPull[a]._value == val)) return this.itemPull[a]._idd;
			if (this.itemPull[a]._list != null) {
				for (var q=0; q<this.itemPull[a]._list.length; q++) {
					var r = this.itemPull[a]._list[q]._getRGroup(id, val);
					if (r != null) return r;
				}
			}
		}
		return null;
	}
	
	this.setItemValue = function(id, value) {
		this.resetValidateCss(id, value);
		if (this.getItemType(id) == "radio") {
			if (this._getRGroup(id, value) != null) this.checkItem(id, value); else this.uncheckItem(id, this.getCheckedValue(id));
			return null;
		}
		return this.doWithItem(id, "setValue", value);
	}
	
	this.getItemValue = function(id, param) {
		if (this.getItemType(id) == "radio") return this.getCheckedValue(id);
		return this.doWithItem(id, "getValue", param);
	}
	
	this.updateValues = function() {
		this._updateValues();
	}
	
	/* visibility */
	this.showItem = function(id, value) {
		if (value != null) id = [id,value];
		this.doWithItem(id, "show");
	}
	
	this.hideItem = function(id, value) {
		if (value != null) id = [id,value];
		this.doWithItem(id, "hide");
	}
	
	this.isItemHidden = function(id, value) {
		if (value != null) id = [id,value];
		return this.doWithItem(id, "isHidden");
	}
	
	/* options (select only) */
	this.getOptions = function(id) {
		return this.doWithItem(id, "getOptions");
	}
	
	/* width/height */
	this.setItemWidth = function(id, width) {
		this.doWithItem(id, "setWidth", width);
	}
	
	this.getItemWidth = function(id) {
		return this.doWithItem(id, "getWidth");
	}
	
	this.setItemHeight = function(id, height) { // textarea
		this.doWithItem(id, "setHeight", height);
	}
	
	this.setItemFocus = function(id, value) {
		if (value != null) id = [id,value];
		this.doWithItem(id, "setFocus");
	}
	
	/* validation */
	
	// required before validate and data sending for updating values for input, password
	// datasending call validation inside
	this._updateValues = function() {
		for (var a in this.itemPull) {
			if (this.objPull[a] && typeof(this.objPull[a].updateValue) == "function") {
				this.objPull[a].updateValue(this.itemPull[a]);
			}
			if (this.itemPull[a]._list) {
				for (var q=0; q<this.itemPull[a]._list.length; q++) {
					this.itemPull[a]._list[q]._updateValues();
				}
			}
		}
	}
	
	// css
	this._getItemByName = function(id) {
		for (var a in this.itemPull) {
			if (this.itemPull[a]._idd == id) return this.itemPull[a];
			if (this.itemPull[a]._list != null) {
				for (var q=0; q<this.itemPull[a]._list.length; q++) {
					var r = this.itemPull[a]._list[q]._getItemByName(id);
					if (r != null) return r;
				}
			}
		}
		return null;
	}
	this._resetValidateCss = function(item) {
		item.className = (item.className).replace(item._vcss,"");
		item._vcss = null;
	}
	this.setValidateCss = function(name, state, custom) {
		var item = this._getItemByName(name);
		if (!item) return;
		if (item._vcss != null) this._resetValidateCss(item);
		item._vcss = (typeof(custom)=="string"?custom:"validate_"+(state===true?"ok":"error"));
		item.className += " "+item._vcss;
	}
	this.resetValidateCss = function(name) {
		for (var a in this.itemPull) {
			if (this.itemPull[a]._vcss != null) this._resetValidateCss(this.itemPull[a]);
			if (this.itemPull[a]._list != null) {
				for (var q=0; q<this.itemPull[a]._list.length; q++) this.itemPull[a]._list[q].resetValidateCss();
			}
		}
	}
	this._validateLoop = function(handler) { // same as forEach only omit radio button value
		for (var a in this.objPull) {
			handler(String(a).replace(this.idPrefix,""));
			if (this.itemPull[a]._list) {
				for (var q=0; q<this.itemPull[a]._list.length; q++) this.itemPull[a]._list[q]._validateLoop(handler);
			}
		}
	}
	// action
	this.validate = function(type) {
		
		if (this.callEvent("onBeforeValidate",[]) == false) return;
		
		var completed = true;
		
		this._validateLoop(function(name, value){
			var k = that.doWithItem(name, "_validate");
			if (typeof(k) != "boolean") k = true;
			completed = k && completed;
		}, true);
		
		this.callEvent("onAfterValidate",[completed]);
		return completed;
		
	}
	
	this.validateItem = function(name, value) {
		if (typeof(value) != "undefined") name = [name,value];
		return this.doWithItem(name,"_validate");
	}
	
	this.enableLiveValidation = function(state) {
		this.live_validate = (state==true);
	}
	
	
	/* readonly */
	
	this.setReadonly = function(id, state) {
		this.doWithItem(id, "setReadonly", state);
	}
	
	this.isReadonly = function(id) {
		return this.doWithItem(id, "isReadonly");
	}
	
	/* index */
	
	this.getFirstActive = function(withFocus) {
		for (var q=0; q<this._indexId.length; q++) {
			var k = true;
			if (withFocus == true) {
				var t = this.getItemType(this._indexId[q]);
				if (!dhtmlXForm.prototype.items[t].setFocus) k = false;
			}
			if (k && this._idIndex[this._indexId[q]].enabled) return this._indexId[q];
		}
		return null;
	}
	
	this.setFocusOnFirstActive = function() {
		var k = this.getFirstActive(true);
		if (k != null) this.setItemFocus(k);
	}
	
	/* enable/disable */
	
	this.enableItem = function(id, value) {
		if (value != null) id = [id,value];
		this.doWithItem(id, "userEnable");
		this._autoCheck();
	}
	
	this.disableItem = function(id, value) {
		if (value != null) id = [id,value];
		this.doWithItem(id, "userDisable");
		this._autoCheck();
	}
	
	this.isItemEnabled = function(id, value) {
		if (value != null) id = [id,value];
		return this.doWithItem(id, "isUserEnabled");
	}
	
	this.clear = function() {
		var usedRAs = {};
		this.formId = (new Date()).valueOf();//remove form id, so next operation will be insert
		this.resetDataProcessor("inserted");
		
		for (var a in this.itemPull) {
			var t = this.itemPull[a]._idd;
			// checkbox
			if (this.itemPull[a]._type == "ch") this.uncheckItem(t);
			// input/textarea
			if (this.itemPull[a]._type in {"ta":1,"editor":1,"calendar":1,"pw":1,"hd":1})
				this.setItemValue(t, "");
			// dhxcombo
			if (this.itemPull[a]._type == "combo") {
				this.itemPull[a]._apiChange = true;
				var combo = this.getCombo(t);
				combo.selectOption(0);
				combo = null;
				this.itemPull[a]._apiChange = false;
			}
			// select
			if (this.itemPull[a]._type == "se") {
				var opts = this.getOptions(t);
				if (opts.length > 0) opts[0].selected = true;
			}
			// radiobutton
			if (this.itemPull[a]._type == "ra") {
				var g = this.itemPull[a]._group;
				if (!usedRAs[g]) { this.checkItem(g, this.doWithItem(t, "_getFirstValue")); usedRAs[g] = true; }
			}
			// nested lists
			if (this.itemPull[a]._list) for (var q=0; q<this.itemPull[a]._list.length; q++) this.itemPull[a]._list[q].clear();
			// check for custom cell
			if (this["setFormData_"+this.itemPull[a]._type]) {
				this["setFormData_"+this.itemPull[a]._type](t,"");
			}
		}
		usedRAs = null;
		if (this._parentForm) this._autoCheck();
		
		// validate
		this.resetValidateCss();
		
	}
	
	this.unload = function() {
		
		window.dhx4._enableDataLoading(this, null, null, null, "clear");
		window.dhx4._eventable(this, "clear");
		
		for (var a in this.objPull) this._removeItem(String(a).replace(this.idPrefix,""));
		
		if (this._ccTm) window.clearTimeout(this._ccTm);
		this._formLS = null;
		
		for (var q=0; q<this.base.length; q++) {
			while (this.base[q].childNodes.length > 0) this.base[q].removeChild(this.base[q].childNodes[0]);
			if (this.base[q].parentNode) this.base[q].parentNode.removeChild(this.base[q]);
			this.base[q] = null;
		}
		this.base = null;
		
		this.cont.onkeypress = null;
		this.cont.className = "";
		this.cont = null;
		
		for (var a in this) this[a] = null;
		
		that = null;
		
	}
	
	for (var a in this.items) {
		
		this.items[a].t = a;
		
		if (typeof(this.items[a]._index) == "undefined") {
			this.items[a]._index = true;
		}
		
		if (!this.items[a].show) {
			this.items[a].show = function(item) {
				item.style.display = "";
				if (item._listObj) for (var q=0; q<item._listObj.length; q++) item._listObj[q].show(item._listBase[q]);
			}
		}
		
		if (!this.items[a].hide) {
			this.items[a].hide = function(item) {
				item.style.display = "none";
				if (item._listObj) for (var q=0; q<item._listObj.length; q++) item._listObj[q].hide(item._listBase[q]);
			}
		}
		
		if (!this.items[a].isHidden) {
			this.items[a].isHidden = function(item) {
				return (item.style.display == "none");
			}
		}
		
		if (!this.items[a].userEnable) {
			this.items[a].userEnable = function(item) {
				item._udis = false;
			}
		}
			
		if (!this.items[a].userDisable) {
			this.items[a].userDisable = function(item) {
				item._udis = true;
			}
		}
		
		if (!this.items[a].isUserEnabled) {
			this.items[a].isUserEnabled = function(item) {
				return (item._udis!==true);
			}
		}
		
		if (!this.items[a].getType) {
			this.items[a].getType = function() {
				return this.t;
			}
		}
		
		if (!this.items[a].isExist) {
			this.items[a].isExist = function() {
				return true;
			}
		}
		
		if (!this.items[a]._validate) {
			this.items[a]._validate = function(item) {
				
				if (!item._validate || !item._enabled) return true;
				
				if (item._type == "ch" || item._type == "ra") {
					var val = (this.isChecked(item)?this.getValue(item):0);
					if (item._type == "ra" && typeof(val) == "undefined") val = 0;
				} else {
					var val = this.getValue(item);
				}
				
				var r = true;
				
				for (var q=0; q<item._validate.length; q++) {
					
					var v = "is"+item._validate[q];
					
					if ((val == null || val.length == 0) && v != "isNotEmpty" && item._type != "container") {
						// field not required or empty (+ validate not set to NotEmpty)
					} else {
						var f = dhtmlxValidation[v];
						
						if (item._type == "container" && typeof(f) == "function") f = function(){return true;}
						
						if (typeof(f) != "function" && typeof(item._validate[q]) == "function") f = item._validate[q];
						if (typeof(f) != "function" && typeof(window[item._validate[q]]) == "function") f = window[item._validate[q]];
						r = ((typeof(f)=="function"?f(val,item._idd):new RegExp(item._validate[q]).test(val)) && r);
						f = null;
					}
				}
				
				if (!(item.callEvent("onValidate"+(r?"Success":"Error"),[item._idd,val,r])===false)) item.getForm().setValidateCss(item._idd, r);
				
				return r;
			}
		}
		
		
	}
	
	// lock/unlock form
	this._locked = false;
	this._doLock = function(state) {
		var t = (state===true?true:false);
		if (this._locked == t) return; else this._locked = t;
		this._autoCheck(!this._locked);
	}
	this.lock = function() {
		this._doLock(true);
	}
	this.unlock = function() {
		this._doLock(false);
	}
	this.isLocked = function() {
		return this._locked;
	}
	
	// date format for inputs
	this.setNumberFormat = function(id, format, g_sep, d_sep) {
		// return false if format incorrect and true if it successfuly applied
		return this.doWithItem(id, "setNumberFormat", format, g_sep, d_sep);
	}
	
	window.dhx4._enableDataLoading(this, "_initObj", "_xmlToObject", "items", {struct: true, data: true});
	window.dhx4._eventable(this);
	
	this.attachEvent("_onButtonClick", function(name, cmd){
		this.callEvent("onButtonClick", [name, cmd]);
	});
	
	this._updateBlocks = function() {
		this.forEachItem(function(id){
			if (that.getItemType(id) == "block" || that.getItemType(id) == "combo") {
				that.doWithItem(id,"_setCss",that.skin,that.cont.style.fontSize);
			}
		});
	}
	
	// copy init data to prevent init obj extension
	this._isObj = function(k) {
		return (k != null && typeof(k) == "object" && typeof(k.length) == "undefined");
	}
	this._copyObj = function(r) {
		if (this._isObj(r)) {
			var t = {};
			for (var a in r) {
				if (typeof(r[a]) == "object" && r[a] != null) t[a] = this._copyObj(r[a]); else t[a] = r[a];
			}
		} else {
			var t = [];
			for (var a=0; a<r.length; a++) {
				if (typeof(r[a]) == "object" && r[a] != null) t[a] = this._copyObj(r[a]); else t[a] = r[a];
			}
		}
		return t;
	}
	//
	
	if (data != null && typeof(data) == "object") {
		this._initObj(this._copyObj(data));
	};
	
	if (this._parentForm) {
		this._updateBlocks();
	}
	
	// ls for input change, affected: input, select, pwd, calendar, colorpicker
	this._ccActive = false;
	this._ccTm = null;
	
	return this;
	
};

dhtmlXForm.prototype.getInput = function(id) {
	return this.doWithItem(id, "getInput");
};

dhtmlXForm.prototype.getSelect = function(id) {
	return this.doWithItem(id, "getSelect");
};


dhtmlXForm.prototype.items = {};

/* checkbox */
dhtmlXForm.prototype.items.checkbox = {
	
	render: function(item, data) {
		
		item._type = "ch";
		item._enabled = true;
		item._checked = false;
		item._value = (typeof(data.value)=="undefined"?null:String(data.value));
		item._ro = (data.readonly==true);
		
		if (data._autoInputWidth !== false) data.inputWidth = 14;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "INPUT", "TEXT", true, true, "dhxform_textarea");
		
		item.childNodes[item._ll?1:0].className += " dhxform_img_node";
		
		var p = document.createElement("DIV");
		p.className = "dhxform_img chbx0";
		item.appendChild(p);
		
		if (!isNaN(data.inputLeft)) item.childNodes[item._ll?1:0].style.left = parseInt(data.inputLeft)+"px";
		if (!isNaN(data.inputTop)) item.childNodes[item._ll?1:0].style.top = parseInt(data.inputTop)+"px";
		
		item.childNodes[item._ll?1:0].appendChild(p);
		item.childNodes[item._ll?1:0].firstChild.value = String(data.value);
		
		item._updateImgNode = function(item, state) {
			var t = item.childNodes[item._ll?1:0].lastChild;
			t.className = (state?"dhxform_actv_c":"dhxform_img")+" "+(item._checked?"chbx1":"chbx0");
			item = t = null;
		}
		
		item._doOnFocus = function(item) {
			item.getForm().callEvent("onFocus",[item._idd]);
		}
		
		item._doOnBlur = function(item) {
			item.getForm().callEvent("onBlur",[item._idd]);
		}
		
		item._doOnKeyUpDown = function(evName, evObj) {
			this.callEvent(evName, [this.childNodes[this._ll?0:1].childNodes[0], evObj, this._idd]);
		}
		
		if (data.checked == true) this.check(item);
		if (data.hidden == true) this.hide(item);
		if (data.disabled == true) this.userDisable(item);
		
		this.doAttachEvents(item);
		
		return this;
	},
	
	destruct: function(item) {
		item._doOnFocus = item._doOnBlur = item._updateImgNode = null;
		this.doUnloadNestedLists(item);
		this.doDestruct(item);
	},
	
	doAddLabel: function(item, data) {
		
		var t = document.createElement("DIV");
		t.className = "dhxform_label "+data.labelAlign;
		
		if (data.wrap == true) t.style.whiteSpace = "normal";
		
		if (item._ll) {
			item.insertBefore(t,item.firstChild);
		} else {
			item.appendChild(t);
		}
		
		if (typeof(data.tooltip) != "undefined") t.title = data.tooltip;
		
		t.innerHTML = "<div class='dhxform_label_nav_link' "+
				"onfocus='if(this.parentNode.parentNode._updateImgNode)this.parentNode.parentNode._updateImgNode(this.parentNode.parentNode,true);this.parentNode.parentNode._doOnFocus(this.parentNode.parentNode);' "+
				"onblur='if(this.parentNode.parentNode._updateImgNode)this.parentNode.parentNode._updateImgNode(this.parentNode.parentNode,false);this.parentNode.parentNode._doOnBlur(this.parentNode.parentNode);' "+
				"onkeypress='var e=event||window.arguments[0];if(e.keyCode==32||e.charCode==32){e.cancelBubble=true;if(e.preventDefault)e.preventDefault();else e.returnValue=false;_dhxForm_doClick(this,\"mousedown\");return false;}' "+
				"onkeyup='var e=event||window.arguments[0];this.parentNode.parentNode._doOnKeyUpDown(\"onKeyUp\",e);' "+
				"onkeydown='var e=event||window.arguments[0];this.parentNode.parentNode._doOnKeyUpDown(\"onKeyDown\",e);' "+
				(window.dhx4.isIPad?"ontouchstart='var e=event;e.preventDefault();_dhxForm_doClick(this,\"mousedown\");' ":"")+
				"role='link' tabindex='0'>"+data.label+(data.info?"<span class='dhxform_info'>[?]</span>":"")+(item._required?"<span class='dhxform_item_required'>*</span>":"")+'</div>';
		
		if (!isNaN(data.labelWidth)) t.firstChild.style.width = parseInt(data.labelWidth)+"px";
		if (!isNaN(data.labelHeight)) t.firstChild.style.height = parseInt(data.labelHeight)+"px";
		
		if (!isNaN(data.labelLeft)) t.style.left = parseInt(data.labelLeft)+"px";
		if (!isNaN(data.labelTop)) t.style.top = parseInt(data.labelTop)+"px";
		
	},
	
	doAddInput: function(item, data, el, type, pos, dim, css) {
		
		var p = document.createElement("DIV");
		p.className = "dhxform_control";
		
		if (item._ll) {
			item.appendChild(p);
		} else {
			item.insertBefore(p,item.firstChild);
		}
		
		var t = document.createElement(el);
		t.className = css;
		t.name = item._idd;
		t._idd = item._idd;
		t.id = data.uid;
		
		if (typeof(type) == "string") t.type = type;
		
		if (el == "INPUT" || el == "TEXTAREA") {
			t.onkeyup = function(e) {
				e = e||event;
				item.callEvent("onKeyUp",[this,e,this._idd]);
			};
			t.onkeydown = function(e) {
				e = e||event;
				item.callEvent("onKeyDown",[this,e,this._idd]);
			};
		}
		
		if (el == "SELECT" && data.type == "select" && item.getForm().skin == "material") {
			if (window.dhx4.isOpera || window.dhx4.isChrome) {
				t.className += " dhxform_arrow_fix_webkit";
			} else if (window.dhx4.isEdge) {
				t.className += " dhxform_arrow_fix_edge";
			} else if (window.dhx4.isFF) {
				t.className += " dhxform_fix_ff";
			}
		}
		
		p.appendChild(t);
		
		if (pos) {
			if (!isNaN(data.inputLeft)) p.style.left = parseInt(data.inputLeft)+"px";
			if (!isNaN(data.inputTop)) p.style.top = parseInt(data.inputTop)+"px";
		}
		
		var u = "";
		
		var dimFix = false;
		if (dim) {
			if (!isNaN(data.inputWidth)) { u += "width:"+parseInt(data.inputWidth)+"px;"; dimFix=true; }
			if (!isNaN(data.inputHeight)) u += "height:"+parseInt(data.inputHeight)+"px;";
		}
		if (typeof(data.style) == "string") u += data.style;
		t.style.cssText = u;
		
		if (data.maxLength) t.setAttribute("maxLength", data.maxLength);
		if (data.connector) t.setAttribute("connector",data.connector);
		
		var i = (dhtmlXForm.prototype.items[this.t] != null ? dhtmlXForm.prototype.items[this.t]._dimFix == true : false);
		if (dimFix && ({input: 1, password:1, select:1, multiselect:1, calendar:1, colorpicker:1}[this.t] == 1 || i)) {
			if (dhtmlXForm.prototype.items[this.t]._dim == null) dhtmlXForm.prototype.items[this.t]._dim = item.getForm()._checkDim(p, t);
			t.style.width = parseInt(t.style.width)-dhtmlXForm.prototype.items[this.t]._dim+"px";
		}
		
		if (typeof(data.note) == "object") {
			var note = document.createElement("DIV");
			note.className = "dhxform_note";
			note.style.width = (isNaN(data.note.width)?t.offsetWidth:parseInt(data.note.width))+"px";
			note._w = data.note.width;
			note.innerHTML = data.note.text;
			p.appendChild(note);
			note = null;
		}
		
		if (data.readonly) this.setReadonly(item, true);
		if (data.disabled == true) this.userDisable(item);
		if (data.hidden == true && this.t != "combo") this.hide(item);
		
	},
	
	doUnloadNestedLists: function(item) {
		
		if (!item._list) return;
		for (var q=0; q<item._list.length; q++) {
			item._list[q].unload();
			item._list[q] = null;
			item._listObj[q] = null;
			item._listBase[q].parentNode.removeChild(item._listBase[q]);
			item._listBase[q] = null;
		}
		item._list = null;
		item._listObj = null;
		item._listBase = null;
	},
	
	doDestruct: function(item) {
		
		item.callEvent = null;
		item.checkEvent = null;
		item.getForm = null;
		
		item._autoCheck = null;
		item._checked = null;
		item._enabled = null;
		item._idd = null;
		item._type = null;
		item._value = null;
		item._group = null;
		
		item.onselectstart = null;
		
		item.childNodes[item._ll?1:0].onmousedown = null;
		item.childNodes[item._ll?1:0].ontouchstart = null;
		
		item.childNodes[item._ll?0:1].onmousedown = null;
		item.childNodes[item._ll?0:1].ontouchstart = null;
		
		item.childNodes[item._ll?0:1].childNodes[0].onfocus = null;
		item.childNodes[item._ll?0:1].childNodes[0].onblur = null;
		item.childNodes[item._ll?0:1].childNodes[0].onkeypress = null;
		item.childNodes[item._ll?0:1].childNodes[0].onkeyup = null;
		item.childNodes[item._ll?0:1].childNodes[0].onkeydown = null;
		item.childNodes[item._ll?0:1].childNodes[0].onmousedown = null;
		item.childNodes[item._ll?0:1].childNodes[0].ontouchstart = null;
		item.childNodes[item._ll?0:1].removeChild(item.childNodes[item._ll?0:1].childNodes[0]);
		
		while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
		
		item.parentNode.removeChild(item);
		item = null;
		
	},
	
	doAttachEvents: function(item) {
		var that = this;
		// image click
		item.childNodes[item._ll?1:0][window.dhx4.isIPad?"ontouchstart":"onmousedown"] = function(e) {
			e = e||event;
			if (e.preventDefault) e.preventDefault();
			var t = (e.target||e.srcElement); // need to skip "note" if exists
			if (!this.parentNode._enabled || this.parentNode._ro || (typeof(t.className) != "undefined" && t.className == "dhxform_note")) {
				e.cancelBubble = true;
				if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
				return false;
			}
			that.doClick(this.parentNode);
		}
		// label click
		item.childNodes[item._ll?0:1].childNodes[0][window.dhx4.isIPad?"ontouchstart":"onmousedown"] = function(e) {
			e = e||event;
			if (e.preventDefault) e.preventDefault();
			// do not check if r/o here, allow item's be highlighted, check for r/o added into doClick
			if (!this.parentNode.parentNode._enabled) {
				e.cancelBubble = true;
				if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
				return false;
			}
			// check if "info" clicked (checkbox/radio only)
			var t = e.target||e.srcElement;
			if (typeof(t.className) != "undefined" && t.className == "dhxform_info") {
				this.parentNode.parentNode.callEvent("onInfo",[this.parentNode.parentNode._idd, e]);
				e.cancelBubble = true;
				if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
				return false;
			}
			that.doClick(this.parentNode.parentNode);
		}
	},
	
	doClick: function(item) {
		
		item.childNodes[item._ll?0:1].childNodes[0].focus();
		
		if (!item._enabled || item._ro) return;
		
		if (item.checkEvent("onBeforeChange")) if (item.callEvent("onBeforeChange", [item._idd, item._value, item._checked]) !== true) return;
		
		this.setChecked(item, !item._checked);
		item._autoCheck();
		item.callEvent("onChange", [item._idd, item._value, item._checked]);
	},
	
	doCheckValue: function(item) {
		if (item._checked && item._enabled) {
			item.childNodes[item._ll?1:0].firstChild.name = String(item._idd);
			item.childNodes[item._ll?1:0].firstChild.value = this.getValue(item);
		} else {
			item.childNodes[item._ll?1:0].firstChild.name = "";
			item.childNodes[item._ll?1:0].firstChild.value = "";
		}
	},
	
	setChecked: function(item, state) {
		item._checked = (state===true?true:false);
		//item.childNodes[item._ll?1:0].lastChild.className = "dhxform_img "+(item._checked?"chbx1":"chbx0");
		item.childNodes[item._ll?1:0].lastChild.className = item.childNodes[item._ll?1:0].lastChild.className.replace(/chbx[0-1]{1}/gi,"")+(item._checked?" chbx1":" chbx0");
		this.doCheckValue(item);
	},
	
	check: function(item) {
		this.setChecked(item, true);
	},
	
	unCheck: function(item) {
		this.setChecked(item, false);
	},
	
	isChecked: function(item) {
		return item._checked;
	},
	
	enable: function(item) {
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
		item._enabled = true;
		item.childNodes[item._ll?0:1].childNodes[0].tabIndex = 0;
		item.childNodes[item._ll?0:1].childNodes[0].removeAttribute("disabled");
		this.doCheckValue(item);
	},
	
	disable: function(item) {
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
		item._enabled = false;
		if (item._updateImgNode != null) item._updateImgNode(item, false); // clear focus on disable fix
		item.childNodes[item._ll?0:1].childNodes[0].tabIndex = -1;
		item.childNodes[item._ll?0:1].childNodes[0].setAttribute("disabled", "true");
		this.doCheckValue(item);
	},
	
	isEnabled: function(item) {
		return item._enabled;
	},
	
	setText: function(item, text) {
		item.childNodes[item._ll?0:1].childNodes[0].innerHTML = text+(item._required?"<span class='dhxform_item_required'>*</span>":"");
	},
	
	getText: function(item) {
		return item.childNodes[item._ll?0:1].childNodes[0].innerHTML.replace(/<span class=\"dhxform_item_required\">[^<]*<\/span>/g,"");
	},
	
	setValue: function(item, value) {
		this.setChecked(item,(value===true||parseInt(value)==1||value=="true"||item._value===value));
	},
	
	getValue: function(item, mode) {
		if (mode == "realvalue") return item._value;
		return ((typeof(item._value)=="undefined"||item._value==null)?(item._checked?1:0):item._value);
	},
	
	setReadonly: function(item, state) {
		item._ro = (state===true);
	},
	
	isReadonly: function(item) {
		return item._ro;
	},
	
	setFocus: function(item) {
		item.childNodes[item._ll?0:1].childNodes[0].focus();
	}
	
};

/* radio */
dhtmlXForm.prototype.items.radio = {
	
	input: {},
	
	r: {},
	
	firstValue: {},
	
	render: function(item, data, uid) {
		
		item._type = "ra";
		item._enabled = true;
		item._checked = false;
		item._group = data.name;
		item._value = data.value;
		item._uid = uid;
		item._ro = (data.readonly==true);
		item._rName = item._rId+item._group;
		
		this.r[item._idd] = item;
		
		data.inputWidth = 14;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "INPUT", "TEXT", true, true, "dhxform_textarea");
		
		item.childNodes[item._ll?1:0].className += " dhxform_img_node";
		
		// radio img
		var p = document.createElement("DIV");
		p.className = "dhxform_img rdbt0";
		item.appendChild(p);
		
		if (!isNaN(data.inputLeft)) item.childNodes[item._ll?1:0].style.left = parseInt(data.inputLeft)+"px";
		if (!isNaN(data.inputTop)) item.childNodes[item._ll?1:0].style.top = parseInt(data.inputTop)+"px";
		
		item.childNodes[item._ll?1:0].appendChild(p);
		
		// hidden input needed just to keep common logic, name-value should be empty to prevent sending to server from real form
		item.childNodes[item._ll?1:0].firstChild.name = "";
		item.childNodes[item._ll?1:0].firstChild.value = "";
		
		item._updateImgNode = function(item, state) {
			var t = item.childNodes[item._ll?1:0].lastChild;
			t.className = (state?"dhxform_actv_r":"dhxform_img")+" "+(item._checked?"rdbt1":"rdbt0");
			item = t = null;
		}
		
		item._doOnFocus = function(item) {
			item.getForm().callEvent("onFocus",[item._group, item._value]);
		}
		
		item._doOnBlur = function(item) {
			item.getForm().callEvent("onBlur",[item._group, item._value]);
		}
		
		item._doOnKeyUpDown = function(evName, evObj) {
			this.callEvent(evName, [this.childNodes[this._ll?0:1].childNodes[0], evObj, this._group, this._value]);
		}
		
		// input
		if (this.input[item._rName] == null) {
			var k = document.createElement("INPUT");
			k.type = "HIDDEN";
			k.name = data.name;
			k.firstValue = item._value;
			item.appendChild(k);
			this.input[item._rName] = k;
		}
		
		if (!this.firstValue[item._rName]) this.firstValue[item._rName] = data.value;
		
		if (data.checked == true) this.check(item);
		if (data.hidden == true) this.hide(item);
		if (data.disabled == true) this.userDisable(item);
		
		this.doAttachEvents(item);
		
		return this;
	},
	
	destruct: function(item, value) {
		
		// check if any items will left to keep hidden input on page
		
		if (item.lastChild == this.input[item._rName]) {
			var done = false;
			for (var a in this.r) {
				if (!done && this.r[a]._group == item._group && this.r[a]._idd != item._idd) {
					this.r[a].appendChild(this.input[item._rName]);
					done = true;
				}
			}
			if (!done) {
				// remove hidden input
				this.input[item._rName].parentNode.removeChild(this.input[item._rName]);
				this.input[item._rName] = null;
				this.firstValue[item._rName] = null;
			}
		}
		
		this.r[item._idd] = null;
		delete this.r[item._idd];
		
		item._doOnFocus = item._doOnBlur = item._updateImgNode = null;
		this.doUnloadNestedLists(item);
		this.doDestruct(item);
		
		var id = item._idd;
		item = null;
		
		return id;
		
	},
	
	doClick: function(item) {
		
		item.childNodes[item._ll?0:1].childNodes[0].focus();
		
		if (!(item._enabled && !item._checked)) return;
		if (item._ro) return;
		
		var args = [item._group, item._value, true];
		if (item.checkEvent("onBeforeChange")) if (item.callEvent("onBeforeChange", args) !== true) return;
		this.setChecked(item, true);
		item.getForm()._autoCheck();
		item.callEvent("onChange", args);
		
	},
	
	doCheckValue: function(item) {
		var value = null;
		for (var a in this.r) {
			if (this.r[a]._checked && this.r[a]._group == item._group && this.r[a]._rId == item._rId) value = this.r[a]._value; // allow getChecked for disabled, v3.6.2
		}
		if (value != null && this.r[a]._enabled) {
			this.input[item._rName].name = String(item._group);
			this.input[item._rName].value = value;
		} else {
			this.input[item._rName].name = "";
			this.input[item._rName].value = "";
		}
		this.input[item._rName]._value = value;
	},
	
	setChecked: function(item, state) {
		state = (state===true);
		for (var a in this.r) {
			if (this.r[a]._group == item._group && this.r[a]._rId == item._rId) {
				var needCheck = false;
				if (this.r[a]._idd == item._idd) {
					if (this.r[a]._checked != state) { this.r[a]._checked = state; needCheck = true; }
				} else {
					if (this.r[a]._checked) { this.r[a]._checked = false; needCheck = true; }
				}
				if (needCheck) {
					var t = this.r[a].childNodes[this.r[a]._ll?1:0].childNodes[1];
					t.className = t.className.replace(/rdbt[0-1]{1}/gi,"")+(this.r[a]._checked?" rdbt1":" rdbt0");
					t = null;
				}
			}
		}
		this.doCheckValue(item);
	},
	
	getChecked: function(item) {
		return this.input[item._rName]._value;
	},
	
	_getFirstValue: function(item) {
		return this.firstValue[item._rName];
	},
	
	_getId: function(item) {
		return item._idd; // return inner id by name/value
	},
	
	setValue: function(item, value) {
		// this method will never called at all
	}
	
};

(function(){
	for (var a in {doAddLabel:1,doAddInput:1,doDestruct:1,doUnloadNestedLists:1,doAttachEvents:1,check:1,unCheck:1,isChecked:1,enable:1,disable:1,isEnabled:1,setText:1,getText:1,getValue:1,setReadonly:1,isReadonly:1,setFocus:1})
		dhtmlXForm.prototype.items.radio[a] = dhtmlXForm.prototype.items.checkbox[a];
})();


/* select */
dhtmlXForm.prototype.items.select = {
	
	render: function(item, data) {
		
		item._type = "se";
		item._enabled = true;
		item._value = null;
		item._newValue = null;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "SELECT", null, true, true, "dhxform_select");
		this.doAttachEvents(item);
		
		this.doLoadOpts(item, data);
		if (data.connector != null) this.doLoadOptsConnector(item, data.connector);
		
		if (typeof(data.value) != "undefined" && data.value != null) {
			this.setValue(item, data.value);
		}
		
		return this;
	},
	
	destruct: function(item) {
		
		this.doUnloadNestedLists(item);
		
		item.callEvent = null;
		item.checkEvent = null;
		item.getForm = null;
		
		item._autoCheck = null;
		item._enabled = null;
		item._idd = null;
		item._type = null;
		item._value = null;
		item._newValue = null;
		
		item.onselectstart = null;
		
		item.childNodes[item._ll?1:0].childNodes[0].onclick = null;
		item.childNodes[item._ll?1:0].childNodes[0].onkeydown = null;
		item.childNodes[item._ll?1:0].childNodes[0].onchange = null;
		item.childNodes[item._ll?1:0].childNodes[0].onfocus = null;
		item.childNodes[item._ll?1:0].childNodes[0].onblur = null;
		item.childNodes[item._ll?1:0].childNodes[0].onkeyup = null;
		item.childNodes[item._ll?1:0].removeChild(item.childNodes[item._ll?1:0].childNodes[0]);
		
		while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
		
		item.parentNode.removeChild(item);
		item = null;
		
	},
	
	doAddLabel: function(item, data) {
		
		var j = document.createElement("DIV");
		j.className = "dhxform_label "+data.labelAlign;
		j.innerHTML = "<label for='"+data.uid+"'>"+
				data.label+
				(data.info?"<span class='dhxform_info'>[?]</span>":"")+
				(item._required?"<span class='dhxform_item_required'>*</span>":"")+
				"</label>";
		//
		if (data.wrap == true) j.style.whiteSpace = "normal";
		
		if (typeof(data.tooltip) != "undefined") j.title = data.tooltip;
		
		item.appendChild(j);
		
		if (typeof(data.label) == "undefined" || data.label == null || data.label.length == 0) j.style.display = "none";
		
		if (!isNaN(data.labelWidth)) j.style.width = parseInt(data.labelWidth)+"px";
		if (!isNaN(data.labelHeight)) j.style.height = parseInt(data.labelHeight)+"px";
		
		if (!isNaN(data.labelLeft)) j.style.left = parseInt(data.labelLeft)+"px";
		if (!isNaN(data.labelTop)) j.style.top = parseInt(data.labelTop)+"px";
		
		if (data.info) {
			j.onclick = function(e) {
				e = e||event;
				var t = e.target||e.srcElement;
				if (typeof(t.className) != "undefined" && t.className == "dhxform_info") {
					this.parentNode.callEvent("onInfo",[this.parentNode._idd, e]);
					e.cancelBubble = true;
					if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
					return false;
				}
			}
		}
	},
	
	doAttachEvents: function(item) {
		
		var t = item.childNodes[item._ll?1:0].childNodes[0];
		var that = this;
		
		t.onclick = function() {
			that.doOnChange(this);
		}
		t.onkeydown = function(e) {
			e = e||event;
			that.doOnChange(this);
			this.parentNode.parentNode.callEvent("onKeyDown",[this,e,this.parentNode.parentNode._idd]);
		}
		t.onchange = function() {
			that.doOnChange(this);
		}
		t.onkeyup = function(e) {
			e = e||event;
			this.parentNode.parentNode.callEvent("onKeyUp",[this,e,this.parentNode.parentNode._idd]);
		}
		t = null;
		
		this.doAttachChangeLS(item);
	},
	
	doAttachChangeLS: function(item) {
		
		var t = item.childNodes[item._ll?1:0].childNodes[0];
		t.onfocus = function() {
			var i = this.parentNode.parentNode;
			i.getForm()._ccActivate(i._idd, this, i.getForm().getItemValue(i._idd,true));
			i.getForm().callEvent("onFocus",[i._idd]);
			i = null;
		}
		t.onblur = function() {
			var i = this.parentNode.parentNode;
			i.getForm()._ccDeactivate(i._idd);
			i.getForm().callEvent("onBlur",[i._idd]);
			i = null;
		}
		t = null;
	},
	
	doValidate: function(item) {
		if (item.getForm().live_validate) this._validate(item);
	},
	
	doLoadOpts: function(item, data, callEvent) {
		var t = item.childNodes[item._ll?1:0].childNodes[0];
		var opts = data.options;
		var k = false;
		for (var q=0; q<opts.length; q++) {
			var t0 = opts[q].text||opts[q].label;
			if (!t0 || typeof(t0) == "undefined") t0 = "";
			var opt = new Option(t0, opts[q].value);
			if (typeof(opts[q].img_src) == "string") opt.setAttribute("img_src", opts[q].img_src);
			t.options.add(opt);
			// selected
			if (typeof(opts[q].selected) != "undefined" && window.dhx4.s2b(opts[q].selected) == true) {
				opt.selected = true;
				item._value = opts[q].value;
				k = true;
			}
			// cehcked (combo only)
			if (typeof(opts[q].checked) != "undefined" && window.dhx4.s2b(opts[q].checked) == true) {
				opt.setAttribute("checked", "1");
			}
			// images (combo only)
			if (typeof(opts[q].img) != "undefined") opt.setAttribute("img", opts[q].img);
			if (typeof(opts[q].img_dis) != "undefined") opt.setAttribute("img_dis", opts[q].img_dis);
			// cehcked (combo only)
			if (typeof(opts[q].css) != "undefined") opt.setAttribute("css", opts[q].css);
		}
		// if "selected" option was not specified, check selected in control
		if (!k && t.selectedIndex >= 0) item._value = t.options[t.selectedIndex].value;
		
		if (callEvent === true) item.callEvent("onOptionsLoaded", [item._idd]);
		// fix note if width set to auto
		this._checkNoteWidth(item);
	},
	
	doLoadOptsConnector: function(item, url) {
		
		var that = this;
		item._connector_working = true;
		
		window.dhx4.ajax.get(url, function(r) {
			
			r = r.xmlDoc.responseXML;
			if (r == null) return;
			
			var root = r.getElementsByTagName("data");
			if (root == null || root[0] == null) return;
			
			root = root[0];
			
			var opts = [];
			for (var q=0; q<root.childNodes.length; q++) {
				if (typeof(root.childNodes[q].tagName) != "undefined" && String(root.childNodes[q].tagName).toLowerCase() == "item") {
					var option = root.childNodes[q];
					opts.push({
						label: option.getAttribute("label"),
						value: option.getAttribute("value"),
						selected: (option.getAttribute("selected") != null)
					});
					option = null;
				}
			}
			
			that.doLoadOpts(item, {options:opts}, true);
			
			// try to set value if it was called while options loading was in progress
			
			item._connector_working = false;
			if (item._connector_value != null) {
				that.setValue(item, item._connector_value);
				item._connector_value = null;
			}
			
			that = item = null;
		});
	},
	
	doOnChange: function(sel) {
		var item = sel.parentNode.parentNode;
		item._newValue = (sel.selectedIndex>=0?sel.options[sel.selectedIndex].value:null);
		if (item._newValue != item._value) {
			if (item.checkEvent("onBeforeChange")) {
				if (item.callEvent("onBeforeChange", [item._idd, item._value, item._newValue]) !== true) {
					// restore last value
					for (var q=0; q<sel.options.length; q++) if (sel.options[q].value == item._value) sel.options[q].selected = true;
					return;
				}
			}
			item._value = item._newValue;
			item.callEvent("onChange", [item._idd, item._value]);
			if (item._type == "se" && item.getForm().live_validate) this._validate(item);
		}
		item._autoCheck();
	},
	
	setText: function(item, text) {
		if (!text) text = "";
		item.childNodes[item._ll?0:1].childNodes[0].innerHTML = text+(item._required?"<span class='dhxform_item_required'>*</span>":"");
		item.childNodes[item._ll?0:1].style.display = (text.length==0||text==null?"none":"");
	},
	
	getText: function(item) {
		return item.childNodes[item._ll?0:1].childNodes[0].innerHTML.replace(/<span class=\"dhxform_item_required\">[^<]*<\/span>/g,"");
	},
	
	enable: function(item) {
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
		item._enabled = true;
		item.childNodes[item._ll?1:0].childNodes[0].removeAttribute("disabled");
	},
	
	disable: function(item) {
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
		item._enabled = false;
		item.childNodes[item._ll?1:0].childNodes[0].setAttribute("disabled", true);
	},
	
	getOptions: function(item) {
		return item.childNodes[item._ll?1:0].childNodes[0].options;
	},
	
	setValue: function(item, val) {
		if (item._connector_working) { // attemp to set value while optins not yet loaded (connector used)
			item._connector_value = val;
			return;
		}
		var opts = this.getOptions(item);
		for (var q=0; q<opts.length; q++) {
			if (opts[q].value == val) {
				opts[q].selected = true;
				item._value = opts[q].value;
			}
		}
		if (item._list != null && item._list.length > 0) {
			item.getForm()._autoCheck();
		}
		
		item.getForm()._ccReload(item._idd, item._value); // selected option id
		
	},
	
	getValue: function(item) {
		var k = -1;
		var opts = this.getOptions(item);
		for (var q=0; q<opts.length; q++) if (opts[q].selected) k = opts[q].value;
		return k;
	},
	
	setWidth: function(item, width) {
		item.childNodes[item._ll?1:0].childNodes[0].style.width = width+"px";
	},
	
	getSelect: function(item) {
		return item.childNodes[item._ll?1:0].childNodes[0];
	},
	
	setFocus: function(item) {
		item.childNodes[item._ll?1:0].childNodes[0].focus();
	},
	
	_checkNoteWidth: function(item) {
		var t;
		if (item.childNodes[item._ll?1:0].childNodes[1] != null) {
			t = item.childNodes[item._ll?1:0].childNodes[1];
			if (t.className != null && t.className.search(/dhxform_note/gi) >= 0 && t._w == "auto") t.style.width = item.childNodes[item._ll?1:0].childNodes[0].offsetWidth+"px";
		}
		t = null;
	}
	
};
(function(){
	for (var a in {doAddInput:1,doUnloadNestedLists:1,isEnabled:1})
		dhtmlXForm.prototype.items.select[a] = dhtmlXForm.prototype.items.checkbox[a];
})();

/* multiselect */
dhtmlXForm.prototype.items.multiselect = {
	
	doLoadOpts: function(item, data, callEvent) {
		var t = item.childNodes[item._ll?1:0].childNodes[0];
		t.multiple = true;
		if (!isNaN(data.size)) t.size = Number(data.size);
		item._value = [];
		item._newValue = [];
		var opts = data.options;
		for (var q=0; q<opts.length; q++) {
			var opt = new Option(opts[q].text||opts[q].label, opts[q].value);
			t.options.add(opt);
			if (opts[q].selected == true || opts[q].selected == "true") {
				opt.selected = true;
				item._value.push(opts[q].value);
			}
		}
		if (callEvent === true) item.callEvent("onOptionsLoaded", [item._idd]);
		//
		this._checkNoteWidth(item);
	},
	
	doAttachEvents: function(item) {
		
		var t = item.childNodes[item._ll?1:0].childNodes[0];
		var that = this;
		
		t.onfocus = function() {
			that.doOnChange(this);
			var i = this.parentNode.parentNode;
			i.getForm().callEvent("onFocus",[i._idd]);
			i = null;
		}
		
		t.onblur = function() {
			that.doOnChange(this);
			var i = this.parentNode.parentNode;
			i.getForm().callEvent("onBlur",[i._idd]);
			i = null;
		}
		
		t.onclick = function() {
			that.doOnChange(this);
			var i = this.parentNode.parentNode;
			i._autoCheck();
			i = null;
		}
		
	},
	
	doOnChange: function(sel) {
		
		var item = sel.parentNode.parentNode;
		
		item._newValue = [];
		for (var q=0; q<sel.options.length; q++) if (sel.options[q].selected) item._newValue.push(sel.options[q].value);
		
		if ((item._value).sort().toString() != (item._newValue).sort().toString()) {
			if (item.checkEvent("onBeforeChange")) {
				if (item.callEvent("onBeforeChange", [item._idd, item._value, item._newValue]) !== true) {
					// restore last value
					var k = {};
					for (var q=0; q<item._value.length; q++) k[item._value[q]] = true;
					for (var q=0; q<sel.options.length; q++) sel.options[q].selected = (k[sel.options[q].value] == true);
					k = null;
					return;
				}
			}
			item._value = [];
			for (var q=0; q<item._newValue.length; q++) item._value.push(item._newValue[q]);
			item.callEvent("onChange", [item._idd, item._value]);
		}
		
		// check autocheck for multiselect
		item._autoCheck();
		
	},
	
	setValue: function(item, val) {
		
		var k = {};
		if (typeof(val) == "string") val = val.split(",");
		if (typeof(val) != "object") val = [val];
		for (var q=0; q<val.length; q++) k[val[q]] = true;
		
		var opts = this.getOptions(item);
		for (var q=0; q<opts.length; q++) opts[q].selected = (k[opts[q].value] == true);
		
		item._autoCheck();
	},
	
	getValue: function(item) {
		
		var k = [];
		
		var opts = this.getOptions(item);
		for (var q=0; q<opts.length; q++) if (opts[q].selected) k.push(opts[q].value);
		return k;
	}
};

(function() {
	for (var a in dhtmlXForm.prototype.items.select) {
		if (!dhtmlXForm.prototype.items.multiselect[a]) dhtmlXForm.prototype.items.multiselect[a] = dhtmlXForm.prototype.items.select[a];
	}
})();

/* input */
dhtmlXForm.prototype.items.input = {
	
	render: function(item, data) {
		
		var ta = (!isNaN(data.rows));
		
		item._type = "ta";
		item._enabled = true;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, (ta?"TEXTAREA":"INPUT"), (ta?null:"TEXT"), true, true, "dhxform_textarea");
		this.doAttachEvents(item);
		
		if (ta) item.childNodes[item._ll?1:0].childNodes[0].rows = Number(data.rows)+(window.dhx4.isIE6?1:0);
		
		if (typeof(data.numberFormat) != "undefined") {
			var a,b=null,c=null;
			if (typeof(data.numberFormat) != "string") {
				a = data.numberFormat[0];
				b = data.numberFormat[1]||null;
				c = data.numberFormat[2]||null;
			} else {
				a = data.numberFormat;
				if (typeof(data.groupSep) == "string") b = data.groupSep;
				if (typeof(data.decSep) == "string") c = data.decSep;
			}
			this.setNumberFormat(item, a, b, c, false);
		}
		
		this.setValue(item, data.value);
		
		return this;
		
	},
	
	doAttachEvents: function(item) {
		
		var node = item.childNodes[item._ll?1:0].childNodes[0];
		
		if (typeof(node.tagName) != "undefined" && {"input":1, "textarea":1, "select":1}[node.tagName.toLowerCase()] == 1) {
			
			var that = this;
			node.onfocus = function() {
				var i = this.parentNode.parentNode;
				if (i._df != null) this.value = i._value||"";
				i.getForm()._ccActivate(i._idd, this, this.value);
				i.getForm().callEvent("onFocus",[i._idd]);
				i = null;
			}
			node.onblur = function() {
				var i = this.parentNode.parentNode;
				i.getForm()._ccDeactivate(i._idd);
				that.updateValue(i, true);
				if (i.getForm().live_validate) that._validate(i);
				i.getForm().callEvent("onBlur",[i._idd]);
				i = null;
			}
			
		}
		node = null;
		
	},
	
	updateValue: function(item, foc) {
		
		var value = item.childNodes[item._ll?1:0].childNodes[0].value;
		
		var form = item.getForm();
		var in_focus = (form._ccActive == true && form._formLS != null && form._formLS[item._idd] != null);
		form = null;
		
		if (!in_focus && item._df != null && value == window.dhx4.template._getFmtValue(item._value, item._df)) return; // if item not in focus
		
		if (!foc && item._df != null && item._value == value && value == window.dhx4.template._getFmtValue(value, item._df)) return;
		
		var t = this;
		if (item._value != value) {
			if (item.checkEvent("onBeforeChange")) if (item.callEvent("onBeforeChange",[item._idd, item._value, value]) !== true) {
				// restore
				if (item._df != null) t.setValue(item, item._value); else item.childNodes[item._ll?1:0].childNodes[0].value = item._value;
				return;
			}
			// accepted
			if (item._df != null && foc) t.setValue(item, value); else item._value = value;
			item.callEvent("onChange",[item._idd, value]);
			return;
		}
		if (item._df != null && foc) this.setValue(item, item._value);
	},
	
	setValue: function(item, value) {
		
		// str only
		item._value = (typeof(value) != "undefined" && value != null ? value : "");
		
		var v = (String(item._value)||"");
		var k = item.childNodes[item._ll?1:0].childNodes[0];
		
		// check if formatting available
		if (item._df != null) v = window.dhx4.template._getFmtValue(v, item._df);
		
		if (k.value != v) {
			k.value = v;
			item.getForm()._ccReload(item._idd, v);
		}
		
		k = null;
	},
	
	getValue: function(item) {
		// update value if item have focus
		var f = item.getForm();
		if (f._formLS && f._formLS[item._idd] != null) this.updateValue(item);
		f = null;
		// str only
		return (typeof(item._value) != "undefined" && item._value != null ? item._value : "");
	},
	
	setReadonly: function(item, state) {
		item._ro = (state===true);
		if (item._ro) {
			item.childNodes[item._ll?1:0].childNodes[0].setAttribute("readOnly", "true");
		} else {
			item.childNodes[item._ll?1:0].childNodes[0].removeAttribute("readOnly");
		}
	},
	
	isReadonly: function(item) {
		if (!item._ro) item._ro = false;
		return item._ro;
	},
	
	getInput: function(item) {
		return item.childNodes[item._ll?1:0].childNodes[0];
	},
	
	setNumberFormat: function(item, format, g_sep, d_sep, refresh) {
		
		if (typeof(refresh) != "boolean") refresh = true;
		
		if (format == "") {
			item._df = null;
			if (refresh) this.setValue(item, item._value);
			return true;
		}
		
		if (typeof(format) != "string") return;
		
		var fmt = window.dhx4.template._parseFmt(format, g_sep, d_sep);
		if (fmt == false) return false; else item._df = fmt;
		
		if (refresh) this.setValue(item, item._value);
		
		return true;
		
	}
	
};

(function(){
	for (var a in {doAddLabel:1,doAddInput:1,destruct:1,doUnloadNestedLists:1,setText:1,getText:1,enable:1,disable:1,isEnabled:1,setWidth:1,setFocus:1})
		dhtmlXForm.prototype.items.input[a] = dhtmlXForm.prototype.items.select[a];
})();


/* password */
dhtmlXForm.prototype.items.password = {
	
	render: function(item, data) {
		
		item._type = "pw";
		item._enabled = true;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "INPUT", "PASSWORD", true, true, "dhxform_textarea");
		this.doAttachEvents(item);
		
		this.setValue(item, data.value);
		
		return this;
		
	}
};

(function(){
	for (var a in {doAddLabel:1,doAddInput:1,doAttachEvents:1,destruct:1,doUnloadNestedLists:1,setText:1,getText:1,setValue:1,getValue:1,updateValue:1,enable:1,disable:1,isEnabled:1,setWidth:1,setReadonly:1,isReadonly:1,setFocus:1,getInput:1})
		dhtmlXForm.prototype.items.password[a] = dhtmlXForm.prototype.items.input[a];
})();

/* file */
dhtmlXForm.prototype.items.file = {
	
	render: function(item, data) {
		
		item._type = "fl";
		item._enabled = true;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "INPUT", "FILE", true, false, "dhxform_textarea");
		
		var t = item.childNodes[item._ll ? 1 : 0].childNodes[0];
		var that = this;
		t.onfocus = function() {
			var i = this.parentNode.parentNode;
			i.getForm().callEvent("onFocus",[i._idd]);
			i = null;
		};
		t.onblur = function () {
			var i = this.parentNode.parentNode;
			if (i.getForm().live_validate) that._validate(i);
			i.getForm().callEvent("onBlur", [i._idd]);
			i = null;
		};
		t = null;
		
		item.childNodes[item._ll?1:0].childNodes[0].onchange = function() {
			item.callEvent("onChange", [item._idd, this.value]);
		}
		
		return this;
		
	},
	
	setValue: function(){},
	
	getValue: function(item) {
		return item.childNodes[item._ll?1:0].childNodes[0].value;
	}
	
};

(function(){
	for (var a in {doAddLabel:1,doAddInput:1,destruct:1,doUnloadNestedLists:1,setText:1,getText:1,getInput:1,enable:1,disable:1,isEnabled:1,setWidth:1})
		dhtmlXForm.prototype.items.file[a] = dhtmlXForm.prototype.items.input[a];
})();

/* label */
dhtmlXForm.prototype.items.label = {
	
	_index: false,
	
	render: function(item, data) {
		
		item._type = "lb";
		item._enabled = true;
		item._checked = true;
		
		var t = document.createElement("DIV");
		t.className = "dhxform_txt_label2"+(data._isTopmost?" topmost":"");
		t.innerHTML = data.label;
		item.appendChild(t);
		
		if (data.hidden == true) this.hide(item);
		if (data.disabled == true) this.userDisable(item);
		
		if (!isNaN(data.labelWidth)) t.style.width = parseInt(data.labelWidth)+"px";
		if (!isNaN(data.labelHeight)) t.style.height = parseInt(data.labelHeight)+"px";
		
		if (!isNaN(data.labelLeft)) t.style.left = parseInt(data.labelLeft)+"px";
		if (!isNaN(data.labelTop)) t.style.top = parseInt(data.labelTop)+"px";
		
		return this;
	},
	
	destruct: function(item) {
		
		this.doUnloadNestedLists(item);
		
		item._autoCheck = null;
		item._enabled = null;
		item._type = null;
		
		item.callEvent = null;
		item.checkEvent = null;
		item.getForm = null;
		
		item.onselectstart = null;
		item.parentNode.removeChild(item);
		item = null;
		
	},
	
	enable: function(item) {
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
		item._enabled = true;
	},
	
	disable: function(item) {
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
		item._enabled = false;
	},
	
	setText: function(item, text) {
		item.firstChild.innerHTML = text;
	},

	getText: function(item) {
		return item.firstChild.innerHTML;
	}
	
};

(function(){
	for (var a in {doUnloadNestedLists:1,isEnabled:1})
		dhtmlXForm.prototype.items.label[a] = dhtmlXForm.prototype.items.checkbox[a];
})();


/* button */
dhtmlXForm.prototype.items.button = {
	
	render: function(item, data) {
		
		item._type = "bt";
		item._enabled = true;
		item._name = data.name;
		
		item.className = String(item.className).replace("item_label_top","item_label_left").replace("item_label_right","item_label_left");
		
		item._doOnKeyUpDown = function(evName, evObj) {
			this.callEvent(evName, [this.childNodes[0].childNodes[0], evObj, this._idd]);
		}
		
		item.innerHTML = '<div class="dhxform_btn" role="link" tabindex="0" dir="ltr">'+
					'<div class="dhxform_btn_txt">'+data.value+'</div>'+
					'<div class="dhxform_btn_filler" disabled="true"></div>'+ // IE click w/o focus loss
				'</div>';
		
		if (!isNaN(data.width)) {
			var w = Math.max(data.width,10);
			if (dhtmlXForm.prototype.items[this.t]._dim == null) {
				item.firstChild.style.width = w+"px";
				dhtmlXForm.prototype.items[this.t]._dim = item.getForm()._checkDim(item, item.firstChild);
			}
			item.firstChild.style.width = w-dhtmlXForm.prototype.items[this.t]._dim+"px";
			item.firstChild.firstChild.className += " dhxform_btn_txt_autowidth";
		}
		
		
		
		if (!isNaN(data.inputLeft)) item.childNodes[0].style.left = parseInt(data.inputLeft)+"px";
		if (!isNaN(data.inputTop)) item.childNodes[0].style.top = parseInt(data.inputTop)+"px";
		
		if (data.hidden == true) this.hide(item);
		if (data.disabled == true) this.userDisable(item);
		
		if (typeof(data.tooltip) != "undefined") item.firstChild.title = data.tooltip;
		
		// item onselectstart also needed once
		// will reconstructed!
		
		item.onselectstart = function(e){
			e = e||event;
			e.cancelBubble = true;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			return false;
		}
		item.firstChild.onselectstart = function(e){
			e = e||event;
			e.cancelBubble = true;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			return false;
		}
		
		item.firstChild.onkeypress = function(e) {
			e = e||event
			if ((e.keyCode == 32 || e.charCode == 32 || e.keyCode == 13 || e.charCode == 13) && !this.parentNode._busy) {
				this.parentNode._busy = true;
				e.cancelBubble = true;
				if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
				_dhxForm_doClick(this.childNodes[0], ["mousedown", "mouseup"]);
				return false;
			}
		}
		
		item.firstChild.onfocus = function() {
			this.parentNode._doOnFocus(this.parentNode);
		}
		
		item.firstChild.onblur = function() {
			_dhxForm_doClick(this.childNodes[0], "mouseout");
			this.parentNode._doOnBlur(this.parentNode);
		}
		
		item.firstChild.onkeyup = function(e) {
			this.parentNode._doOnKeyUpDown("onKeyUp", e||event);
		}
		item.firstChild.onkeydown = function(e) {
			this.parentNode._doOnKeyUpDown("onKeyDown", e||event);
		}
		item.firstChild.onmouseover = function(){
			var t = this.parentNode;
			if (!t._enabled) return;
			this._isOver = true;
			this.className = "dhxform_btn dhxform_btn_over";
			t = null;
		}
		item.firstChild.onmouseout = function(){
			var t = this.parentNode;
			if (!t._enabled) return;
			this.className = "dhxform_btn";
			this._allowClick = false;
			this._pressed = false;
			this._isOver = false;
			t = null;
		}
		item.firstChild.ontouchstart = item.firstChild.onmousedown = function(e){
			e = e||event;
			if (e.type == "touchstart" && e.preventDefault) e.preventDefault();
			if (e.button >= 2) return; // ie=0/other=1
			if (this._pressed) return;
			var t = this.parentNode;
			if (!t._enabled) return;
			this.className = "dhxform_btn dhxform_btn_pressed";
			this._allowClick = true;
			this._pressed = true;
			t = null;
		}
		
		item.firstChild.ontouchend = item.firstChild.onmouseup = function(e){
			e = e||event;
			if (e.button >= 2) return;
			if (!this._pressed) return;
			var t = this.parentNode;
			if (!t._enabled) return;
			t._busy = false;
			this.className = "dhxform_btn"+(this._isOver?" dhxform_btn_over":"");
			if (this._pressed && this._allowClick) t.callEvent("_onButtonClick", [t._name, t._cmd]);
			this._allowClick = false;
			this._pressed = false;
			t = null;
		}
		
		item._doOnFocus = function(item) {
			item.getForm().callEvent("onFocus",[item._idd]);
		}
		
		item._doOnBlur = function(item) {
			item.getForm().callEvent("onBlur",[item._idd]);
		}
		
		return this;
	},
	
	destruct: function(item) {
		
		this.doUnloadNestedLists(item);
		
		item.callEvent = null;
		item.checkEvent = null;
		item.getForm = null;
		
		item._autoCheck = null;
		item._type = null;
		item._enabled = null;
		item._cmd = null;
		item._name = null;
		item._doOnFocus = null;
		item._doOnBlur = null;
		item._doOnKeyUpDown = null;
		
		item.onselectstart = null;
		
		item.firstChild.onselectstart = null;
		item.firstChild.onkeypress = null;
		item.firstChild.ontouchstart = null;
		item.firstChild.ontouchend = null;
		item.firstChild.onfocus = null;
		item.firstChild.onblur = null;
		item.firstChild.onkeyup = null;
		item.firstChild.onkeydown = null;
		item.firstChild.onmouseover = null;
		item.firstChild.onmouseout = null;
		item.firstChild.onmousedown = null;
		item.firstChild.onmouseup = null;
		
		while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
		
		item.parentNode.removeChild(item);
		item = null;
		
	},
	
	enable: function(item) {
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
		item._enabled = true;
		item.childNodes[0].removeAttribute("disabled");
		item.childNodes[0].setAttribute("role", "link");
		item.childNodes[0].setAttribute("tabIndex", "0");
	},
	
	disable: function(item) {
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
		item._enabled = false;
		item.childNodes[0].setAttribute("disabled", "true");
		item.childNodes[0].removeAttribute("role");
		item.childNodes[0].removeAttribute("tabIndex");
	},
	
	setText: function(item, text) {
		item.childNodes[0].childNodes[0].innerHTML = text;
	},

	getText: function(item) {
		return item.childNodes[0].childNodes[0].innerHTML;
	},
	
	setFocus: function(item) {
		item.childNodes[0].focus();
	}
	
};

(function(){
	for (var a in {doUnloadNestedLists:1,isEnabled:1})
		dhtmlXForm.prototype.items.button[a] = dhtmlXForm.prototype.items.checkbox[a];
})();

/* hidden item */
dhtmlXForm.prototype.items.hidden = {
	
	_index: false,
	
	render: function(item, data) {
		
		item.style.display = "none";
		
		item._name = data.name;
		item._type = "hd";
		item._enabled = true;
		
		var t = document.createElement("INPUT");
		t.type = "HIDDEN";
		t.name = data.name;
		t.value = (data.value||"")
		item.appendChild(t);
		
		return this;
	},
	
	destruct: function(item) {
		
		
		this.doUnloadNestedLists(item);
		
		while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
		
		item._autoCheck = null;
		item._name = null;
		item._type = null;
		item._enabled = null;
		item.onselectstart = null;
		item.callEvent = null;
		item.checkEvent = null;
		item.getForm = null;
		item.parentNode.removeChild(item);
		item = null;
		
	},
	
	enable: function(item) {
		item._enabled = true;
		item.childNodes[0].setAttribute("name", item._name);
	},
	
	disable: function(item) {
		item._enabled = false;
		item.childNodes[0].removeAttribute("name");
	},
	
	show: function() {
		
	},
	
	hide: function() {
		
	},
	
	isHidden: function() {
		return true;
	},
	
	setValue: function(item, val) {
		item.childNodes[0].value = val;
	},
	
	getValue: function(item) {
		return item.childNodes[0].value;
	},
	
	getInput: function(item) {
		return item.childNodes[0];
	}
	
};

(function(){
	for (var a in {doUnloadNestedLists:1,isEnabled:1})
		dhtmlXForm.prototype.items.hidden[a] = dhtmlXForm.prototype.items.checkbox[a];
})();

/* sub list */
dhtmlXForm.prototype.items.list = {
	
	_index: false,
	
	render: function(item, skin) {
		
		item._type = "list";
		item._enabled = true;
		item._isNestedForm = true;
		item.style.paddingLeft = item._ofsNested+"px";
		
		item.className = "dhxform_base_nested"+(item._custom_css||"");
		
		return [this, new dhtmlXForm(item, null, skin)];
	},
	
	destruct: function(item) {
		
		// linked to _listBase
		// automaticaly cleared when parent item unloaded
		
	}
};

/* fieldset */
dhtmlXForm.prototype.items.fieldset = {
	
	_index: false,
	
	render: function(item, data) {
		
		item._type = "fs";
		
		if (typeof(parseInt(data.inputWidth)) == "number") {
			// if (window.dhx4.isFF||window.dhx4.isOpera) data.inputWidth -= 12;
			// chrome-11/ie9 - ok
		}
		
		item._width = data.width;
		
		item._enabled = true;
		item._checked = true; // required for authoCheck
		
		item.className = "fs_"+data.position+(typeof(data.className)=="string"?" "+data.className:"");
		
		var f = document.createElement("FIELDSET");
		f.className = "dhxform_fs";
		var align = String(data.labelAlign).replace("align_","");
		f.innerHTML = "<legend class='fs_legend' align='"+align+"' style='text-align:"+align+"'>"+data.label+"</legend>";
		item.appendChild(f);
		
		if (!isNaN(data.inputLeft)) f.style.left = parseInt(data.inputLeft)+"px";
		if (!isNaN(data.inputTop)) f.style.top = parseInt(data.inputTop)+"px";
		if (data.inputWidth != "auto") {
			if (!isNaN(data.inputWidth)) {
				f.style.width = parseInt(data.inputWidth)+"px";
				var w = parseInt(f.style.width);
				if (f.offsetWidth > w) f.style.width = w+(w-f.offsetWidth)+"px";
			}
		}
		
		item._addSubListNode = function() {
			var t = document.createElement("DIV");
			t._custom_css = " dhxform_fs_nested";
			this.childNodes[0].appendChild(t);
			return t;
		}
		
		if (data.hidden == true) this.hide(item);
		if (data.disabled == true) this.userDisable(item);
		
		return this;
	},
	
	destruct: function(item) {
		
		this.doUnloadNestedLists(item);
		
		item._checked = null;
		item._enabled = null;
		item._idd = null;
		item._type = null;
		item._width = null;
		
		item.onselectstart = null;
		
		item._addSubListNode = null;
		item._autoCheck = null;
		item.callEvent = null;
		item.checkEvent = null;
		item.getForm = null;
		
		while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
		
		item.parentNode.removeChild(item);
		item = null;
	
	},
	
	setText: function(item, text) {
		item.childNodes[0].childNodes[0].innerHTML = text;
	},
	
	getText: function(item) {
		return item.childNodes[0].childNodes[0].innerHTML;
	},
	
	enable: function(item) {
		item._enabled = true;
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
	},
	
	disable: function(item) {
		item._enabled = false;
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
	},
	
	setWidth: function(item, width) {
		item.childNodes[0].style.width = width+"px";
		item._width = width;
	},
	
	getWidth: function(item) {
		return item._width;
	}
	
};

(function(){
	for (var a in {doUnloadNestedLists:1,isEnabled:1})
		dhtmlXForm.prototype.items.fieldset[a] = dhtmlXForm.prototype.items.checkbox[a];
})();


/* block */
dhtmlXForm.prototype.items.block = {
	
	_index: false,
	
	render: function(item, data) {
		
		item._type = "bl";
		
		item._width = data.width;
		
		item._enabled = true;
		item._checked = true; // required for authoCheck
		
		item.className = "block_"+data.position+(typeof(data.className)=="string"?" "+data.className:"");
		
		var b = document.createElement("DIV");
		b.className = "dhxform_obj_"+item.getForm().skin+" dhxform_block";
		b.style.fontSize = item.getForm().cont.style.fontSize;
		if (data.style) b.style.cssText = data.style;
		
		if (typeof(data.id) != "undefined") b.id = data.id;
		
		item.appendChild(b);
		
		if (!isNaN(data.inputLeft)) b.style.left = parseInt(data.inputLeft)+"px";
		if (!isNaN(data.inputTop)) b.style.top = parseInt(data.inputTop)+"px";
		if (data.inputWidth != "auto") if (!isNaN(data.inputWidth)) b.style.width = parseInt(data.inputWidth)+"px";
		
		if (!isNaN(data.blockOffset)) {
			item._ofsNested = data.blockOffset;
		}
		
		item._addSubListNode = function() {
			var t = document.createElement("DIV");
			t._inBlcok = true;
			if (typeof(this._ofsNested) != "undefined") t._ofsNested = this._ofsNested;
			this.childNodes[0].appendChild(t);
			return t;
		}
		
		if (data.hidden == true) this.hide(item);
		if (data.disabled == true) this.userDisable(item);
		
		return this;
	},
	
	_setCss: function(item, skin, fontSize) {
		item.firstChild.className = "dhxform_obj_"+skin+" dhxform_block";
		item.firstChild.style.fontSize = fontSize;
	}
};

(function(){
	for (var a in {enable:1,disable:1,isEnabled:1,setWidth:1,getWidth:1,doUnloadNestedLists:1,destruct:1})
		dhtmlXForm.prototype.items.block[a] = dhtmlXForm.prototype.items.fieldset[a];
})();

/* new column */
dhtmlXForm.prototype.items.newcolumn = {
	_index: false
};

/* template */
dhtmlXForm.prototype.items.template = {
	
	render: function(item, data) {
		
		var ta = (!isNaN(data.rows));
		
		item._type = "tp";
		item._enabled = true;
		
		if (data.format != null) {
			if (typeof(data.format) == "function") {
				item.format = data.format;
			} else if (typeof(data.format) == "string" && typeof(window[data.format]) == "function") {
				item.format = window[data.format];
			}
		}
		if (item.format == null) {
			item.format = function(name, value) { return value; }
		}
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "DIV", null, true, true, "dhxform_item_template");
		
		this.setValue(item, data.value||"");
		
		return this;
		
	},
	
	destruct: function(item) {
		item.format = null;
		this.d2(item);
		item = null;
	},
	
	setValue: function(item, value) {
		item._value = value;
		item.childNodes[item._ll?1:0].childNodes[0].innerHTML = item.format(item._idd, item._value);
	},
	
	getValue: function(item) {
		return item._value;
	},
	
	enable: function(item) {
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
		item._enabled = true;
	},
	
	disable: function(item) {
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
		item._enabled = false;
	}
	
};

(function(){
	dhtmlXForm.prototype.items.template.d2 = dhtmlXForm.prototype.items.input.destruct;
	for (var a in {doAddLabel:1,doAddInput:1,doUnloadNestedLists:1,setText:1,getText:1,isEnabled:1,setWidth:1})
		dhtmlXForm.prototype.items.template[a] = dhtmlXForm.prototype.items.select[a];
})();

//loading from UL list

dhtmlXForm.prototype._ulToObject = function(ulData, a) {
	var obj = [];
	for (var q=0; q<ulData.childNodes.length; q++) {
		if (String(ulData.childNodes[q].tagName||"").toLowerCase() == "li") {
			var p = {};
			var t = ulData.childNodes[q];
			for (var w=0; w<a.length; w++) if (t.getAttribute(a[w]) != null) p[String(a[w]).replace("ftype","type")] = t.getAttribute(a[w]);
			if (!p.label) try { p.label = t.firstChild.nodeValue; } catch(e){}
			var n = t.getElementsByTagName("UL");
			if (n[0] != null) p[(p.type=="select"?"options":"list")] = dhtmlXForm.prototype._ulToObject(n[0], a);
			// userdata
			for (var w=0; w<t.childNodes.length; w++) {
				if (String(t.childNodes[w].tagName||"").toLowerCase() == "userdata") {
					if (!p.userdata) p.userdata = {};
					p.userdata[t.childNodes[w].getAttribute("name")] = t.childNodes[w].firstChild.nodeValue;
				}
			}
			obj[obj.length] = p;
		}
		if (String(ulData.childNodes[q].tagName||"").toLowerCase() == "div") {
			var p = {};
			p.type = "label";
			try { p.label = ulData.childNodes[q].firstChild.nodeValue; } catch(e){}
			obj[obj.length] = p;
		}
	}
	return obj;
};

dhtmlXForm.prototype.setUserData = function(id, name, value, rValue) {
	if (typeof(rValue) != "undefined") { // radiobutton: name,value,ud_name,ud_value
		var k = this.doWithItem([id,name], "_getId");
		if (k != null) { id = k; name = value; value = rValue; }
	}
	if (!this._userdata) this._userdata = {};
	this._userdata[id] = (this._userdata[id]||{});
	this._userdata[id][name] = value;
};

dhtmlXForm.prototype.getUserData = function(id, name, rValue) {
	if (typeof(rValue) != "undefined") { // radiobutton: name,value,ud_name
		var k = this.doWithItem([id,name], "_getId");
		if (k != null) { id = k; name = rValue; }
	}
	if (this._userdata != null && typeof(this._userdata[id]) != "undefined" && typeof(this._userdata[id][name]) != "undefined") return this._userdata[id][name];
	return "";
};

dhtmlXForm.prototype.setRTL = function(state) {
	this._rtl = (state===true?true:false);
	if (this._rtl) {
		if (String(this.cont).search(/dhxform_rtl/gi) < 0) this.cont.className += " dhxform_rtl";
	} else {
		if (String(this.cont).search(/dhxform_rtl/gi) >= 0) this.cont.className = String(this.cont.className).replace(/dhxform_rtl/gi,"");
	}
};

_dhxForm_doClick = function(obj, evType) {
	if (typeof(evType) == "object") {
		var t = evType[1];
		evType = evType[0];
	}
	if (document.createEvent) {
		var e = document.createEvent("MouseEvents");
		e.initEvent(evType, true, false);
		obj.dispatchEvent(e);
	} else if (document.createEventObject) {
		var e = document.createEventObject();
		e.button = 1;
		obj.fireEvent("on"+evType, e);
	}
	if (t) window.setTimeout(function(){_dhxForm_doClick(obj,t);},100);
}

dhtmlXForm.prototype.setFormData = function(t) {
	for (var a in t) {
		var r = this.getItemType(a);
		switch (r) {
			case "checkbox":
				this[t[a]==true||parseInt(t[a])==1||t[a]=="true"||t[a]==this.getItemValue(a, "realvalue")?"checkItem":"uncheckItem"](a);
				break;
			case "radio":
				this.checkItem(a,t[a]);
				break;
			case "input":
			case "textarea":
			case "password":
			case "select":
			case "multiselect":
			case "hidden":
			case "template":
			case "combo":
			case "calendar":
			case "colorpicker":
			case "editor":
				this.setItemValue(a,t[a]);
				break;
			default:
				if (this["setFormData_"+r]) {
					// check for custom cell
					this["setFormData_"+r](a,t[a]);
				} else {
					// if item with specified name not found, keep value in userdata
					if (!this.hId) this.hId = this._genStr(12);
					this.setUserData(this.hId, a, t[a]);
				}
				break;
		}
	}
};

dhtmlXForm.prototype.getFormData = function(p0, only_fields) {
	
	var r = {};
	var that = this;
	for (var a in this.itemPull) {
		var i = this.itemPull[a]._idd;
		var t = this.itemPull[a]._type;
		if (t == "ch") r[i] = (this.isItemChecked(i)?this.getItemValue(i):0);
		if (t == "ra" && !r[this.itemPull[a]._group]) r[this.itemPull[a]._group] = this.getCheckedValue(this.itemPull[a]._group);
		if (t in {se:1,ta:1,pw:1,hd:1,tp:1,fl:1,calendar:1,combo:1,editor:1,colorpicker:1}) r[i] = this.getItemValue(i,p0);
		// check for custom cell
		if (this["getFormData_"+t]) r[i] = this["getFormData_"+t](i);
		// merge with files/uploader
		if (t == "up") {
			var r0 = this.getItemValue(i);
			for (var a0 in r0) r[a0] = r0[a0];
		}
		//
		if (this.itemPull[a]._list) {
			for (var q=0; q<this.itemPull[a]._list.length; q++) {
				var k = this.itemPull[a]._list[q].getFormData(p0,only_fields);
				for (var b in k) r[b] = k[b];
			}
		}
	}
	// collecr hId userdata
	if (!only_fields && this.hId && this._userdata[this.hId]) {
		for (var a in this._userdata[this.hId]) {
			if (!r[a]) r[a] = this._userdata[this.hId][a];
		}
	}
	return r;
};

dhtmlXForm.prototype.adjustParentSize = function() {
	
	var kx = 0;
	var ky = -1;
	for (var q=0; q<this.base.length; q++) {
		kx += this.base[q].firstChild.offsetWidth;
		if (this.base[q].offsetHeight > ky) ky = this.base[q].offsetHeight;
	}
	
	// check if layout
	var isLayout = false;
	try {
		isLayout = (this.cont.parentNode.parentNode.parentNode.parentNode._isCell==true);
		if (isLayout) var layoutCell = this.cont.parentNode.parentNode.parentNode.parentNode;
	} catch(e){};
	
	if (isLayout && typeof(layoutCell) != "undefined") {
		
		if (kx > 0) layoutCell.setWidth(kx+10);
		if (ky > 0) layoutCell.setHeight(ky+layoutCell.firstChild.firstChild.offsetHeight+5);
		
		isLayout = layoutCell = null;
		return;
	}
	
	// check if window
	var isWindow = false;
	try {
		isWindow = (this.cont.parentNode.parentNode.parentNode._isWindow == true);
		if (isWindow) {
			var winCell = this.cont.parentNode.parentNode;
			if (typeof(winCell.callEvent) == "function") {
				this.cont.style.display = "none";
				winCell.callEvent("_setCellSize", [kx+15,ky+15]);
				this.cont.style.display = "";
			}
		}
	} catch(e){};
	
};

// dataproc
dhtmlXForm.prototype.reset = function() {
	if (this.callEvent("onBeforeReset", [this.formId, this.getFormData()])) {
		if (this._last_load_data) this.setFormData(this._last_load_data);
		this.callEvent("onAfterReset", [this.formId]);
	}
};

dhtmlXForm.prototype.send = function(url, mode, callback, skipValidation) {
	
	if (typeof mode == "function") {
		callback = mode;
		mode = "post";
	} else {
		mode = (mode=="get"?"get":"post");
	}
	
	if (skipValidation !== true && !this.validate()) return;
	var formData = this.getFormData(true);
	
	var data = [];
	for (var key in formData) data.push(key+"="+encodeURIComponent(formData[key]));
	
	var afterload = function(loader) {
		if (callback) callback.call(this, loader, loader.xmlDoc.responseText);
	};
	
	if (mode == "get") {
		window.dhx4.ajax.get(url+(url.indexOf("?")==-1?"?":"&")+data.join("&"), afterload);
	} else {
		window.dhx4.ajax.post(url, data.join("&"), afterload);
	}
	
};

dhtmlXForm.prototype.save = function(url, type){};

dhtmlXForm.prototype.dummy = function(){};

dhtmlXForm.prototype._changeFormId = function(oldid, newid) {
	this.formId = newid;
};

dhtmlXForm.prototype._dp_init = function(dp) {
	
	dp._methods = ["dummy", "dummy", "_changeFormId", "dummy"];
	
	dp._getRowData = function(id, pref) {
		var data = this.obj.getFormData(true);
		data[this.action_param] = this.obj.getUserData(id, this.action_param);
		return data;
	};
	dp._clearUpdateFlag = function(){};
	
	dp.attachEvent("onAfterUpdate", function(sid, action, tid, tag){
		if (action == "inserted" || action == "updated" || action == "error" || action == "invalid")
			this.obj.resetDataProcessor("updated");
		if (action == "inserted" || action == "updated")
			this.obj._last_load_data = this.obj.getFormData(true);
					
		this.obj.callEvent("onAfterSave",[this.obj.formId, tag]);
		return true;
	});
	
	dp.autoUpdate = false;
	dp.setTransactionMode("POST", true);
	
	this.dp = dp;
	
	this.formId = (new Date()).valueOf();
	this.resetDataProcessor("inserted");
	
	this.save = function(){
		if (!this.callEvent("onBeforeSave", [this.formId, this.getFormData()])) return;
		if (!this.validate()) return;
		dp.sendData();
	};
};


dhtmlXForm.prototype.resetDataProcessor = function(mode){
	if (!this.dp) return;
	this.dp.updatedRows = []; this.dp._in_progress = [];
	this.dp.setUpdated(this.formId, true, mode);
};

// cc listener
dhtmlXForm.prototype._ccActivate = function(id, inp, val) {
	
	if (!this._formLS) this._formLS = {};
	if (!this._formLS[id]) this._formLS[id] = {input: inp, value: val};
	if (!this._ccActive) {
		this._ccActive = true;
		this._ccDo();
	}
	inp = null;
};

dhtmlXForm.prototype._ccDeactivate = function(id) {
	
	if (this._ccTm) window.clearTimeout(this._ccTm);
	this._ccActive = false;
	if (this._formLS != null && this._formLS[id] != null) {
		this._formLS[id].input = null;
		this._formLS[id] = null;
		delete this._formLS[id];
	}
};

dhtmlXForm.prototype._ccDo = function() {
	
	if (this._ccTm) window.clearTimeout(this._ccTm);
	
	for (var a in this._formLS) {
		
		var inp = this._formLS[a].input;
		
		if (String(inp.tagName).toLowerCase() == "select") {
			var v = "";
			if (inp.selectedIndex >= 0 && inp.selectedIndex < inp.options.length) v = inp.options[inp.selectedIndex].value;
		} else {
			var v = inp.value;
		}
		if (v != this._formLS[a].value) {
			this._formLS[a].value = v;
			this.callEvent("onInputChange",[inp._idd,v,this]);
		}
		inp = null;
		
	}
	
	if (this._ccActive) {
		var t = this;
		this._ccTm = window.setTimeout(function(){t._ccDo();t=null;},100);
	}
	
};
	
dhtmlXForm.prototype._ccReload = function(id, value) { // update item's value while item have focus
	if (this._formLS && this._formLS[id]) {
		this._formLS[id].value = value;
	}
};

dhtmlXForm.prototype._checkDim = function(formNode, inpObj) {
	
	var testNode = document.createElement("DIV");
	testNode.className = "dhxform_obj_"+this.skin;
	testNode.style.cssText += (dhx4.isIE6==true?"visibility:hidden;":"position:absolute;left:-2000px;top:-1000px;");
	document.body.appendChild(testNode);
	
	var pNode = formNode.parentNode;
	var sNode = formNode.nextSibling;
	testNode.appendChild(formNode);
	
	var w = parseInt(inpObj.style.width);
	var w2 = (dhx4.isFF || dhx4.isIE || dhx4.isChrome || dhx4.isOpera ? inpObj.offsetWidth : inpObj.clientWidth);
	var dim = w2-w;
	
	if (sNode != null) pNode.insertBefore(formNode, sNode); else pNode.appendChild(formNode);
	testNode.parentNode.removeChild(testNode);
	
	pNode = sNode = testNode = formNode = inpObj = null;
	
	return dim;
};

dhtmlXForm.prototype._autoload = function() {
	var a = [
		"ftype", "name", "value", "label", "check", "checked", "disabled", "text", "rows", "select", "selected", "width", "style", "className",
		"labelWidth", "labelHeight", "labelLeft", "labelTop", "inputWidth", "inputHeight", "inputLeft", "inputTop", "position", "size"
	];
	var k = document.getElementsByTagName("UL");
	var u = [];
	for (var q=0; q<k.length; q++) {
		if (k[q].className == "dhtmlxForm") {
			var formNode = document.createElement("DIV");
			u[u.length] = {nodeUL:k[q], nodeForm:formNode, data:dhtmlXForm.prototype._ulToObject(k[q], a), name:(k[q].getAttribute("name")||null)};
		}
	}
	for (var q=0; q<u.length; q++) {
		u[q].nodeUL.parentNode.insertBefore(u[q].nodeForm, u[q].nodeUL);
		var listObj = new dhtmlXForm(u[q].nodeForm, u[q].data);
		if (u[q].name !== null) window[u[q].name] = listObj;
		var t = (u[q].nodeUL.getAttribute("oninit")||null);
		u[q].nodeUL.parentNode.removeChild(u[q].nodeUL);
		u[q].nodeUL = null;
		u[q].nodeForm = null;
		u[q].data = null;
		u[q] = null;
		// oninit call
		if (t) { if (typeof(t) == "function") t(); else if (typeof(window[t]) == "function") window[t](); }
	}
	if (typeof(window.addEventListener) == "function") {
		window.removeEventListener("load", dhtmlXForm.prototype._autoload, false);
	} else {
		window.detachEvent("onload", dhtmlXForm.prototype._autoload);
	};
	
};

if (typeof(window.addEventListener) == "function") {
	window.addEventListener("load", dhtmlXForm.prototype._autoload, false);
} else {
	window.attachEvent("onload", dhtmlXForm.prototype._autoload);
};

if (typeof(window.dhtmlXCellObject) != "undefined") {
	
	dhtmlXCellObject.prototype.attachForm = function(data) {
		
		this.callEvent("_onBeforeContentAttach",["form"]);
		
		var obj = document.createElement("DIV");
		obj.style.width = "100%";
		obj.style.height = "100%";
		obj.style.position = "relative";
		
		if (window.dhtmlx && dhtmlx.$customScroll) dhtmlx.CustomScroll.enable(obj); else obj.style.overflow = "auto";
		
		this._attachObject(obj);
		
		this.dataType = "form";
		this.dataObj = new dhtmlXForm(obj, data, this.conf.skin);
		obj = null;
		
		this.callEvent("_onContentAttach",[]);
		
		return this.dataObj;
		
	};
	
}


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXForm.prototype.items.combo = {
	
	render: function(item, data) {
		
		item._type = "combo";
		item._enabled = true;
		item._value = null;
		item._newValue = null;
		
		var skin = item.getForm().skin;
		if (typeof(data.inputWidth) != "undefined" && skin == "material" && String(data.inputWidth).match(/^\d*$/) != null) {
			data.inputWidth = parseInt(data.inputWidth)+2;
		}
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "SELECT", null, true, true, "dhxform_select");
		this.doAttachEvents(item);
		this.doLoadOpts(item, data);
		
		// allow selection to prevent broking combo logic
		item.onselectstart = function(e){return true;}
		
		// item.childNodes[1].childNodes[0].opt_type = data.comboType||"";
		item.childNodes[item._ll?1:0].childNodes[0].setAttribute("mode", data.comboType||"");
		if (data.comboImagePath) item.childNodes[item._ll?1:0].childNodes[0].setAttribute("imagePath", data.comboImagePath);
		if (data.comboDefaultImage) item.childNodes[item._ll?1:0].childNodes[0].setAttribute("defaultImage", data.comboDefaultImage);
		if (data.comboDefaultImageDis) item.childNodes[item._ll?1:0].childNodes[0].setAttribute("defaultImageDis", data.comboDefaultImageDis);
		
		item._combo = new dhtmlXComboFromSelect(item.childNodes[item._ll?1:0].childNodes[0]);
		item._combo.setSkin(skin);
		item._combo._currentComboValue = item._combo.getSelectedValue();
		item._combo.getInput().id = data.uid;
		
		if (skin == "material") item._combo.list.className += " dhxform_obj_"+skin;
		
		var k = this;
		item._combo.attachEvent("onChange", function(){
			k.doOnChange(this);
		});
		
		if (data.connector) this.doLoadOptsConnector(item, data.connector);
		
		if (data.filtering) {
			item._combo.enableFilteringMode(true);
		} else if (data.serverFiltering) {
			item._combo.enableFilteringMode(true, data.serverFiltering, data.filterCache, data.filterSubLoad);
		}
		
		if (data.readonly == true) this.setReadonly(item, true);
		if (data.hidden == true) this.hide(item);
		
		if (data.style) item._combo.DOMelem_input.style.cssText += data.style;
		
		item._combo.attachEvent("onFocus", function(){
			var item = this.cont.parentNode.parentNode;
			var f = item.getForm();
			if ((f.skin == "dhx_terrace" || f.skin == "material") && this.cont.className.search(/combo_in_focus/) < 0) this.cont.className += " combo_in_focus";
			f.callEvent("onFocus", [item._idd]);
			f = item = null;
		});
		
		item._combo.attachEvent("onBlur", function(){
			var item = this.cont.parentNode.parentNode;
			var f = item.getForm();
			if ((f.skin == "dhx_terrace" || f.skin == "material") && this.cont.className.search(/combo_in_focus/) >= 0) this.cont.className = this.cont.className.replace(/\s{0,}combo_in_focus/gi,"");
			f.callEvent("onBlur", [item._idd]);
			f = item = null;
		});
		
		return this;
	},
	
	destruct: function(item) {
		
		// unload combo
		item.childNodes[item._ll?1:0].childNodes[0].onchange = null;
		
		item._combo._currentComboValue = null;
		item._combo.unload();
		item._combo = null;
		
		// unload item
		item._apiChange = null;
		this.d2(item);
		item = null;
		
	},
	
	doAttachEvents: function(item) {
		
		var that = this;
		
		item.childNodes[item._ll?1:0].childNodes[0].onchange = function() {
			that.doOnChange(this);
			that.doValidate(this.DOMParent.parentNode.parentNode);
		}
	},
	
	doValidate: function(item) {
		if (item.getForm().hot_validate) this._validate(item);
	},
	
	doOnChange: function(combo) {
		var item = combo.base.parentNode.parentNode.parentNode;
		if (item._apiChange) return;
		combo._newComboValue = combo.getSelectedValue();
		if (combo._newComboValue != combo._currentComboValue) {
			if (item.checkEvent("onBeforeChange")) {
				if (item.callEvent("onBeforeChange", [item._idd, combo._currentComboValue, combo._newComboValue]) !== true) {
					// restore last value
					// not the best solution, should be improved
					window.setTimeout(function(){combo.setComboValue(combo._currentComboValue);},1);
					return false;
				}
			}
			combo._currentComboValue = combo._newComboValue;
			item.callEvent("onChange", [item._idd, combo._currentComboValue]);
		}
		item._autoCheck();
	},
	
	doLoadOptsConnector: function(item, url) {
		var that = this;
		var i = item;
		item._connector_working = true;
		item._apiChange = true;
		item._combo.load(url, function(){
			// try to set value if it was called while options loading was in progress
			i.callEvent("onOptionsLoaded", [i._idd]);
			i._connector_working = false;
			if (i._connector_value != null) {
				that.setValue(i, i._connector_value);
				i._connector_value = null;
			}
			i._apiChange = false;
			that = i = null;
		});
	},
	
	enable: function(item) {
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
		item._enabled = true;
		item._combo.enable();
	},
	
	disable: function(item) {
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
		item._enabled = false;
		item._combo.disable();
	},
	
	getCombo: function(item) {
		return item._combo;
	},
	
	setValue: function(item, val) {
		if (item._connector_working) { // attemp to set value while optins not yet loaded (connector used)
			item._connector_value = val;
			return;
		}
		item._apiChange = true;
		item._combo.setComboValue(val);
		item._combo._currentComboValue = item._combo.getActualValue();
		item._apiChange = false;
	},
	
	getValue: function(item) {
		return item._combo.getActualValue();
	},
	
	setWidth: function(item, width) {
		item.childNodes[item._ll?1:0].childNodes[0].style.width = width+"px";
	},
	
	setReadonly: function(item, state) {
		if (!item._combo) return;
		item._combo_ro = state;
		item._combo.readonly(item._combo_ro);
	},

	isReadonly: function(item, state) {
		return item._combo_ro||false;
	},
	
	setFocus: function(item) {
		if (item._enabled) item._combo.setFocus();
	},
	
	_setCss: function(item, skin, fontSize) {
		// update font-size for input and list-options div
		item._combo.setFontSize(fontSize, fontSize);
	}
	
};

(function(){
	for (var a in {doAddLabel:1,doAddInput:1,doLoadOpts:1,doUnloadNestedLists:1,setText:1,getText:1,isEnabled:1,_checkNoteWidth:1})
		dhtmlXForm.prototype.items.combo[a] = dhtmlXForm.prototype.items.select[a];
})();

dhtmlXForm.prototype.items.combo.d2 = dhtmlXForm.prototype.items.select.destruct;

dhtmlXForm.prototype.getCombo = function(name) {
	return this.doWithItem(name, "getCombo");
};



/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXForm.prototype.items.calendar = {
	
	render: function(item, data) {
		
		var t = this;
		
		item._type = "calendar";
		item._enabled = true;
		
		// dbl-click fix for IE6-8 (i.e. to select date user needs to click twice)
		var n = navigator.userAgent;
		var dblclickFix = (n.indexOf("MSIE 6.0") >= 0 || n.indexOf("MSIE 7.0") >= 0 || n.indexOf("MSIE 8.0") >= 0);
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "INPUT", "TEXT", true, true, "dhxform_textarea calendar");
		this.doAttachChangeLS(item);
		
		if (dblclickFix) {
			item.childNodes[item._ll?1:0].childNodes[0].onfocus2 = item.childNodes[item._ll?1:0].childNodes[0].onfocus;
			item.childNodes[item._ll?1:0].childNodes[0].onfocus = function() {
				if (this._skipOnFocus == true) {
					this._skipOnFocus = false;
					return;
				}
				this.onfocus2.apply(this,arguments);
			}
		}
		
		item.childNodes[item._ll?1:0].childNodes[0]._idd = item._idd;
		item.childNodes[item._ll?1:0].childNodes[0].onblur = function() {
			var i = this.parentNode.parentNode;
			if (i._c.base._formMouseDown) { // dblclickFix
				i._c.base._formMouseDown = false;
				this._skipOnFocus = true;
				this.focus();
				this.value = this.value;
				i = null;
				return true;
			}
			var f = i.getForm();
			f._ccDeactivate(i._idd);
			t.checkEnteredValue(this.parentNode.parentNode);
			if (f.live_validate) t._validate(i);
			f.callEvent("onBlur",[i._idd]);
			if (!i._c.isVisible()) i._tempValue = null;
			f = i = null;
		}
		
		item._f = (data.dateFormat||null); // formats
		item._f0 = (data.serverDateFormat||item._f); // formats for save-load, if set - use them for saving and loading only
		
		var f = item.getForm();
		
		item._c = new dhtmlXCalendarObject(item.childNodes[item._ll?1:0].childNodes[0], data.skin||f.skin||"dhx_skyblue");
		item._c._nullInInput = true; // allow null value from input
		item._c.enableListener(item.childNodes[item._ll?1:0].childNodes[0]);
		if (item._f != null) item._c.setDateFormat(item._f);
		if (!window.dhx4.s2b(data.enableTime)) item._c.hideTime();
		if (window.dhx4.s2b(data.enableTodayButton)) item._c.showToday();
		if (window.dhx4.s2b(data.showWeekNumbers)) item._c.showWeekNumbers();
		if (!isNaN(data.weekStart)) item._c.setWeekStartDay(data.weekStart);
		if (typeof(data.calendarPosition) != "undefined") item._c.setPosition(data.calendarPosition);
		if (data.minutesInterval != null) item._c.setMinutesInterval(data.minutesInterval);
		
		item._c._itemIdd = item._idd;
		
		item._c.attachEvent("onBeforeChange", function(d) {
			if (item._value != d) {
				// call some events
				if (item.checkEvent("onBeforeChange")) {
					if (item.callEvent("onBeforeChange",[item._idd, item._value, d]) !== true) {
						return false;
					}
				}
				// accepted
				item._tempValue = item._value = d;
				t.setValue(item, d, false);
				item.callEvent("onChange", [this._itemIdd, item._value]);
			}
			return true;
			
		});
		
		item._c.attachEvent("onClick", function(){
			item._tempValue = null;
		});
		item._c.attachEvent("onHide", function(){
			item._tempValue = null;
		});
		
		if (dblclickFix) {
			item._c.base.onmousedown = function() {
				this._formMouseDown = true;
				return false;
			}
		}
		
		this.setValue(item, data.value);
		
		f = null;
		
		return this;
		
	},
	
	getCalendar: function(item) {
		return item._c;
	},
	
	setSkin: function(item, skin) {
		item._c.setSkin(skin);
	},
	
	setValue: function(item, value, cUpd) {
		if (!value || value == null || typeof(value) == "undefined" || value == "") {
			item._value = null;
			item.childNodes[item._ll?1:0].childNodes[0].value = "";
		} else {
			item._value = (value instanceof Date ? value : item._c._strToDate(value, item._f0||item._c._dateFormat));
			item.childNodes[item._ll?1:0].childNodes[0].value = item._c._dateToStr(item._value, item._f||item._c._dateFormat);
		}
		if (cUpd !== false) item._c.setDate(item._value);
	},
	
	getValue: function(item, asString) {
		var d = item._tempValue||item._c.getDate();
		if (asString===true && d == null) return "";
		return (asString===true?item._c._dateToStr(d,item._f0||item._c._dateFormat):d);
	},
	
	setDateFormat: function(item, dateFormat, serverDateFormat) {
		item._f = dateFormat;
		item._f0 = (serverDateFormat||item._f);
		item._c.setDateFormat(item._f);
		this.setValue(item, this.getValue(item));
	},
	
	destruct: function(item) {
		
		// unload calendar instance
		item._c.disableListener(item.childNodes[item._ll?1:0].childNodes[0]);
		item._c.unload();
		item._c = null;
		try {delete item._c;} catch(e){}
		
		item._f = null;
		try {delete item._f;} catch(e){}
		
		item._f0 = null;
		try {delete item._f0;} catch(e){}
		
		// remove custom events/objects
		item.childNodes[item._ll?1:0].childNodes[0]._idd = null;
		item.childNodes[item._ll?1:0].childNodes[0].onblur = null;
		
		// unload item
		this.d2(item);
		item = null;
	},
	
	checkEnteredValue: function(item) {
		this.setValue(item, item._c.getDate());
	}
	
};

(function(){
	for (var a in {doAddLabel:1,doAddInput:1,doUnloadNestedLists:1,setText:1,getText:1,enable:1,disable:1,isEnabled:1,setWidth:1,setReadonly:1,isReadonly:1,setFocus:1,getInput:1})
		dhtmlXForm.prototype.items.calendar[a] = dhtmlXForm.prototype.items.input[a];
})();
dhtmlXForm.prototype.items.calendar.doAttachChangeLS = dhtmlXForm.prototype.items.select.doAttachChangeLS;
dhtmlXForm.prototype.items.calendar.d2 = dhtmlXForm.prototype.items.input.destruct;

dhtmlXForm.prototype.getCalendar = function(name) {
	return this.doWithItem(name, "getCalendar");
};

dhtmlXForm.prototype.setCalendarDateFormat = function(name, dateFormat, serverDateFormat) {
	this.doWithItem(name, "setDateFormat", dateFormat, serverDateFormat);
};


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXForm.prototype.items.btn2state = {
	setChecked: function(item, state) {
		item._checked = (state===true?true:false);
		item.childNodes[item._ll?1:0].lastChild.className = "dhxform_img "+item._cssName+"_"+(item._checked?"1":"0");
		this.doCheckValue(item);
	}
};

(function() {
	for (var a in dhtmlXForm.prototype.items.checkbox) {
		if (!dhtmlXForm.prototype.items.btn2state[a]) dhtmlXForm.prototype.items.btn2state[a] = dhtmlXForm.prototype.items.checkbox[a];
	}
})();


dhtmlXForm.prototype.items.btn2state.render2 = dhtmlXForm.prototype.items.btn2state.render;
dhtmlXForm.prototype.items.btn2state.render = function(item, data) {
	data._autoInputWidth = false;
	this.render2(item, data);
	item._type = "btn2state";
	item._cssName = (typeof(data.cssName)=="undefined"?"btn2state":data.cssName);
	item._updateImgNode = function(){};
	item._doOnFocus = function() {
		item.getForm().callEvent("onFocus",[item._idd]);
	}
	item._doOnBlur = function() {
		item.getForm().callEvent("onBlur",[item._idd]);
	}
	item._doOnKeyUpDown = function(evName, evObj, inp) {
		this.callEvent(evName, [this.childNodes[this._ll?0:1].childNodes[0], evObj, this._idd]);
	}
	this.setChecked(item, item._checked);
	return this;
};

dhtmlXForm.prototype.setFormData_btn2state = function(name, value) {
	this[value==true||parseInt(value)==1||value=="true"||value==this.getItemValue(name)?"checkItem":"uncheckItem"](name);
};
dhtmlXForm.prototype.getFormData_btn2state = function(name) {
	return (this.isItemChecked(name)?this.getItemValue(name):0);
};


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXForm.prototype.items.colorpicker = {
	
	colorpicker: {}, // colorpicker instances
	
	render: function(item, data) {
		
		var t = this;
		
		item._type = "colorpicker";
		item._enabled = true;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "INPUT", "TEXT", true, true, "dhxform_textarea");
		
		item._value = (data.value||"");
		item.childNodes[item._ll?1:0].childNodes[0].value = item._value;
		
		var conf = {
			input: item.childNodes[item._ll?1:0].childNodes[0],
			custom_colors: (window.dhx4.s2b(data.enableCustomColors) == true),
			skin: item.getForm().skin
		};
		
		this.colorpicker[item._idd] = new dhtmlXColorPicker(conf);
		this.colorpicker[item._idd]._nodes[0].valueColor = null; // disable input's bg change
		this.colorpicker[item._idd].base.className += " dhtmlxcp_in_form";
		
		if (typeof(data.customColors) != "undefined") {
			this.colorpicker[item._idd].setCustomColors(data.customColors);
		}
		
		if (typeof(data.cpPosition) == "string") {
			this.colorpicker[item._idd].setPosition(data.cpPosition);
		}
		
		// select handler
		this.colorpicker[item._idd].attachEvent("onSelect", function(color){
			if (item._value != color) {
				// call some events
				if (item.checkEvent("onBeforeChange")) {
					if (item.callEvent("onBeforeChange",[item._idd, item._value, color]) !== true) {
						// do not allow set new value
						item.childNodes[item._ll?1:0].childNodes[0].value = item._value;
						return;
					}
				}
				// accepted
				item._value = color;
				t.setValue(item, color);
				item.callEvent("onChange", [item._idd, item._value]);
			}
		});
		this.colorpicker[item._idd].attachEvent("onHide", function(color){
			var i = item.childNodes[item._ll?1:0].childNodes[0];
			if (i.value != item._value) i.value = item._value;
			i = null;
		});
		
		
		item.childNodes[item._ll?1:0].childNodes[0]._idd = item._idd;
		
		return this;
		
	},
	
	getColorPicker: function(item) {
		return this.colorpicker[item._idd];
	},
	
	destruct: function(item) {
		
		// unload color picker instance
		if (this.colorpicker[item._idd].unload) this.colorpicker[item._idd].unload();
		this.colorpicker[item._idd] = null;
		try {delete this.colorpicker[item._idd];} catch(e){}
		
		// remove custom events/objects
		item.childNodes[item._ll?1:0].childNodes[0]._idd = null;
		
		// unload item
		this.d2(item);
		item = null;
	},
	
	setSkin: function(item, skin) {
		this.colorpicker[item._idd].setSkin(skin);
	}
	
};


(function(){
	for (var a in {doAddLabel:1,doAddInput:1,doUnloadNestedLists:1,setText:1,getText:1,enable:1,disable:1,isEnabled:1,setWidth:1,setReadonly:1,isReadonly:1,setValue:1,getValue:1,updateValue:1,setFocus:1,getInput:1})
		dhtmlXForm.prototype.items.colorpicker[a] = dhtmlXForm.prototype.items.input[a];
})();

dhtmlXForm.prototype.items.colorpicker.d2 = dhtmlXForm.prototype.items.input.destruct;


dhtmlXForm.prototype.getColorPicker = function(name) {
	return this.doWithItem(name, "getColorPicker");
};



/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXForm.prototype.items.container = {
	
	render: function(item, data) {
		
		item._type = "container";
		item._enabled = true;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "DIV", null, true, true, "dhxform_container");
		
		return this;
		
	},
	
	getContainer: function(item) {
		return item.childNodes[item._ll?1:0].childNodes[0];
	},
	
	enable: function(item) {
		item._enabled = true;
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
		//
		item.callEvent("onEnable",[item._idd]);
	},
	
	disable: function(item) {
		item._enabled = false;
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
		//
		item.callEvent("onDisable",[item._idd]);
	},
	
	doAttachEvents: function(){
		
	},
	
	setValue: function(){
		
	},
	
	getValue: function(){
		return null;
	}
	
};

dhtmlXForm.prototype.getContainer = function(name) {
	return this.doWithItem(name, "getContainer");
};

(function(){
	for (var a in dhtmlXForm.prototype.items.input) {
		if (!dhtmlXForm.prototype.items.container[a]) dhtmlXForm.prototype.items.container[a] = dhtmlXForm.prototype.items.input[a];
	}
})();


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXForm.prototype.items.editor = {
	
	editor: {},
	
	render: function(item, data) {
		
		var ta = (!isNaN(data.rows));
		
		item._type = "editor";
		item._enabled = true;
		item._editor_id = item.getForm().idPrefix+item._idd;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "DIV", null, true, true, "dhxform_item_template");
		
		item._value = (data.value||"");
		
		var that = this;
		this.editor[item._editor_id] = new dhtmlXEditor({
			parent: item.childNodes[item._ll?1:0].childNodes[0],
			content: item._value,
			iconsPath: data.iconsPath, // path for toolbar icons
			toolbar: data.toolbar,
			skin: item.getForm().skin
		});
		
		this.editor[item._editor_id].attachEvent("onAccess",function(t, ev){
			// generate body click to hide menu/toolbar/calendar/combo/other stuff if any
			item.callEvent("_onBeforeEditorAccess", []); // if editor attached to form in popup - do some tricks
			_dhxForm_doClick(document.body, "click");
			// continue
			if (t == "blur") {
				that.doOnBlur(item, this);
				item.callEvent("onBlur", [item._idd]);
				if ({dhx_terrace:1, material: 1}[item.getForm().skin] == 1) {
					var css = item.childNodes[item._ll?1:0].className;
					if (css.indexOf("dhxeditor_focus") >= 0) item.childNodes[item._ll?1:0].className = (css).replace(/\s{0,}dhxeditor_focus/gi,"");
				}
			} else {
				item.callEvent("onEditorAccess", [item._idd, t, ev, this, item.getForm()]);
				item.callEvent("onFocus", [item._idd]);
				if ({dhx_terrace:1, material: 1}[item.getForm().skin] == 1) {
					var css = item.childNodes[item._ll?1:0].className;
					if (css.indexOf("dhxeditor_focus") == -1) item.childNodes[item._ll?1:0].className += " dhxeditor_focus";
				}
			}
		});
		
		this.editor[item._editor_id].attachEvent("onToolbarClick", function(a){
			item.callEvent("onEditorToolbarClick", [item._idd, a, this, item.getForm()]);
		});
		
		if (data.readonly) this.setReadonly(item, true);
		
		// emulate label-for
		item.childNodes[item._ll?0:1].childNodes[0].removeAttribute("for");
		item.childNodes[item._ll?0:1].childNodes[0].onclick = function() {
			that.editor[item._editor_id]._focus();
		}
		
		return this;
		
	},
	
	// destructor for editor needed
	doOnBlur: function(item, editor) {
		var t = editor.getContent();
		if (item._value != t) {
			if (item.checkEvent("onBeforeChange")) {
				if (item.callEvent("onBeforeChange",[item._idd, item._value, t]) !== true) {
					// restore
					editor.setContent(item._value);
					return;
				}
			}
			// accepted
			item._value = t;
			item.callEvent("onChange",[item._idd, t]);
		}
	},
	
	setValue: function(item, value) {
		if (item._value == value) return;
		item._value = value;
		this.editor[item._editor_id].setContent(item._value);
	},
	
	getValue: function(item) {
		item._value = this.editor[item._editor_id].getContent();
		return item._value;
	},
	
	enable: function(item) {
		if (this.isEnabled(item) != true) {
			this.editor[item._editor_id].setReadonly(false);
			this.doEn(item);
		}
	},
	
	disable: function(item) {
		if (this.isEnabled(item) == true) {
			this.editor[item._editor_id].setReadonly(true);
			this.doDis(item);
		}
	},
	
	setReadonly: function(item, mode) {
		this.editor[item._editor_id].setReadonly(mode);
	},
	
	getEditor: function(item) {
		return (this.editor[item._editor_id]||null);
	},
	
	destruct: function(item) {
		
		// custom editor functionality
		item.childNodes[item._ll?0:1].childNodes[0].onclick = null;
		
		// unload editor
		this.editor[item._editor_id].unload();
		this.editor[item._editor_id] = null;
		
		// unload item
		this.d2(item);
		item = null;
		
	},
	
	setFocus: function(item) {
		this.editor[item._editor_id]._focus();
	}
	
};

(function(){
	for (var a in {doAddLabel:1,doAddInput:1,doUnloadNestedLists:1,setText:1,getText:1,setWidth:1,isEnabled:1})
		dhtmlXForm.prototype.items.editor[a] = dhtmlXForm.prototype.items.template[a];
})();

dhtmlXForm.prototype.items.editor.d2 = dhtmlXForm.prototype.items.select.destruct;
dhtmlXForm.prototype.items.editor.doEn = dhtmlXForm.prototype.items.select.enable;
dhtmlXForm.prototype.items.editor.doDis = dhtmlXForm.prototype.items.select.disable;

dhtmlXForm.prototype.getEditor = function(name) {
	return this.doWithItem(name, "getEditor");
};



/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXForm.prototype.items.image = {
	
	_dimFix: true,
	
	render: function(item, data) {
		
		item._type = "image";
		item._enabled = true;
		
		item._fr_name = "dhxform_image_"+window.dhx4.newId();
		item._url = (typeof(data.url)=="undefined"||data.url==null?"":data.url);
		
		if (data.inputWidth == "auto") data.inputWidth = 120;
		if (data.inputHeight == "auto") data.inputHeight = data.inputWidth;
		
		this.doAddLabel(item, data);
		
		this.doAddInput(item, data, "DIV", null, true, true, "dhxform_image");
		
		var t = item.childNodes[item._ll?1:0].childNodes[0];
		t.style.height = parseInt(t.style.height)-dhtmlXForm.prototype.items[this.t]._dim+"px";
		
		var w = (typeof(data.imageWidth)!="undefined"?parseInt(data.imageWidth):data.inputWidth);
		var h = (typeof(data.imageHeight)!="undefined"?parseInt(data.imageHeight):data.inputHeight);
		if (h == "auto") h = w;
		
		item._dim = {mw: data.inputWidth-this._dim, mh: data.inputHeight-this._dim, w: w, h: h};
		
		t.innerHTML = "<img class='dhxform_image_img' border='0' style='visibility:hidden;'>"+
				"<iframe name='"+item._fr_name+"' style='position: absolute; width:0px; height:0px; top:-10px; left:-10px;' frameBorder='0' border='0'></iframe>"+
				"<div class='dhxform_image_wrap'>"+
					"<form action='"+item._url+"' method='POST' enctype='multipart/form-data' target='"+item._fr_name+"' class='dhxform_image_form'>"+
						"<input type='hidden' name='action' value='uploadImage'>"+
						"<input type='hidden' name='itemId' value='"+item._idd+"'>"+
						"<input type='file' name='file' class='dhxform_image_input'>"+
					"</form>";
				"</div>";
		
		this.adjustImage(item);
		
		// file selection
		t.childNodes[2].firstChild.lastChild.onchange = function() {
			item._is_uploading = true;
			this.parentNode.submit();
			this.parentNode.parentNode.className = "dhxform_image_wrap dhxform_image_in_progress";
			this.value = ""; // prevent update on cancel click in chrome
		}
		
		// iframe updates
		var that = this;
		if (window.navigator.userAgent.indexOf("MSIE") >= 0) {
			t.childNodes[1].onreadystatechange = function() {if (this.readyState == "complete") that.doOnUpload(item);}
		} else {
			t.childNodes[1].onload = function(){that.doOnUpload(item);}
		}
		this._moreClear = function() {
			that = null;
		}
		
		// initial value
		this.setValue(item, data.value||"");
		
		t = null;
		
		return this;
		
	},
	
	destruct: function(item) {
		// custom functionality
		var t = item.childNodes[item._ll?1:0].childNodes[0];
		t.childNodes[2].firstChild.lastChild.onchange = null;
		t.childNodes[1].onreadystatechange = null;
		t.childNodes[1].onload = null;
		this._moreClear();
		
		// common form's unload
		this.d2(item);
		item = null;
	},
	
	doAttachEvents: function() {
		
	},
	
	setValue: function(item, value) {
		item._value = (value==null?"":value);
		
		var u = item._url+
			(item._url.indexOf("?")>=0?"&":"?")+"action=loadImage"+
			"&itemId="+encodeURIComponent(item._idd)+
			"&itemValue="+encodeURIComponent(item._value)+
			window.dhx4.ajax._dhxr("&")
		
		var currentImg = item.childNodes[item._ll?1:0].childNodes[0].firstChild;
		
		if (currentImg.nextSibling.tagName.toLowerCase() == "img") {
			currentImg.nextSibling.src = u; // new img created and still loaded from prev setValue() call
		} else {
			var img = document.createElement("IMG");
			img.className = "dhxform_image_img";
			img.style.visibility = "hidden";
			img.onload = function() {
				this.style.visibility = "visible";
				this.parentNode.removeChild(this.nextSibling);
				this.onload = this.onerror = null;
			}
			img.onerror = function() {
				this.onload.apply(this, arguments);
				this.style.visibility = "hidden";
			}
			currentImg.parentNode.insertBefore(img, currentImg);
			img.src = u;
			img = null;
			this.adjustImage(item);
		}
		
		currentImg = null;
	},
	
	getValue: function(item) {
		return item._value;
	},
	
	doOnUpload: function(item) {
		if (item._is_uploading == true) {
			
			var fr = item.childNodes[item._ll?1:0].childNodes[0].lastChild.previousSibling; // iframe
			var r = dhx4.s2j(fr.contentWindow.document.body.innerHTML);
			
			if (typeof(r) == "object" && r != null && r.state == true && r.itemId == item._idd) {
				this.setValue(item, r.itemValue, true);
				item.getForm().callEvent("onImageUploadSuccess", [r.itemId, r.itemVaule, r.extra])
			} else {
				// show empty field, r can be null
				item.getForm().callEvent("onImageUploadFail", [item._idd, (r?r.extra:null)]);
			}
			
			r = fr = null;
			
			window.setTimeout(function(){
				item.childNodes[item._ll?1:0].childNodes[0].lastChild.className = "dhxform_image_wrap"; // div
				item._is_uploading = false; // ready to new upload
			},50);
			
		}
	},
	
	adjustImage: function(item) {
		var i = item.childNodes[item._ll?1:0].childNodes[0].firstChild; // image
		var w = Math.min(item._dim.mw, item._dim.w);
		var h = Math.min(item._dim.mh, item._dim.h);
		i.style.width = w+"px";
		i.style.height = h+"px";
		i.style.marginLeft = Math.max(0, Math.round(item._dim.mw/2-w/2))+"px";
		i.style.marginTop = Math.max(0, Math.round(item._dim.mh/2-h/2))+"px";
		i = item = null;
	}
	
};

(function(){
	for (var a in dhtmlXForm.prototype.items.input) {
		if (!dhtmlXForm.prototype.items.image[a]) dhtmlXForm.prototype.items.image[a] = dhtmlXForm.prototype.items.input[a];
	}
})();
dhtmlXForm.prototype.items.image.d2 = dhtmlXForm.prototype.items.input.destruct;

dhtmlXForm.prototype.setFormData_image = function(name, value) {
	this.setItemValue(name, value);
};
dhtmlXForm.prototype.getFormData_image = function(name) {
	return this.getItemValue(name);
};


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXForm.prototype.items.upload = {
	
	render: function(item, data) {
		
		item._type = "up";
		
		item._enabled = true;
		item._checked = true; // required for authoCheck
		
		item.className = data.position+(typeof(data.className)=="string"?" "+data.className:"");
		
		var k = document.createElement("DIV");
		item.appendChild(k);
		
		if (!isNaN(data.inputLeft)) item.style.left = parseInt(data.inputLeft)+"px";
		if (!isNaN(data.inputTop)) item.style.top = parseInt(data.inputTop)+"px";
		if (data.inputWidth != "auto") if (!isNaN(data.inputWidth)) k.style.width = parseInt(data.inputWidth)+"px";
		
		item._uploader = new dhtmlXFileUploader(k, data.swfPath||"", data.swfUrl||"", data.mode||null, data.swfLogs, data.slXap||"", data.slUrl||"", data.slLogs||"", data.multiple);
		item._uploader.setURL(data.url||"");
		item._uploader.callEvent = item.callEvent;
		
		if (typeof(data.autoStart) != "undefined") item._uploader.setAutoStart(data.autoStart);
		if (typeof(data.autoRemove) != "undefined") item._uploader.setAutoRemove(data.autoRemove);
		if (typeof(data.titleScreen) != "undefined") item._uploader.enableTitleScreen(data.titleScreen);
		if (typeof(data.titleText) != "undefined") item._uploader.setTitleText(data.titleText);
		
		if (data.hidden == true) this.hide(item);
		if (data.disabled == true) this.userDisable(item);
		
		if (!(data.inputHeight == "auto" || parseInt(data.inputHeight) == NaN))
			item._uploader.p_files.style.height = parseInt(data.inputHeight)+"px";
		
		return this;
	},
	
	destruct: function(item) {
		
		this.doUnloadNestedLists(item);
		
		item._uploader.callEvent = function(){return true;};
		item._uploader.unload();
		item._uploader.callEvent = null;
		item._uploader = null;
		
		item._checked = null;
		item._enabled = null;
		item._idd = null;
		item._type = null;
		
		item.onselectstart = null;
		
		item._autoCheck = null;
		item.callEvent = null;
		item.checkEvent = null;
		item.getForm = null;
		
		while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
		
		item.parentNode.removeChild(item);
		item = null;
	
	},
	
	setText: function(item, text) {
		
	},
	
	getText: function(item) {
		
	},
	
	enable: function(item) {
		item._enabled = true;
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
		item._uploader.enable();
	},
	
	disable: function(item) {
		item._enabled = false;
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
		item._uploader.disable();
	},
	
	setWidth: function(item, width) {
		item.childNodes[0].style.width = width+"px";
		item._width = width;
	},
	
	getWidth: function(item) {
		return item._width||parseInt(item.childNodes[0].style.width);
	},
	
	setValue: function(item) {
		item._uploader.clear();
	},
	
	getValue: function(item) {
		var t = item._uploader.getData();
		var r = {};
		var i = 0;
		for (var a in t) {
			r[item._idd+"_r_"+i] = t[a].realName;
			r[item._idd+"_s_"+i] = t[a].serverName;
			i++;
		}
		r[item._idd+"_count"] = i;
		return r;
	},
	
	getUploader: function(item) {
		return item._uploader;
	},
	
	getStatus: function(item) {
		return item._uploader.getStatus();
	}
};

(function(){
	for (var a in {doUnloadNestedLists:1,isEnabled:1})
		dhtmlXForm.prototype.items.upload[a] = dhtmlXForm.prototype.items.checkbox[a];
})();

dhtmlXForm.prototype.setFormData_upload = function(name) {
	this.doWithItem(name, "setValue");
};

dhtmlXForm.prototype.getUploader = function(name) {
	return this.doWithItem(name, "getUploader");
};

dhtmlXForm.prototype.getUploaderStatus = function(name) {
	return this.doWithItem(name, "getStatus");
};

/* uploader */

function dhtmlXFileUploader(p, swfPath, swfUrl, mode, swfLogs, slXap, slUrl, slLogs, multiple) {
	
	var that = this;
	
	if (typeof(mode) == "string" && typeof(this[mode]) == "function") {
		this.engine = mode;
	} else {
		this.engine = "html4";
		
		var k = null;
		if (typeof(window.FormData) != "undefined" && typeof(window.XMLHttpRequest) != "undefined") {
			k = new XMLHttpRequest();
			if (typeof(k.upload) == "undefined") k = null;
		}
		
		if (k != null) {
			// IE10, IE11, FF, Chrome, Opera
			this.engine = "html5";
		} else if (typeof(window.swfobject) != "undefined" || k === false) {
			var k = swfobject.getFlashPlayerVersion();
			if (k.major >= 10) this.engine = "flash";
		} else {
			// check if silverlight installed
			this._sl_v = this.getSLVersion();
			if (this._sl_v) this.engine = "sl";
		}
		k = null;
	}
	
	if (typeof(p) == "string") p = document.getElementById(p);
	
	this._upload_mp = (typeof(multiple) != "undefined" ? multiple==true : true); // multiple file select
	this._upload_dnd = true;
	
	
	// swf-file path
	this._swf_file_url = swfPath||"";
	this._swf_upolad_url = swfUrl||"";
	this._swf_logs = swfLogs;
	
	// sl-data
	this._sl_xap = slXap;
	this._sl_upload_url = slUrl;
	this._sl_logs = slLogs;
	
	// main cont
	this.p = document.createElement("DIV");
	this.p.className += " dhx_file_uploader";
	p.appendChild(this.p);
	
	// files
	this.p_files = document.createElement("DIV");
	this.p_files.className = "dhx_upload_files";
	this.p.appendChild(this.p_files);
	
	// buttons
	this.p_controls = document.createElement("DIV");
	this.p_controls.className = "dhx_upload_controls";
	this.p.appendChild(this.p_controls);
	
	// init engine
	
	/* upload */
	
	this._files = {};
	this._items = {};
	
	this._data = {}; // uploaded files
	
	this._autoStart = false;
	this._autoRemove = false;
	this._titleScreen = true;
	
	this._enabled = true;
	
	this._uploaded_count = 0;
	
	this._initToolbar = function() {
		
		// add
		this.b_opts = {
			info:	{ onclick: null },
			browse:	{ onclick: null, tooltip: "Browse" },
			upload:	{ onclick: function() { if (!that._enabled) return; if (!that._uploading) { that._uploadStart(); } }, tooltip: "Upload" },
			cancel:	{ onclick: function() { if (!that._enabled) return; that._uploadStop(); that._switchButton(false); }, tooltip: "Stop" },
			clear:	{ onclick: function() { if (!that._enabled) return; that.clear(); }, tooltip: "Clear list" }
		};
		
		this.buttons = {};
		
		for (var a in this.b_opts) {
			var k = document.createElement("DIV");
			k.innerHTML = "&nbsp;";
			k.className = "dhx_file_uploader_button button_"+a;
			k.onclick = this.b_opts[a].onclick;
			if (this.b_opts[a].tooltip) k.title = this.b_opts[a].tooltip;
			this.p_controls.appendChild(k);
			this.buttons[a] = k;
			k = null;
		}
		
		this.buttons["cancel"].style.display = "none";
	}
	
	this._readableSize = function(t) {
		var i = false;
		var b = ["b","Kb","Mb","Gb","Tb","Pb","Eb"];
		for (var q=0; q<b.length; q++) if (t > 1024) t = t / 1024; else if (i === false) i = q;
		if (i === false) i = b.length-1;
		return Math.round(t*100)/100+" "+b[i];
	}
	
	this._beforeAddFileToList = function(name, size) {
		return (this.callEvent("onBeforeFileAdd", [name, size])===true);
	}
	
	this._addFileToList = function(id, name, size, state, progress) {
		
		this._checkTitleScreen();
		
		var t = document.createElement("DIV");
		t._idd = id;
		t.className = "dhx_file dhx_file_"+state;
		t.innerHTML =   "<div class='dhx_file_param dhx_file_name'>&nbsp;</div>"+
				"<div class='dhx_file_param dhx_file_progress'>"+progress+"%</div>"+
				"<div class='dhx_file_param dhx_file_delete' title='Remove from list'>&nbsp;</div>";
		
		this.p_files.appendChild(t);
		
		// filename area width
		t.childNodes[0].style.width = t.offsetWidth-127+"px";
		
		this._items[id] = t;
		
		this._updateFileNameSize(id);
		
		t.childNodes[2].onclick = function() {
			if (!that._enabled) return;
			var id = this.parentNode._idd;
			that._removeFileFromQueue(id);
		}
		
		this.callEvent("onFileAdd", [name]);
	}
	
	this._removeFileFromList = function(id) {
		
		if (!this._items[id]) return;
		
		this._items[id].childNodes[2].onclick = null;
		this._items[id].parentNode.removeChild(this._items[id]);
		this._items[id] = null;
		delete this._items[id];
		
		if (this._data[id]) {
			this._data[id] = null;
			delete this._data[id];
		}
		
		this._checkTitleScreen();
	}
	
	this._updateFileNameSize = function(id) {
		this._items[id].childNodes[0].innerHTML = this._files[id].name+(!isNaN(this._files[id].size)?" ("+this._readableSize(this._files[id].size)+")":"&nbsp;");
		this._items[id].childNodes[0].title = this._files[id].name+(!isNaN(this._files[id].size)?" ("+this._readableSize(this._files[id].size)+")":"");
	}
	
	this._updateFileInList = function(id, state, progress) {
		if (!this._items[id]) return;
		this._items[id].className = "dhx_file dhx_file_"+state;
		// progress
		this._updateProgress(id, state, progress);
		this._updateFileNameSize(id);
	}
	
	this._updateProgress = function(id, state, progress) {
		if (state == "uploading" && progress < 100 && this._progress_type == "loader") {
			this._items[id].childNodes[1].className = "dhx_file_param dhx_file_uploading";
			this._items[id].childNodes[1].innerHTML = "&nbsp;";
		} else {
			this._items[id].childNodes[1].className = "dhx_file_param dhx_file_progress";
			this._items[id].childNodes[1].innerHTML = progress+"%";
		}
		this._updateFileNameSize(id);
	}
	
	this._removeFilesByState = function(state) {
		for (var a in this._files) {
			if (state === true || this._files[a].state == state) {
				this._removeFileFromQueue(a);
			}
		}
	}
	
	this._switchButton = function(state) {
		if (state == true) {
			this.buttons["upload"].style.display = "none";
			this.buttons["cancel"].style.display = "";
		} else {
			var t = this._uploaded_count;
			this.buttons["upload"].style.display = "";
			this.buttons["cancel"].style.display = "none";
			this._uploaded_count = 0;
			if (t > 0) this.callEvent("onUploadComplete",[t]);
		}
	}
	
	this._uploadStart = function() {
		
		this._switchButton(true);
		
		// change status for prev fail auploads if any
		if (!this._uploading) {
			for (var a in this._files) {
				if (this._files[a].state == "fail") {
					this._files[a].state = "added";
					this._updateFileInList(a, "added", 0);
				}
			}
		}
		
		this._uploading = true;
		
		var t = false;
		
		for (var a in this._files) {
			if (!t && [this._files[a].state] == "added") {
				t = true;
				this._files[a].state = "uploading";
				this._updateFileInList(a, "uploading", 0);
				this._doUploadFile(a);
			}
		}
		if (!t) {
			this._uploading = false;
			this._switchButton(false);
		}
		
	}
	
	this._onUploadSuccess = function(id, serverName, r, extra) {
		
		// flash mode
		if (typeof(r) != "undefined" && this.engine == "flash") {
			var t = dhx4.s2j(r.data);
			if (t != null && t.state == true && t.name != null) {
				serverName = t.name;
				if (t.extra != null) extra = t.extra;
			} else {
				this._onUploadFail(id, (t!=null&&t.extra!=null?t.extra:null));
				return;
			}
		}
		
		//
		this._uploaded_count++;
		this._data[id] = {realName: this._files[id].name, serverName: serverName};
		this._files[id].state = "uploaded";
		this._updateFileInList(id, "uploaded", 100);
		this.callEvent("onUploadFile", [this._files[id].name, serverName, extra]);
		if (this._autoRemove) this._removeFileFromQueue(id);
		if (this._uploading) this._uploadStart();
	}
	
	this._onUploadFail = function(id, extra) {
		this._files[id].state = "fail";
		this._updateFileInList(id, "fail", 0);
		this.callEvent("onUploadFail", [this._files[id].name, extra]);
		if (this._uploading) this._uploadStart();
	}
	
	this._onUploadAbort = function(id) {
		this._uploading = false;
		this._files[id].state = "added";
		this._updateFileInList(id, "added", 0);
		this.callEvent("onUploadCancel",[this._files[id].name]);
	}
	
	this._checkTitleScreen = function() {
		var k = 0;
		for (var a in this._files) k++;
		
		if (k == 0 && this.p.className.search("dhx_file_uploader_title") < 0 && this._titleScreen) {
			// show title screen
			this.p.className += " dhx_file_uploader_title";
			this.buttons["info"].innerHTML = this._titleText;
			this.buttons["info"].style.width = Math.max(this.p_controls.offsetWidth-134, 0)+"px";
		}
		if ((k > 0 || !this._titleScreen) && this.p.className.search("dhx_file_uploader_title") >= 0) {
			// hide title screen
			this.p.className = this.p.className.replace(/dhx_file_uploader_title/g,"");
			this.buttons["info"].innerHTML = "";
		}
	}
	
	// events
	this.callEvent = function(){}
	
	// public
	this.upload = function() {
		if (!this._uploading) this._uploadStart();
	}
	
	this.setAutoStart = function(state) {
		this._autoStart = (state==true);
	}
	
	this.setAutoRemove = function(state) {
		this._autoRemove = (state==true);
	}
	
	this.enableTitleScreen = function(state) {
		this._titleScreen = (state==true);
		this._checkTitleScreen();
	}
	
	this.setTitleText = function(text) {
		this._titleText = text;
		if (this.p.className.search("dhx_file_uploader_title") >= 0) this.buttons["info"].innerHTML = this._titleText;
	}
	
	this.setURL = function(url) {
		this._url = url;
	}
	
	this.setSWFURL = function(url) {
		this._swf_upolad_url = url;
	}
	
	this.enable = function() {
		this._enabled = true;
		this.p_files.className = "dhx_upload_files";
		this.p_controls.className = "dhx_upload_controls";
	}
	
	this.disable = function() {
		this._enabled = false;
		this.p_files.className = "dhx_upload_files dhx_uploader_dis";
		this.p_controls.className = "dhx_upload_controls dhx_uploader_dis";
	}
	
	this.getStatus = function() {
		// 0 - filelist is empty
		// 1 - all files in filelist uploaded
		//-1 - not all files uploaded
		var t = 0;
		for (var a in this._files) {
			if (this._files[a].state != "uploaded") return -1;
			t = 1;
		}
		return t;
	}
	
	this.getData = function() {
		// return struct of uploaded files
		return this._data;
	}
	
	this.clear = function() {
		if (this.callEvent("onBeforeClear", []) !== true) return;
		if (this._uploading) that._uploadStop();
		that._switchButton(false);
		that._removeFilesByState(true);
		this.callEvent("onClear",[]);
	}
	
	this.unload = function() {
		
		// remove all files from queue/list
		this._removeFilesByState(true);
		this._data = null;
		this._files = null;
		this._items = null;
		
		// custom engine stuff
		this._unloadEngine();
		
		// buttons
		for (var a in this.buttons) {
			this.buttons[a].onclick = null;
			this.buttons[a].parentNode.removeChild(this.buttons[a]);
			this.buttons[a] = null;
			delete this.buttons[a];
		}
		this.buttons = null;
		
		// buttons settings
		for (var a in this.b_opts) {
			this.b_opts[a].onclick = null;
			this.b_opts[a] = null;
			delete this.b_opts[a];
		}
		this.b_opts = null;
		
		this.p_controls.parentNode.removeChild(this.p_controls);
		this.p_files.parentNode.removeChild(this.p_files);
		
		// main container
		this.p.className = this.p.className.replace(/dhx_file_uploader_title/gi,"").replace(/dhx_file_uploader/gi,"");
		
		for (var a in this) this[a] = null;
		
		that = a = null;
		
	}
	
	// init engine-relative funcs
	var e = new this[this.engine]();
	for (var a in e) { this[a] = e[a]; e[a] = null; }
	a = e = p = null;
	
	// init app
	this._initToolbar();
	this._initEngine();
	this._checkTitleScreen();
	
	return this;
	
}

// html5 engine

dhtmlXFileUploader.prototype.html5 = function(){};

dhtmlXFileUploader.prototype.html5.prototype = {

	_initEngine: function() {
		
		var that = this;
		this.buttons["browse"].onclick = function(){
			if (that._enabled) that.f.click();
		}
		
		this._progress_type = "percentage";
		
		// Safari on Windows sometimes have problem with multiple file selections
		// file length set to zero, do not allow multiple file selecting
		// d-n-d seems works fine
		
		var k = window.navigator.userAgent;
		if (k.match(/Windows/gi) != null && k.match(/AppleWebKit/gi) != null && k.match(/Safari/gi) != null) {
			if (k.match(/Version\/5\.1\.5/gi)) this._upload_mp = false;
			if (k.match(/Version\/5\.1[^\.\d{1,}]/gi)) this._upload_dnd = false;
			if (k.match(/Version\/5\.1\.1/gi)) {
				this._upload_mp = false;
				this._upload_dnd = false;
			}
			if (k.match(/Version\/5\.1\.2/gi)) this._upload_dnd = false;
			if (k.match(/Version\/5\.1\.7/gi)) this._upload_mp = false;
		}
		
		// "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-EN) AppleWebKit/533.21.1 (KHTML, like Gecko) Version/5.0.1 Safari/533.17.8"	// ok, no dnd
		// "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-EN) AppleWebKit/533.21.1 (KHTML, like Gecko) Version/5.0.2 Safari/533.18.5"	// ok, no dnd
		// "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-EN) AppleWebKit/533.21.1 (KHTML, like Gecko) Version/5.0.3 Safari/533.19.4"	// ok, no dnd
		// "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-EN) AppleWebKit/533.21.1 (KHTML, like Gecko) Version/5.0.4 Safari/533.20.27"	// ok, no dnd
		// "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-EN) AppleWebKit/533.21.1 (KHTML, like Gecko) Version/5.0.5 Safari/533.21.1"	// ok, no dnd
		// "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50"				// ok, dnd partialy fail, disabled
		// "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.52.7 (KHTML, like Gecko) Version/5.1.1 Safari/534.51.22"			// multiple files add - fail, dnd partialy fail, disabled
		// "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.52.7 (KHTML, like Gecko) Version/5.1.2 Safari/534.52.7"			// ok, dnd partialy fail, disabled
		// "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.54.16 (KHTML, like Gecko) Version/5.1.4 Safari/534.54.16"			// ok
		// "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.55.3 (KHTML, like Gecko) Version/5.1.5 Safari/534.55.3"			// multiple files add - fail
		// "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2"			// dnd - ok, multiselect - fail (Windows 8)
		
		// input
		this._addFileInput();
		
		// dnd
		if (this._upload_dnd) {
			
			this.p.ondragenter = function(e){
				if (!e.dataTransfer) return;
				e.stopPropagation();
				e.preventDefault();
			}
			this.p.ondragover = function(e){
				if (!e.dataTransfer) return;
				e.stopPropagation();
				e.preventDefault();
			}
			this.p.ondrop = function(e) {
				if (!e.dataTransfer) return;
				e.stopPropagation();
				e.preventDefault();
				if (that._enabled) that._parseFilesInInput(e.dataTransfer.files);
			}
			
			this._titleText = "Drag-n-Drop files here or<br>click to select files for upload.";
			
		} else {
			this._titleText = "Click to select files for upload.";
		}
	},
	
	_addFileInput: function() {
		
		// complete input reload, opera needs
		if (this.f != null) {
			this.f.onchange = null;
			this.f.parentNode.removeChild(this.f);
			this.f = null;
		}
		
		var that = this;
		
		this.f = document.createElement("INPUT");
		this.f.type = "file";
		
		if (this._upload_mp) this.f.multiple = "1";
		this.f.className = "dhx_uploader_input";
		this.p_controls.appendChild(this.f);
		
		this.f.onchange = function() {
			that._parseFilesInInput(this.files);
			if (window.dhx4.isOpera) that._addFileInput(); else this.value = "";
		}
	},

	_doUploadFile: function(id) {
		
		var that = this;
		
		if (!this._loader) {
			this._loader = new XMLHttpRequest();
			this._loader.upload.onprogress = function(e) {
				if (that._files[this._idd].state == "uploading") that._updateFileInList(this._idd, "uploading", Math.round(e.loaded*100/e.total));
			}
			this._loader.onload = function(e) {
				var r = dhx4.s2j(this.responseText);
				if (typeof(r) == "object" && r != null && typeof(r.state) != "undefined" && r.state == true) {
					that._onUploadSuccess(this.upload._idd, r.name, null, r.extra);
					r = null;
				} else {
					that._onUploadFail(this.upload._idd, (r!=null&&r.extra!=null?r.extra:null));
				}
			}
			this._loader.onerror = function(e) {
				that._onUploadFail(this.upload._idd);
			}
			this._loader.onabort = function(e) {
				that._onUploadAbort(this.upload._idd);
			}
		}
		
		this._loader.upload._idd = id;
		
		var form = new FormData();
		form.append("file", this._files[id].file);
		
		this._loader.open("POST", this._url+(String(this._url).indexOf("?")<0?"?":"&")+"mode=html5"+window.dhx4.ajax._dhxr("&"), true);
		this._loader.setRequestHeader("X-Requested-With", "XMLHttpRequest");
		this._loader.send(form);
		
	},
	
	_uploadStop: function() {
		if (!this._uploading || !this._loader) return;
		this._loader.abort();
	},
	
	_parseFilesInInput: function(f) {
		for (var q=0; q<f.length; q++) this._addFileToQueue(f[q]);
	},
	
	_addFileToQueue: function(f) {
		if (!this._beforeAddFileToList(f.name, f.size)) return;
		var id = (f._idd||window.dhx4.newId());
		this._files[id] = {file: f, name: f.name, size: f.size, state: "added"};
		this._addFileToList(id, f.name, f.size, "added", 0);
		if (this._autoStart && !this._uploading) this._uploadStart(true);
	},
	
	_removeFileFromQueue: function(id) {
		
		if (!this._files[id]) return;
		
		var name = this._files[id].name;
		var serverName = (this._data!=null&&this._data[id]!=null?this._data[id].serverName:null);
		
		if (this.callEvent("onBeforeFileRemove",[name,serverName]) !== true) return;
		
		var k = false;
		if (this._uploading && id == this._loader.upload._idd && this._files[id].state == "uploading") {
			this._uploadStop();
			k = true;
		}
		
		this._files[id].file = null;
		this._files[id].name = null;
		this._files[id].size = null;
		this._files[id].state = null;
		this._files[id] = null;
		delete this._files[id];
		
		this._removeFileFromList(id);
		
		this.callEvent("onFileRemove",[name,serverName]);
		
		if (k) this._uploadStart();

	},
	
	_unloadEngine: function() {
		
		this.buttons["browse"].onclick = null;
		
		this.f.onchange = null;
		this.f.parentNode.removeChild(this.f);
		this.f = null;
		
		this.p.ondragenter = null;
		this.p.ondragover = null;
		this.p.ondrop = null;
		
		if (this._loader) {
			this._loader.upload.onprogress = null;
			this._loader.onload = null;
			this._loader.onerror = null;
			this._loader.onabort = null;
			this._loader.upload._idd = null;
			this._loader = null;
		}
		
		this._initEngine = null;
		this._doUploadFile = null;
		this._uploadStop = null;
		this._parseFilesInInput = null;
		this._addFileToQueue = null;
		this._removeFileFromQueue = null;
		this._unloadEngine = null;
		
	}
	
};

// html4 engine

dhtmlXFileUploader.prototype.html4 = function(){};

dhtmlXFileUploader.prototype.html4.prototype = {

	_initEngine: function() {
		
		this._addForm();
		this._progress_type = "loader";
		
		this._titleText = "Click button<br>to select files for upload.";
	},
	
	_addForm: function() {
		
		var that = this;
		var id = window.dhx4.newId();
		
		if (!this.k) {
			
			this.k = document.createElement("DIV");
			this.k.className = "dhx_file_form_cont";
			this.buttons["browse"].appendChild(this.k);
			
			this.fr_name = "dhx_file_"+window.dhx4.newId();
			this.k.innerHTML = '<iframe name="'+this.fr_name+'" style="height:0px;width:0px;" frameBorder="0"></iframe>';
			
			this.fr = this.k.firstChild;
			
			if (window.navigator.userAgent.indexOf("MSIE") >= 0) {
				this.fr.onreadystatechange = function() {
					if (this.readyState == "complete") that._onLoad();
				}
			} else {
				this.fr.onload = function() {
					that._onLoad();
				}
			}
			
		}
		
		var f = document.createElement("DIV");
		f.innerHTML = "<form method='POST' enctype='multipart/form-data' target='"+this.fr_name+"' class='dhx_file_form' name='dhx_file_form_"+window.dhx4.newId()+"'>"+
				"<input type='hidden' name='mode' value='html4'>"+
				"<input type='hidden' name='uid' value='"+id+"'>"+
				"<input type='file' name='file' class='dhx_file_input'>"+
				"</form>";
		this.k.appendChild(f);
		
		f.firstChild.lastChild._idd = id;
		
		f.firstChild.lastChild.onchange = function(){
			if (!that._beforeAddFileToList(this.value, null)) return;
			that._addFileToQueue(this);
			this.onchange = null;
			this.parentNode.parentNode.style.display = "none";
			that._addForm();
		}
		
		f = null;
	},
	
	_onLoad: function() {
		if (this._uploading) {
			var r = dhx4.s2j(this.fr.contentWindow.document.body.innerHTML);
			//this.fr.contentWindow.document.body.innerHTML = "";
			if (typeof(r) == "object" && r != null) {
				if (typeof(r.state) != "undefined") {
					if (r.state == "cancelled") {
						this._onUploadAbort(this.fr._idd);
						r = null;
						return;
					} else if (r.state == true) {
						if (typeof(r.size) != "undefined" && !isNaN(r.size)) this._files[this.fr._idd].size = r.size;
						this._onUploadSuccess(this.fr._idd, r.name, null, r.extra);
						r = null;
						return;
					}
				}
			}
			this._onUploadFail(this.fr._idd, (r!=null && r.extra != null ? r.extra:null));
		}
		
	},
	
	_addFileToQueue: function(t) {
		var v = t.value.match(/[^\\\/]*$/g);
		if (v[0] != null) v = v[0]; else v = t.value;
		//
		this._files[t._idd] = { name: v, form: t.parentNode, node: t.parentNode.parentNode, input: t, state: "added"};
		this._addFileToList(t._idd, t.value, false, "added", 0);
		if (this._autoStart && !this._uploading) this._uploadStart(true);
	},
	
	_removeFileFromQueue: function(id) {
		
		var name = this._files[id].name;
		var serverName = (this._data!=null&&this._data[id]!=null?this._data[id].serverName:null);
		
		if (this.callEvent("onBeforeFileRemove",[name,serverName]) !== true) return;
		
		this._files[id].input.onchange = null;
		this._files[id].form.removeChild(this._files[id].input);
		this._files[id].node.removeChild(this._files[id].form);
		this._files[id].node.parentNode.removeChild(this._files[id].node);
		this._files[id].input = null;
		this._files[id].name = null;
		this._files[id].form = null;
		this._files[id].node = null;
		this._files[id].size = null;
		this._files[id].state = null;
		this._files[id] = null;
		delete this._files[id];
		
		this._removeFileFromList(id);
		
		this.callEvent("onFileRemove",[name,serverName]);
	},
	
	_doUploadFile: function(id) {
		this.fr._idd = id;
		this._files[id].form.action = this._url;
		this._files[id].form.submit();
	},
	
	_uploadStop: function() {
		if (!this._uploading) return;
		this.fr.contentWindow.location.href = (this._url)+(this._url.indexOf("?")<0?"?":"&")+"mode=html4&action=cancel"+window.dhx4.ajax._dhxr("&");
	},
	
	_unloadEngine: function() {
		
		if (this.k) {
			
			this.fr_name = null;
			this.fr.onreadystatechange = null;
			this.fr.onload = null;
			this.fr.parentNode.removeChild(this.fr);
			this.fr = null;
			
			// remove empty form
			this.k.firstChild.firstChild.lastChild.onchange = null;
			
			this.k.parentNode.removeChild(this.k);
			this.k = null;
			
		}
		
		this._initEngine = null;
		this._addForm = null;
		this._onLoad = null;
		this._addFileToQueue = null;
		this._removeFileFromQueue = null;
		this._doUploadFile = null;
		this._uploadStop = null;
		this._unloadEngine = null;
		
	}
	
};


dhtmlXFileUploader.prototype.flash = function(){};

dhtmlXFileUploader.prototype.flash.prototype = {
	
	_initEngine: function() {
		
		if (window.dhtmlXSWFObjectsPull == null) {
			window.dhtmlXSWFObjectsPull = {
				items: {},
				callEvent: function(id, name, params) {
					return window.dhtmlXSWFObjectsPull.items[id].uploader[name].apply(window.dhtmlXSWFObjectsPull.items[id].uploader,params);
				}
			};
		}
		
		var that = this;
		
		this._swf_obj_id = "dhtmlXFileUploaderSWFObject_"+window.dhx4.newId();
		this._swf_file_url = this._swf_file_url+window.dhx4.ajax._dhxr(this._swf_file_url);
		this.buttons["browse"].innerHTML = "<div id='"+this._swf_obj_id+"' style='width:100%;height:100%;'></div>";
		swfobject.embedSWF(this._swf_file_url, this._swf_obj_id, "100%", "100%", "9", null, {ID:this._swf_obj_id,enableLogs:this._swf_logs}, {wmode:"transparent"});
		
		var v = swfobject.getFlashPlayerVersion();
		this._titleText = "Engine successfuly inited<br>Flash Player: "+v.major+"."+v.minor+"."+v.release;
		
		this._progress_type = "percentage";
		
		window.dhtmlXSWFObjectsPull.items[this._swf_obj_id] = {id: this._swf_obj_id, uploader: this};
	},
	
	_beforeAddFileToQueue: function(name, size) {
		return (this.callEvent("onBeforeFileAdd", [name, size])===true);
	},
	
	_addFileToQueue: function(id, name, size) {
		if (window.dhx4.isIE) {
			// focus+hide fix for IE
			var k = document.createElement("INPUT");
			k.type = "TEXT";
			k.style.position = "absolute";
			k.style.left = "0px";
			k.style.top = window.dhx4.absTop(this.buttons["browse"])+"px";
			k.style.width = "10px";
			document.body.appendChild(k);
			k.focus();
			document.body.removeChild(k);
			k = null;
		}
		this._files[id] = {name: name, size: size, state: "added"};
		this._addFileToList(id, name, size, "added", 0);
		if (this._autoStart && !this._uploading) this._uploadStart(true);
	},
		
	_removeFileFromQueue: function(id) {
		
		if (!this._files[id]) return;
		
		var name = this._files[id].name;
		var serverName = (this._data!=null&&this._data[id]!=null?this._data[id].serverName:null);
		
		if (this.callEvent("onBeforeFileRemove",[name,serverName]) !== true) return;
		
		var k = false;
		if (this._uploading && this._files[id].state == "uploading") {
			this._uploadStop();
			k = true;
		}
		
		swfobject.getObjectById(this._swf_obj_id).removeFileById(id);
		
		this._files[id].name = null;
		this._files[id].size = null;
		this._files[id].state = null;
		this._files[id] = null;
		delete this._files[id];
		
		this._removeFileFromList(id);
		
		this.callEvent("onFileRemove",[name,serverName]);
		
		if (k) this._uploadStart();

	},
	
	_doUploadFile: function(id) {
		swfobject.getObjectById(this._swf_obj_id).upload(id, this._swf_upolad_url);
	},
	
	_uploadStop: function(id) {
		for (var a in this._files) if (this._files[a].state == "uploading") swfobject.getObjectById(this._swf_obj_id).uploadStop(a);
	},
	
	_unloadEngine: function() {
		
		// remove instance from global storage
		
		if (window.dhtmlXSWFObjectsPull.items[this._swf_obj_id]) {
			window.dhtmlXSWFObjectsPull.items[this._swf_obj_id].id = null;
			window.dhtmlXSWFObjectsPull.items[this._swf_obj_id].uploader = null;
			window.dhtmlXSWFObjectsPull.items[this._swf_obj_id] = null
			delete window.dhtmlXSWFObjectsPull.items[this._swf_obj_id];
		}
		
		this._swf_obj_id = null;
		
		this._initEngine = null;
		this._addFileToQueue = null;
		this._removeFileFromQueue = null;
		this._doUploadFile = null;
		this._uploadStop = null;
		this._unloadEngine = null;
	}
	
};

dhtmlXFileUploader.prototype.sl = function(){};
		
dhtmlXFileUploader.prototype.sl.prototype = {
	
	_initEngine: function() {
		
		if (typeof(this._sl_v) == "undefined") this._sl_v = this.getSLVersion();
		
		if (!window.dhtmlXFileUploaderSLObjects) {
			window.dhtmlXFileUploaderSLObjects = {
				items: {},
				callEvent: function(id, name, params) {
					//console.log(arguments)
					window.dhtmlXFileUploaderSLObjects.items[id].uploader[name].apply(window.dhtmlXFileUploaderSLObjects.items[id].uploader,params);
				}
			};
		}
		
		//var that = this;
		
		this._sl_obj_id = "dhtmlXFileUploaderSLObject_"+window.dhx4.newId();
		
		if (this._sl_v != false) {
			this._titleText = "Engine successfuly inited<br>Silverlight version: "+this._sl_v[0]+"."+this._sl_v[1];
			this.buttons["browse"].innerHTML = '<div style="width:100%;height:100%;">'+
									'<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="100%" height="100%" id="'+this._sl_obj_id+'">'+
										'<param name="source" value="'+this._sl_xap+'"/>'+
										'<param name="background" value="Transparent"/>'+
										'<param name="windowless" value="true"/>'+
										'<param name="initParams" value="SLID='+this._sl_obj_id+',LOGS='+this._sl_logs+'"/>'+
										'<param name="minRuntimeVersion" value="5.0"/>'+
									'</object>'+
								'</div>';
		} else {
			this._titleText = "Silverlight plugin not found<br>or version less than 4.0";
			this.buttons["browse"].style.cursor = "wait";
			this.buttons["browse"].title = "";
		}
		
		this._progress_type = "percentage";
		
		window.dhtmlXFileUploaderSLObjects.items[this._sl_obj_id] = {id: this._sl_obj_id, uploader: this};
	},
	
	_addFileToQueue: function(id, name, size) {
		this._files[id] = {name: name, size: size, state: "added"};
		this._addFileToList(id, name, size, "added", 0);
		if (this._autoStart && !this._uploading) this._uploadStart(true);
	},
	
	_removeFileFromQueue: function(id) {
		if (!this._files[id]) return;
		
		var k = false;
		if (this._uploading && this._files[id].state == "uploading") {
			this._uploadStop();
			k = true;
		}
		
		document.getElementById([this._sl_obj_id]).Content.a.removeFileById(id);
		
		this._files[id].name = null;
		this._files[id].size = null;
		this._files[id].state = null;
		this._files[id] = null;
		delete this._files[id];
		
		this._removeFileFromList(id);
		
		if (k) this._uploadStart();
		
	},
	
	_doUploadFile: function(id) {
		// sl have inner url parser and params will cut,
		// sho should be passed via 3rd param
		var p = this._sl_upload_url.split("?");
		p = (p[1]!=null?"&"+p[1]:"");
		//
		document.getElementById(this._sl_obj_id).Content.a.upload(id, this._sl_upload_url, p+"&mode=sl"+window.dhx4.ajax._dhxr("&")); // leading "&" required!
	},
	
	_uploadStop: function(id) {
		this._uploading = false;
		for (var a in this._files) if (this._files[a].state == "uploading") document.getElementById(this._sl_obj_id).Content.a.uploadStop(a);
	},
	
	_unloadEngine: function() {
		
		// remove instance from global storage
		
		if (window.dhtmlXFileUploaderSLObjects.items[this._sl_obj_id]) {
			window.dhtmlXFileUploaderSLObjects.items[this._sl_obj_id].id = null;
			window.dhtmlXFileUploaderSLObjects.items[this._sl_obj_id].uploader = null;
			window.dhtmlXFileUploaderSLObjects.items[this._sl_obj_id] = null
			delete window.dhtmlXFileUploaderSLObjects.items[this._sl_obj_id];
		}
		
		this._sl_obj_id = null;
		
		this._initEngine = null;
		this._addFileToQueue = null;
		this._removeFileFromQueue = null;
		this._doUploadFile = null;
		this._uploadStop = null;
		this._unloadEngine = null;
	}
	
};

dhtmlXFileUploader.prototype.setSLURL = function(url) {
	this._sl_upload_url = url;
};

dhtmlXFileUploader.prototype.getSLVersion = function() {
	var v = false;
	if (window.dhx4.isIE) {
		try {
			var t = new ActiveXObject('AgControl.AgControl');
			if (t != null) {
				// loop through [4-x, 0-9] until supported
				var k1 = 4, k2 = 0;
				while (t.isVersionSupported([k1,k2].join("."))) {
					v = [k1,k2];
					if (++k2 > 9) { k1++; k2=0; }
				}
			}
			t = null;
		} catch(e) {};
	} else {
		if (navigator.plugins["Silverlight Plug-In"] != null) {
			v = navigator.plugins["Silverlight Plug-In"].description.split(".");
		}
	}
	return v;
};


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXForm.prototype.saveBackup = function() {
	if (!this._backup) {
		this._backup = {};
		this._backupId = new Date().getTime();
	}
	this._backup[++this._backupId] = this.getFormData();
	return this._backupId;
};

dhtmlXForm.prototype.restoreBackup = function(id) {
	if (this._backup != null && this._backup[id] != null) {
		this.setFormData(this._backup[id]);
	}
};

dhtmlXForm.prototype.clearBackup = function(id) {
	if (this._backup != null && this._backup[id] != null) {
		this._backup[id] = null;
		delete this._backup[id];
	}
};


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/* add item */
dhtmlXForm.prototype.addItem = function(pId, itemData, pos, insertAfter) {
	
	// insertAfter
	// if any columns used - item will inserted into colunm where item[pos] positioned, before it
	// insertAfter specifies that new item will inserted after item[pos], to add possibility to make new item last in column
	// this param ignored when inserting newcolumn
	
	// pId = [id,value] for radiobutton
	var pValue = null;
	if (pId instanceof Array) {pValue = pId[1];pId = pId[0];}
	
	var f = null;
	if (pId != null) {
		var f = this._getParentForm(pId, pValue);
		// check if item in "f" have nested form
		if (f != null) {
			if (f.item._list == null) {
				// create list
				if (!itemData.listParent) itemData.listParent = f.item._idd;
				f.form._addItem("list", f.item._idd, [itemData], null, f.item._idd, pos, insertAfter);
			} else {
				f.item._list[0].addItem(null, itemData, pos, insertAfter);
			}
			f.form = f.item = null;
			f = null;
			this._autoCheck();
			return;
		}
	}
	
	this._prepareItem(itemData, pos, insertAfter);
	this._autoCheck();
};

/* remove item */
dhtmlXForm.prototype.removeItem = function(id, value) {
	this._removeItem(id, value);
};

/* remove newcolumn */
dhtmlXForm.prototype.removeColumn = function(pId, index, removeItems, moveAfter) {
	
	// index of column
	// if single column - only items can be deleted if removeItems==true
	// if more than one column and removeItems==false, move items to leftmost column (if not exists - to right) and vise versa if moveAfter=true
	
	// pId = [id,value] for radiobutton
	var pValue = null;
	if (pId instanceof Array) {pValue = pId[1];pId = pId[0];}
	
	if (pId != null) {
		var f = this._getParentForm(pId, pValue);
		if (f != null) {
			if (f.item._list != null && f.item._list[0] != null) {
				f.item._list[0].removeColumn(null, index, removeItems, moveAfter);
			}
			f.form = f.item = null;
			f = null;
		}
		return;
	}
	
	// find base
	index = Math.min(Math.max(index,0), this.cont.childNodes.length-1); // index [0..length-1)
	if (this.cont.childNodes.length == 1) {
		// one column
		if (removeItems == true) {
			// remove items
			this._removeItemsInColumn(this.cont.childNodes[index]);
		}
	} else {
		// more than one
		if (removeItems == true) {
			// remove items
			this._removeItemsInColumn(this.cont.childNodes[index]);
		} else {
			// move items to next column
			if (!moveAfter) {
				var moveToBase = index-1;
				if (moveToBase < 0) moveToBase = index+1;
			} else {
				var moveToBase = index+1;
				if (moveToBase > this.cont.childNodes.length-1) moveToBase = index-1;
			}
			// console.log("index ",index,"moveToBase",moveToBase)
			while (this.cont.childNodes[index].childNodes.length > 0) {
				this.cont.childNodes[moveToBase].appendChild(this.cont.childNodes[index].childNodes[0]);
			}
			
		}
		var t = [];
		for (var q=0; q<this.base.length; q++) {
			if (this.cont.childNodes[index] != this.base[q]) t.push(this.base[q]);
		}
		this.base = t;
		this.cont.removeChild(this.cont.childNodes[index]);
		this.b_index--;
		t = null;
	}
};

dhtmlXForm.prototype.getColumnNode = function(pId, index) {
	
	var node = null;
	
	var pValue = null;
	if (pId instanceof Array) {pValue = pId[1];pId = pId[0];}
	
	if (pId != null) {
		var f = this._getParentForm(pId, pValue);
		if (f != null) {
			if (f.item._list != null && f.item._list[0] != null && node == null) {
				node = f.item._list[0].getColumnNode(null, index);
			}
			f.form = f.item = null;
			f = null;
		}
		return node;
	}
	
	if (index < 0 || index > this.cont.childNodes.length-1) return null;
	return this.cont.childNodes[index];
};

dhtmlXForm.prototype._removeItemsInColumn = function(base) {
	var items = [];
	for (var q=0; q<base.childNodes.length; q++) {
		var i = base.childNodes[q];
		if (i._idd != null && i._type != null) items.push([i._idd, (i._type=="ra"?i._value:null)]);
		i = null;
	}
	for (var q=0; q<items.length; q++) {
		this.removeItem(items[q][0],items[q][1]);
	}
};

dhtmlXForm.prototype._getParentForm = function(id, value) {
	// check if simple item
	if (this.itemPull[this.idPrefix+id] != null) {
		return {form: this, item: this.itemPull[this.idPrefix+id]};
	}
	// check if radio
	for (var a in this.itemPull) {
		if (this.itemPull[a]._type == "ra" && this.itemPull[a]._group == id && this.itemPull[a]._value == value) {
			return {form: this, item: this.itemPull[a]};
		}
	}
	var f = null;
	for (var a in this.itemPull) {
		if (!f && this.itemPull[a]._list != null) {
			for (var q=0; q<this.itemPull[a]._list.length; q++) {
				if (!f) f = this.itemPull[a]._list[q]._getParentForm(id, value);
			}
		}
	}
	
	return f;
};

(function(){
	for (var a in dhtmlXForm.prototype.items) {
		if (!dhtmlXForm.prototype.items[a]._getItemNode) dhtmlXForm.prototype.items[a]._getItemNode = function(item){return item;}
	}
})();

dhtmlXForm.prototype._getItemNode = function(id, value) {
	if (value != null) id = [id, value];
	return this.doWithItem(id, "_getItemNode");
};


/* set/clear required flag */
dhtmlXForm.prototype.setRequired = function(id, value, state) {
	
	if (typeof(state) == "undefined") state = value; else id = [id,value];
	var item = this._getItemNode(id);
	if (!item) return;
	
	state = window.dhx4.s2b(state);
	item._required = (state==true);
	
	// validation
	if (item._required) {
		if (!item._validate) item._validate = [];
		var t = false;
		for (var q=0; q<item._validate.length; q++) t = (item._validate[q]=="NotEmpty"||t);
		if (!t) item._validate.push("NotEmpty");
		var p = item.childNodes[item._ll?0:1].childNodes[0];
		if (!(p.lastChild && p.lastChild.className && p.lastChild.className.search(/required/) >= 0)) {
			var k = document.createElement("SPAN");
			k.className = "dhxform_item_required";
			k.innerHTML = "*";
			p.appendChild(k);
			k = p = null;
		}
	} else {
		if (item._validate != null) {
			var t = item._validate;
			item._validate = [];
			for (var q=0; q<t.length; q++) { if (t[q] != "NotEmpty") item._validate.push(t[q]); }
			if (item._validate.length == 0) item._validate = null;
		}
		var p = item.childNodes[item._ll?0:1].childNodes[0];
		if (p.lastChild && p.lastChild.className && p.lastChild.className.search(/required/) >= 0) {
			p.removeChild(p.lastChild);
			p = null;
		}
	}
	
	this._resetValidateCss(item);
	item = null;
	
};

/* set/clear note */
dhtmlXForm.prototype.setNote = function(id, value, note) {
	
	if (typeof(note) == "undefined") note = value; else id = [id,value];
	var item = this._getItemNode(id);
	if (!item) return;
	
	var p = this._getNoteNode(item);
	
	if (!p) {
		if (!note.width) note.width = item.childNodes[item._ll?1:0].childNodes[0].offsetWidth;
		p = document.createElement("DIV");
		p.className = "dhxform_note";
		if ({"ch":1,"ra":1}[item._type]) {
			item.childNodes[item._ll?1:0].insertBefore(p, item.childNodes[item._ll?1:0].lastChild);
		} else {
			item.childNodes[item._ll?1:0].appendChild(p);
		}
		
	}
	
	p.innerHTML = note.text;
	if (note.width != null) {
		p.style.width = note.width+"px";
		p._w = note.width;
	}
	
	p = null;
};

dhtmlXForm.prototype.clearNote = function(id, value) {
	
	if (typeof(value) != "undefined") id = [id,value];
	var item = this._getItemNode(id);
	if (!item) return;
	
	var p = this._getNoteNode(item);
	if (p != null) {
		p.parentNode.removeChild(p);
		p = null;
	}
	
};

dhtmlXForm.prototype._getNoteNode = function(item) {
	
	var p = null;
	for (var q=0; q<item.childNodes[item._ll?1:0].childNodes.length; q++) {
		if (String(item.childNodes[item._ll?1:0].childNodes[q].className).search(/dhxform_note/) >= 0) {
			p = item.childNodes[item._ll?1:0].childNodes[q];
		}
	}
	
	item = null;
	
	return p;
};

/* set/clear validation */

dhtmlXForm.prototype.setValidation = function(id, value, rule) {
	
	if (typeof(note) == "undefined") rule = value; else id = [id,value];
	var item = this._getItemNode(id);
	if (!item) return;
	
	// init state, clear prev
	if (item._validate != null) for (var q=0; q<item._validate.length; q++) item._validate[q] = null;
	item._validate = [];
	
	// apply new rules
	if (typeof(rule) == "function" || typeof(window[rule]) == "function") {
		item._validate = [rule];
	} else {
		item._validate = String(rule).split(this.separator);
	}
	
	// check required state
	if (item._required) {
		var r = false;
		for (var q=0; q<item._validate.length; q++) r = (item._validate[q]=="NotEmpty"||r);
		if (!r) item._validate.push("NotEmpty");
	}
	
	item = null;

};

dhtmlXForm.prototype.clearValidation = function(id, value) {
	
	if (typeof(value) != "undefined") id = [id,value];
	var item = this._getItemNode(id);
	if (!item) return;
	
	// clear
	if (item._validate != null) for (var q=0; q<item._validate.length; q++) item._validate[q] = null;
	
	// check required
	item._validate = item._required?["NotEmpty"]:null;
	
	item = null;
	
};

/* reload options */

dhtmlXForm.prototype.reloadOptions = function(name, data) {
	
	var t = this.getItemType(name);
	
	if (!{select:1,multiselect:1,combo:1}[t]) return;
	
	if (t == "select" || t == "multiselect") {
		var opts = this.getOptions(name);
		while (opts.length > 0) opts.remove(0);
		opts.length = 0;
		opts = null;
		if (typeof(data) == "string") {
			this.doWithItem(name, "doLoadOptsConnector", data);
		} else if (data instanceof Array) {
			this.doWithItem(name, "doLoadOpts", {options:data});
		}
	}
	
	if (t == "combo") {
		var combo = this.getCombo(name);
		combo.clearAll();
		combo.setComboValue("");
		if (typeof(data) == "string") {
			this.doWithItem(name, "doLoadOptsConnector", data);
		} else if (data instanceof Array) {
			var toSelect = null;
			for (var q=0; q<data.length; q++) if (window.dhx4.s2b(data[q].selected)) toSelect = data[q].value;
			combo.addOption(data);
			if (toSelect != null) this.setItemValue(name, toSelect);
			combo = null;
		}
	}
};

/* tooltips */

dhtmlXForm.prototype.setTooltip = function(id, value, tooltip) {
	
	if (typeof(tooltip) == "undefined") tooltip = value; else id = [id,value];
	var item = this._getItemNode(id);
	if (!item) return;
	
	var node = null;
	if (item.childNodes.length == 1) {
		node = item.childNodes[0];
	} else {
		for (var q=0; q<item.childNodes.length; q++) {
			if (item.childNodes[q].className != null && item.childNodes[q].className.search("dhxform_label") >= 0) {
				node = item.childNodes[q];
			}
		}
	}
	if (node != null) {
		if (tooltip == null || tooltip.length == 0) {
			node.removeAttribute("title");
		} else {
			node.title = tooltip;
		}
	}
	node = null;
};


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXAccordion(base, skin) {
	
	var that = this;
	var transData = window.dhx4.transDetect();
	
	this.conf = {
		skin: (skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxacc")||"material"),
		css: "dhxacc", // css prefix for topcell mtb
		icons_path: "",
		icons_css: false,
		multi_mode: false,
		last_opened: null, // single_mode only
		on_active_id: null, // id for onActive in single_mode, inner
		on_active_click: false, // activation by click or by script
		size_changed: true,
		def_height: 90, // defult height
		// items count
		total_count: 0,
		hiden_count: 0,
		cont_w: null
	};
	
	// effects
	this.conf.tr = {
		prop: transData.transProp, // false if not available
		ev: transData.transEv,
		height_open: "height 0.2s cubic-bezier(0.25,0.1,0.25,1)", // cell open/close by click
		height_close: "height 0.18s cubic-bezier(0.25,0.1,0.25,1)", // cell open/close by click
		op_open: "opacity 0.16s ease-in", // cell_cont on open
		op_close: "opacity 0.2s ease-out", // cell_cont on close
		op_v_open: "1", // opacity for opened cell
		op_v_close: "0.4", // opacity for closed cell
		dnd_top: "top 0.16s" // dnd
	};
	
	// cells offsets
	this.ofs = {
		// working values, will generated by _applyOffsets
		m:{}, // multi_mode
		s:{},  // single_mode
		// default offset, based on skyblue
		def: {
			m: { // multi_mode
				left: 0, // horizontal offset between parent-edge and cell for both left and right sides
				right: 0, // cell to edge from right
				first: 0, // top before first
				between: 8 // vertical offset between cells for multi_mode
			},
			s: { // single_mode
				left: 0,
				right: 0,
				first: 0,
				between: -1,
				last: 0 // last cell bottom's and bottom edge
			}
		},
		// override by base (parentId), if base._ofs attr is set, used in attachComponent()
		base: {
			s: {},
			m: {}
		},
		// override by skin
		skin: {
			dhx_web: {
				s: { between: 3 },
				m: { between: 3 }
			},
			dhx_terrace: {
				m: { between: 12, left: 0, right: 0 }
			},
			material: {
				m: { between: 12, left: 0, right: 0 }
			}
		}
	};
	
	// open/close fix
	if (navigator.userAgent.indexOf("MSIE") >= 0 || navigator.userAgent.indexOf("Trident") >= 0) {
		// ie10, ie11
		this.conf.tr.height_open = this.conf.tr.height_close;
	} else {
		// ff, opera, chrome - good
		this.conf.tr.height_open = this.conf.tr.height_close;
	}
	
	var apiInit = null;
	if (typeof(base) == "object" && !base.tagName) {
		apiInit = {};
		for (var a in base) {
			apiInit[a] = base[a];
			base[a] = null;
		}
		base = apiInit.parent;
		apiInit.parent = null;
	}
	
	// init top container
	window.dhtmlXCellTop.apply(this, [base, base._ofs]);
	this._adjustCont();
	
	// offset fix, base override
	if (this.base._ofs != null) {
		for (var mode in this.ofs.base) {
			if (this.base._ofs[mode] != null) {
				for (var a in this.base._ofs[mode]) this.ofs.base[mode][a] = this.base._ofs[mode][a];
			}
		}
	}
	
	this._applyOffsets = function() {
		// 1) default
		// 2) skin override if any
		// 3) base._ofs override if any
		for (var mode in this.ofs.def) {
			var def = this.ofs.def[mode];
			var skin = (this.ofs.skin[this.conf.skin] != null && this.ofs.skin[this.conf.skin][mode] != null ? this.ofs.skin[this.conf.skin][mode] : null);
			var base = (this.base._ofs != null ? this.base._ofs[mode] : null);
			for (var a in def) {
				if (skin != null && skin[a] != null) {
					this.ofs[mode][a] = skin[a];
				} else if (base != null && base[a] != null) {
					this.ofs[mode][a] = base[a];
				} else {
					this.ofs[mode][a] = def[a];
				}
			}
		}
	}
	this._applyOffsets();
	
	this.t = {};
	
	this.addItem = function(id, text, open, height, icon) {
		
		// open - open/close new in 4.0, true by default, close prev item if any in single_mode
		// height - for multi_mode, new in 4.0
		
		// create cell
		// extend hdr
		// open/close
		// depending on mode - calculate width/height
		
		if (id == null) id = "a"+window.dhx4.newId();
		while (this.t[id] != null) id = "a"+window.dhx4.newId();
		
		var cell = new dhtmlXAccordionCell(id, this);
		cell.conf.skin = this.conf.skin;
		cell.setText(text);
		if (icon != null) cell.setIcon(icon);
		
		cell.cell._accId = id;
		cell.cell.childNodes[cell.conf.idx.hdr].onselectstart = function(e) {
			e = e||event;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			return false;
		}
		cell.cell.childNodes[cell.conf.idx.hdr].onclick = function(e) {
			e = e||event;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			if (that._dnd != null && that._dnd.ofs == true) return; // dnd
			var t = (e.target||e.srcElement);
			var id = null;
			while (t._accId != this && id == null) {
				if (t._accId != null) id = t._accId; else t = t.parentNode;
			}
			if (id != null) that._hdrClick(id);
		}
		
		this.t[id] = {cell: cell};
		
		this.conf.total_count++;
		
		if (this.conf.multi_mode) {
			
			if (typeof(open) == "undefined") open = true; // opened by default if not set
			
			this.cont.appendChild(cell.cell);
			
			cell.conf.opened = (open==true);
			if (typeof(height) == "undefined" || height == null || height == "*") {
				if (height == "*") cell.conf.h_auto = true;
				height = this.conf.def_height;
			} else {
				height = Math.max(parseInt(height),30);
			}
			
			// dim
			cell._setSize(this.ofs.m.left, 0, this.conf.cont_w||this._getAvailItemWidth(), cell.conf.opened?height:cell._getHdrHeight());
			cell.cell.style.marginTop = (cell.cell==this.cont.firstChild?this.ofs.m.first:this.ofs.m.between)+"px";
			if (open != true) {
				cell.conf.size.h = height;
				cell._adjustCell();
				cell.cell.className += " dhx_cell_closed";
			}
			this._adjustOpened();
			
			if (this._dnd != null) this._dndAttachEvent(id);
			
		} else {
			
			// closed by default or force if first node
			open = (this.conf.last_opened==null?true:window.dhx4.s2b(open));
			
			var h = this._updateCellsHeight();
			
			// close prev already opened cell if any or reduce height
			if (this.conf.last_opened != null) {
				if (open) {
					this._closeItem(this.conf.last_opened, false);
				} else {
					var openedCell = this.t[this.conf.last_opened].cell;
					openedCell._setSize(openedCell.conf.size.x, openedCell.conf.size.y, openedCell.conf.size.w, h);
					openedCell = null;
				}
			}
			this.cont.appendChild(cell.cell);
			cell.conf.opened = open;
			cell.cell.style.marginTop = String(cell.cell==this.cont.firstChild?this.ofs.s.first:this.ofs.s.between)+"px";
			
			cell._setSize(this.ofs.s.left, 0, this.conf.cont_w||this._getAvailItemWidth(), open?h:cell._getHdrHeight());
			if (open) {
				this.conf.last_opened = id;
			} else {
				cell.conf.size.h = h;
				cell._adjustCell();
				cell.cell.className += " dhx_cell_closed";
			}
			
		}
		
		cell = null;
		
		return this.t[id].cell;
	}
	
	this.removeItem = function(id) {
		
		if (!this.t[id]) return;
		if (this.conf.last_opened == id) this.conf.last_opened = null;
		if (this.conf.on_active_id == id) this.conf.on_active_id = null;
		
		if (this._dnd != null) this._dndClearCell(id);
		
		this.conf.total_count--;
		if (!this.conf.multi_mode && !this.t[id].cell.conf.visible) this.conf.hiden_count--;
		
		this.t[id].cell._unload();
		this.t[id].cell = null;
		this.t[id] = null;
		delete this.t[id];
		
		if (!this.conf.unloading) {
			if (!this.conf.multi_mode) this._updateCellsMargin();
			this.setSizes();
		}
	}
	
	this.cells = function(id) {
		return this.t[id].cell;
	}
	
	this.enableMultiMode = function(yScrollMode, defaultHeight) { // disabled by default
		this.conf.multi_mode = true;
		if (!isNaN(defaultHeight)) this.conf.def_height = defaultHeight;
		if (yScrollMode == "auto" || yScrollMode == "scroll") {
			this.cont.style.overflowX = "hidden";
			this.cont.style.overflowY = yScrollMode;
		} else {
			this.cont.style.overflow = "visible";
		}
	}
	
	this.forEachItem = function(func) {
		for (var a in this.t) {
			if (typeof(func) == "function") {
				func.apply(this, [this.t[a].cell]);
			} else {
				if (typeof(func) == "string" && typeof(window[func]) == "function") window[func].apply(this, [this.t[a].cell]);
			}
		}
	}
	
	this._openItem = function(id, ef) {
		
		if (typeof(ef) == "undefined") ef = true;
		
		if (this.t[id].cell.conf.opened == false) {
			
			if (this.conf.multi_mode) {
				
				this.t[id].cell._open(ef);
				
			} else {
				
				if (this.conf.tr.prop == false) {
					
					// simple open/close
					if (this.conf.last_opened != null) this.t[this.conf.last_opened].cell._close(false);
					this.t[id].cell._open(false);
					this.conf.last_opened = id;
					
				} else {
					this.conf.on_active_id = id;
					this.t[id].cell._open(ef);
					if (this.conf.last_opened != null) this.t[this.conf.last_opened].cell._close(ef);
					this.conf.last_opened = id;
				}
			}
		}
	}
	
	this._closeItem = function(id, ef) {
		if (typeof(ef) == "undefined") ef = true;
		if (this.t[id].cell.conf.opened == true) {
			this.t[id].cell._close(ef);
			this.conf.last_opened = null;
		}
	}
	
	this._adjustOpened = function() {
		
		// multi_mode - only width, check v-scroll
		// single_mode - width/height
		
		if (this.conf.multi_mode == true) {
			
			// new edition
			if (this._openCache == null) {
				var dynData = this._getDynData();
				for (var a in dynData) {
					this.t[a].cell.conf.size.h = Math.max(dynData[a],0);
					this.t[a].cell.cell.style.height = Math.max(dynData[a],0)+"px";
				}
			} else {
				var inProgress = false;
				for (var a in this._openCache) inProgress = (inProgress||this._openCache[a]);
				if (inProgress == true) return;
				this._openCache = this._openId = null;
			}
			
			var w2 = this._getAvailItemWidth();
			for (var a in this.t) {
				var adj = true;
				if (w2 == this.t[a].cell.conf.size.w && (this._openMode == "close" || this.t[a].cell.conf.opened == false)) adj = false;
				if (adj) this.t[a].cell._setWidth(w2);
			}
			
			this._openMode = null;
			
		} else {
			if (this.conf.last_opened != null) {
				var id = this.conf.last_opened;
				this.t[id].cell._setSize(this.t[id].cell.conf.size.x, this.t[id].cell.conf.size.y, this.t[id].cell.conf.size.w, this.t[id].cell.conf.size.h);
			}
		}
	}
	
	this._getDynData = function(toOpen, toClose) {
		
		// toOpen/toClose - static_or_dyn closed cell from _open() or _close(),
		// cells shoule be included into calculations
		if (typeof(toOpen) == "undefined" || toOpen == null) toOpen = {};
		if (typeof(toClose) == "undefined" || toClose == null) toClose = {};
		
		var dynData = {};
		var dynCount = 0;
		var h = 0;
		var f0 = 0; // item index (visible only)
		
		for (var q=0; q<this.cont.childNodes.length; q++) {
			var id = this.cont.childNodes[q]._accId;
			var t = this.t[id].cell;
			if (t.conf.visible == true) {
				var ofs = this.ofs.m[f0==0?"first":"between"];
				if (toOpen[id] == true || toClose[id] == true || (t.conf.opened == true && t.conf.h_auto == true)) {
					if (toClose[id] == true) {
						var h0 = t._getHdrHeight();
						dynData[id] = h0; // static cell going to opened, include to common h
						h += h0+ofs;
					} else if (t.conf.h_auto == true) { // dyn cell is here, just mark, include margin only
						dynData[id] = true;
						h += ofs;
						dynCount++;
					} else if (toOpen[id] == true) {
						dynData[id] = t.conf.size.h; // static cell going to opened, include to common h
						h += t.conf.size.h+ofs;
					}
				} else {
					h += t.cell.offsetHeight+ofs; // collapsed or static
				}
				f0++;

			}
			t = null;
		}
		
		// 2) calculate height for single h_auto cell
		// (avail_space-static_cells_height-closed_cells_height) / h_auto_cells_count
		
		if (dynCount > 0) {
			var hSum = this.cont.offsetHeight-h;
			var h = Math.floor(hSum/dynCount);
			for (var a in dynData) {
				if (dynData[a] == true) {
					if (dynCount > 1) hSum -= h; else h = hSum; // decrease main height each time, last item used all left height
					dynData[a] = h;
					dynCount--;
				}
			}
		}
		
		return dynData;
		
	}
	
	this.setSizes = function() {
		
		this._adjustCont();
		if (this.conf.multi_mode == true) {
			this._adjustOpened();
		} else {
			this.conf.cont_w = null; // reset saved base width
			var h = this._updateCellsHeight();
			for (var a in this.t) {
				if (this.t[a].cell.conf.visible == true) {
					this.t[a].cell._setSize(this.ofs.s.left, 0, this.conf.cont_w||this._getAvailItemWidth(), this.t[a].cell.conf.opened?h:this.t[a].cell._getHdrHeight());
					if (this.t[a].cell.conf.opened != true) {
						this.t[a].cell.conf.size.h = h;
						this.t[a].cell._adjustCell();
					}
				}
			}
			this.conf.size_changed = true; // for cell-show, recall setSizes()
		}
		
		this.callEvent("_onSetSizes", []);
	}
	
	this.setSkin = function(skin) {
		this._setBaseSkin(skin);
		this.conf.skin = skin;
		for (var a in this.t) {
			this.t[a].cell.conf.cells_cont = null; // reset cached cells offsets
			this.t[a].cell.conf.skin = this.conf.skin;
		}
		this._applyOffsets();
		this._updateCellsMargin();
		this.setSizes();
	}
	
	this.setIconsPath = function(path) {
		this.conf.icons_path = path;
	}
	
	this._getAvailItemWidth = function() {
		// 
		var p = this.ofs[(this.conf.multi_mode?"m":"s")];
		var w = Math.max(this.cont.clientWidth-p.left-p.right, 10);
		this.conf.cont_w = w;
		p = null;
		return w;
	}
	
	this._updateCellsHeight = function() {
		
		// single_mode only
		if (this.conf.multi_mode == true) return;
		
		var k = this.conf.total_count-this.conf.hiden_count; // visible count
		var h = this.cont.offsetHeight-this.ofs.s.last;
		
		if (k == 0) return h;
		
		// single item_heigth = header_height + content_height
		// i.e. base_height - (visible_count-1)*header_height
		var itemFound = false;
		for (var q=0; q<this.cont.childNodes.length; q++) {
			if (itemFound == false) {
				var id = this.cont.childNodes[q]._accId;
				if (this.t[id].cell.conf.visible) {
					h -= this.t[id].cell._getHdrHeight()*(k-1);
					itemFound = true;
				}
			}
		}
		
		// all items except 1st have top-padding=-1, include it into cell height
		h -= (k-1)*this.ofs.s.between+this.ofs.s.first;
		
		for (var a in this.t) {
			// check if item inited
			if (this.t[a].cell.conf.size != null) {
				this.t[a].cell.conf.size.h = h;
				this.t[a].cell._adjustCell();
			}
		}
		
		return h;
	}
	
	this._updateCellsMargin = function() {
		
		var f0 = 0;
		for (var q=0; q<this.cont.childNodes.length; q++) {
			var id = this.cont.childNodes[q]._accId;
			if (this.t[id].cell.conf.visible) {
				this.t[id].cell.cell.style.marginTop = String(this.ofs[this.conf.multi_mode?"m":"s"][f0++==0?"first":"between"])+"px";
			}
		}

	}
	
	this._hdrClick = function(id) {
		
		if (!this.conf.multi_mode && this.t[id].cell.conf.opened) return; // not allow click-close in single-open mode
		
		var opened = this.t[id].cell.conf.opened;
		if (this.callEvent("onBeforeActive",[id,(opened?false:true)]) !== true) return; // doc do not have 2nd param, remove or change to true/false like for onActive
		
		this.conf.on_active_click = true;
		this[opened?"_closeItem":"_openItem"](id);
		if (this.conf.multi_mode && this.conf.tr.prop == false) this._adjustOpened();
	}
	
	this.unload = function() {
		
		this.conf.unloading = true;
		
		for (var a in this.t) this.removeItem(a);
		this.t = null;
		
		if (typeof(this._unloadDND) == "function") this._unloadDND();
		
		if (this.dhxWins) {
			this.dhxWins.unload();
			this.dhxWins = null;
		}
		
		this._unloadTop();
		
		window.dhx4._enableDataLoading(this, null, null, null, "clear");
		window.dhx4._eventable(this, "clear");
		
		this.ofs = this.conf = null;
		
		for (var a in this) this[a] = null;
		
		that = null;
		
	}
	
	this.setOffset = function(ofsBetween) { // offset "between" cells, not in doc but public in prev version
		this.ofs.s.between = ofsBetween;
		this.ofs.m.between = ofsBetween;
		this._updateCellsMargin();
		this.setSizes();
	}
	
	this._initObj = function(data) {
		if (data.skin != null) {
			this.setSkin(data.skin);
		}
		if (window.dhx4.s2b(data.multi_mode)) {
			this.enableMultiMode();
		}
		if (data.icons_path != null) {
			this.setIconsPath(data.icons_path);
		}
		if (data.icon_path != null) { // back compat
			this.setIconsPath(data.icon_path);
		}
		if (data.iconset != null) {
			this.conf.icons_css = (data.iconset == "awesome");
		}
		if (data.items != null) {
			for (var q=0; q<data.items.length; q++) {
				this.addItem(data.items[q].id, data.items[q].text, data.items[q].open, data.items[q].height, data.items[q].icon||data.items[q].img);
			}
		}
		if (window.dhx4.s2b(data.dnd) == true && typeof(this.enableDND) == "function") {
			this.enableDND();
		}
	}
	
	this._xmlToObj = function(data) {
		var t = {items:[]};
		var root = data.getElementsByTagName("accordion")[0];
		if (root.getAttribute("skin") != null) t.skin = root.getAttribute("skin");
		if (root.getAttribute("mode") == "multi") t.multi_mode = true;
		if (root.getAttribute("multiMode") != null) t.multi_mode = window.dhx4.s2b(root.getAttribute("multiMode"));
		if (root.getAttribute("iconsPath") != null) t.icons_path = root.getAttribute("iconsPath");
		for (var q=0; q<root.childNodes.length; q++) {
			var p = root.childNodes[q];
			if (typeof(p.tagName) != "undefined" && String(p.tagName).toLowerCase() == "cell") {
				var k = {};
				if (p.getAttribute("id") != null) k.id = p.getAttribute("id");
				if (p.getAttribute("icon") != null) k.icon = p.getAttribute("icon");
				if (p.getAttribute("height") != null) k.height = p.getAttribute("height");
				if (p.getAttribute("open") != null) k.open = window.dhx4.s2b(p.getAttribute("open"));
				k.text = p.firstChild.nodeValue;
				t.items.push(k);
			}
			p = null;
		}
		return t;
	}
	
	window.dhx4._enableDataLoading(this, "_initObj", "_xmlToObj", "accordion", {struct:true});
	window.dhx4._eventable(this);
	
	this._callMainEvent = function(name, args) {
		return this.callEvent(name, args);
	}
	
	// attach/detach content improves
	this.attachEvent("onActive", function(id){
		// open/close - editor save state/make editable
		if (id != null && this.t[id] != null && this.t[id].cell.dataObj != null && this.t[id].cell.dataType == "editor") {
			this.t[id].cell.dataObj._prepareContent(true);
		}
		// adjust progress if it was activated while cell was closed
		if (id != null && this.t[id] != null && this.t[id].cell.conf.opened == true) {
			this.t[id].cell._adjustProgress();
		}
	});
	
	if (typeof(window.dhtmlXWindows) == "function") {
		this.dhxWins = new dhtmlXWindows();
		this.dhxWins.setSkin(this.conf.skin);
	}
	
	if (apiInit != null) {
		this._initObj(apiInit);
		apiInit = null;
	}
	
	return this;
	
};

// top-level extensions
dhtmlXAccordion.prototype = new dhtmlXCellTop();

dhtmlXAccordion.prototype.setIconset = function(name) {
	this.conf.icons_css = (name=="awesome");
};
/* cell extensions */
function dhtmlXAccordionCell(id, acc) {
	
	dhtmlXCellObject.apply(this, [id, "_acc"]);
	
	this.acc = acc;
	
	this.conf.visible = true;
	this.conf.docked = true;
	
	this.attachEvent("_onCellUnload", function(){
		
		this._trDetachEv();
		this._unloadDocking();
		
		this.acc = null;
		this.cell._accObj = null;
		
		this.cell.childNodes[this.conf.idx.hdr].onselectstart = null;
		this.cell.childNodes[this.conf.idx.hdr].onclick = null;
		
		this._initHeader = null;
		this._getHdrHeight = null;
		this._setWidth = null;
		this._adjustCell = null;
		this._open = null;
		this._close = null;
		this._isOpened = null;
		this._trInitEv = null;
		this._trAttachEv = null;
		this._trDetachEv = null;
		this._trOnEnd = null;
		this._onActiveCall = null;
		this.setText = null;
		this.getText = null;
		this.setIcon = null;
		this.clearIcon = null;
		this.show = null;
		this.hide = null;
		this.isVisible = null;
		this.setHeight = null;
		this.moveOnTop = null;
		
	});
	
	// fix editor contentEditable while dnd if attached
	this.acc.attachEvent("onBeforeDrag", function(id){
		if (this.t[id].cell.dataObj != null && this.t[id].cell.dataType == "editor") {
			if (this.conf.editor_data == null) this.conf.editor_data = {};
			this.conf.editor_data[id] = this.t[id].cell.dataObj.getContent();
		}
		for (var a in this.t) this.t[a].cell._showCellCover();
		return true;
	});
	
	this.acc.attachEvent("onDrop", function(id){
		if (this.t[id].cell.dataObj != null && this.t[id].cell.dataType == "editor") {
			this.t[id].cell.dataObj._prepareContent(true);
			if (this.conf.editor_data != null && this.conf.editor_data[id] != null) {
				this.t[id].cell.dataObj.setContent(this.conf.editor_data[id]);
				this.conf.editor_data[id] = null;
			}
		}
		for (var a in this.t) this.t[a].cell._hideCellCover();
	});
	
	this.acc.attachEvent("_onDropCancel", function(id){
		for (var a in this.t) this.t[a].cell._hideCellCover();
	});
	
	this.attachEvent("_onContentLoaded", function() {
		this.acc._callMainEvent("onContentLoaded", arguments);
	});
	this.attachEvent("_onBeforeContentAttach", function(dataType) {
		if (dataType == "sidebar" && this.conf.skin != "dhx_skyblue") {
			this._hideBorders();
		}
	});
	// init header
	this._initHeader();
	
	// open/close, check trans-effects
	this.conf.tr = {};
	for (var a in this.acc.conf.tr) this.conf.tr[a] = this.acc.conf.tr[a];
	
	if (this.conf.tr.prop != false) {
		this.attachEvent("_onIdxUpdated", function(){
			// if cell hidden - update opacity for menu/toolbar/status attached
			this._cellSetOpacity((this.conf.opened?"open":"close"), false);
		});
	}
	
	// open/close
	this.open = function(callEvent) {
		if (window.dhx4.s2b(callEvent) == true) this.acc.conf.on_active_click = true
		this.acc._openItem(this._idd);
	}
	this.close = function(callEvent) {
		if (window.dhx4.s2b(callEvent) == true) this.acc.conf.on_active_click = true
		this.acc._closeItem(this._idd);
	}
	
	// misc
	this._setWidth = function(w) {
		if (w != this.conf.size.w) {
			this.conf.size.w = w;
			this.cell.style.width = w+"px";
		}
		this._adjustCell();
	}
	
	this._adjustCell = function() {
		this._adjustCont();
		if (this.dataObj != null && typeof(this.dataObj.setSizes) == "function") {
			this.dataObj.setSizes();
		}
	}
	
	this._initDocking();
	return this;
	
};

dhtmlXAccordionCell.prototype = new dhtmlXCellObject();

/* header */
dhtmlXAccordionCell.prototype._initHeader = function() {
	
	var t = document.createElement("DIV");
	t.className = "dhx_cell_hdr";
	t.innerHTML = "<div class='dhx_cell_hdr_text'></div>"+
			"<div class='dhx_cell_hdr_arrow'></div>";
	
	this.cell.insertBefore(t, this.cell.childNodes[this.conf.idx.cont]);
	t = null;
	
	// include into content top offset calculation
	this.conf.ofs_nodes.t._getHdrHeight = "func";
	
	// show/hide
	this.conf.hdr = {visible: true};
	
	// include into index
	this.conf.idx_data.hdr = "dhx_cell_hdr";
	this._updateIdx();
	
};

dhtmlXAccordionCell.prototype._getHdrHeight = function() {
	var t = this.cell.childNodes[this.conf.idx.hdr];
	var h = t.offsetHeight||t.offsetHeight; // fix for ie8 - sometimes on 1st check it gives 0
	t = null;
	return h;
};

/* hdr visibility, added in 4.2.1 */
dhtmlXAccordionCell.prototype.showHeader = function() {
	if (this.conf.hdr.visible == true) return;
	this.conf.hdr.visible = true;
	this.cell.childNodes[this.conf.idx.hdr].className = "dhx_cell_hdr";
	this._adjustCont(this._idd);
};

dhtmlXAccordionCell.prototype.hideHeader = function() {
	if (this.conf.hdr.visible != true) return;
	this.conf.hdr.visible = false;
	this.cell.childNodes[this.conf.idx.hdr].className = "dhx_cell_hdr dhx_cell_hdr_hidden";
	this._adjustCont(this._idd);
};

dhtmlXAccordionCell.prototype.isHeaderVisible = function() {
	return (this.conf.hdr.visible==true);
};

/* hdr text */
dhtmlXAccordionCell.prototype.setText = function(text) {
	this.conf.text = text;
	var t = this.cell.childNodes[this.conf.idx.hdr];
	t.childNodes[(t.firstChild.className=="dhx_cell_hdr_icon"?1:0)].innerHTML = "<span>"+text+"</span>";
	t = null;
};

dhtmlXAccordionCell.prototype.getText = function() {
	return this.conf.text;
};

/* header icon */
dhtmlXAccordionCell.prototype.setIcon = function(icon) {
	var t = this.cell.childNodes[this.conf.idx.hdr];
	if (this.acc.conf.icons_css == true) {
		if ((t.firstChild.tagName||"").toLowerCase() != "i") {
			t.firstChild.className += " dhx_cell_hdr_icon";
			var i = document.createElement("I");
			t.insertBefore(i, t.firstChild);
			i = null;
		}
		t.firstChild.className = icon;
	} else {
		if (t.firstChild.className != "dhx_cell_hdr_icon") {
			t.firstChild.className += " dhx_cell_hdr_icon";
			var k = document.createElement("IMG");
			k.className = "dhx_cell_hdr_icon";
			t.insertBefore(k, t.firstChild);
			k = null;
		}
		t.firstChild.src = this.acc.conf.icons_path+icon;
	}
	t = null;
};

dhtmlXAccordionCell.prototype.clearIcon = function() {
	var t = this.cell.childNodes[this.conf.idx.hdr];
	if (t.firstChild.className == "dhx_cell_hdr_icon" || (t.firstChild.tagName||"").toLowerCase() == "i") {
		t.removeChild(t.firstChild);
		t.firstChild.className = String(t.firstChild.className).replace(/\s{1,}dhx_cell_hdr_icon/gi,"");
	}
	t = null;
};

/* open/close */
dhtmlXAccordionCell.prototype._open = function(ef) {
	
	var dynData = {};
	
	if (this.acc.conf.multi_mode) {
		
		var toOpen = {};
		toOpen[this._idd] = true;
		dynData = this.acc._getDynData(toOpen);
		
		this.acc._openId = this._idd;
		this.acc._openCache = {};
		this.acc._openMode = "open";
		
	} else {
		
		// h_auto cells not found, simple change height of current cell
		dynData[this._idd] = this.conf.size.h;
		
	}
	
	for (var a in dynData) {
		
		if (this.acc._openCache != null) this.acc._openCache[a] = true;
		
		var t = this.acc.t[a].cell;
		t.cell.className = String(t.cell.className).replace(/\s{1,}dhx_cell_closed/gi,"");
		t.conf.opened = true;
		t._trInitEv("open", ef);
		t.conf.size.h = dynData[a];
		t.cell.style.height = t.conf.size.h+"px"; // restore last height
		t = null;
		
	}
	
	// effect is not enabled, adjust cells after resize
	if (this.conf.tr.prop == false) {
		this.acc._openId = this.acc._openCache = this.acc._openMode = null;
		this._onActiveCall(true);
	}
	
};

dhtmlXAccordionCell.prototype._close = function(ef) {
	
	var dynData = {};
	
	if (this.acc.conf.multi_mode) {
		
		var toClose = {};
		toClose[this._idd] = true;
		dynData = this.acc._getDynData(null, toClose);
		
		this.acc._openId = this._idd;
		this.acc._openCache = {};
		this.acc._openMode = "close";
		
	} else {
		
		dynData[this._idd] = this._getHdrHeight();
	}
	
	for (var a in dynData) {
		
		var t = this.acc.t[a].cell;
		
		if (this.acc._openCache != null) this.acc._openCache[a] = true;
		if (a == this._idd) {
			t.cell.className += " dhx_cell_closed";
			t.conf.opened = false;
			t._trInitEv("close", ef);
		} else {
			// keep opened
			t.conf.size.h = dynData[a];
			t._adjustCell();
			t._trInitEv("open", ef);
		}
		
		t.cell.style.height = dynData[a]+"px"; // set height as hdr height
		
		t = null;
	}
	
	if (this.conf.tr.prop == false) {
		this.acc._openId = this.acc._openCache = this.acc._openMode = null;
		this._onActiveCall(false);
	}
};

dhtmlXAccordionCell.prototype.isOpened = function() {
	return (this.conf.opened==true);
};

dhtmlXAccordionCell.prototype._trInitEv = function(mode, ef) {
	
	if (this.conf.tr.prop == false) return;
	this._trAttachEv();
	
	if (!this.cell._accObj) this.cell._accObj = this.acc; // acc obj for transion end
	
	// open with effect (usualy by click, w/o usualy on init stage)
	if (ef) {
		this.cell.style[this.conf.tr.prop] = this.conf.tr["height_"+mode];
	}
	
	// opacity
	this._cellSetOpacity(mode, ef);
};

dhtmlXAccordionCell.prototype._trAttachEv = function() {
	if (!this.conf.tr.ev_attached) {
		this.cell._trProp = this.conf.tr.prop;
		this.cell.addEventListener(this.conf.tr.ev, this._trOnEnd, false);
		this.conf.tr.ev_attached = true;
	}
};
dhtmlXAccordionCell.prototype._trDetachEv = function() {
	if (this.conf.tr.ev_attached) {
		this.cell.addEventListener(this.conf.tr.ev, this._trOnEnd, false);
		this.conf.tr.ev_attached = false;
	}
};

dhtmlXAccordionCell.prototype._trOnEnd = function(ev) {
	if (ev.stopPropagation) ev.stopPropagation();
	if (ev.propertyName == "height" && this._accObj != null) {
		this.style[this._trProp] = "";
		if (this._accObj.conf.multi_mode) {
			if (this._accObj._openCache != null) this._accObj._openCache[this._accId] = false;
			this._accObj._adjustOpened();
		}
		if (this._accObj.conf.on_active_click == true) {
			if (this._accObj.conf.multi_mode) {
				this._accObj._callMainEvent("onActive", [this._accId, this._accObj.t[this._accId].cell.conf.opened]);
				this._accObj.conf.on_active_click = false;
			} else {
				if (this._accObj.conf.on_active_id != null) {
					// trigger only open-state events for single-cell mode
					this._accObj._callMainEvent("onActive", [this._accObj.conf.on_active_id, true]);
				}
				this._accObj.conf.on_active_id = null;
				this._accObj.conf.on_active_click = false;
			}
		}
		this._accObj = null;
	}
};

dhtmlXAccordionCell.prototype._cellSetOpacity = function(mode, ef) {
	// mode - "open"/"close"
	for (var a in this.conf.idx) {
		if ({hdr:true,pr1:true,pr2:true,cover:true}[a] != true) { // skip hdr and progress
			if (ef) this.cell.childNodes[this.conf.idx[a]].style[this.conf.tr.prop] = this.conf.tr["op_"+mode];
			this.cell.childNodes[this.conf.idx[a]].style.opacity = this.conf.tr["op_v_"+mode];
		}
	}
};

dhtmlXAccordionCell.prototype._onActiveCall = function(mode) {
	if (this.acc.conf.on_active_click == false) return;
	if (this.acc.conf.multi_mode == true) {
		this.acc._callMainEvent("onActive", [this._idd, this.conf.opened]);
		this.acc.conf.on_active_click = false;
	} else {
		// single_mode, call only for opened
		if (mode == true) {
			this.acc._callMainEvent("onActive",[this._idd, true]);
			this.acc.conf.on_active_click = false;
		}
	}
	
};

/* visibility */
dhtmlXAccordionCell.prototype.show = function() {
	if (this.conf.visible) return;
	
	if (this.conf.docked == false) { // if cell is undocked - show after dock
		this.dock();
		return;
	}
	
	this.cell.style.display = "";
	this.conf.visible = true;
	if (!this.acc.conf.multi_mode) {
		this.acc.conf.hiden_count--;
		this.acc._updateCellsHeight();
		this.acc._updateCellsMargin();
	}
	if (this.acc.conf.size_changed) {
		this.acc.setSizes();
		this.acc.conf.size_changed = false;
	} else {
		this.acc._adjustOpened();
	}
};

dhtmlXAccordionCell.prototype.hide = function() {
	if (!this.conf.visible) return;
	if (!this.acc.conf.multi_mode && this.conf.opened) { // close before hide if any
		this._close(false);
		this.acc.conf.last_opened = null;
	}
	this.cell.style.display = "none";
	this.conf.visible = false;
	if (!this.acc.conf.multi_mode) {
		this.acc.conf.hiden_count++;
		this.acc._updateCellsHeight();
		this.acc._updateCellsMargin();
	}
	this.acc._adjustOpened();
};

dhtmlXAccordionCell.prototype.isVisible = function() {
	return (this.conf.visible==true);
};

/* height */
dhtmlXAccordionCell.prototype.setHeight = function(h) { // multi_mode only
	
	if (!this.acc.conf.multi_mode) return;
	
	if (h == "*") {
		this.conf.h_auto = true;
	} else {
		this.conf.h_auto = false;
		this.conf.size.h = h;
	}
	
	if (this.conf.opened) {
		if (h != "*") this.cell.style.height = h+"px";
		this.acc._adjustOpened();
	}
};

/* position */
dhtmlXAccordionCell.prototype.moveOnTop = function() {
	if (this.cell.parentNode.firstChild == this.cell) return; // item moved
	this.cell.parentNode.insertBefore(this.cell, this.cell.parentNode.firstChild);
	this.acc._updateCellsMargin();
};


/* dock/undock */
dhtmlXAccordionCell.prototype._initDocking = function() {
	
	var that = this;
	
	this.dock = function() {
		
		if (this.acc.dhxWins == null || this.conf.docked == true) return;
		var w1 = this.acc.dhxWins.window(this._idd);
		w1.close();
		
		// move content
		this._attachFromCell(w1);
		this.conf.docked = true;
		this.show();
		
		if (this.conf.dock_opened) this.open();
		
		w1 = null;
		this.acc._callMainEvent("onDock", [this._idd]);
	};
	
	this.undock = function(x, y, w, h) {
		
		if (this.acc.dhxWins == null || this.conf.docked == false) return;
		
		this.conf.dock_opened = this.conf.opened;
		
		if (this.acc.dhxWins.window(this._idd) != null) {
			var w1 = this.acc.dhxWins.window(this._idd);
			w1.show();
		} else {
			if (x == null) x = 20;
			if (y == null) y = 20;
			if (w == null) w = 320;
			if (h == null) h = 200;
			
			var w1 = this.acc.dhxWins.createWindow(this._idd, x, y, w, h);
			w1.button("close").hide();
			
			// dock button
			w1.addUserButton("dock", 99, "Dock");
			w1.button("dock").show();
			w1.button("dock").attachEvent("onClick", this._doOnDockClick);
			
			// text update only first time
			w1.setText(this.getText());
			
			// closeing
			w1.attachEvent("onClose", this._doOnDockWinClose);
		}
		this.conf.docked = false;
		this.hide();
		
		// move content
		w1._attachFromCell(this);
		w1 = null;
		
		this.acc._callMainEvent("onUnDock", [this._idd]);
		
	}
	
	this._doOnDockClick = function() {
		that.dock();
	}
	this._doOnDockWinClose = function(win) {
		win.hide();
		return false;
	}
	
	this._unloadDocking = function() {
		that = null;
	}
};

dhtmlXCellObject.prototype.attachAccordion = function(conf) {
	
	this.callEvent("_onBeforeContentAttach",["acc"]);
	
	var obj = document.createElement("DIV");
	obj.style.width = "100%";
	obj.style.height = "100%";
	obj.style.position = "relative";
	this._attachObject(obj);
	
	if (typeof(conf) == "undefined") conf = {};
	if (typeof(conf.skin) == "undefined") conf.skin = this.conf.skin;
	conf.parent = obj;
	
	if (typeof(window.dhtmlXAccordionCell) == "function" && this instanceof window.dhtmlXAccordionCell) {
		if (this.conf.skin == "material") {
			obj._ofs = {t:-1,r:-1,b:-1,l:-1}; // attach acc to acc
		} else {
			obj._ofs = {
				s:{first:-1},
				m:{first:4}
			}
		}
	}
	
	if (typeof(window.dhtmlXTabBarCell) == "function" && this instanceof window.dhtmlXTabBarCell) {
		if (this.conf.skin == "dhx_skyblue" || this.conf.skin == "material") obj._ofs = {t:-1,r:-1,b:-1,l:-1};
	}
	
	if (typeof(window.dhtmlXSideBarCell) == "function" && this instanceof window.dhtmlXSideBarCell) {
		if (this.conf.skin == "dhx_web") {
			obj._ofs = {};
			if (this.sidebar.conf.autohide != true) obj._ofs.l = 2;
			if (this.sidebar.conf.header == true) obj._ofs.t = 3; // default acc 'betweeb' conf for both single/multi modes for web skin
		} else {
			obj._ofs = {l:-1};
			if (this.conf.skin == "dhx_terrace") {
				if (this.sidebar.conf.autohide == true) obj._ofs.l = 0;
				if (this.sidebar.conf.header == true) obj._ofs.t = -1;
			}
		}
	}
	
	if (typeof(window.dhtmlXCarouselCell) == "function" && this instanceof window.dhtmlXCarouselCell) {
		this._hideBorders();
	}
	
	this.dataType = "acc";
	this.dataObj = new dhtmlXAccordion(conf);
	
	conf.parent = null;
	obj = conf = null;
	
	this.callEvent("_onContentAttach",[]);
	
	return this.dataObj;
};


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXAccordion.prototype.enableDND = function() {
	
	if (this.conf.multi_mode == false || this._dnd != null) return;
	
	var that = this;
	
	this._dnd = {
		tr_count: 0,
		tr_items: {}
	};
	
	this._dndAttachEvent = function(id) {
		var t = this.t[id].cell;
		if (t.conf.dnd_inited != true) {
			if (typeof(window.addEventListener) == "function") {
				t.cell.childNodes[t.conf.idx.hdr].addEventListener("mousedown", this._dndOnMouseDown, false);
			} else {
				t.cell.childNodes[t.conf.idx.hdr].attachEvent("onmousedown", this._dndOnMouseDown);
			}
			t.conf.dnd_inited = true;
		}
		t = null;
	}
	
	this._dndDetachEvent = function(id) {
		var t = this.t[id].cell;
		if (t.conf.dnd_inited == true) {
			if (typeof(window.addEventListener) == "function") {
				t.cell.childNodes[t.conf.idx.hdr].removeEventListener("mousedown", this._dndOnMouseDown, false);
			} else {
				t.cell.childNodes[t.conf.idx.hdr].detachEvent("onmousedown", this._dndOnMouseDown);
			}
			t.conf.dnd_inited = false;
		}
		t = null;
	}
	
	this._dndOnMouseDown = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault(); // selection in chrome
		var t = (e.target||e.srcElement);
		while (t != null && t.parentNode != that.cont) t = t.parentNode;
		if (t != null) that._dndDragStart(e, t);
		t = null;
	}
	
	this._dndDragStart = function(e,t) {
		
		if (this._dnd.tr_waiting == true) return;
		
		// cell index
		var ind0 = -1;
		for (var q=0; q<t.parentNode.childNodes.length; q++) {
			if (t.parentNode.childNodes[q] == t) ind0 = q;
		}
		
		if (this.callEvent("onBeforeDrag",[t._accId, ind0]) !== true) return; // added in 4.2
		
		if (typeof(window.addEventListener) == "function") {
			document.body.addEventListener("mousemove", this._dndOnMouseMove, false);
			document.body.addEventListener("mouseup", this._dndOnMouseUp, false);
		} else {
			document.body.attachEvent("onmousemove", this._dndOnMouseMove, false);
			document.body.attachEvent("onmouseup", this._dndOnMouseUp, false);
		}
		
		this._dnd.dragObj = t;
		
		this._dnd.dy = e.clientY;
		
		// define index and min/max offset for dragged object
		var u = 0;
		
		for (var q=0; q<this._dnd.dragObj.parentNode.childNodes.length; q++) {
			this._dnd.dragObj.parentNode.childNodes[q]._ind = q; // recalculate indecies
			if (this._dnd.dragObj.parentNode.childNodes[q] == this._dnd.dragObj) {
				this._dnd.dragObj._k0 = u;
				if (q > 0) this._dnd.dragObj._k0 += this.ofs.m.between-this.ofs.m.first; // include margins for non-top cells
				u = 0;
			} else {
				u += this._dnd.dragObj.parentNode.childNodes[q].offsetHeight+
					parseInt(this._dnd.dragObj.parentNode.childNodes[q].style.marginTop);
			}
		}
		this._dnd.dragObj._k1 = u;
		
		this._dnd.h = this._dnd.dragObj.offsetHeight;
		
		this._dnd.ofs = false; // check if mouse was realy moved over screen
	}
	
	this._dndDoDrag = function(e) {
		
		if (!this._dnd.dragObj) return;
		if (this._dnd.tr_waiting == true) return;
		
		var r = e.clientY-this._dnd.dy;
		
		if (this._dnd.ofs == false && Math.abs(r) > 5) {
			this._dnd.dragObj.className += " acc_cell_dragged";
			this._dnd.ofs = true;
		}
		
		// overlaying left/right
		if (r < 0) {
			if (r < -this._dnd.dragObj._k0) r = -this._dnd.dragObj._k0;
		} else {
			if (r > this._dnd.dragObj._k1) r = this._dnd.dragObj._k1;
		}
		
		this._dnd.dragObj.style.top = r+"px";
		
		// prev
		
		// get offset
		var ofs = e.clientY-this._dnd.dy;
		var s0 = 0;
		var i = 0;
		for (var q=this._dnd.dragObj._ind+1; q<=this._dnd.dragObj.parentNode.lastChild._ind; q++) {
			var w0 = this._dnd.dragObj.parentNode.childNodes[q].offsetHeight;
			if (ofs > s0+w0*2/3) i++;
			s0 += w0;
		}
		
		// loop through siblings
		var s = this._dnd.dragObj.nextSibling;
		var q = 0;
		
		while (s != null) {
			
			if (++q<=i && s != null) {
				// move to left if not moved yet
				if (!s._ontop) {
					if (s._tm) window.clearTimeout(s._tm);
					this._dndAnim(s, false, parseInt(s.style.top||0), -this._dnd.h-this.ofs.m.between); // margin-top always "between", index here will never equal 0
					s._ontop = true;
				}
			} else {
				// move to right (to orig position) if moved to left
				if (s._ontop) {
					if (s._tm) window.clearTimeout(s._tm);
					this._dndAnim(s, true, parseInt(s.style.top||0), 0);
					s._ontop = false;
				}
			}
			
			s = s.nextSibling;
		}
		
		// next
		
		// get offset
		var ofs = this._dnd.dy-e.clientY;
		var s0 = 0;
		var i = 0;
		for (var q=this._dnd.dragObj._ind-1; q>=this._dnd.dragObj.parentNode.firstChild._ind; q--) {
			var w0 = this._dnd.dragObj.parentNode.childNodes[q].offsetHeight;
			if (ofs > s0+w0*2/3) i++;
			s0 += w0;
		}
		
		// loop through siblings
		var s = this._dnd.dragObj.previousSibling;
		var q = 0;
		
		while (s != null) {
			
			if (++q<=i && s != null) {
				if (!s._onbottom) {
					if (s._tm) window.clearTimeout(s._tm);
					this._dndAnim(s, true, parseInt(s.style.top||0), this._dnd.h+this.ofs.m.between);
					s._onbottom = true;
				}
			} else {
				if (s._onbottom) {
					if (s._tm) window.clearTimeout(s._tm);
					this._dndAnim(s, false, parseInt(s.style.top), 0);
					s._onbottom = false;
				}
			}
			
			s = s.previousSibling;
		}
		
	}
	
	this._dndDragStop = function(e, force) {
		
		if (force) {
			// console.log("tr ended, fix drop");
		} else {
			if (this._dnd.tr_count > 0) {
				this._dnd.tr_waiting = true;
				// console.log("still moving", this._dnd.tr_count);
				return;
			}
		}
		
		if (!this._dnd.dragObj) return;
		
		this._dnd.dragObj.className = String(this._dnd.dragObj.className).replace(/\s{0,}acc_cell_dragged/gi,"");
		this._dnd.dragObj.style.top = "0px";
		
		var p = false;
		
		for (var q=0; q<this._dnd.dragObj.parentNode.childNodes.length; q++) {
			var s = this._dnd.dragObj.parentNode.childNodes[q];
			
			if (s != this._dnd.dragObj) {
				if (s._tm) window.clearTimeout(s._tm);
				s.style.top = "0px";
				if (s._ontop && ((s.nextSibling != null && s.nextSibling._ontop != true) || !s.nextSibling)) {
					p = (s.nextSibling||null);
				}
				if (s._onbottom && ((s.previousSibling != null && s.previousSibling._onbottom != true) || !s.previousSibling)) {
					p = s;
				}
			}
			s = null;
		}
		for (var q=0; q<this._dnd.dragObj.parentNode.childNodes.length; q++) {
			this._dnd.dragObj.parentNode.childNodes[q]._ontop = null;
			this._dnd.dragObj.parentNode.childNodes[q]._onbottom = null;
		}
		
		if (p !== false) {
			if (p == null) {
				this._dnd.dragObj.parentNode.appendChild(this._dnd.dragObj);
			} else {
				this._dnd.dragObj.parentNode.insertBefore(this._dnd.dragObj, p);
			}
		}
		
		var id = this._dnd.dragObj._accId;
		var ind0 = this._dnd.dragObj._ind;
		var ind1 = ind0;
		for (var q=0; q<this._dnd.dragObj.parentNode.childNodes.length; q++) {
			if (this._dnd.dragObj.parentNode.childNodes[q] == this._dnd.dragObj) ind1 = q;
		}
		
		this._dnd.dragObj = null;
		this._dnd.tr_waiting = false;
		
		this._updateCellsMargin();
		if (ind0 != ind1) {
			this.setSizes();
			this.callEvent("onDrop", [id, ind0, ind1]);
		} else {
			this.callEvent("_onDropCancel", [id]);
		}
		
		if (typeof(window.addEventListener) == "function") {
			document.body.removeEventListener("mousemove", this._dndOnMouseMove, false);
			document.body.removeEventListener("mouseup", this._dndOnMouseUp, false);
		} else {
			document.body.detachEvent("onmousemove", this._dndOnMouseMove, false);
			document.body.detachEvent("onmouseup", this._dndOnMouseUp, false);
		}		
	}
	
	this._dndAnim = function(obj, dir, f, t) {
		
		if (this.conf.tr.prop != false) {
			
			if (!obj._dnd_ev) {
				obj._dnd_ev = true;
				obj._dnd_tr_prop = this.conf.tr.prop;
				obj.addEventListener(this.conf.tr.ev, this._dndOnTrEnd, false);
			}
			
			if (this._dnd.tr_items[obj._accId] != true) {
				this._dnd.tr_items[obj._accId] = true;
				this._dnd.tr_count++;
			}
			
			obj.style[this.conf.tr.prop] = this.conf.tr.dnd_top;
			obj.style.top = t+"px";
			return;
		}
		
		var stop = false;
		if (dir) {
			f += 5;
			if (f >= t) { f = t; stop = true; }
		} else {
			f -= 5;
			if (f <= t) { f = t; stop = true; }
		}
		obj.style.top = f+"px";
		if (obj._tm) window.clearTimeout(obj._tm);
		if (!stop) {
			obj._tm = window.setTimeout(function(){that._dndAnim(obj, dir, f, t);},5);
		} else {
			obj._tm = null;
		}
		
	}
	
	this._dndOnTrEnd = function(ev) {
		if (ev.stopPropagation) ev.stopPropagation();
		if (ev.propertyName == "top") {
			// clear cache
			if (that._dnd.tr_items[this._accId] == true) {
				that._dnd.tr_count--;
				that._dnd.tr_items[this._accId] = false;
			}
			// remove prop
			this.style[this._dnd_tr_prop] = "";
			//
			if (that._dnd.tr_count == 0 && that._dnd.tr_waiting == true) {
				that._dndDragStop(null, true);
			}
		}
	}
	
	this._dndOnMouseMove = function(e) {
		that._dndDoDrag(e||event);
	}
	
	this._dndOnMouseUp = function(e) {
		that._dndDragStop(e||event);
	}
	
	this._dndClearCell = function(id) {
		if (this.t[id].cell.cell._dnd_ev) this.t[id].cell.cell.addEventListener(this.conf.tr.ev, this._dndOnTrEnd, false);
		this._dndDetachEvent(id);
	}
	
	this._unloadDND = function() {
		
		// functions
		for (var a in this) {
			if (String(a).indexOf("_dnd") == 0 && typeof(this[a]) == "function") this[a] = null;
		}
		
		// cell-clear will called from removeItem()
		this._dnd = null;
		that = null;
	}
	
	// update cells
	for (var a in this.t) this._dndAttachEvent(a);
	
};


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXLayoutObject(base, pattern, skin) {
	
	// console.log("resize over iframe");
	
	var autoload = null;
	if (base != null && typeof(base) == "object" && typeof(base.tagName) == "undefined" && base._isCell != true) {
		// api-init
		autoload = {};
		if (base.autosize != null) autoload.autosize = base.autosize;
		if (base.cells != null) autoload.cells = base.cells;
		if (base.pattern != null) pattern = base.pattern;
		if (base.skin != null) skin = base.skin;
		if (base.offsets != null) autoload.offsets = base.offsets;
		base = base.parent;
	}
	
	this.cdata = {};
	this.conf = {
		skin: (skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxlayout")||"material"),
		css: "dhxlayout", // css prefix for topcell mtb
		hh: 20, // header height collapsed, add auto-detect?
		autosize: "b", // cell which will sized when parent size changed
		nextCell: {a:"b",b:"a"},
		inited: false,
		b_size: {w:-1,h:-1} // base size for onResize
	};
	
	if (this.conf.skin == "material") {
		this.conf.hh = window.dhx4.readFromCss("dhxlayout_base_material dhxlayout_collapsed_height");
	}
	
	// attach layout
	if (typeof(base) == "object" && base._isCell == true) {
		
		var conf = (typeof(autoload) != "undefined" && autoload != null ? autoload : {});
		if (conf.pattern == null && pattern != null) conf.pattern = pattern;
		if (conf.skin == null && skin != null) conf.skin = skin;
		
		var layout = base.attachLayout(conf);
		return layout;
		
	}
	
	// init top container
	window.dhtmlXCellTop.apply(this, [base, (autoload==null?null:autoload.offsets)]);
	
	// separator width/height
	this.conf.sw = this._detectSW();
	
	var that = this;
	
	this._getLayout = function() {
		return this;
	}
	
	this.mainInst = (base._layoutMainInst != null ? base._layoutMainInst : null);
	
	this._getMainInst = function() {
		if (this.mainInst != null) return this.mainInst._getMainInst();
		return this;
	}
	
	this._init = function(pattern) {
		
		var t = (typeof(pattern) == "string" ? this.tplData[pattern] : pattern );
		
		this.conf.mode = t.mode;
		
		if (this.conf.mode == "c") {
			this.cdata.a = new dhtmlXLayoutCell("a", this);
		} else {
			this.cdata.a = new dhtmlXLayoutCell("a", this);
			this.cdata.b = new dhtmlXLayoutCell("b", this);
		}
		
		for (var a in this.cdata) {
			this.cont.appendChild(this.cdata[a].cell);
			this.cdata[a].conf.init = { w: 0.5, h: 0.5 };
		}
		
		if (this.conf.mode != "c") {
			
			var mainInst = this._getMainInst();
			if (mainInst.conf.sep_idx == null) mainInst.conf.sep_idx = 1; else mainInst.conf.sep_idx++;
			
			this.sep = new dhtmlXLayoutSepObject(this.conf.mode, mainInst.conf.sep_idx);
			this.cont.appendChild(this.sep.sep);
			
			this.sep._getLayout = function() {
				return that._getLayout();
			}
			
			mainInst = null;
		}
		
		if (t.cells != null) {
			for (var a in t.cells) {
				if (t.cells[a].width != null) this.cdata[a].conf.init.w = t.cells[a].width;
				if (t.cells[a].height != null) this.cdata[a].conf.init.h = t.cells[a].height;
				if (t.cells[a].name != null) {
					this.cdata[a].conf.name = t.cells[a].name;
					this.cdata[a].setText(t.cells[a].name);
				}
				// fixed size conf
				if (t.cells[a].fsize != null) this.cdata[a].conf.fsize = t.cells[a].fsize;
			}
		}
		
		this.setSizes();
		
		for (var a in this.cdata) this.cdata[a].conf.init = {};
			
		if (t.cells != null) {
			for (var a in t.cells) {
				if (t.cells[a].layout != null) {
					this.cdata[a].dataNested = true;
					this.cdata[a]._layoutMainInst = this;
					this.cdata[a].cell.className += " dhx_cell_nested_layout";
					this.cdata[a].attachLayout({pattern:t.cells[a].layout});
					this.cdata[a]._layoutMainInst = null;
				}
			}
		}
		
	}
	
	this.setSizes = function(parentIdd, autosize, noCalcCont, actionType) {
		
		// noCalcCont = skip inner content adjusting, for autoexpand
		
		var rEv = (this.conf.inited==true && this._getMainInst()==this && this.checkEvent("onResizeFinish")==true ? {}:false); // resize event
		
		// celltop
		this._adjustCont();
		
		var w = this.cont.offsetWidth; // baseW
		var h = this.cont.offsetHeight; // baseH
		
		if (this.conf.mode == "c") {
			
			var ax = 0;
			var ay = 0;
			var aw = w;
			var ah = h;
			
			this.cdata.a._setSize(ax, ay, aw, ah, parentIdd, noCalcCont, actionType);
			
			this.callEvent("_onSetSizes", []);
			
			if (rEv && (!(this.conf.b_size.w == w && this.conf.b_size.h == h))) {
				this._callMainEvent("onResizeFinish", []);
			}
			
			this.conf.b_size = {w: w, h: h};
			
			return;
		}
		
		if (typeof(autosize) == "undefined") {
			
			var k = (this.conf.mode=="v"?"w":"h");
			
			autosize = this.conf.autosize;
			
			if (this.cdata.a.conf.collapsed) {
				autosize = "b";
			} else if (this.cdata.b.conf.collapsed) {
				autosize = "a";
			} else if (parentIdd == "a" || parentIdd == "b") {
				autosize = this.conf.nextCell[parentIdd];
			}
			
		} else {
			//debugger
		}
		
		
		if (this.conf.mode == "v") {
			
			if (autosize == "a") { // fix "b", fit "a"
				
				if (this.cdata.b.conf.init.w != null) {
					var bw = Math.round(w*this.cdata.b.conf.init.w-this.conf.sw/2);
				} else {
					var bw = this.cdata.b.conf.size.w;
				}
				var bx = w-bw;
				var by = 0;
				var bh = h;
				
				var ax = 0;
				var ay = by;
				var aw = bx-ax-this.conf.sw;
				var ah = bh;
				
			} else { // fix "a", fit "b"
				
				var ax = 0;
				var ay = 0;
				
				// check if init stage
				if (this.cdata.a.conf.init.w != null) {
					var aw = Math.round(w*this.cdata.a.conf.init.w-this.conf.sw/2)-ax;
				} else {
					var aw = this.cdata.a.conf.size.w;
				}
				
				var ah = h-ay;
				
				var bx = ax+aw+this.conf.sw;
				var by = ay;
				var bw = w-bx;
				var bh = ah;
				
			}
			
			this.cdata.a._setSize(ax, ay, aw, ah, parentIdd, noCalcCont, actionType);
			this.cdata.b._setSize(bx, by, bw, bh, parentIdd, noCalcCont, actionType);
			
			this.sep._setSize(ax+aw, ay, this.conf.sw, ah);
			
		} else {
			
			if (autosize == "a") { // fix "b", fit "a"
				
				if (this.cdata.b.conf.init.h != null) {
					var bh = Math.round(h*this.cdata.b.conf.init.h-this.conf.sw/2);
				} else {
					var bh = this.cdata.b.conf.size.h;
				}
				var bx = 0;
				var by = h-bh;
				var bw = w-bx;
				
				var ax = bx;
				var ay = 0;
				var aw = bw;
				var ah = by-ay-this.conf.sw;
				
			} else { // fix "a", fit "b"
				
				var ax = 0;
				var ay = 0;
				var aw = w-ax;
				
				// check if init stage
				if (this.cdata.a.conf.init.h != null) {
					var ah = Math.round(h*this.cdata.a.conf.init.h-this.conf.sw/2);
				} else {
					var ah = this.cdata.a.conf.size.h;
				}
				
				var bx = ax;
				var by = ay+ah+this.conf.sw;
				var bw = aw;
				var bh = h-by;
				
			}
			
			this.cdata.a._setSize(ax, ay, aw, ah, parentIdd, noCalcCont, actionType);
			this.cdata.b._setSize(bx, by, bw, bh, parentIdd, noCalcCont, actionType);
			
			this.sep._setSize(ax, ay+ah, aw, this.conf.sw);
			
		}
		
		this.callEvent("_onSetSizes", []);
		
		// public event for main instance
		if (rEv && (!(this.conf.b_size.w == w && this.conf.b_size.h == h))) {
			this._callMainEvent("onResizeFinish", []);
		}
		
		this.conf.b_size = {w: w, h: h};
		
	}
	
	this._getAvailWidth = function() {
		
		// logic:
		// 1) take width of all not-collapsed cells marked as "autosize"
		// 2) if cell collapsed - try next cell
		// 3) get min alaiv width
		// 4) base.ofsW - minW -> allowed min
		
		var w = [];
		
		for (var q=0; q<this.conf.as_cells.h.length; q++) {
			var cell = this.cells(this.conf.as_cells.h[q]);
			var k = cell.layout;
			var a = k.conf.autosize;
			if (cell.conf.collapsed) {
				cell = k.cdata[k.conf.nextCell[cell._idd]];
				a = k.conf.nextCell[a];
			}
			w.push(Math.max(0, cell.getWidth()-cell._getMinWidth(a))); // current_width - min_width = size allowed for cell shrink
			k = cell = null;
		}
		var r = (w.length>0?Math.min.apply(window, w):0);
		return this.cont.offsetWidth-r;
		
	}
	
	this._getAvailHeight = function() {
		
		var h = [];
		
		for (var q=0; q<this.conf.as_cells.v.length; q++) {
			var cell = this.cells(this.conf.as_cells.v[q]);
			var k = cell.layout;
			var a = k.conf.autosize;
			if (cell.conf.collapsed) {
				cell = k.cdata[k.conf.nextCell[cell._idd]];
				a = k.conf.nextCell[a];
			}
			h.push(Math.max(0, cell.getHeight()-cell._getHdrHeight()-cell._getMinHeight(a))); // current_height - hdr_height - min_height = size allowed for cell shrink
			k = cell = null;
		}
		var r = Math.min.apply(window, h);
		return this.cont.offsetHeight-r;
		
	}
	
	this.setSkin = function(skin) {
		this._setBaseSkin(skin);
		this.conf.skin = skin;
	}
	
	this.unload = function() {
		
		this.conf.unloading = true;
		
		this.mainInst = null;
		this.parentLayout = null;
		
		// deprecated in 4.0
		if (this.items != null) {
			for (var q=0; q<this.items.length; q++) this.items[q] = null;
			this.items = null;
		}
		
		if (this.dhxWins != null) {
			this.dhxWins.unload();
			this.dhxWins = null;
		}
		
		if (this.sep != null) {
			this.sep._unload();
			this.sep = null;
		}
		
		for (var a in this.cdata) {
			this.cdata[a]._unload();
			this.cdata[a] = null;
		}
		
		this._unloadTop();
		
		// clear events
		window.dhx4._eventable(this, "clear");
		
		for (var a in this) this[a] = null;
		
		that = null;
	}
	
	// old container version compat
	this._getWindowMinDimension = function(win) {
		
		var w = that._getAvailWidth()+7+7; // + window left/right borders, move to conf?
		var h = that._getAvailHeight()+7+31; // + window hdr height + bottom border
		
		var t = {w: Math.max(w,200), h: Math.max(h, 140)}; // default window min width/height
		win = null;
		
		return t;
	}
	
	window.dhx4._eventable(this);
	this._callMainEvent = function(name, args) {
		return this.callEvent(name, args);
	}
	this._init(pattern||"3E");
	
	var a = this._availAutoSize[pattern];
	if (a != null) {
		this.conf.pattern = pattern;
		this.setAutoSize(a.h[a.h.length-1], a.v[a.v.length-1]);
	}
	
	if (typeof(window.dhtmlXWindows) == "function" && this.mainInst == null) {
		var params = {
			vp_overflow: (this.conf.fs_mode == true ? false : "auto") // set viewport "auto" for body to keep scroll visible
		};
		this.dhxWins = new dhtmlXWindows(params);
		this.dhxWins.setSkin(this.conf.skin);
	}
	
	this.conf.inited = true;
	
	// deprecated in 4.0
	if (this == this._getMainInst()) {
		var idx = 0;
		this.items = [];
		this.forEachItem(function(cell){
			that.items.push(cell);
			cell.conf.index = idx++;
		});
	}
	
	// autoload
	if (this == this._getMainInst() && autoload != null) {
		if (autoload.autosize != null) this.setAutoSize.apply(this, autoload.autosize);
		if (autoload.cells != null) {
			for (var q=0; q<autoload.cells.length; q++) {
				var data = autoload.cells[q];
				var cell = this.cells(data.id);
				if (data.width) cell.setWidth(data.width);
				if (data.height) cell.setHeight(data.height);
				if (data.text) cell.setText(data.text);
				if (data.collapsed_text) cell.setCollapsedText(data.collapsed_text);
				if (data.collapse) cell.collapse();
				if (data.fix_size) cell.fixSize(data.fix_size[0], data.fix_size[1]);
				if (typeof(data.header) != "undefined" && window.dhx4.s2b(data.header) == false) cell.hideHeader();
			}
		}
		
	}
	autoload = null;
	
	return this;
};

// top-level extensions
dhtmlXLayoutObject.prototype = new dhtmlXCellTop();

// cell access
dhtmlXLayoutObject.prototype.cells = function(name) {
	for (var a in this.cdata) {
		if (this.cdata[a].conf.name == name) return this.cdata[a];
		if (this.cdata[a].dataType == "layout" && this.cdata[a].dataNested == true && this.cdata[a].dataObj != null) {
			var k = this.cdata[a].dataObj.cells(name);
			if (k != null) return k;
		}
	}
	return null;
};

// iterator
dhtmlXLayoutObject.prototype.forEachItem = function(handler, env) {
	if (typeof(handler) != "function") return;
	if (typeof(env) == "undefined") env = this;
	for (var a in this.cdata) {
		if (typeof(this.cdata[a].conf.name) != "undefined") handler.apply(env, [this.cdata[a]]);
		if (this.cdata[a].dataType == "layout" && this.cdata[a].dataNested == true && this.cdata[a].dataObj != null) {
			this.cdata[a].dataObj.forEachItem(handler, env);
		}
	}
	env = null;
};

dhtmlXLayoutObject.prototype._forEachSep = function(handler, env) {
	if (typeof(handler) != "function") return;
	if (typeof(env) == "undefined") env = this;
	if (this.sep != null) handler.apply(env, [this.sep])
	for (var a in this.cdata) {
		if (this.cdata[a].dataType == "layout" && this.cdata[a].dataNested == true && this.cdata[a].dataObj != null) {
			this.cdata[a].dataObj._forEachSep(handler, env);
		}
	}
	env = null;
};

// separator width/height detect
dhtmlXLayoutObject.prototype._detectSW = function() {
	if (this._confGlob.sw == null) this._confGlob.sw = {};
	if (this._confGlob.sw[this.conf.skin] == null) {
		this._confGlob.sw[this.conf.skin] = window.dhx4.readFromCss("dhxlayout_sep_sw_"+this.conf.skin);
	}
	return this._confGlob.sw[this.conf.skin];
};


// conf
dhtmlXLayoutObject.prototype._confGlob = {};

dhtmlXLayoutObject.prototype.listPatterns = function() {
	var t = [];
	for (var a in this.tplData) t.push(a);
	return t;
};

dhtmlXLayoutObject.prototype.listAutoSizes = function() {
	
	var curH = (this.conf.as_cells != null ? (this.conf.as_cells.h).join(";") : "");
	var curV = (this.conf.as_cells != null ? (this.conf.as_cells.v).join(";") : "");
	
	var allH = this._availAutoSize[this.conf.pattern].h;
	var allV = this._availAutoSize[this.conf.pattern].v;
	
	return [curH, curV, allH, allV];
	
};


dhtmlXLayoutObject.prototype._getCellsNames = function(cId) {
	var names = {};
	if (this.cdata[cId].conf.name != null) names[this.cdata[cId].conf.name] = true;
	if (this.cdata[cId].dataType == "layout" && this.cdata[cId].dataObj != null && this.cdata[cId].dataObj.mainInst == this) {
		var k0 = this.cdata[cId].dataObj._getCellsNames("a");
		var k1 = this.cdata[cId].dataObj._getCellsNames("b");
		for (var a in k0) names[a] = k0[a];
		for (var a in k1) names[a] = k1[a];
	}
	return names;
};

dhtmlXLayoutObject.prototype.setAutoSize = function(hor, ver, innerCall) {
	
	if (innerCall !== true) {
	
		var t = this.listAutoSizes();
		if (t[0] == hor && t[1] == ver) return;
		
		var t0 = false;
		var t1 = false;
		for (var q=0; q<t[2].length; q++) t0 = t0||t[2][q]==hor;
		for (var q=0; q<t[3].length; q++) t1 = t1||t[3][q]==ver;
		
		if (!t0 || !t1) {
			// console.log("set autosize, incorect values, aborted", hor, ver, t[2], t[3])
			return;
		}
		
	}
	
	this.conf.as_cells = { h: hor.split(";"), v: ver.split(";") };
	var m = (this.conf.mode=="v"?"h":"v");
	
	for (var a in this.cdata) {
		var k = this._getCellsNames(a);
		var s = false;
		for (var q=0; q<this.conf.as_cells[m].length; q++) s = s||k[this.conf.as_cells[m][q]];
		if (s) this.conf.autosize = a;
		if (this.cdata[a].dataType == "layout" && this.cdata[a].dataObj != null) this.cdata[a].dataObj.setAutoSize(hor, ver, true);
	}
	
};

dhtmlXLayoutObject.prototype.tplData = {
	
	// fsize - separators near specified cell for fix_size
	
	"1C": { mode: "c", cells: { a: { name: "a" } } },
	
	"2E": { mode: "h", cells: { a: { name: "a", fsize: {v:1} }, b: { name: "b", fsize: {v:1} } } },
	"2U": { mode: "v", cells: { a: { name: "a", fsize: {h:1} }, b: { name: "b", fsize: {h:1} } } },
	
	"3E": { mode: "h", cells: { a: { name: "a", height: 1/3, fsize: {v:1} }, b: { layout: { mode: "h", cells: { a: { name: "b", fsize: {v:[1,2]} }, b: { name: "c", fsize: {v:2} } } } } } },
	"3W": { mode: "v", cells: { a: { name: "a",  width: 1/3, fsize: {h:1} }, b: { layout: { mode: "v", cells: { a: { name: "b", fsize: {h:[1,2]} }, b: { name: "c", fsize: {h:2} } } } } } },
	"3J": { mode: "v", cells: { a: { layout: { mode: "h", cells: { a: { name: "a", fsize: {h:1, v:2} }, b: { name: "c", fsize: {h:1, v:2} } } } }, b: { name: "b", fsize: {h:1} } } },
	"3L": { mode: "v", cells: { a: { name: "a", fsize: {h:1} }, b: { layout: { mode: "h", cells: { a: { name: "b", fsize: {h:1, v:2} }, b: { name: "c", fsize: {h:1, v:2} } } } } } },
	"3T": { mode: "h", cells: { a: { name: "a", fsize: {v:1} }, b: { layout: { mode: "v", cells: { a: { name: "b", fsize: {h:2, v:1} }, b: { name: "c", fsize: {h:2, v:1} } } } } } },
	"3U": { mode: "h", cells: { a: { layout: { mode: "v", cells: { a: { name: "a", fsize: {h:2, v:1} }, b: { name: "b", fsize: {h:2, v:1} } } } }, b: { name: "c", fsize: {v:1} } } },
	
	"4H": { mode: "v", cells: { a: { name: "a",  width: 1/3, fsize: {h:1} }, b: { layout: { mode: "v", cells: { a: { layout: { mode: "h", cells: { a: { name: "b", fsize: {h:[1,2], v:3} }, b: { name: "c", fsize: {h:[1,2], v:3} } } } }, b: { name: "d", fsize: {h:2} } } } } } },
	"4I": { mode: "h", cells: { a: { name: "a", height: 1/3, fsize: {v:1} }, b: { layout: { mode: "h", cells: { a: { layout: { mode: "v", cells: { a: { name: "b", fsize: {h:3, v:[1,2]} }, b: { name: "c", fsize: {h:3, v:[1,2]} } } } }, b: { name: "d", fsize: {v:2} } } } } } },
	"4T": { mode: "h", cells: { a: { name: "a", fsize: {v:1} }, b: { layout: { mode: "v", cells: { a: { name: "b", width: 1/3, fsize: {h:2, v:1} }, b: { layout: { mode: "v", cells: { a: { name: "c", fsize: {h:[2,3], v:1} }, b: { name: "d", fsize: {h:3, v:1} } } } } } } } } },
	"4U": { mode: "h", cells: { a: { layout: { mode: "v", cells: { a: { name: "a", width: 1/3, fsize: {h:2, v:1} }, b: { layout: { mode: "v", cells: { a: { name: "b", fsize: {h:[2,3], v:1} }, b: { name: "c", fsize: {h:3, v:1} } } } } } } }, b: { name: "d", fsize: {v:1} } } },
	"4E": { mode: "h", cells: { a: { name: "a", height: 1/4, fsize: {v:1} }, b: { layout: { mode: "h", cells: { a: { name: "b", height: 1/3, fsize: {v:[1,2]} }, b: { layout: { mode: "h", cells: { a: { name: "c", fsize: {v:[2,3]} }, b: { name: "d", fsize: {v:3} } } } } } } } } },
	"4W": { mode: "v", cells: { a: { name: "a",  width: 1/4, fsize: {h:1} }, b: { layout: { mode: "v", cells: { a: { name: "b",  width: 1/3, fsize: {h:[1,2]} }, b: { layout: { mode: "v", cells: { a: { name: "c", fsize: {h:[2,3]} }, b: { name: "d", fsize: {h:3} } } } } } } } } },
	"4A": { mode: "v", cells: { a: {  width: 1/3, layout: { mode: "h", cells: { a: { name: "a", fsize: {h:1, v:2} }, b: { name: "b", fsize: {h:1, v:2} } } } }, b: { layout: { mode: "v", cells: { a: { name: "c", fsize: {h:[1,3]} }, b: { name: "d", fsize: {h:3} } } } } } },
	"4L": { mode: "v", cells: { a: { name: "a",  width: 1/3, fsize: {h:1} }, b: { layout: { mode: "v", cells: { a: { name: "b", fsize: {h:[1,2]} }, b: { layout: { mode: "h", cells: { a: { name: "c", fsize: {h:2, v:3} }, b: { name: "d", fsize: {h:2, v:3} } } } } } } } } },
	"4J": { mode: "h", cells: { a: { name: "a", height: 1/3, fsize: {v:1} }, b: { layout: { mode: "h", cells: { a: { name: "b", fsize: {v:[1,2]} }, b: { layout: { mode: "v", cells: { a: { name: "c", fsize: {h:3, v:2} }, b: { name: "d", fsize: {h:3, v:2} } } } } } } } } },
	"4F": { mode: "h", cells: { a: { height: 1/3, layout: { mode: "v", cells: { a: { name: "a", fsize: {h:2, v:1} }, b: { name: "b", fsize: {h:2, v:1} } } } }, b: { layout: { mode: "h", cells: { a: { name: "c", fsize: {v:[1,3]} }, b: { name: "d", fsize: {v:3} } } } } } },
	"4G": { mode: "v", cells: { a: { layout: { mode: "h", cells: { a: { name: "a", height: 1/3, fsize: {h:1, v:2} }, b: { layout: { mode: "h", cells: { a: { name: "b", fsize: {h:1, v:[2,3]} }, b: { name: "c", fsize: {h:1, v:3} } } } } } } }, b: { name: "d", fsize: {h:1} } } },
	"4C": { mode: "v", cells: { a: { name: "a", fsize: {h:1} }, b: { layout: { mode: "h", cells: { a: { name: "b", height: 1/3, fsize: {h:1, v:2} }, b: { layout: { mode: "h", cells: { a: { name: "c", fsize: {h:1, v:[2,3]} }, b: { name: "d", fsize: {h:1, v:3} } } } } } } } } },
	
	"5H": { mode: "v", cells: { a: {  width: 1/3, name: "a", fsize: {h:1}}, b: { layout: { mode: "v", cells: { a: { layout: { mode: "h", cells: { a: { name: "b", height: 1/3, fsize: {h:[1,2], v:3} }, b: { layout: { mode: "h", cells: { a: { name: "c", fsize: {h:[1,2], v:[3,4]} }, b: { name: "d", fsize: {h:[1,2], v:4} } } } } } } }, b: { name: "e", fsize: {h:2} } } } } } },
	"5I": { mode: "h", cells: { a: { height: 1/3, name: "a", fsize: {v:1} }, b: { layout: { mode: "h", cells: { a: { layout: { mode: "v", cells: { a: { name: "b", width: 1/3, fsize: {h:3, v:[1,2]} }, b: { layout: { mode: "v", cells: { a: { name: "c", fsize: {h:[3,4], v:[1,2]} }, b: { name: "d", fsize: {h:4, v:[1,2]} } } } } } } }, b: { name: "e", fsize: {v:2} } } } } } },
	"5U": { mode: "h", cells: { a: { layout: { mode: "v", cells: { a: { name: "a",  width: 1/4, fsize: {h:2, v:1} }, b: { layout: { mode: "v", cells: { a: { name: "b",  width: 1/3, fsize: {h:[2,3], v:1} }, b: { layout: { mode: "v", cells: { a: { name: "c", fsize: {h:[3,4], v:1} }, b: { name: "d", fsize: {h:4, v:1} } } } } } } } } } }, b: { name: "e", fsize: {v:1} } } },
	"5E": { mode: "h", cells: { a: { name: "a", height: 1/5, fsize: {v:1} }, b: { layout: { mode: "h", cells: { a: { name: "b", height: 1/4, fsize: {v:[1,2]} }, b: { layout: { mode: "h", cells: { a: { name: "c", height: 1/3, fsize: {v:[2,3]} }, b: { layout: { mode: "h", cells: { a: { name: "d", fsize: {v:[3,4]} }, b: { name: "e", fsize: {v:4} } } } } } } } } } } } },
	"5W": { mode: "v", cells: { a: { name: "a",  width: 1/5, fsize: {h:1} }, b: { layout: { mode: "v", cells: { a: { name: "b",  width: 1/4, fsize: {h:[1,2]} }, b: { layout: { mode: "v", cells: { a: { name: "c",  width: 1/3, fsize: {h:[2,3]} }, b: { layout: { mode: "v", cells: { a: { name: "d", fsize: {h:[3,4]} }, b: { name: "e", fsize: {h:4} } } } } } } } } } } } },
	"5K": { mode: "v", cells: { a: { layout: { mode: "h", cells: { a: { name: "a", height: 1/3, fsize: {h:1, v:2} }, b: { layout: { mode: "h", cells: { a: { name: "b", fsize: {h:1, v:[2,3]} }, b: { name: "c", fsize: {h:1, v:3} } } } } } } }, b: { layout: { mode: "h", cells: { a: { name: "d", fsize: {h:1, v:4} }, b: { name: "e", fsize: {h:1, v:4} } } } } } },
	"5S": { mode: "v", cells: { a: { layout: { mode: "h", cells: { a: { name: "a", fsize: {h:1, v:2} }, b: { name: "b", fsize: {h:1, v:2} } } } }, b: { layout: { mode: "h", cells: { a: { name: "c", height: 1/3, fsize: {h:1, v:3} }, b: { layout: { mode: "h", cells: { a: { name: "d", fsize: {h:1, v:[3,2]} }, b: { name: "e", fsize: {h:1, v:4} } } } } } } } } },
	"5G": { mode: "v", cells: { a: {  width: 1/3, layout: { mode: "h", cells: { a: { name: "a", height: 1/3, fsize: {h:1, v:2} }, b: { layout: { mode: "h", cells: { a: { name: "b", fsize: {h:1, v:[2,3]} }, b: { name: "c", fsize: {h:1, v:3} } } } } } } }, b: { layout: { mode: "v", cells: { a: { name: "d", fsize: {h:[1,4]} }, b: { name: "e", fsize: {h:4} } } } } } },
	"5C": { mode: "v", cells: { a: {  width: 2/3, layout: { mode: "v", cells: { a: { name: "a", fsize: {h:2} }, b: { name: "b", fsize: {h:[2,1]} } } } }, b: { layout: { mode: "h", cells: { a: { name: "c", height: 1/3, fsize: {h:1, v:3} }, b: { layout: { mode: "h", cells: { a: { name: "d", fsize: {h:1, v:[3,4]} }, b: { name: "e", fsize: {h:1, v:4} } } } } } } } } },
	
	"6H": { mode: "v", cells: { a: {  width: 1/3, name: "a", fsize: {h:1} }, b: { layout: { mode: "v", cells: { a: { layout: { mode: "h", cells: { a: { name: "b", height: 1/4, fsize: {h:[1,2], v:3} }, b: { layout: { mode: "h", cells: { a: { name: "c", height: 1/3, fsize: {h:[1,2], v:[3,4]} }, b: { layout: { mode: "h", cells: { a: { name: "d", fsize: {h:[1,2], v:[4,5]} }, b: { name: "e", fsize: {h:[1,2], v:5} } } } } } } } } } }, b: { name: "f", fsize: {h:2} } } } } } },
	"6I": { mode: "h", cells: { a: { height: 1/3, name: "a", fsize: {v:1} }, b: { layout: { mode: "h", cells: { a: { layout: { mode: "v", cells: { a: { name: "b",  width: 1/4, fsize: {h:3, v:[1,2]} }, b: { layout: { mode: "v", cells: { a: { name: "c",  width: 1/3, fsize: {h:[3,4], v:[1,2]} }, b: { layout: { mode: "v", cells: { a: { name: "d", fsize: {h:[4,5], v:[1,2]} }, b: { name: "e", fsize: {h:5, v:[1,2]} } } } } } } } } } }, b: { name: "f", fsize: {v:2} } } } } } },
	"6A": { mode: "v", cells: { a: { layout: { mode: "h", cells: { a: { name: "a", height: 1/5, fsize: {h:1, v:2} }, b: { layout: { mode: "h", cells: { a: { name: "b", height: 1/4, fsize: {h:1, v:[2,3]} }, b: { layout: { mode: "h", cells: { a: { name: "c", height: 1/3, fsize: {h:1, v:[3,4]} }, b: { layout: { mode: "h", cells: { a: { name: "d", fsize: {h:1, v:[4,5]} }, b: { name: "e", fsize: {h:1, v:5} } } } } } } } } } } } } }, b: { name: "f", fsize: {h:1} } } },
	"6C": { mode: "v", cells: { a: { name: "a", fsize: {h:1} }, b: { layout: { mode: "h", cells: { a: { name: "b", height: 1/5, fsize: {h:1, v:2} }, b: { layout: { mode: "h", cells: { a: { name: "c", height: 1/4, fsize: {h:1, v:[2,3]} }, b: { layout: { mode: "h", cells: { a: { name: "d", height: 1/3, fsize: {h:1, v:[3,4]} }, b: { layout: { mode: "h", cells: { a: { name: "e", fsize: {h:1, v:[4,5]} }, b: { name: "f", fsize: {h:1, v:5} } } } } } } } } } } } } } } },
	"6J": { mode: "v", cells: { a: {  width: 1/3, layout: { mode: "h", cells: { a: { name: "a", height: 1/4, fsize: {h:1, v:2} }, b: { layout: { mode: "h", cells: { a: { name: "b", height: 1/3, fsize: {h:1, v:[2,3]} }, b: { layout: { mode: "h", cells: { a: { name: "c", fsize: {h:1, v:[3,4]} }, b: { name: "d", fsize: {h:1, v:4} } } } } } } } } } }, b: { layout: { mode: "v", cells: { a: { name: "e", fsize: {h:[1,5]} }, b: { name: "f", fsize: {h:5} } } } } } },
	"6E": { mode: "v", cells: { a: { name: "a",  width: 1/3, fsize: {h:1} }, b: { layout: { mode: "v", cells: { a: { name: "b", fsize: {h:[1,2]} }, b: { layout: { mode: "h", cells: { a: { name: "c", height: 1/4, fsize: {h:2, v:3} }, b: { layout: { mode: "h", cells: { a: { name: "d", height: 1/3, fsize: {h:2, v:[3,4]} }, b: { layout: { mode: "h", cells: { a: { name: "e", fsize: {h:2, v:[4,5]} }, b: { name: "f", fsize: {h:2, v:5} } } } } } } } } } } } } } } },
	"6W": { mode: "v", cells: { a: { name: "a",  width: 1/6, fsize: {h:1} }, b: { layout: { mode: "v", cells: { a: { name: "b", width: 1/5, fsize: {h:[1,2]} }, b: { layout: { mode: "v", cells: { a: { name: "c", width: 1/4, fsize: {h:[2,3]} }, b: { layout: { mode: "v", cells: { a: { name: "d", width: 1/3, fsize: {h:[3,4]} }, b: { layout: { mode: "v", cells: { a: { name: "e", fsize: {h:[4,5]} }, b: { name: "f", fsize: {h:5} } } } } } } } } } } } } } } },
	
	"7H": { mode: "v", cells: { a: { name: "a",  width: 1/3, fsize: {h:1} }, b: { layout: { mode: "v", cells: { a: { layout: { mode: "h", cells: { a: { name: "b", height: 1/5, fsize: {h:[1,2], v:3} }, b: { layout: { mode: "h", cells: { a: { name: "c", height: 1/4, fsize: {h:[1,2], v:[3,4]} }, b: { layout: { mode: "h", cells: { a: { name: "d", height: 1/3, fsize: {h:[1,2], v:[4,5]} }, b: { layout: { mode: "h", cells: { a: { name: "e", fsize: {h:[1,2], v:[5,6]} }, b: { name: "f", fsize: {h:[1,2], v:6} } } } } } } } } } } } } }, b: { name: "g", fsize: {h:2} } } } } } },
	"7I": { mode: "h", cells: { a: { name: "a", height: 1/3, fsize: {v:1} }, b: { layout: { mode: "h", cells: { a: { layout: { mode: "v", cells: { a: { name: "b",  width: 1/5, fsize: {h:3, v:[1,2]} }, b: { layout: { mode: "v", cells: { a: { name: "c",  width: 1/4, fsize: {h:[3,4], v:[1,2]} }, b: { layout: { mode: "v", cells: { a: { name: "d",  width: 1/3, fsize: {h:[4,5], v:[1,2]} }, b: { layout: { mode: "v", cells: { a: { name: "e", fsize: {h:[5,6], v:[1,2]} }, b: { name: "f", fsize: {h:6, v:[1,2]} } } } } } } } } } } } } }, b: { name: "g", fsize: {v:2} } } } } } }
	
};

dhtmlXLayoutObject.prototype._availAutoSize = {
	
	"1C": { h: ["a"], v: ["a"] },
	
	"2E": { h: ["a;b"], v: ["a", "b"] },
	"2U": { h: ["a", "b"], v: ["a;b"] },
	
	"3E": { h: ["a;b;c"], v: ["a", "b", "c"] },
	"3W": { h: ["a", "b", "c"], v: ["a;b;c"] },
	"3J": { h: ["a;c", "b"], v: ["a;b", "b;c"] },
	"3L": { h: ["a", "b;c"], v: ["a;b", "a;c"] },
	"3T": { h: ["a;b", "a;c"], v: ["a", "b;c"] },
	"3U": { h: ["a;c", "b;c"], v: ["a;b", "c"] },
	
	"4H": { h: ["a", "b;c", "d"], v: ["a;b;d", "a;c;d"] },
	"4I": { h: ["a;b;d", "a;c;d"], v: ["a", "b;c", "d"] },
	"4T": { h: ["a;b", "a;c", "a;d"], v: ["a", "b;c;d"] },
	"4U": { h: ["a;d", "b;d", "c;d"], v: ["a;b;c", "d"] },
	"4E": { h: ["a;b;c;d"], v: ["a", "b", "c", "d"] },
	"4W": { h: ["a", "b", "c", "d"], v: ["a;b;c;d"] },
	"4A": { h: ["a;b", "c", "d"], v: ["a;c;d", "b;c;d"] },
	"4L": { h: ["a", "b", "c;d"], v: ["a;b;c", "a;b;d"] },
	"4J": { h: ["a;b;c", "a;b;d"], v: ["a", "b", "c;d"] },
	"4F": { h: ["a;c;d", "b;c;d"], v: ["a;b", "c", "d"] },
	"4G": { h: ["a;b;c", "d"], v: ["a;d", "b;d", "c;d"] },
	"4C": { h: ["a", "b;c;d"], v: ["a;b", "a;c", "a;d"] },
	
	"5H": { h: ["a", "b;c;d", "e"], v: ["a;b;e", "a;c;e", "a;d;e"] },
	"5I": { h: ["a;b;e", "a;c;e", "a;d;e"], v: ["a", "b;c;d", "e"] },
	"5U": { h: ["a;e", "b;e", "c;e", "d;e"], v: ["a;b;c;d", "e"] },
	"5E": { h: ["a;b;c;d;e"], v: ["a", "b", "c", "d", "e"] },
	"5W": { h: ["a", "b", "c", "d", "e"], v: ["a;b;c;d;e"] },
	"5K": { h: ["a;b;c", "d;e"], v: ["a;d", "b;d", "c;d", "a;e", "b;e", "c;e"] },
	"5S": { h: ["a;b", "c;d;e"], v: ["a;c", "a;d", "a;e", "b;c", "b;d", "b;e"] },
	"5G": { h: ["a;b;c", "d", "e"], v: ["a;d;e", "b;d;e", "c;d;e"] },
	"5C": { h: ["a", "b", "c;d;e"], v: ["a;b;c", "a;b;d", "a;b;e"] },
	
	"6H": { h: ["a", "b;c;d;e", "f"], v: ["a;b;f", "a;c;f", "a;d;f", "a;e;f"] },
	"6I": { h: ["a;b;f", "a;c;f", "a;d;f", "a;e;f"], v: ["a", "b;c;d;e", "f"] },
	"6A": { h: ["a;b;c;d;e", "f"], v: ["a;f", "b;f", "c;f", "d;f", "e;f"] },
	"6C": { h: ["a", "b;c;d;e;f"], v: ["a;b", "a;c", "a;d", "a;e", "a;f"] },
	"6J": { h: ["a;b;c;d", "e", "f"], v: ["a;e;f", "b;e;f", "c;e;f", "d;e;f"] },
	"6E": { h: ["a", "b", "c;d;e;f"], v: ["a;b;c", "a;b;d", "a;b;e", "a;b;f"] },
	"6W": { h: ["a", "b", "c", "d", "e", "f"], v: ["a;b;c;d;e;f"] },
	
	"7H": { h: ["a", "b;c;d;e;f", "g"], v: ["a;b;g", "a;c;g", "a;d;g", "a;e;g", "a;f;g"] },
	"7I": { h: ["a;b;g", "a;c;g", "a;d;g", "a;e;g", "a;f;g"], v: ["a", "b;c;d;e;f", "g"] }
	
};

function dhtmlXLayoutSepObject(mode, idx) {
	
	var that = this;
	
	this.conf = {
		mode: mode,
		idx: idx,
		blocked: false, // by expand/collapse
		locked: false, // by fix cell size
		btn_left: ((window.dhx4.isIE6||window.dhx4.isIE7||window.dhx4.isIE8) && typeof(window.addEventListener) == "undefined" ? 1:0) // 1 for IE8-
	};
	
	// ie-11 in ie-7 mode
	if (window.dhx4.isIE && navigator.userAgent.indexOf("MSIE 7.0") >= 0 && navigator.userAgent.indexOf("Trident") >= 0) {
		this.conf.btn_left = 1;
	}
	
	this.sep = document.createElement("DIV");
	this.sep.className = "dhxlayout_sep";
	
	/*
	// dev, show sep index
	this.sep.innerHTML = "<span style='font-size: 11px; color: red; line-height: 9px;'>"+idx+"</span>";
	this.sep.style.overflow = "visible";
	*/
	
	if (window.dhx4.isIE == true) {
		this.sep.onselectstart = function(){return false;};
	}
	
	this.sep.className = "dhxlayout_sep dhxlayout_sep_resize_"+this.conf.mode;
	
	this._setSize = function(x, y, w, h) {
		this.sep.style.left = x+"px";
		this.sep.style.top = y+"px";
		this.sep.style.width = Math.max(w,0)+"px";
		this.sep.style.height = Math.max(h,0)+"px";
	}
	
	this._lockSep = function(mode) { // by fix cell size
		this.conf.locked = (mode==true);
		this._blockSep();
	}
	
	this._setWH = function(size) { // change default separator size
		var layout = this._getLayout();
		layout.conf.sw = (size == null ? layout._detectSW() : Math.max(parseInt(size)||-1, -1));
		layout._getMainInst().setSizes();
		layout = null;
	}
	
	this._blockSep = function() { // by expand/collapse
		var k = this._getLayout();
		var state = k.cdata.a.conf.collapsed||k.cdata.b.conf.collapsed||this.conf.locked;
		k = null;
		if (this.conf.blocked == state) return;
		this.sep.className = "dhxlayout_sep"+(state?"":" dhxlayout_sep_resize_"+this.conf.mode);
		this.conf.blocked = state;
	}
	
	this._beforeResize = function(e) {
		
		if (this.conf.blocked) return;
		
		if (this.conf.resize != null && this.conf.resize.active == true) return;
		
		if (e.type == window.dhx4.dnd.evs.start) {
			this.sep.className += " dhxlayout_sep_resize_actv";
			var sx = (e.pageX||e.touches[0].pageX);
			var sy = (e.pageY||e.touches[0].pageY);
		} else {
			if (e.button !== this.conf.btn_left) return;
			var sx = e.clientX;
			var sy = e.clientY;
		}
		
		if (window.dhx4.dnd.p_en == true) window.dhx4.dnd._touchOff();
		
		var k = this._getLayout();
		
		// resize init point
		
		this.conf.resize = {
			sx: sx,
			sy: sy,
			tx: e.layerX,
			ty: e.layerY,
			sep_x: parseInt(this.sep.style.left),
			sep_y: parseInt(this.sep.style.top),
			min_wa: k.cdata.a._getAvailWidth("a"),
			min_wb: k.cdata.b._getAvailWidth("b"),
			min_ha: k.cdata.a._getAvailHeight("a"),
			min_hb: k.cdata.b._getAvailHeight("b")
		}
		
		this.conf.resize.nx = this.conf.resize.sep_x;
		this.conf.resize.ny = this.conf.resize.sep_y;
		
		if (typeof(window.addEventListener) == "function") {
			window.addEventListener("mousemove", this._doOnMouseMove, false);
			window.addEventListener("mouseup", this._doOnMouseUp, false);
			window.addEventListener(window.dhx4.dnd.evs.move, this._doOnMouseMove, false);
			window.addEventListener(window.dhx4.dnd.evs.end, this._doOnMouseUp, false);
		} else {
			document.body.attachEvent("onmousemove", this._doOnMouseMove);
			document.body.attachEvent("onmouseup", this._doOnMouseUp);
		}
		
		k = null;
		
	}
	
	this._onResize = function(e) {
		
		if (!this.conf.resize.active) {
			this._initResizeArea();
			this.conf.resize.active = true;
		}
		
		if (this.conf.mode == "v") {
			
			var x = (e.type == "mousemove" ? e.clientX : (e.pageX||e.touches[0].pageX));
			var ofs = this.conf.resize.sx-x;
			this.conf.resize.nx = this.conf.resize.sep_x-ofs;
			
			if (this.conf.resize.nx > this.conf.resize.sep_x+this.conf.resize.min_wb) {
				this.conf.resize.nx = this.conf.resize.sep_x+this.conf.resize.min_wb;
			} else if (this.conf.resize.nx < this.conf.resize.sep_x-this.conf.resize.min_wa) {
				this.conf.resize.nx = this.conf.resize.sep_x-this.conf.resize.min_wa;
			}
			
			this.r_sep.style.left = this.conf.resize.nx+"px";
			
		} else {
			
			var y = (e.type == "mousemove" ? e.clientY : (e.pageY||e.touches[0].pageY));
			var ofs = this.conf.resize.sy-y;
			this.conf.resize.ny = this.conf.resize.sep_y-ofs;
			
			if (this.conf.resize.ny > this.conf.resize.sep_y+this.conf.resize.min_hb) {
				this.conf.resize.ny = this.conf.resize.sep_y+this.conf.resize.min_hb;
			} else if (this.conf.resize.ny < this.conf.resize.sep_y-this.conf.resize.min_ha) {
				this.conf.resize.ny = this.conf.resize.sep_y-this.conf.resize.min_ha;
			}
			
			this.r_sep.style.top = this.conf.resize.ny+"px";
		}
		
	}
	
	this._afterResize = function(e) {
		
		if (typeof(window.addEventListener) == "function") {
			window.removeEventListener("mousemove", this._doOnMouseMove, false);
			window.removeEventListener("mouseup", this._doOnMouseUp, false);
			window.removeEventListener(window.dhx4.dnd.evs.move, this._doOnMouseMove, false);
			window.removeEventListener(window.dhx4.dnd.evs.end, this._doOnMouseUp, false);
		} else {
			document.body.detachEvent("onmousemove", this._doOnMouseMove);
			document.body.detachEvent("onmouseup", this._doOnMouseUp);
		}
		
		if (!this.conf.resize.active) {
			this.conf.resize = null;
			return;
		}
		
		if (e.type == window.dhx4.dnd.evs.end) {
			this.sep.className = this.sep.className.replace(/\s{0,}dhxlayout_sep_resize_actv/gi,"");
		} else {
			if (e.button !== this.conf.btn_left) return;
		}
		
		var k = this._getLayout();
		
		var mainInst = k._getMainInst();
		var rCells = (mainInst.checkEvent("onPanelResizeFinish")==true?{}:false);
		
		if (rCells !== false) {
			mainInst.forEachItem(function(cell){
				rCells[cell.conf.name] = {w: cell.conf.size.w, h: cell.conf.size.h};
				cell = null;
			});
		}
		
		var ofs_x = this.conf.resize.nx-this.conf.resize.sep_x;
		var ofs_y = this.conf.resize.ny-this.conf.resize.sep_y;
		
		k.cdata.a._setSize(k.cdata.a.conf.size.x, k.cdata.a.conf.size.y, k.cdata.a.conf.size.w+ofs_x, k.cdata.a.conf.size.h+ofs_y, "a");
		k.cdata.b._setSize(k.cdata.b.conf.size.x+ofs_x, k.cdata.b.conf.size.y+ofs_y, k.cdata.b.conf.size.w-ofs_x, k.cdata.b.conf.size.h-ofs_y, "b");
		
		this._setSize(parseInt(this.r_sep.style.left), parseInt(this.r_sep.style.top), parseInt(this.r_sep.style.width), parseInt(this.r_sep.style.height));
		
		if (window.dhx4.isIE) {
			// w/o timeout cursor not changed to normal state in IE
			var p0 = this;
			window.setTimeout(function(){p0._removeResizeArea();p0=null;},1);
		} else {
			this._removeResizeArea();
		}
		
		
		if (rCells !== false) {
			var p = [];
			mainInst.forEachItem(function(cell){
				var t = rCells[cell.conf.name];
				if (!(t.w == cell.conf.size.w && t.h == cell.conf.size.h)) p.push(cell.conf.name);
				cell = null;
			});
			mainInst._callMainEvent("onPanelResizeFinish", [p]);
		}
		
		mainInst = k = null;
		
		this.conf.resize.active = false;
		this.conf.resize = null;
		
		if (window.dhx4.dnd.p_en == true) window.dhx4.dnd._touchOn();
	}
	
	this._initResizeArea = function() {
		
		if (this.r_sep == null) {
			
			this.r_sep = document.createElement("DIV");
			this.r_sep.className = "dhxlayout_resize_sep";
			this.r_sep.style.left = this.sep.style.left;
			this.r_sep.style.top = this.sep.style.top;
			this.r_sep.style.width = this.sep.style.width;
			this.r_sep.style.height = this.sep.style.height;
			this.sep.parentNode.appendChild(this.r_sep);
			
			if (window.dhx4.isIE) this.r_sep.onselectstart = function(){return false;};
			
		}
		
		if (this.r_area == null) {
			
			this.r_area = document.createElement("DIV");
			this.r_area.className = "dhxlayout_resize_area";
			this.sep.parentNode.appendChild(this.r_area);
			
			if (window.dhx4.isIE) this.r_area.onselectstart = function(){return false;};
			
			if (this.conf.mode == "v") {
				var x = parseInt(this.r_sep.style.left)-this.conf.resize.min_wa;
				var y = parseInt(this.r_sep.style.top);
				var w = this.conf.resize.min_wa+this.conf.resize.min_wb+parseInt(this.r_sep.style.width);
				var h = parseInt(this.r_sep.style.height);
			} else {
				var x = parseInt(this.r_sep.style.left);
				var y = parseInt(this.r_sep.style.top)-this.conf.resize.min_ha;
				var w = parseInt(this.r_sep.style.width);
				var h = this.conf.resize.min_ha+this.conf.resize.min_hb+parseInt(this.r_sep.style.height);
			}
			
			this.r_area.style.left = x+"px";
			this.r_area.style.top = y+"px";
			
			if (!dhtmlXLayoutObject.prototype._confGlob.reszieCover) {
				dhtmlXLayoutObject.prototype._confGlob.reszieCover = {};
				this.r_area.style.width = w+"px";
				this.r_area.style.height = h+"px";
				dhtmlXLayoutObject.prototype._confGlob.reszieCover.w = parseInt(this.r_area.style.width)-this.r_area.offsetWidth;
				dhtmlXLayoutObject.prototype._confGlob.reszieCover.h = parseInt(this.r_area.style.height)-this.r_area.offsetHeight;
			}
			
			this.r_area.style.width = w+dhtmlXLayoutObject.prototype._confGlob.reszieCover.w+"px";
			this.r_area.style.height = h+dhtmlXLayoutObject.prototype._confGlob.reszieCover.h+"px";
		}
		
		document.body.className += " dhxlayout_resize_"+this.conf.mode;
	}
	
	this._removeResizeArea = function() {
		
		this.r_sep.onselectstart = null;
		this.r_sep.parentNode.removeChild(this.r_sep);
		this.r_sep = null;
		
		this.r_area.onselectstart = null;
		this.r_area.parentNode.removeChild(this.r_area);
		this.r_area = null;
		
		document.body.className = String(document.body.className).replace(/\s{0,}dhxlayout_resize_[vh]/gi,"");
		
	}
	
	this._doOnMouseDown = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.cancelBubble = true;
		that._beforeResize(e);
	}
	
	this._doOnBodyMouseDown = function(e) {
		e = e||event;
		if (that.conf.resize == null) return;
		if (that.conf.resize.active == true && e.button !== that.conf.btn_left) {
			if (e.preventDefault) e.preventDefault();
			e.returnValue = false;
			e.cancelBubble = true;
			return false;
		}
	}
	
	this._doOnMouseMove = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.cancelBubble = true;
		that._onResize(e);
	}
	
	this._doOnMouseUp = function(e) {
		e = e||event;
		if (e.type == "mouseup" && e.button !== that.conf.btn_left) return;
		that._afterResize(e);
	}
	
	if (typeof(window.addEventListener) == "function") {
		this.sep.addEventListener("mousedown", this._doOnMouseDown, false);
		this.sep.addEventListener(window.dhx4.dnd.evs.start, this._doOnMouseDown, false);
		document.body.addEventListener("mousedown", this._doOnBodyMouseDown, false);
		document.body.addEventListener("contextmenu", this._doOnBodyMouseDown, false);
	} else {
		this.sep.attachEvent("onmousedown", this._doOnMouseDown);
		document.body.attachEvent("onmousedown", this._doOnBodyMouseDown);
		document.body.attachEvent("oncontextmenu", this._doOnBodyMouseDown);
	}
	
	this._unload = function() {
		
		if (typeof(window.addEventListener) == "function") {
			this.sep.removeEventListener("mousedown", this._doOnMouseDown, false);
			this.sep.removeEventListener(window.dhx4.dnd.evs.start, this._doOnMouseDown, false);
			document.body.removeEventListener("mousedown", this._doOnBodyMouseDown, false);
			document.body.removeEventListener("contextmenu", this._doOnBodyMouseDown, false);
		} else {
			this.sep.detachEvent("onmousedown", this._doOnMouseDown);
			document.body.detachEvent("onmousedown", this._doOnBodyMouseDown);
			document.body.detachEvent("oncontextmenu", this._doOnBodyMouseDown);
		}
		
		if (window.dhx4.isIE == true) {
			this.sep.onselectstart = null;
		}
		
		this.sep.parentNode.removeChild(this.sep);
		this.sep = null;
		
		for (var a in this) this[a] = null;
		
		that = null;
	}
	
	return this;
	
};

dhtmlXLayoutObject.prototype.setSeparatorSize = function(index, size) {
	if (typeof(index) == "number") {
		var s = this.setSeparatorSize({index: index, current: -1}, size);
		if (s.sep != null) s.sep._setWH(size);
		return;
	}
	// seq: a->sep->b
	for (var a in this.cdata) {
		if (this.cdata[a].dataType == "layout" && this.cdata[a].dataNested == true && this.cdata[a].dataObj != null) {
			index = this.cdata[a].dataObj.setSeparatorSize(index, size);
			if (index.sep != null) return index;
		}
		if (a == "a" && this.sep != null) {
			index.current++;
			if (index.index == index.current) return {sep: this.sep};
		}
	}
	return index;
};

window.dhtmlXLayoutCell = function(id, layout) {
	
	dhtmlXCellObject.apply(this, [id, "_layout"]);
	
	var that = this;
	this.layout = layout;
	
	this.conf.skin = this.layout.conf.skin;
	this.conf.mode = this.layout.conf.mode;
	this.conf.collapsed = false;
	this.conf.fixed = {w: false, h: false}; // fix size
	this.conf.docked = true;
	
	if (this.conf.skin == "material") {
		this.conf.min_width = 42;
		this.conf.min_height = 26;
	} else {
		this.conf.min_width = 26;
		this.conf.min_height = 26;
	}
	
	this.attachEvent("_onCellUnload", function(){
		this.cell.childNodes[this.conf.idx.hdr].ondblclick = null; // header dblclick
		if (this.conf.mode != "c") this.cell.childNodes[this.conf.idx.hdr].lastChild.onclick = null; // arrow onclick
		this._unloadDocking();
		this.layout = null;
		that = null;
	});
	
	// init header
	this._hdrInit();
	this.cell.childNodes[this.conf.idx.hdr].ondblclick = function(){
		var mainInst = that.layout._getMainInst();
		mainInst._callMainEvent("onDblClick", [that.conf.name]);
		mainInst = null;
	};
	
	// onContentLoaded
	this.attachEvent("_onContentLoaded", function() {
		var mainInst = this.layout._getMainInst();
		mainInst._callMainEvent("onContentLoaded", [this.conf.name]);
		mainInst = null;
	});
	
	// init expand/collapse
	if (this.conf.mode != "c") {
		var t = document.createElement("DIV");
		t.className = "dhxlayout_arrow dhxlayout_arrow_"+this.conf.mode+this._idd;
		this.cell.childNodes[this.conf.idx.hdr].appendChild(t);
		t.onclick = function(e) {
			if (that.conf.collapsed) that.expand(); else that.collapse();
		}
		t = null;
	}
	
	this.attachEvent("_onBeforeContentAttach", function(dataType) {
		if (dataType == "tabbar" || dataType == "layout" || dataType == "acc") {
			this._hideBorders();
		}
		if (dataType == "sidebar" && this.conf.skin != "dhx_skyblue" && this.conf.skin != "dhx_terrace") {
			this._hideBorders();
			this.showHeader();
		}
	});
	
	this._initDocking();
	
	return this;
	
};

dhtmlXLayoutCell.prototype = new dhtmlXCellObject();

dhtmlXLayoutCell.prototype.getId = function() {
	return this.conf.name;
};

dhtmlXLayoutCell.prototype._initDocking = function() {
	
	var that = this;
	
	this.dock = function() {
		
		var mainInst = this.layout._getMainInst();
		
		if (mainInst.dhxWins == null || this.conf.docked) {
			mainInst = null;
			return;
		}
		
		var w1 = mainInst.dhxWins.window(this.conf.name);
		w1.close();
		
		// move content
		this._attachFromCell(w1);
		
		this.conf.docked = true;
		if (!this.conf.dock_collapsed) this.expand();
		
		mainInst._callMainEvent("onDock",[this.conf.name]);
		
		mainInst = w1 = null;
		
	};
	
	this.undock = function(x, y, w, h) {
		
		var mainInst = this.layout._getMainInst();
		
		if (mainInst.dhxWins == null || this.conf.docked == false) {
			mainInst = null;
			return;
		}
		
		this.conf.dock_collapsed = this.conf.collapsed;
		if (!this.conf.collapsed) this.collapse();
		
		if (mainInst.dhxWins.window(this.conf.name) != null) {
			var w1 = mainInst.dhxWins.window(this.conf.name);
			w1.show();
		} else {
			if (x == null) x = 20;
			if (y == null) y = 20;
			if (w == null) w = 320;
			if (h == null) h = 200;
			
			var w1 = mainInst.dhxWins.createWindow(this.conf.name, x, y, w, h);
			w1.button("close").hide();
			
			// dock button
			w1.addUserButton("dock", 99, "Dock");
			w1.button("dock").show();
			w1.button("dock").attachEvent("onClick", this._doOnDockClick);
			
			// text update only first time
			w1.setText(this.getText());
			
			// closeing
			w1.attachEvent("onClose", this._doOnDockWinClose);
		}
		this.conf.docked = false;
		
		// move content
		w1._attachFromCell(this);
		
		mainInst._callMainEvent("onUnDock",[this.conf.name]);
		
		mainInst = w1 = null;
		
	}
	
	this._doOnDockClick = function() {
		that.dock();
	}
	this._doOnDockWinClose = function(win) {
		win.hide();
		return false;
	}
	
	this._unloadDocking = function() {
		that = null;
	}
};

dhtmlXLayoutCell.prototype._hdrInit = function() {
	
	var cssExt = "";
	if (window.dhx4.isIE) {
		if (navigator.userAgent.indexOf("MSIE 9.0") != -1) {
			cssExt = " dhx_cell_hdr_text_ie9";
		} else if (window.dhx4.isIE8) {
			cssExt = " dhx_cell_hdr_text_ie8";
		} else if (window.dhx4.isIE7) {
			cssExt = " dhx_cell_hdr_text_ie7";
		} else if (window.dhx4.isIE6) {
			cssExt = " dhx_cell_hdr_text_ie6";
		}
	} else if (window.dhx4.isChrome || window.dhx4.isKHTML) {
		cssExt = " dhx_cell_hdr_text_chrome";
	}
	
	var t = document.createElement("DIV");
	t.className = "dhx_cell_hdr";
	t.innerHTML = "<div class='dhx_cell_hdr_text"+cssExt+"'></div>";
	this.cell.insertBefore(t, this.cell.childNodes[this.conf.idx.cont]);
	t = null;
	
	// include into content top offset calculation
	this.conf.ofs_nodes.t._getHdrHeight = "func";
	
	// show/hide
	this.conf.hdr = {visible: true};
	
	// include into index
	this.conf.idx_data.hdr = "dhx_cell_hdr";
	this._updateIdx();
	
	// fit header when cell changed
	this.attachEvent("_onSetSize", this._hdrOnSetSize);
	this.attachEvent("_onBorderChange", this._hdrOnBorderChange);
	
	// keep visibility state of header if view changed
	this.attachEvent("_onViewSave", this._hdrOnViewSave);
	this.attachEvent("_onViewRestore", this._hdrOnViewRestore);
	
};

dhtmlXLayoutCell.prototype.showHeader = function(noCalcCont) {
	
	if (this.conf.hdr.visible || this.conf.collapsed) return;
	
	if (this.conf.hdr.w_saved > this._getAvailWidth() || this.conf.hdr.h_saved > this._getAvailHeight()) {
		// console.log("no space to show header");
		return;
	}
	
	this.conf.hdr.w_saved = this.conf.hdr.h_saved = null;
	
	this.conf.hdr.visible = true;
	this.cell.childNodes[this.conf.idx.hdr].className = "dhx_cell_hdr";
	
	if (noCalcCont !== true) this._adjustCont(this._idd);
};

dhtmlXLayoutCell.prototype.hideHeader = function(noCalcCont) {
	
	if (!this.conf.hdr.visible || this.conf.collapsed) return;
	
	this.conf.hdr.w_saved = this._getMinWidth(this._idd);
	this.conf.hdr.h_saved = this._getMinHeight(this._idd);
	
	this.conf.hdr.visible = false;
	this.cell.childNodes[this.conf.idx.hdr].className = "dhx_cell_hdr dhx_cell_hdr_hidden";
	this._hdrUpdBorder();
	this._mtbUpdBorder();
	
	if (noCalcCont !== true) this._adjustCont(this._idd);
};

dhtmlXLayoutCell.prototype.isHeaderVisible = function() {
	return (this.conf.hdr.visible==true);
};

// arrow
dhtmlXLayoutCell.prototype.showArrow = function() {
	this.cell.childNodes[this.conf.idx.hdr].childNodes[1].style.display = "";
};

dhtmlXLayoutCell.prototype.hideArrow = function() {
	this.cell.childNodes[this.conf.idx.hdr].childNodes[1].style.display = "none";
};

dhtmlXLayoutCell.prototype.isArrowVisible = function() {
	return (this.cell.childNodes[this.conf.idx.hdr].childNodes[1].style.display == "");
};

// text
dhtmlXLayoutCell.prototype.setText = function(text) {
	this.conf.hdr.text = text;
	this._hdrUpdText();
};

dhtmlXLayoutCell.prototype.getText = function() {
	return this.conf.hdr.text;
};

dhtmlXLayoutCell.prototype.setCollapsedText = function(text) {
	this.conf.hdr.text_collapsed = text;
	this._hdrUpdText();
};

dhtmlXLayoutCell.prototype.getCollapsedText = function() {
	return (this.conf.hdr.text_collapsed != null ? this.conf.hdr.text_collapsed : this.conf.hdr.text );
};

dhtmlXLayoutCell.prototype._hdrUpdText = function() {
	var text = (this.conf.collapsed == true && this.conf.hdr.text_collapsed != null ? this.conf.hdr.text_collapsed : this.conf.hdr.text);
	this.cell.childNodes[this.conf.idx.hdr].firstChild.innerHTML = "<span>"+text+"</span>";
};

dhtmlXLayoutCell.prototype._hdrUpdBorder = function() {
	if (this.conf.borders == true) {
		this.cell.childNodes[this.conf.idx.hdr].className = "dhx_cell_hdr"+(this.conf.hdr.visible?"":" dhx_cell_hdr_hidden");
	} else {
		if (!this.conf.hdr.visible) {
			this.cell.childNodes[this.conf.idx.hdr].className = "dhx_cell_hdr dhx_cell_hdr_hidden_no_borders";
		}
	}
};

dhtmlXLayoutCell.prototype._hdrOnSetSize = function() {
	if (this.conf.collapsed && this.conf.mode == "v") this._fitHdr();
};
dhtmlXLayoutCell.prototype._hdrOnBorderChange = function() {
	this.hideHeader(true);
	this._hdrUpdBorder();
};
dhtmlXLayoutCell.prototype._hdrOnViewSave = function(name) {
	this.views[name].hdr_vis = this.conf.hdr.visible;
};
dhtmlXLayoutCell.prototype._hdrOnViewRestore = function(name){
	if (this.conf.hdr.visible != this.views[name].hdr_vis) {
		this[this.views[name].hdr_vis?"showHeader":"hideHeader"](true);
	}
	this.views[name].hdr_vis = null;
	delete this.views[name].hdr_vis;
};
dhtmlXLayoutCell.prototype._getHdrHeight = function(incColl) {
	
	if (this.conf.collapsed && this.conf.mode == "v" && incColl !== true) {
		// collapsed vertical cell, move to conf?
		// offsetHeight returns full cell height, needed only for adjusting bottom border
		return 27;
	}
	return this.cell.childNodes[this.conf.idx.hdr].offsetHeight;
};

dhtmlXLayoutCell.prototype._fitHdr = function() {
	var h = this.cell.childNodes[this.conf.idx.hdr];
	if (this.conf.collapsed == true) {
		if (typeof(dhtmlXLayoutObject.prototype._confGlob.hdrColH) == "undefined") {
			h.style.height = this.cell.offsetHeight+"px";
			dhtmlXLayoutObject.prototype._confGlob.hdrColH = parseInt(h.style.height)-this._getHdrHeight(true);
		}
		var size = this.cell.offsetHeight+dhtmlXLayoutObject.prototype._confGlob.hdrColH;
		h.style.height = size+"px";
		h.firstChild.style.width = size-39+"px";
	} else {
		h.firstChild.style.width = h.style.height = null;
	}
	h = null;
};


/* expand */
dhtmlXLayoutCell.prototype.expand = function(autoExpand) {
	
	if (!this.conf.collapsed) return true;
	
	var k = this.layout;
	
	if (this.conf.mode == "v") {
		
		var w_nextCell = (autoExpand ? k.conf.hh : k.cdata[k.conf.nextCell[this._idd]]._getMinWidth(this._idd));
		var w_avl = k.cont.offsetWidth-k.conf.sw;
		
		if (w_nextCell + this.conf.size.w_avl > w_avl) {
			k = null;
			return false;
		}
		
	} else {
		
		// if autoExpand - next cell coing to be collapsed, move value to conf?
		// min heigth of next cell = min_height+hdr_height
		
		var h_nextCell = (autoExpand ? k.conf.hh : k.cdata[k.conf.nextCell[this._idd]]._getMinHeight(this._idd)+k.cdata[k.conf.nextCell[this._idd]]._getHdrHeight());
		var h_avl = k.cont.offsetHeight-k.conf.sw; // avail height for both cells = base_h-sep_h
		
		if (h_nextCell + this.conf.size.h_avl > h_avl) {
			// new logic, menu/tb attached
			k = null;
			return false;
		}
		
	}
	
	if (this.conf.docked == false) {
		this.dock();
		return;
	}
	
	// hide header if it was temporary restored while cell collapsed
	if (this.conf.hdr.visible == false) {
		this.cell.childNodes[this.conf.idx.hdr].className = "dhx_cell_hdr dhx_cell_hdr_hidden";
		this._hdrUpdBorder();
	}
	
	this.cell.className = String(this.cell.className).replace(/\s{0,}dhxlayout_collapsed_[hv]/gi, "");
	this.conf.collapsed = false;
	
	if (this.conf.mode == "v") {
		this.conf.size.w = Math.min(w_avl-w_nextCell, this.conf.size.w_saved);
		this.conf.size.w_saved = this.conf.size.w_avl = null;
	} else {
		this.conf.size.h = Math.min(h_avl-h_nextCell, this.conf.size.h_saved);
		this.conf.size.h_saved = this.conf.size.h_avl = null;
	}
	
	if (this.conf.mode == "v") this._fitHdr();
	
	k.setSizes(k.conf.nextCell[this._idd], k.conf.nextCell[this._idd], autoExpand==true, "expand");
	k.sep._blockSep();
	
	k = null;
	
	this._hdrUpdText();
	
	var mainInst = this.layout._getMainInst();
	mainInst._callMainEvent("onExpand", [this.conf.name]);
	mainInst = null;
	
	return true;
};

/* collapse */
dhtmlXLayoutCell.prototype.collapse = function() {
	
	if (this.conf.collapsed) return false;
	
	var k = this.layout;
	
	if (k.cdata[k.conf.nextCell[this._idd]].expand(true) == false) return false; // no space to expand next cell if it collapsed
	
	if (this.conf.mode == "v") {
		this.conf.size.w_saved = this.conf.size.w;
		this.conf.size.w_avl = this._getMinWidth(this._idd); // save min width
	} else {
		this.conf.size.h_saved = this.conf.size.h;
		this.conf.size.h_avl = this._getMinHeight(this._idd)+this._getHdrHeight(); // save min height
	}
	
	// restore header temporary while cell collapsed
	if (this.conf.hdr.visible == false) {
		this.cell.childNodes[this.conf.idx.hdr].className = "dhx_cell_hdr";
	}
	
	this.cell.className += " dhxlayout_collapsed_"+this.conf.mode;
	this.conf.collapsed = true;
	
	if (this.conf.mode == "v") {
		this.conf.size.w = k.conf.hh; // move to conf?
	} else {
		this.conf.size.h = this._getHdrHeight();
	}
	
	k.setSizes(k.conf.nextCell[this._idd], k.conf.nextCell[this._idd], false, "collapse");
	k.sep._blockSep();
	
	k = null;
	
	this._hdrUpdText();
	
	var mainInst = this.layout._getMainInst();
	mainInst._callMainEvent("onCollapse", [this.conf.name]);
	mainInst = null;
	
	return true;
	
};

dhtmlXLayoutCell.prototype.isCollapsed = function() {
	return (this.conf.collapsed==true);
};

// cell sizing
dhtmlXLayoutCell.prototype.setMinWidth = function(w) { // added in 4.1.3
	this.conf.min_width = parseInt(w)||0;
};

dhtmlXLayoutCell.prototype.setMinHeight = function(h) { // added in 4.1.3
	this.conf.min_height = parseInt(h)||0;
};

dhtmlXLayoutCell.prototype._getMinWidth = function(parentIdd) {
	// min space should allow to collapse ?
	if (this.dataType == "layout" && this.dataObj != null) {
		
		if (this.layout._getMainInst() != this.dataObj._getMainInst()) {
			return this.dataObj._getAvailWidth();
		}
		
		if (this.dataObj.conf.pattern == "1C") {
			return Math.max(this.conf.min_width, this.dataObj.cdata.a._getMinWidth(parentIdd));
		} else if (this.dataObj.conf.mode == "v") {
			
			var c1 = parentIdd||this._idd; // "views" fix for layout-in-layout
			if (this.dataObj.cdata[c1].conf.collapsed) c1 = this.dataObj.conf.nextCell[c1];
			
			return Math.max(this.conf.min_width, this.dataObj.cdata[c1]._getMinWidth(parentIdd)+this.dataObj.cdata[this.dataObj.conf.nextCell[c1]]._getWidth()+this.dataObj.conf.sw); // c1 min width + c2 full width + sw
			
		} else {
			return Math.max(this.conf.min_width, this.dataObj.cdata.a._getMinWidth(parentIdd), this.dataObj.cdata.b._getMinWidth(parentIdd));
		}
		
	}
	return Math.max(this.conf.min_width, 1);
};

dhtmlXLayoutCell.prototype._getMinHeight = function(parentIdd) {
	
	var h = 0;
	if (this.conf.idx.menu != null) h += this.cell.childNodes[this.conf.idx.menu].offsetHeight;
	
	if (this.dataType == "layout" && this.dataObj != null) {
		
		if (this.layout._getMainInst() != this.dataObj._getMainInst()) {
			return this.dataObj._getAvailHeight();
		}
		
		if (this.dataObj.conf.pattern == "1C") {
			return Math.max(this.conf.min_height, this.dataObj.cdata.a._getMinHeight(parentIdd));
		} else if (this.dataObj.conf.mode == "h") {
			
			var c1 = parentIdd;
			if (this.dataObj.cdata[c1].conf.collapsed) c1 = this.dataObj.conf.nextCell[c1];
			
			return Math.max(this.conf.min_height, this.dataObj.cdata[c1]._getMinHeight(parentIdd)+this.dataObj.cdata[c1]._getHdrHeight()+this.dataObj.cdata[this.dataObj.conf.nextCell[c1]]._getHeight()+this.dataObj.conf.sw); // c1 min height + c1 hdr height + c2 full height + sw
			
		} else {
			return Math.max(this.conf.min_height, this.dataObj.cdata.a._getMinHeight(parentIdd)+this.dataObj.cdata.a._getHdrHeight(), this.dataObj.cdata.b._getMinHeight(parentIdd)+this.dataObj.cdata.b._getHdrHeight());
		}

	}
	
	return Math.max(this.conf.min_height, h);
};

dhtmlXLayoutCell.prototype._getAvailWidth = function(parentIdd) {
	
	if (this.dataType == "layout" && this.dataObj != null) {
		if (this.dataObj.conf.pattern == "1C") {
			return this.dataObj.cdata.a._getAvailWidth(parentIdd);
		} else if (this.dataObj.conf.mode == "v") {
			var ac = (this.dataObj.cdata.a.conf.collapsed == true);
			var bc = (this.dataObj.cdata.b.conf.collapsed == true);
			
			if (parentIdd == "a") {
				return this.dataObj.cdata[bc?"a":"b"]._getAvailWidth(parentIdd);
			} else {
				return this.dataObj.cdata[ac?"b":"a"]._getAvailWidth(parentIdd);
			}
		} else {
			return Math.min(this.dataObj.cdata.a._getAvailWidth(parentIdd), this.dataObj.cdata.b._getAvailWidth(parentIdd));
		}
		
	}
	return this.cell.offsetWidth-this._getMinWidth();
};

dhtmlXLayoutCell.prototype._getAvailHeight = function(parentIdd) {
	
	if (this.dataType == "layout" && this.dataObj != null) {
		if (this.dataObj.conf.pattern == "1C") {
			return this.dataObj.cdata.a._getAvailHeight(parentIdd);
		} else if (this.dataObj.conf.mode == "h") {
			
			var ac = (this.dataObj.cdata.a.conf.collapsed == true);
			var bc = (this.dataObj.cdata.b.conf.collapsed == true);
			
			if (parentIdd == "a") {
				return this.dataObj.cdata[bc?"a":"b"]._getAvailHeight(parentIdd);
			} else {
				return this.dataObj.cdata[ac?"b":"a"]._getAvailHeight(parentIdd);
			}
		} else {
			return Math.min(this.dataObj.cdata.a._getAvailHeight(parentIdd), this.dataObj.cdata.b._getAvailHeight(parentIdd));
		}
		
	}
	
	var hh = this._getHdrHeight();
	if (this.conf.mode == "v" && this.conf.collapsed) hh = this.conf.hh; // not include header if v-cell is collapsed
	
	return this.cell.offsetHeight-hh-this._getMinHeight();
};

dhtmlXLayoutCell.prototype.setWidth = function(w) {
	
	if (this.conf.mode == "v") {
		
		if (this.conf.collapsed) return;
		
		var k = this.layout;
		var nextCell = k.cdata[k.conf.nextCell[this._idd]];
		
		if (nextCell.conf.collapsed) {
			
			// try to change parent cell
			
			w = w + k.conf.sw + nextCell._getWidth(); // increase width including nextCell and sw
			
			/*
			var p = this.layout._getMainInst();
			if (p != this.layout) {
				for (var a in p.cdata) if (p.cdata[a].dataObj == k) p.cdata[a].setWidth(w);
			}
			*/
			
			p = k = nextCell = null;
			
			return;
			
		}
		
		var minW = this._getMinWidth(this._idd);
		var maxW = k.cont.offsetWidth-nextCell._getMinWidth(this._idd)-k.conf.sw;
		w = Math.max(minW, Math.min(w, maxW));
		
		this.conf.size.w = w;
		
		k.setSizes(nextCell._idd, nextCell._idd);
		k = nextCell = null;
		
	} else {
		// check parent's width
		if (this.layout == null || this.layout.parentLayout == null) return;
		
		var p = this.layout.parentLayout;
		
		var k = this.layout;
		var nextCell = k.cdata[k.conf.nextCell[this._idd]];
		
		for (var a in p.cdata) if (p.cdata[a].dataObj == k) p.cdata[a].setWidth(w);
		
		p = k = null;
	}
	
};

dhtmlXLayoutCell.prototype.setHeight = function(h) {
	
	if (this.conf.mode == "h") {
		
		if (this.conf.collapsed) return;
		
		var k = this.layout;
		var nextCell = k.cdata[k.conf.nextCell[this._idd]];
		
		if (nextCell.conf.collapsed) {
			
			// try to change parent cell
			
			h = h + k.conf.sw + nextCell._getHeight(); // increase with including nextCell and sw, header=cell_height due it collapsed
			
			var p = (this.layout != null && this.layout.parentLayout != null ? this.layout.parentLayout : null);
			if (p != null) {
				for (var a in p.cdata) if (p.cdata[a].dataObj == k) p.cdata[a].setHeight(h);
			}
			
			p = k = nextCell = null;
			
			return;
			
		}
		
		var minH = this._getMinHeight(this._idd)+this._getHdrHeight();
		var maxH = k.cont.offsetHeight-nextCell._getMinHeight(this._idd)-nextCell._getHdrHeight()-k.conf.sw;
		h = Math.max(minH, Math.min(h, maxH));
		
		this.conf.size.h = h;
		
		k.setSizes(nextCell._idd, nextCell._idd);
		k = nextCell = null;
		
	} else {
		// check parent's height
		if (this.layout == null || this.layout.parentLayout == null) return;
		
		var p = this.layout.parentLayout;
		
		var k = this.layout;
		var nextCell = k.cdata[k.conf.nextCell[this._idd]];
		
		for (var a in p.cdata) if (p.cdata[a].dataObj == k) p.cdata[a].setHeight(h);
		
		p = k = null;
	}
	
};

dhtmlXLayoutCell.prototype.getWidth = function() {
	return this.conf.size.w;
};

dhtmlXLayoutCell.prototype.getHeight = function() {
	return this.conf.size.h;
};

dhtmlXLayoutCell.prototype.fixSize = function(w, h) {
	
	this.conf.fixed.w = window.dhx4.s2b(w);
	this.conf.fixed.h = window.dhx4.s2b(h);
	
	var mainInst = this.layout._getMainInst();
	var s = {};
	
	mainInst.forEachItem(function(cell){
		if (cell.conf.fsize != null) {
			var id = cell.getId();
			var p = {
				h: (cell.conf.fixed.w==true),
				v: (cell.conf.fixed.h==true)
			};
			for (var a in p) {
				if (p[a] == true && cell.conf.fsize[a] != null) {
					if (!(cell.conf.fsize[a] instanceof Array)) cell.conf.fsize[a] = [cell.conf.fsize[a]];
					for (var q=0; q<cell.conf.fsize[a].length; q++) s[cell.conf.fsize[a][q]] = true;
				}
			}
		}
		cell = null;
	});
	
	mainInst._forEachSep(function(sep){
		sep._lockSep(s[sep.conf.idx]==true);
		sep = null;
	});
	
	mainInst = null;
	
};


dhtmlXCellObject.prototype.attachLayout = function(conf) {
	
	this.callEvent("_onBeforeContentAttach",["layout"]);
	
	var obj = document.createElement("DIV");
	obj.style.width = "100%";
	obj.style.height = "100%";
	obj.style.position = "relative";
	obj.style.overflow = "hidden";
	this._attachObject(obj);
	
	if (typeof(this._layoutMainInst) != "undefined") {
		obj._layoutMainInst = this._layoutMainInst;
	}
	
	if (typeof(window.dhtmlXLayoutCell) == "function" && this instanceof window.dhtmlXLayoutCell) {
		obj._isParentCell = true;
		if (this.conf.skin == "material" && String(this.cell.className).match(/dhx_cell_nested_layout/) == null) {
			this.cell.className += " dhx_cell_nested_layout";
		}
	}
	
	if (typeof(window.dhtmlXAccordionCell) == "function" && this instanceof window.dhtmlXAccordionCell) {
		if (this.conf.skin == "material") {
			obj._ofs = {t:14,r:14,b:14,l:14};
		} else {
			obj._ofs = {t:-1,r:-1,l:-1,b:-1};
		}
	}
	
	if (typeof(window.dhtmlXTabBarCell) == "function" && this instanceof window.dhtmlXTabBarCell) {
		if (this.conf.skin == "dhx_skyblue") obj._ofs = {t:-1,r:-1,b:-1,l:-1};
		if (this.conf.skin == "material") obj._ofs = {t:8,r:8,b:8,l:8};
	}
	
	if (typeof(window.dhtmlXSideBarCell) == "function" && this instanceof window.dhtmlXSideBarCell) {
		if (this.conf.skin == "dhx_web") {
			obj._ofs = {l:8};
			if (this.sidebar.conf.autohide == true) obj._ofs.l = 0;
			if (this.sidebar.conf.header == true) obj._ofs.t = 9; // default separator size for web
		} else if (this.conf.skin == "dhx_terrace") {
			obj._ofs = {l:11};
			if (this.sidebar.conf.autohide == true) obj._ofs.l = 0;
			if (this.sidebar.conf.header == true) obj._ofs.t = 10; // default separator size for web
		} else {
			obj._ofs = {l:-1};
		}
	}
	
	if (typeof(window.dhtmlXCarouselCell) == "function" && this instanceof window.dhtmlXCarouselCell) {
		this._hideBorders();
	}
	
	if (typeof(window.dhtmlXWindowsCell) == "function" && this instanceof window.dhtmlXWindowsCell) {
		if (this.conf.skin == "material") obj._ofs = {t:14,r:14,b:14,l:14};
	}
	
	if (typeof(conf) == "string") conf = {pattern: conf};
	if (typeof(conf.skin) == "undefined") conf.skin = this.conf.skin;
	conf.parent = obj;
	
	this.dataType = "layout";
	this.dataObj = new dhtmlXLayoutObject(conf);
	
	if (this instanceof window.dhtmlXLayoutCell) {
		this.dataObj.parentLayout = this.layout;
	}
	
	obj._layoutMainInst = null;
	conf.parent = null;
	obj = conf = null;
	
	this.callEvent("_onContentAttach",[]);
	
	return this.dataObj;
	
};


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXTabBar(conf, mode) { // skin? data?
	
	// console.log("context menu for tabs?");
	// console.log("first tab open event?");
	
	var that = this;
	
	this.conf = {
		skin: (window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxtabbar")||"material"),
		css: "dhxtabbar", // css prefix for topcell mtb
		lastActive: null,
		closeButton: false,
		align: "left", // tabs aligned to right side, inversed, default "right" align
		tabsMode: (mode=="bottom"?"bottom":"top"), // top/bottom
		tabsContCss: "", // fix for Safari 5.1.7 desktop or Safari iOS 7.x mobile
		contZone: true,
		transSpeed: "0.15s",
		arwMode: "always", // always (def), auto
		tabsOfs: 1, // dhx_skyblue and dhx_terrace have margin-left:-1px for tabs, should be included
		tabsTop: 0, // tabs top position, used in attachObject to hide border
		url_demand: false,
		urls: {},
		autoload: {},
		tabsWidth: {dhx_terrace: [44,14], dhx_web: [35,9], dhx_skyblue: [35,9], material: [44,14]} // extra width for tabs/tab_with_close_icon, for tab width detect, since 4.2.1
	};
	
	if (this.conf.skin == "material") this.conf.arwMode = "auto";
	
	// safari fix
	var a = navigator.userAgent;
	if (a.indexOf("Safari") >= 0 && (a.indexOf("5.1.7") >= 0 || (a.match(/7[\.\d]* mobile/gi) != null && a.match(/AppleWebKit/gi) != null))) {
		this.conf.tabsContCss = " safari_517_fix";
	}
	
	var base;
	
	// check if api init
	if (conf != null && typeof(conf) == "object" && typeof(conf.tagName) == "undefined") {
		base = conf.parent;
		if (typeof(conf.skin) != "undefined") this.conf.skin = conf.skin;
		if (typeof(conf.mode) != "undefined") this.conf.tabsMode = (conf.mode=="bottom"?"bottom":"top");
		if (typeof(conf.align) != "undefined") this.conf.align = (conf.align=="right"?"right":"left");
		if (typeof(conf.close_button) != "undefined") this.conf.closeButton = window.dhx4.s2b(conf.close_button);
		if (typeof(conf.content_zone) != "undefined") this.conf.contZone = window.dhx4.s2b(conf.content_zone);
		if (typeof(conf.xml) != "undefined") this.conf.autoload.xml = conf.xml;
		if (typeof(conf.json) != "undefined") this.conf.autoload.xml = conf.json; // new in 4.0
		if (typeof(conf.tabs) != "undefined") this.conf.autoload.tabs = conf.tabs;
		if (typeof(conf.onload) != "undefined") this.conf.autoload.onload = conf.onload; // new in 4.0
		if (typeof(conf.arrows_mode) != "undefined") this.conf.autoload.arrows_mode = conf.arrows_mode; // new in 4.1.2
		// deprecated from 4.0
		// conf { height, offset, margin, image_path, href_mode, scroll, forced, size_by_content, auto_size }
	} else {
		base = conf;
	}
	
	// init top container
	window.dhtmlXCellTop.apply(this, [base, conf.offsets]);
	
	// tabsTop override
	if (this.base._ofs != null && this.base._ofs.t != null) this.conf.tabsTop = this.base._ofs.t;
	
	this.tabsMode = document.createElement("DIV");
	this.tabsMode.className = "dhxtabbar_tabs_"+this.conf.tabsMode;
	this.cont.appendChild(this.tabsMode);
	
	this.tabsArea = document.createElement("DIV");
	this.tabsArea.className = "dhxtabbar_tabs dhxtabbar_tabs_"+this.conf.tabsMode;
	this.tabsArea.innerHTML = "<div class='dhxtabbar_tabs_ar_left'><div class='dhxtabbar_arrow_img'></div></div>"+
					"<div class='dhxtabbar_tabs_base'>"+
						"<div class='dhxtabbar_tabs_cont_"+this.conf.align+this.conf.tabsContCss+"'>"+
							"<div class='dhxtabbar_tabs_line'></div>"+
						"</div>"+
					"</div>"+
					"<div class='dhxtabbar_tabs_ar_right'><div class='dhxtabbar_arrow_img'></div></div>";
	
	this.tabsArea.style.top = (this.conf.tabsMode=="top"?this.conf.tabsTop+"px":"auto");
	this.tabsMode.appendChild(this.tabsArea);
	
	// area to move tabs
	this.tabsArea.childNodes[1].childNodes[0].style[this.conf.align] = "0px";
	
	this.tabsArea.childNodes[0].onclick = function() {
		if (that.conf.align == "left") {
			that._moveTabs(1);
		} else {
			that._moveTabs(-1);
		}
	}
	this.tabsArea.childNodes[2].onclick = function() {
		if (that.conf.align == "left") {
			that._moveTabs(-1);
		} else {
			that._moveTabs(1);
		}
	}
	
	this._onTabsAreaClick = function(id) {
		return this._callMainEvent("onTabClose",[id]);
	}
	
	this.tabsArea.onclick = function(e) {
		e = e||event;
		var t = (e.target||e.srcElement);
		while (t != null) {
			if (typeof(t._tabCloseId) != "undefined") {
				if (that._onTabsAreaClick(t._tabCloseId) !== true) return;
				that.t[t._tabCloseId].conf.remove = true;
				that._hideTab(t._tabCloseId);
				t = null;
			} else if (typeof(t._tabId) != "undefined") {
				that._doOnClick(t._tabId);
				t = null;
			}
			if (t != null) {
				t = t.parentNode;
				if (t == this) t = null;
			}
		}
	}
	
	this.tabsArea.onselectstart = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
	}
	
	this._doOnClick = function(id) {
		// onBeforeEvent here
		this.callEvent("onTabClick", [id, this.conf.lastActive]);
		if (this.t[id].conf.enabled) this._setTabActive(id);
	}
	
	this.t = {};
	
	this.addTab = function(id, text, width, position, active, close) {
		
		// close = show close button, false by default
		// true - show_closeButton
		// false - do not show (ignoring enableTabCloseButton)
		// not set - depending on enableTabCloseButton
		close = (typeof(close)=="undefined"?(this.conf.closeButton==true):window.dhx4.s2b(close));
		active = window.dhx4.s2b(active);
		
		var tab = document.createElement("DIV");
		tab.className = "dhxtabbar_tab";
		tab.innerHTML = "<div class='dhxtabbar_tab_text"+(close?" dhxtabbar_tab_text_close":"")+"'>"+text+"</div>"+
				(close?"<div class='dhxtabbar_tab_close'></div>":"");
		
		tab._tabId = id;
		if (close) tab.childNodes[1]._tabCloseId = id; // close button
		
		var p = this.tabsArea.childNodes[1].firstChild;
		
		if (position != null && position+1 > 0 && position+1 < p.childNodes.length) { // 1st item - line
			p.insertBefore(tab, p.childNodes[position+1]);
		} else {
			p.appendChild(tab);
		}
		
		
		// width
		var autowidth = false;
		if (typeof(width) == "undefined" || width == null || width == "*") {
			width = this._getLabelWidth(text, close);
			autowidth = true;
		} else {
			width = parseInt(width);
		}
		
		tab.style.width = width+"px";
		
		var cell = new dhtmlXTabBarCell(id, this);
		this.tabsMode.appendChild(cell.cell);
		
		this.t[id] = {
			tab: tab,
			cell: cell,
			conf: {
				text: text,
				visible: true,
				active: false,
				enabled: true,
				close: close,
				width: width,
				autowidth: autowidth
			}
		};
		
		p = cell = null;
		
		if (active) {
			this._setTabActive(id);
		} else {
			this._adjustCell(id);
		}
		
		if (this.conf.initSeq != true && this.conf.arwMode == "auto") this.setSizes();
	}
	
	this.setSizes = function() {
		
		// celltop
		this._adjustCont();
		
		if (this.conf.tabsAreaOfs == null) {
			this.tabsArea.style.width = this.cont.offsetWidth+"px";
			this.conf.tabsAreaOfs = parseInt(this.tabsArea.style.width)-this.tabsArea.offsetWidth;
		}
		this.tabsArea.style.width = this.cont.offsetWidth+this.conf.tabsAreaOfs+"px";
		
		this._adjustCell(this.conf.lastActive);
		this._adjustTabs(true);
		
		this.callEvent("_onSetSizes", []);
		
	}
	
	this._adjustCell = function(id) {
		
		// adjust specified cell or active
		
		if (!this.conf.contZone || id == null) return;
		
		var y = (this.conf.tabsMode=="top"?this.tabsArea.offsetHeight:0)+this.conf.tabsTop;
		var h = this.cont.offsetHeight-this.tabsArea.offsetHeight-this.conf.tabsTop;
		
		// if layout attached - move a bit
		var t = this.t[id].cell.dataType;
		if (this.conf.skin == "dhx_skyblue" && (t == "layout" || t == "tabbar" || t == "acc")) {
			if (this.conf.tabsMode == "top") y = y - 1; // only for top
			h = h + 1; // always
		}
		
		if (id != this.conf.lastActive) {
			y = -5000;
			this.t[id].cell.cell.style.visibility = "hidden";
			this.t[id].cell.cell.style.zIndex = 0;
		}
		this.t[id].cell._setSize(0, y, this.cont.offsetWidth, h);

	}
	
	this.setTabsMode = function(mode) {
		// new
		this.conf.tabsMode = (mode=="bottom"?"bottom":"top");
		this.tabsMode.className = "dhxtabbar_tabs_"+this.conf.tabsMode;
		this.tabsArea.className = "dhxtabbar_tabs dhxtabbar_tabs_"+this.conf.tabsMode;
		this.tabsArea.style.top = (this.conf.tabsMode=="top"?this.conf.tabsTop+"px":"auto");
		this.setSizes();
	}
	
	// generate tab css depending on actv/en state
	this._tabCss = function(id, hidden) {
		var a = this.t[id].conf.active;
		var d = !this.t[id].conf.enabled;
		var h = !this.t[id].conf.visible;
		return "dhxtabbar_tab"+(h?" dhxtabbar_tab_hidden":(a||d?" dhxtabbar_tab"+(a?"_actv":"")+(d?"_dis":""):""));
	}
	
	// calculate tab width depending on text and close button
	this._getLabelWidth = function(text, close) {
		
		if (this.tabsTextTest == null) {
			this.tabsTextTest = document.createElement("SPAN");
			this.tabsTextTest.className = "dhxtabbar_tabs_text_test_"+this.conf.skin;
		}
		
		document.body.appendChild(this.tabsTextTest);
		this.tabsTextTest.innerHTML = text;
		var w = this.tabsTextTest.offsetWidth;
		if (window.dhx4.isIE && w == 0) w = this.tabsTextTest.offsetWidth; // strange IE bug
		
		// some extra width
		w += this.conf.tabsWidth[this.conf.skin][0];
		if (close == true) w += this.conf.tabsWidth[this.conf.skin][1];
		
		//
		document.body.removeChild(this.tabsTextTest);
		return w;
	}
	
	// if tabs overflow left/right side, adjust active tab position
	this._adjustTabs = function(fixTabsArea) {
		
		if (this._checkArrows() == true || fixTabsArea == true) {
			this.tabsArea.childNodes[1].style.left = this.tabsArea.childNodes[0].offsetWidth-1+"px";
			this.tabsArea.childNodes[1].style.width = Math.max(0, this.tabsArea.clientWidth-this.tabsArea.childNodes[0].offsetWidth-this.tabsArea.childNodes[2].offsetWidth)+this.conf.tabsOfs*2+"px"; // minus 2 arrows
		}
		
		var p = this.tabsArea.childNodes[1];
		if (p.offsetWidth < 5) {
			p = null;
			return;
		}
		
		var x = parseInt(p.childNodes[0].style[this.conf.align]);
		
		var k = null;
		for (var q=0; q<p.childNodes[0].childNodes.length; q++) {
			var id = p.childNodes[0].childNodes[q]._tabId;
			if (id != null && this.t[id].conf.visible) {
				var w = this.t[id].tab.offsetWidth-this.conf.tabsOfs;
				if (this.t[id].conf.active) {
					if (x < 0 || p.offsetWidth<w) {
						k = {d: 1, id: id}; // tab hidden on left side, move to right OR tab width less than space available
					} else if (x+w > p.offsetWidth) {
						k = {d:-1, id: id}; // overflow on right
					}
				}
				x += w;
			}
		}
		
		if (k != null) {
			// move selected tab to visible space
			this._moveTabs(k.d, k.id);
		} else if (p.offsetWidth > x+1) {
			// check space on right side
			p.childNodes[0].style[this.conf.align] = Math.min(0, parseInt(p.childNodes[0].style[this.conf.align])+(p.offsetWidth-x))+"px";
		}
		
		p = k = null;
		
	}
	
	// tabs scrolling
	this._moveTabs = function(d, tabId) {
		
		// get all visible tabs
		var p = this.tabsArea.childNodes[1].childNodes[0];
		var i = 0;
		var tabs = [];
		var tabInd = null; // index of tabId
		for (var q=0; q<p.childNodes.length; q++) {
			var id = p.childNodes[q]._tabId;
			if (id != null && this.t[id].conf.visible) {
				tabs.push({id: id, w: this.t[id].tab.offsetWidth-this.conf.tabsOfs, ind: i});
				if (id == tabId) tabInd = i;
				i++;
			}
		}
		
		// find 1st/last full visible tabs or null
		var x = parseInt(this.tabsArea.childNodes[1].childNodes[0].style[this.conf.align]);
		var totalSpace = this.tabsArea.clientWidth-this.tabsArea.childNodes[0].offsetWidth-this.tabsArea.childNodes[2].offsetWidth+this.conf.tabsOfs;
		
		var f = null;
		var l = null;
		
		for (var q=0; q<tabs.length; q++) {
			tabs[q].x = x;
			if (f == null && x >= 0 && x+tabs[q].w > 0) f = tabs[q];
			if (x < totalSpace && x+tabs[q].w <= totalSpace) l = tabs[q];
			x += tabs[q].w;
		}
		
		if (tabInd != null) {
			
			var t = tabs[tabInd];
			
		} else {
			
			var t = null;
			if (d > 0) {
				// left arrow clicked
				// find prev tab (for 1st visible) or last (if 1st is null)
				if (f == null) {
					if (tabs.length > 0) t = tabs[tabs.length-1];
				} else {
					if (f.ind > 0 && tabs.length >= f.ind) t = tabs[f.ind-1];
				}
				
			} else {
				// right arrow clicked
				// find next tab (for last visible) or first (if last-visible is null)
				if (l == null) {
					if (tabs.length > 0) t = tabs[0];
				} else {
					if (tabs.length > l.ind) t = tabs[l.ind+1];
				}
				
			}
		}
		
		// move prev/last tab to 1st position
		if (t != null) {
			if (d > 0) {
				if (x < totalSpace) {
					// some tabs are on left and some space left on right
					p.style[this.conf.align] = Math.min(0, parseInt(p.style[this.conf.align])+(totalSpace-x))+"px";
				} else {
					// show tab on left
					p.style[this.conf.align] = parseInt(p.style[this.conf.align])-t.x+"px";
				}
			} else {
				p.style[this.conf.align] = parseInt(p.style[this.conf.align])-t.x+totalSpace-t.w+"px";
			}
		}
		
		p = t = tabs = null;
		
	}
	
	// return next visible related to tab-id
	this._getNextVisible = function(id, getFirst) {
		return this._getNearVisible(id, getFirst, "next");
	}
	
	// return prev visible related to tab-id
	this._getPrevVisible = function(id, getFirst) {
		return this._getNearVisible(id, getFirst, "previous");
	}
	
	// get first visible
	this._getFirstVisible = function() {
		return this._getNearVisible(null, false, "first");
	}
	
	this._getNearVisible = function(id, getFirst, mode) {
		
		if (mode == "first") {
			var node = this.tabsArea.childNodes[1].childNodes[0].childNodes[1]; // firstChild is line
			mode = "next";
		} else {
			if (id == null || this.t[id] == null) return (getFirst?this._getFirstVisible():null);
			var node = this.t[id].tab[mode+"Sibling"];
		}
		
		var tabId = null;
		
		while (node != null && tabId == null) {
			var k = node._tabId;
			if (k != null && tabId == null && this.t[k].conf.visible) {
				tabId = k;
			} else {
				node = node[mode+"Sibling"];
			}
		}
		
		node = null;
		
		return tabId;
	}
	
	
	
	this._showTab = function(id, activate) { // activate true/false
		
		if (this.t[id] == null) return;
		
		if (this.t[id].conf.transActv == true) {
			if (this.t[id].conf.transMode == "show") return;
		} else {
			if (this.t[id].conf.visible == true) return;
		}
		
		// get next tab
		// move
		// show prev+set marg to -1
		// get next/prev tabs
		
		if (this.conf.transProp !== false) {
			
			// slide effect
			this.t[id].conf.transActv = true;
			this.t[id].conf.transMode = "show";
			this.t[id].conf.transProp = this.conf.transProp;
			this.t[id].conf.transActvId = (activate?id:null);
			
			if (!this.t[id].conf.transEv) {
				this.t[id].tab.addEventListener(this.conf.transEv, this._doOnTrEnd, false);
				this.t[id].conf.transEv = true;
			}
			
			this.t[id].conf.visible = true;
			this.t[id].tab.className = this._tabCss(id);
			
			this.t[id].tab.style[this.conf.transProp] = this.conf.transValueWidth;
			this.t[id].tab.style.width = this.t[id].conf.width+"px";
			
			if (this.t[id].tab.clientWidth >= this.t[id].conf.width) {
				this.t[id].tab.style.visibility = "visible";
			}
			
		} else {
			this.t[id].conf.visible = true;
			this.t[id].tab.style.display = "";
			
			if (activate || this.t[id].conf.active) {
				this.t[id].conf.active = false;
				this._setTabActive(id);
			} else {
				this._adjustTabs();
			}
		}
	}
	
	this._hideTab = function(id, activateId) { // activateId - tab to activate
		
		// activateId
		// if set to true, selection jump from current tab to nearest one (old logic)
		// activateId can also be id of any other tab (new logic)
		
		if (this.t[id] == null) return;
		
		if (this.t[id].conf.transActv == true) {
			if (this.t[id].conf.transMode == "hide") return;
		} else {
			if (this.t[id].conf.visible != true) return;
		}
		
		// if tab was active clear flags/css
		var lastActive = false;
		if (this.conf.lastActive == id) {
			this.conf.lastActive = null;
			this.t[id].conf.active = false;
			this.t[id].tab.className = this._tabCss(id);
			lastActive = true;
		}
		
		// get next/prev tabs
		var prev = this._getPrevVisible(id);
		var next = this._getNextVisible(id);
		
		var actvId = (lastActive == true && activateId !== false ? (activateId==true?null:activateId)||next||prev : null);
		
		// hide and move next tab to left if any
		if (this.conf.transProp !== false) {
			
			this.t[id].conf.transActv = true;
			this.t[id].conf.transMode = "hide";
			this.t[id].conf.transProp = this.conf.transProp;
			this.t[id].conf.transActvId = actvId;
			this.t[id].conf.visible = false;
			
			if (!this.t[id].conf.transEv) {
				this.t[id].tab.addEventListener(this.conf.transEv, this._doOnTrEnd, false);
				this.t[id].conf.transEv = true;
			}
			
			this.t[id].tab.style.visibility = "hidden";
			this.t[id].tab.className = that._tabCss(id);
			this.t[id].tab.style[this.conf.transProp] = this.conf.transValueWidth;
			this.t[id].tab.style.width = "0px";
			
		} else {
			
			this.t[id].tab.style.display = "none";
			this.t[id].conf.visible = false;
			if (this.conf.contZone) {
				this.t[id].cell.cell.style.visibility = "hidden";
				this.t[id].cell.cell.style.top = "-5000px"; // "vis:hid" > "vis:vis" http://www.w3.org/TR/CSS2/visufx.html#visibility
			}
			
			if (actvId != null) this._setTabActive(actvId);
			this._adjustTabs();
			
			if (this.t[id].conf.remove) this._removeTab(id);
		}
		
	}
	
	this._isTabVisible = function(id) {
		return (this.t[id].conf.visible==true);
	}
	
	this._doOnTrEnd = function() {
		
		var id = this._tabId; // this points to tab
		
		if (that.t[id] == null) return;
		
		var t = that.t[id];
		var actvId = t.conf.transActvId;
		
		if (t.conf.transMode == "hide") {
			
			// remove if any
			if (t.conf.remove) {
				that._removeTab(id);
			} else {
				
				t.tab.style[t.conf.transProp] = "";
				
				if (that.conf.contZone) {
					t.cell.cell.style.visibility = "hidden";
					t.cell.cell.style.top = "-5000px";
				}
				
				t.conf.transActv = false;
				
			}
			
		} else if (t.conf.transMode == "show") {
			
			t.tab.style[t.conf.transProp] = "";
			t.tab.style.visibility = "visible";
			
			t.conf.transMode = null;
			t.conf.transActv = false;
			
		}
		
		if (actvId != null) {
			that._setTabActive(actvId);
		} else {
			that._adjustTabs();
		}
		
		t = null;
		
	}
	
	
	this.enableTabCloseButton = function(mode) {
		this.conf.closeButton = window.dhx4.s2b(mode);
	}
	
	this.unload = function() {
		
		this.conf.unloading = true;
		
		this.clearAll(); // remove all tabs
		this.t = null;
		
		if (this.tabsTextTest != null) {
			if (this.tabsTextTest.parentNode) this.tabsTextTest.parentNode.removeChild(this.tabsTextTest);
			this.tabsTextTest = null;
		}
		
		// clear data loading
		window.dhx4._enableDataLoading(this, null, null, null, "clear");
		
		this.tabsArea.childNodes[0].onclick = null;
		this.tabsArea.childNodes[2].onclick = null;
		this.tabsArea.onclick = null;
		this.tabsArea.onselectstart = null;
		this.tabsArea.parentNode.removeChild(this.tabsArea);
		this.tabsArea = null;
		
		this.tabsMode.parentNode.removeChild(this.tabsMode);
		this.tabsMode = null;
		
		this._unloadTop();
		
		// clear events
		window.dhx4._eventable(this, "clear");
		
		for (var a in this) this[a] = null;
		that = null;
	}
	
	this.enableContentZone = function(mode) {
		// enables/disables the content zone (enabled by default)
		// call before tabs adding
		this.conf.contZone = (mode==true);
	}
	
	this.setSkin = function(skin) {
		
		// sets style used for tabbar
		this._setBaseSkin(skin);
		this.conf.skin = skin;
		
		if (this.tabsTextTest != null) this.tabsTextTest.className = "dhxtabbar_tabs_text_test_"+this.conf.skin;
		
		for (var a in this.t) {
			
			// reset autosaved data for padding/border
			this.t[a].cell._resetSizeState();
			
			// tab width
			if (this.t[a].conf.autowidth == true) {
				this.t[a].conf.width = this._getLabelWidth(this.t[a].conf.text, this.t[a].conf.close);
				if (this.t[a].conf.visible) this.t[a].tab.style.width = this.t[a].conf.width+"px";
			}
			
		}
		
		this.conf.tabsAreaOfs = null;
		this._fixTabsOfs();
		
		this.setSizes();
	}
	
	this.setAlign = function(align) {
		
		align = (align=="left"?"left":"right");
		if (align == this.conf.align) {
			this.tabsArea.childNodes[1].childNodes[0].style[this.conf.align] = "0px";
			return;
		}
			
		if (this.conf.transProp !== false) {
			this.tabsArea.childNodes[1].childNodes[0].style[this.conf.transProp] = "";
		}
		this.tabsArea.childNodes[1].childNodes[0].style[this.conf.align] = "";
		
		this.conf.align = align;
		this.tabsArea.childNodes[1].childNodes[0].className = "dhxtabbar_tabs_cont_"+this.conf.align+this.conf.tabsContCss;
		this.tabsArea.childNodes[1].childNodes[0].style[this.conf.align] = "0px";
		
		if (this.conf.transProp !== false) {
			this.conf.transValuePos = this.conf.align+" "+this.conf.transSpeed;
			this.tabsArea.childNodes[1].childNodes[0].style[this.conf.transProp] = this.conf.transValuePos;
		}
	}
	
	this._initObj = function(data) {
		
		this.conf.initSeq = true;
		
		this.clearAll();
		
		var viaAjax = false;
		
		// settings
		if (data.settings != null) {
			if (data.settings.skin != null) this.setSkin(data.settings.skin);
			if (data.settings.close_button != null) { // added in 4.6
				this.enableTabCloseButton(window.dhx4.s2b(data.settings.close_button));
			} else if (data.settings.closeButton != null) { // deprecated from 4.6
				this.enableTabCloseButton(window.dhx4.s2b(data.settings.closeButton));
			}
			if (data.settings.align != null) this.setAlign(data.settings.align);
			if (data.settings.hrefmode == "ajax") viaAjax = true;
			if (data.settings.hrefmode == "ajax-html") { viaAjax = true; this.conf.url_demand = true; } // ajax-html back in 4.2
		}

		// tabs
		if (data.tabs != null) {
			for (var q=0; q<data.tabs.length; q++) {
				var t = data.tabs[q];
				if (typeof(t.id) == "undefined") t.id = window.dhx4.newId();
				if (!isNaN(parseInt(t.width))) { t.width = parseInt(t.width); } else { t.width = null; }
				this.addTab(t.id, t.text||t.label||"", t.width, t.index, window.dhx4.s2b(t.selected)||window.dhx4.s2b(t.active), t.close);
				if (t.content != null) {
					this.cells(t.id).attachHTMLString(t.content);
				} else if (t.href != null) {
					if (this.conf.url_demand == true) {
						this.conf.urls[t.id] = {href: t.href, ajax: viaAjax};
					} else {
						this.cells(t.id).attachURL(t.href, viaAjax);
					}
				}
				if (typeof(t.enabled) != "undefined" && window.dhx4.s2b(t.enabled) == false) {
					this.tabs(t.id).disable();
				} else if (typeof(t.disabled) != "undefined" && window.dhx4.s2b(t.disabled) == true) {
					this.tabs(t.id).disable();
				}
			}
		}
		
		this.conf.initSeq = false;
		if (this.conf.arwMode == "auto") this.setSizes();
		
		// check url on demand to load
		if (this.conf.url_demand == true) this._loadURLOnDemand(this.conf.lastActive);
		
	}
	
	this._xmlToObj = function(data) {
		
		var obj = { settings: {}, tabs: [] };
		var r = data.getElementsByTagName("tabbar")[0];
		
		if (r != null) {
			
			// settings
			for (var a in {skin:1, align:1, closeButton:1, hrefmode:1}) {
				if (r.getAttribute(a) != null) obj.settings[a] = r.getAttribute(a);
			}
			
			// tabs
			var t = r.getElementsByTagName("tab");
			for (var q=0; q<t.length; q++) {
				
				var tab = { text: (t[q].firstChild.nodeValue||"") };
				
				// attrs
				for (var a in {id:1, width:1, close:1, selected:1, active:1, enabled:1, disabled:1, href:1}) {
					if (t[q].getAttribute(a) != null) tab[a] = t[q].getAttribute(a);
				}
				
				// content
				var cont = t[q].getElementsByTagName("content")[0];
				if (cont != null) {
					tab.content = "";
					for (var w=0; w<cont.childNodes.length; w++) tab.content += (cont.childNodes[w].nodeValue||"");
				}
				
				obj.tabs.push(tab);
			}
		}
		
		return obj;
	}
	
	dhx4._enableDataLoading(this, "_initObj", "_xmlToObj", "tabbar", {struct:true});
	
	// check for transition support
	var k = window.dhx4.transDetect();
	
	this.conf.transProp = k.transProp;
	this.conf.transEv = k.transEv;
	this.conf.transValueWidth = "width "+this.conf.transSpeed;
	
	k = null;
	
	if (this.conf.transProp !== false) {
		this.conf.transValuePos = this.conf.align+" "+this.conf.transSpeed;
		this.tabsArea.childNodes[1].childNodes[0].style[this.conf.transProp] = this.conf.transValuePos;
	}
	
	this._callMainEvent = function(name, args) {
		return this.callEvent(name, args);
	}
	
	window.dhx4._eventable(this);
	
	if (this.conf.autoload.json != null) {
		this.loadStruct(this.conf.autoload.json, this.conf.autoload.onload);
	} else if (this.conf.autoload.xml != null) {
		this.loadStruct(this.conf.autoload.xml, this.conf.autoload.onload);
	} else if (this.conf.autoload.tabs != null) {
		this.loadStruct({tabs:this.conf.autoload.tabs}, this.conf.autoload.onload);
	}
	if (this.conf.autoload.arrows_mode != null) {
		this.setArrowsMode(this.conf.autoload.arrows_mode);
	}
	
	
	this._fixTabsOfs();
	this.setSizes();
	
	return this;
	
};

// top-level extensions
dhtmlXTabBar.prototype = new dhtmlXCellTop();

dhtmlXTabBar.prototype._fixTabsOfs = function() {
	this.conf.tabsOfs = ({dhx_skyblue:1,dhx_web:0,dhx_terrace:1,material:0}[this.conf.skin]);
};

/* cell access */
dhtmlXTabBar.prototype.cells = dhtmlXTabBar.prototype.tabs = function(id) {
	if (this.t[id]) return this.t[id].cell;
	return null;
};

dhtmlXTabBar.prototype.getAllTabs = function() {
	var t = [];
	for (var a in this.t) t.push(a);
	return t;
};

/* set/get active, tab switch */
dhtmlXTabBar.prototype._setTabActive = function(id, mode) {
	
	// mode - if set to true - call onSelect event handler (true by default)
	
	if (!this.t[id] || this.t[id].conf.active) return;
	
	if (typeof(mode) == "undefined") mode = true;
	if (mode == true && this.callEvent("onSelect", [id, this.conf.lastActive]) !== true) return;
	
	this.setTabInActive();
	
	this.t[id].conf.active = true;
	if (this.conf.contZone) {
		this.t[id].cell.cell.style.visibility = "visible";
		this.t[id].cell.cell.style.top = "0px";
		this.t[id].cell.cell.style.zIndex = 1;
	}
	this.t[id].tab.className = this._tabCss(id);
	this.conf.lastActive = id;
	this.setSizes();
	
	if (this.conf.url_demand == true) this._loadURLOnDemand(id);
	
};

dhtmlXTabBar.prototype.setTabInActive = function() {
	
	if (this.conf.lastActive != null && this.t[this.conf.lastActive]) {
		this.t[this.conf.lastActive].conf.active = false;
		if (this.conf.contZone) {
			this.t[this.conf.lastActive].cell.cell.style.visibility = "hidden";
			this.t[this.conf.lastActive].cell.cell.style.top = "-5000px";
			this.t[this.conf.lastActive].cell.cell.style.zIndex = 0;
		}
		this.t[this.conf.lastActive].tab.className = this._tabCss(this.conf.lastActive);
		this.conf.lastActive = null;
	}
	
};

dhtmlXTabBar.prototype._isTabActive = function(id) {
	return (id == this.conf.lastActive && this.conf.lastActive != null);
};

dhtmlXTabBar.prototype.getActiveTab = function() {
	return this.conf.lastActive;
};

dhtmlXTabBar.prototype.goToNextTab = function() {
	var id = this._getNextVisible(this.conf.lastActive, true);
	if (id != null) this._setTabActive(id);
};

dhtmlXTabBar.prototype.goToPrevTab = function() {
	var id = this._getPrevVisible(this.conf.lastActive, true);
	if (id != null) this._setTabActive(id);
};



/* enable/disable */
dhtmlXTabBar.prototype._enableTab = function(id, mode) {
	
	// mode - set to true to select tab
	
	if (!this.t[id] || this.t[id].conf.enabled) return;
	this.t[id].conf.enabled = true;
	this.t[id].tab.className = this._tabCss(id);
	
	if (mode == true) this._setTabActive(id);
	
};

dhtmlXTabBar.prototype._disableTab = function(id, activateId) {
	
	// old code have 2nd param in descr but not in script, will added (logic the same as for hideTab)
	// activateId - if set to true, selection jump from current tab to nearest one, or you can specify tab id
	
	if (!this.t[id] || !this.t[id].conf.enabled) return;
	this.t[id].conf.enabled = false;
	this.t[id].tab.className = this._tabCss(id);
	
	if (activateId !== false && this.conf.lastActive == id) {
		if (activateId == true) activateId = this._getNextVisible(id)||this._getPrevVisible(id);
		this._setTabActive(activateId);
	}
	
};

dhtmlXTabBar.prototype._isTabEnabled = function(id) {
	return (this.t[id] != null && this.t[id].conf.enabled==true);
};

/* set/get label */
dhtmlXTabBar.prototype._setTabText = function(id, text, width) {
	
	if (!this.t[id]) return;
	
	var autowidth = false;
	if (typeof(width) == "undefined" || width == null) {
		width = this._getLabelWidth(text, this.t[id].conf.close);
		autowidth = true;
	}
	
	this.t[id].tab.style.width = width+"px";
	this.t[id].tab.childNodes[0].innerHTML = text;
	
	this.t[id].conf.text = text;
	this.t[id].conf.width = width;
	this.t[id].conf.autowidth = autowidth;
	
};

dhtmlXTabBar.prototype._getTabText = function(id) {
	if (!this.t[id]) return null;
	return this.t[id].conf.text;
};

/* remove tab/all tabs */
dhtmlXTabBar.prototype._removeTab = function(id, activateId, force) { // force = w/o effect, private?
	
	if (!this.t[id]) return;
	
	if (force != true && this.t[id].conf.remove != true) {
		this.t[id].conf.remove = true;
		this._hideTab(id, activateId);
		return;
	}
	
	if (typeof(activateId) == "undefined") activateId = true;
	
	var next = this._getNextVisible(id);
	var prev = this._getPrevVisible(id);
	
	if (this.t[id].conf.transEv == true) {
		this.t[id].tab.removeEventListener(this.conf.transEv, this._doOnTrEnd, false);
		this.t[id].conf.transEv = false;
	}
	
	for (var a in this.t[id].conf) this.t[id].conf[a] = null;
	this.t[id].conf = null;
	delete this.t[id].conf;
	
	this.t[id].cell._unload();
	this.t[id].cell = null;
	
	this.t[id].tab.parentNode.removeChild(this.t[id].tab);
	this.t[id].tab = null;
	
	this.t[id] = null;
	delete this.t[id];
	
	this.conf.urls[id] = null;
	delete this.conf.urls[id];
	
	if (this.conf.lastActive == id) {
		this.conf.lastActive = null;
		if (activateId != false) {
			var actvId = (activateId == true ? (next||prev||this._getFirstVisible()) : activateId);
			if (actvId != null) this._setTabActive(actvId);
		}
	} else if (force != true) {
		this._adjustTabs();
	}
};

dhtmlXTabBar.prototype.clearAll = function() {
	// remove all tabs
	for (var a in this.t) this._removeTab(a, false, true);
	this.tabsArea.childNodes[1].childNodes[0].style[this.conf.align] = "0px";
};


/* positionig */
dhtmlXTabBar.prototype.moveTab = function(id, index) {
	
	if (!this.t[id] || index < 0) return;
	index += 1; // firstChild is line
	
	var p = this.tabsArea.childNodes[1].firstChild;
	
	if (p.childNodes[index] != this.t[id].tab) {
		p.removeChild(this.t[id].tab);
		if (index >= p.childNodes.length) {
			p.appendChild(this.t[id].tab);
		} else {
			p.insertBefore(this.t[id].tab, p.childNodes[index]);
		}
	}
	p = null;
};

dhtmlXTabBar.prototype._getIndex = function(id) {
	var i = -1;
	var p = this.tabsArea.childNodes[1].firstChild;
	for (var q=1; q<p.childNodes.length; q++) {
		if (p.childNodes[q]._tabId == id) i = q-1; // firstChild is line
	}
	p = null;
	return i;
};

dhtmlXTabBar.prototype.getNumberOfTabs = function(mode) {
	// mode - set to true for visible only (new)
	var p = 0;
	for (var a in this.t) {
		p += (mode!=true?1:(this.t[a].conf.visible==true?1:0));
	}
	return p;
};

dhtmlXTabBar.prototype.forEachCell = dhtmlXTabBar.prototype.forEachTab = function(func) {
	for (var a in this.t) func.apply(window, [this.t[a].cell]);
};

dhtmlXTabBar.prototype.enableAutoReSize = function() {
	this._initFSResize();
};

// added in 4.1
dhtmlXTabBar.prototype.setArrowsMode = function(mode) {
	mode = {auto: "auto", always: "always"}[String(mode)];
	if (mode == null || mode == this.conf.mode) return;
	this.conf.arwMode = mode;
	
	if (mode == "always") {
		this.tabsArea.childNodes[0].className = "dhxtabbar_tabs_ar_left";
		this.tabsArea.childNodes[2].className = "dhxtabbar_tabs_ar_right";
	}
	
	this.setSizes();
};

dhtmlXTabBar.prototype._checkArrows = function() {
	
	var adj = false;
	
	if (this.conf.arwMode == "auto") {
		
		var w = 0;
		for (var a in this.t) w+= this.t[a].tab.offsetWidth;
		
		var arLeft = this.tabsArea.childNodes[0];
		var arRight = this.tabsArea.childNodes[2];
		
		if (w > this.cont.offsetWidth) {
			// show arows
			if (arLeft.className.search(/dhxtabbar_tabs_ar_hidden/) >= 0) {
				arLeft.className = arLeft.className.replace(/\s{0,}dhxtabbar_tabs_ar_hidden/, "");
				arRight.className = arRight.className.replace(/\s{0,}dhxtabbar_tabs_ar_hidden/, "");
				adj = true;
			}
		} else {
			// hide arrows
			if (arLeft.className.search(/dhxtabbar_tabs_ar_hidden/) < 1) {
				arLeft.className += " dhxtabbar_tabs_ar_hidden";
				arRight.className += " dhxtabbar_tabs_ar_hidden";
				adj = true;
			}
		}
		arLeft = arRight = null;
		
	}
	
	return adj;
	
};

// load url on demand, added in 4.2
dhtmlXTabBar.prototype._loadURLOnDemand = function(id) {
	if (id != null && this.conf.urls[id] != null) {
		this.cells(id).attachURL(this.conf.urls[id].href, this.conf.urls[id].ajax);
		this.conf.urls[id] = null;
	}
};
window.dhtmlXTabBarCell = function(id, tabbar) {
	
	dhtmlXCellObject.apply(this, [id, "_tabbar"]);
	
	this.tabbar = tabbar;
	
	this.conf.skin = this.tabbar.conf.skin;
	
	this.conf.tabbar_funcs = {
		show: "_showTab",
		hide: "_hideTab",
		isVisible: "_isTabVisible",
		enable: "_enableTab",
		disable: "_disableTab",
		isEnabled: "_isTabEnabled",
		getIndex: "_getIndex",
		getText: "_getTabText",
		setText: "_setTabText",
		setActive: "_setTabActive",
		isActive: "_isTabActive",
		close: "_removeTab"
	};
	
	this._tabbarCall = function(name) {
		return function(){
			var t = [this._idd];
			for (var q=0; q<arguments.length; q++) t.push(arguments[q]);
			return this.tabbar[name].apply(this.tabbar, t);
		};
	};
	
	for (var a in this.conf.tabbar_funcs) {
		if (typeof(this[a]) != "function") this[a] = this._tabbarCall(this.conf.tabbar_funcs[a]);
	};
	
	
	this.attachEvent("_onCellUnload", function(){
		this.tabbar = null;
		for (var a in this.conf.tabbar_funcs) {
			this[a] = null;
			this.conf.tabbar_funcs[a] = null;
		}
		this.conf.tabbar_funcs = null;
	});
	
	// "onTabContentLoaded" DEPRECATED
	this.attachEvent("_onContentLoaded", function() {
		this.tabbar._callMainEvent("onContentLoaded", arguments);
		this.tabbar._callMainEvent("onTabContentLoaded", arguments);
	});
	
	this.attachEvent("_onContentAttach", function(){
		this.tabbar._adjustCell(this.tabbar.conf.lastActive);
	});
	this.attachEvent("_onBeforeContentAttach", function(dataType) {
		if (dataType == "sidebar" && this.conf.skin != "dhx_skyblue") {
			this._hideBorders();
		}
	});
	
};

window.dhtmlXTabBarCell.prototype = new dhtmlXCellObject();

dhtmlXCellObject.prototype.attachTabbar = function(conf) {
	
	this.callEvent("_onBeforeContentAttach",["tabbar"]);
	
	// 3.6 init - attachTabbar(mode)
	if (typeof(conf) == "string") {
		conf = {mode:conf};
	} else if (typeof(conf) != "object" || conf == null) {
		conf = {};
	}
	
	var obj = document.createElement("DIV");
	obj.style.width = "100%";
	obj.style.height = "100%";
	obj.style.position = "relative";
	obj.style.overflow = "hidden";
	
	// acc, move tabbar 1px-up to hide top borders
	if (typeof(window.dhtmlXAccordionCell) == "function" && this instanceof window.dhtmlXAccordionCell) {
		if (this.conf.skin == "material") {
			obj._ofs = {t:-1,r:-1,b:-1,l:-1}; // attach tabbar to acc
		} else {
			obj._ofs = {t:-1};
		}
	}
	
	if (typeof(window.dhtmlXTabBarCell) == "function" && this instanceof window.dhtmlXTabBarCell) {
		if (this.conf.skin == "dhx_skyblue") obj._ofs = {t:-1,r:-1,b:-1,l:-1};
		if (this.conf.skin == "material") obj._ofs = {t:8,r:8,b:8,l:8};
	}
	
	// sidebar, move tabbar 1px-left
	if (typeof(window.dhtmlXSideBarCell) == "function" && this instanceof window.dhtmlXSideBarCell) {
		obj._ofs = {l:-1};
		if (this.conf.skin == "dhx_web" && this.sidebar.conf.autohide == true) obj._ofs.l = 0;
		if (this.conf.skin == "dhx_terrace") {
			if (this.sidebar.conf.autohide == true) obj._ofs.l = 0;
			if (this.sidebar.conf.header == true) obj._ofs.t = -1;
		}
	}
	
	// carousel
	if (typeof(window.dhtmlXCarouselCell) == "function" && this instanceof window.dhtmlXCarouselCell) {
		this._hideBorders();
	}
	
	this._attachObject(obj);
	
	conf.skin = this.conf.skin;
	conf.parent = obj;
	
	this.dataType = "tabbar";
	this.dataObj = new dhtmlXTabBar(conf);
	
	conf.parent = obj = null;
	conf = null;
	
	this.callEvent("_onContentAttach",[]);
	
	return this.dataObj;
};


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXTabBarInitFromHTML() {
	
	var z = document.getElementsByTagName("div");
	
	for (var i=0; i<z.length; i++) {
		
		if (z[i].className.indexOf("dhtmlxTabBar") != -1) {
			
			var conf = { settings: {}, tabs: [] };
			
			var n = z[i];
			var id = n.id;
			n.className = "";
			
			var k = new Array();
			for (var j=0; j<n.childNodes.length; j++) {
				if (n.childNodes[j].tagName && n.childNodes[j].tagName != "!") k[k.length] = n.childNodes[j];
			}
			
			var skin = n.getAttribute("skin");
			if (skin != null) conf.settings.skin = skin;
			
			var w = new dhtmlXTabBar({parent: id, mode: n.getAttribute("mode")});
			
			window[id] = w;
			acs = n.getAttribute("onbeforeinit");
			if (acs) eval(acs);
			
			align = n.getAttribute("align");
			if (align) conf.settings.align = align;
			
			var cont = {};
			
			for (var j=0; j<k.length; j++) {
				
				var m = k[j];
				
				var tab = {
					id: m.id,
					text: m.getAttribute("name"),
					width: m.getAttribute("width"),
					selected: m.getAttribute("selected"),
					active: m.getAttribute("active"),
					close: m.getAttribute("close")
				};
				
				var href = m.getAttribute("href");
				if (href) cont[m.id] = {href: href}; else cont[m.id] = {cont: m};
				
				conf.tabs.push(tab);
				
			}
			
			w.loadStruct(conf);
			for (var a in cont) {
				if (cont[a].href) {
					w.cells(a).attachURL(cont[a].href);
					cont[a].href = null;
				} else {
					w.cells(a).attachObject(cont[a].cont);
					if (cont[a].cont.style.display == "none") cont[a].cont.style.display = "";
					cont[a].cont = null;
				}
				cont[a] = null;
			}
			
			var selId = n.getAttribute("select");
			if (selId != null) {
				w.tabs(selId).setActive();
			} else if (w.getActiveTab() == null) {
				var v = w._getFirstVisible();
				if (v != null) w.cells(v).setActive();
			}
			
			acs = n.getAttribute("oninit");
			if (acs) eval(acs);
		}
	}
	
	if (typeof(window.addEventListener) == "function") {
		window.removeEventListener("load", dhtmlXTabBarInitFromHTML, false);
	} else {
		window.detachEvent("onload", dhtmlXTabBarInitFromHTML);
	};
};

if (typeof(window.addEventListener) == "function") {
	window.addEventListener("load", dhtmlXTabBarInitFromHTML, false);
} else {
	window.attachEvent("onload", dhtmlXTabBarInitFromHTML);
};



/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXSideBar(conf) {
	
	var that = this;
	
	this.conf = {
		skin: (conf.skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxsidebar")||"material"),
		css: "dhxsidebar",
		width: conf.width||200,
		scroll_size: 12,
		scroll_mult: 20,
		close_button: false,
		icons_path: conf.icons_path||"",
		selected: null,
		// single cell mode, added in 4.3
		single_cell: (typeof(conf.single_cell)=="undefined"?false:window.dhx4.s2b(conf.single_cell)),
		cell: null,
		// cells header, added in 4.5
		header: window.dhx4.s2b(conf.header),
		// autohide side, added in 4.5
		autohide: window.dhx4.s2b(conf.autohide),
		animate_items: true
	};
	
	// template
	this.setTemplate(conf.template);
	
	// init base
	window.dhtmlXCellTop.apply(this, [conf.parent, (conf==null?null:conf.offsets)]);
	
	// common event system
	window.dhx4._eventable(this);
	
	if (window.navigator.msPointerEnabled == true) {
		this.conf.touch_ms = true;
		this.conf.touch_start = "MSPointerDown",
		this.conf.touch_end = "MSPointerUp"
	} else {
		this.conf.touch_ms = false;
		this.conf.touch_start = "touchstart",
		this.conf.touch_end = "touchend"
	}
	
	// init bars area
	this.side = document.createElement("DIV");
	this.side.className = "dhxsidebar_side dhxsidebar_tpl_"+this.conf.tpl_name;
	this.side.innerHTML = "<div class='dhxsidebar_side_items'></div>";
	this.cont.appendChild(this.side);
	
	
	// overflow arrows
	this.arw = document.createElement("DIV");
	this.arw.className = "dhxsidebar_arrows dhxsidebar_arrows_hidden";
	this.arw.innerHTML = "<div class='dhxsidebar_arrow dhxsidebar_arrow_left'><div class='dhxsidebar_arrow_image'></div></div>"+
				"<div class='dhxsidebar_arrow dhxsidebar_arrow_right'><div class='dhxsidebar_arrow_image'></div></div>";
	this.cont.appendChild(this.arw);
	
	// autohide mode
	if (this.conf.autohide == true) {
		
		this.hideSide();
		
		// for cells left border
		this.cont.className += " dhxsidebar_autohide";
		
		// hide on click
		this._doOnBodyClick = function() {
			if (that.conf.clear_click == true) {
				that.conf.clear_click = false;
				return;
			}
			that.hideSide();
		}
		this._doOnEscDown = function(e) {
			e = e||event;
			if (e.keyCode == 27) {
				that.conf.clear_click = false;
				that.hideSide();
			}
		}
		if (typeof(window.addEventListener) == "function") {
			window.addEventListener(this.conf.touch_start, this._doOnBodyClick, false);
			window.addEventListener("click", this._doOnBodyClick, false);
			window.addEventListener("keydown", this._doOnEscDown, false);
		} else {
			document.body.attachEvent("onclick", this._doOnBodyClick);
			document.body.attachEvent("onkeydown", this._doOnEscDown);
		}
		
	}
	
	window.setTimeout(function(){
		if (that != null && that.side != null) {
			that.side.firstChild.style.top = "0px";
		}
	},1);
	
	
	this._doOnArwClick = function(e) {
		
		e = e||event;
		
		if (e.type != "click" && e.preventDefault) {
			e.preventDefault(); // this will prevent touchmove and click events
		}
		e.cancelBubble = true;
		
		var t = e.target||e.srcElement;
		if (t.className.match(/dhxsidebar_arrow_image/) != null) t = t.parentNode;
		
		if (t.className.match(/dhxsidebar_arrow_left/) != null) {
			that._scrollSide(-that.conf.scroll_size);
		} else if (t.className.match(/dhxsidebar_arrow_right/) != null) {
			that._scrollSide(that.conf.scroll_size);
		}
		
		t = null;
	}
	
	if (typeof(window.addEventListener) == "function") {
		this.arw.addEventListener(this.conf.touch_start, this._doOnArwClick, false);
		this.arw.addEventListener("click", this._doOnArwClick, false);
	} else {
		this.arw.attachEvent("onclick", this._doOnArwClick);
	}
	
	// side click
	this._doOnSideClick = function(e) {
		e = e||event;
		
		var t = e.target||e.srcElement;
		var id = null;
		var b = false;
		
		that.conf.clear_click = true;
		
		if (e.type == "touchstart" || e.type == "pointerdown" || e.type == "MSPointerDown") {
			if (e.preventDefault) {
				e.preventDefault(); // this will prevent touchmove and click events
			}
			if (this.className.match(/dhxsidebar_touch/gi) == null) {
				if (e.type == "touchstart" || (e.type == "pointerdown" && e.pointerType == "touch")) {
					this.className += " dhxsidebar_touch";
				}
			}
		}
		
		while (t != null && id == null && e.type != "pointerdown" && e.type != "MSPointerDown") {
			if (typeof(t.className) != "undefined") {
				if (t.className.match(/^dhxsidebar_item/) != null && typeof(t._idd) != "undefined") {
					id = t._idd;
				} else if (t.className.match(/^dhxsidebar_bubble/) != null) {
					b = true;
					id = t.parentNode._idd;
				}
			}
			t = t.parentNode;
		}
		if (id != null) {
			if (b == false || (b == true && that.callEvent("onBubbleClick", [id, that.t[id].conf.bubble]) == true)) {
				that._setItemActive(id, true);
			}
		}
		t = null;
	}
	
	if (typeof(window.addEventListener) == "function") {
		this.side.addEventListener(this.conf.touch_start, this._doOnSideClick, false);
		this.side.addEventListener(this.conf.touch_end, this._doOnSideClick, false);
		this.side.addEventListener("mouseup", this._doOnSideClick, false);
	} else {
		this.side.attachEvent("onclick", this._doOnSideClick);
	}
	
	this.side.onmouseover = function() {
		this.className = this.className.replace(/\s*dhxsidebar_touch/gi,"");
	}
	
	// side scroll
	this._doOnSideScroll = function(e) {
		e = e||event;
		var y = (e.type=="mousewheel"?-e.wheelDelta:e.deltaY);
		that._scrollSide(y/Math.abs(y)*3);
	}
	
	this._scrollSide = function(dir) { // dir => -1/1
		var top = parseInt(this.side.firstChild.style.top||0)-dir*this.conf.scroll_mult;
		// first check down
		if (top + this.side.firstChild.offsetHeight < this.side.clientHeight) top = this.side.clientHeight - this.side.firstChild.offsetHeight;
		// also check top
		if (top > 0) top = 0;
		this.side.firstChild.style.top = top+"px";
	}
	
	if (typeof(window.addEventListener) == "function") {
		this.side.addEventListener("wheel", this._doOnSideScroll, false);
	} else {
		this.side.attachEvent("onmousewheel", this._doOnSideScroll);
	}
	
	// items
	this.t = {};
	this.s = {};
	
	this._adjustCell = function(id, force) {
		
		if (this.conf.single_cell != true && id == null) return;
		
		var x = (this.conf.autohide==true?0:this.conf.width);
		var w = this.cont.offsetWidth-x;
		
		var y = 0;
		var h = this.cont.offsetHeight;
		
		if (this.conf.single_cell == true) {
			if (force == true) this.conf.cell._setSize(x, y, w, h); // only call from setSizes
		} else {
			if (id != this.conf.selected) {
				y = -5000;
				this.t[id].cell.cell.style.visibility = "hidden";
				this.t[id].cell.cell.style.zIndex = 0;
			}
			this.t[id].cell._setSize(x, y, w, h);
		}
	}
	
	// transition support if any
	var k = window.dhx4.transDetect();
	
	this.conf.transProp = k.transProp;
	this.conf.transEv = k.transEv;
	this.conf.transValue = "all 0.1s";
	
	this._doOnTrEnd = function(e) {
		
		var id = this._idd; // this points to an item
		
		if (that.t[id] == null) return;
		
		var t = that.t[id];
		var actvId = t.conf.transActvId;
		
		if (t.conf.transMode == "hide") {
			
			if (t.conf.remove == true) {
				that._removeItem(id);
			} else {
				t.item.style[t.conf.transProp] = "";
				if (that.conf.single_cell != true) {
					t.cell.cell.style.visibility = "hidden";
					t.cell.cell.style.top = "-5000px";
				}
				t.conf.transActv = false;
			}
			
		} else if (t.conf.transMode == "show") {
			
			t.item.style[t.conf.transProp] = "";
			t.item.style.visibility = "visible";
			t.conf.transMode = null;
			t.conf.transActv = false;
			
		}
		
		if (actvId != null) {
			that._setItemActive(actvId);
		} else {
			that._checkHeight();
		}
		t = null;
		
	}
	
	// data loading
	this._initObj = function(data) {
		this.clearAll();
		if (data.items != null) this.addItem(data.items);
	}
	
	this._xmlToObj = function(data) {
		var items = [];
		var r = data.getElementsByTagName("sidebar");
		if (r != null && r[0] != null) {
			var t = r[0].getElementsByTagName("item");
			for (var q=0; q<t.length; q++) {
				var item = {};
				for (var w=0; w<t[q].attributes.length; w++) {
					item[t[q].attributes[w].nodeName] = t[q].attributes[w].nodeValue;
				}
				items.push(item);
			}
		}
		return {items:items};
	}
	
	dhx4._enableDataLoading(this, "_initObj", "_xmlToObj", "sidebar", {struct:true});
	
	this.unload = function() {
		
		this.conf.unloading = true;
		
		// scroll
		if (typeof(window.addEventListener) == "function") {
			this.side.removeEventListener("wheel", this._doOnSideScroll, false);
		} else {
			this.side.detachEvent("onmousewheel", this._doOnSideScroll);
		}
		
		// autohide
		if (this.conf.autohide == true) {
			if (typeof(window.addEventListener) == "function") {
				window.removeEventListener("click", this._doOnBodyClick, false);
				window.removeEventListener("keydown", this._doOnEscDown, false);
			} else {
				document.body.detachEvent("onclick", this._doOnBodyClick);
				document.body.detachEvent("onkeydown", this._doOnEscDown);
			}
		}
		
		// sudden unload while side opened
		if (typeof(this._sideCoverDetach) == "function") this._sideCoverDetach();
		
		// remove items and separators
		this.clearAll();
		this.s = this.t = null;
		
		// overflow arrows
		if (typeof(window.addEventListener) == "function") {
			this.arw.removeEventListener(this.conf.touch_start, this._doOnArwClick, false);
			this.arw.removeEventListener("click", this._doOnArwClick, false);
		} else {
			this.arw.detachEvent("onclick", this._doOnArwClick);
		}
		this.arw.parentNode.removeChild(this.arw);
		this.arw = null;
		
		// side
		if (typeof(window.addEventListener) == "function") {
			this.side.removeEventListener(this.conf.touch_start, this._doOnSideClick, false);
			this.side.removeEventListener(this.conf.touch_end, this._doOnSideClick, false);
			this.side.removeEventListener("click", this._doOnSideClick, false);
		} else {
			this.side.detachEvent("onclick", this._doOnSideClick);
		}
		this.side.onmouseover = null;
		this.side.parentNode.removeChild(this.side);
		this.side = null;
		
		// celltop
		this._unloadTop();
		
		// single cell
		if (this.conf.single_cell == true) {
			this.conf.cell._unload()
			this.conf.cell = null;
		}
		
		// events and dataloading
		window.dhx4._eventable(this, "clear");
		window.dhx4._enableDataLoading(this, null, null, null, "clear");
		
		// the rest
		for (var a in this) this[a] = null;
		
		that = null;
		
	}
	
	// init single cell if any
	if (this.conf.single_cell == true) {
		this.conf.cell = new dhtmlXSideBarCell("master", this);
		this.cont.appendChild(this.conf.cell.cell);
		//
		this._cells_native = this.cells;
		this.cells = function(id) {
			this.conf.cell._idd = id;
			return this.conf.cell;
		}
	}
	
	// adjust self
	this.setSizes();
	
	// init
	if (conf.items != null) {
		this._initObj(conf);
	} else if (conf.json != null) {
		this.loadStruct(conf.json, conf.onload);
	} else if (conf.xml != null) {
		this.loadStruct(conf.xml, conf.onload);
	}
	
	return this;
};

dhtmlXSideBar.prototype = new dhtmlXCellTop();


// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// add item

dhtmlXSideBar.prototype._addItem = function(conf) {
	
	var id = (typeof(conf.id)!="undefined"?conf.id:window.dhx4.newId());
	
	if (conf.type == "separator") {
		var t = document.createElement("DIV");
		t.className = "dhxsidebar_sep";
		this.side.firstChild.appendChild(t);
		this.s[id] = {sep: t};
		t = null;
		return;
	}
	
	conf.icons_path = this.conf.icons_path;
	
	var t = document.createElement("DIV");
	t.className = "dhxsidebar_item";
	t.innerHTML = window.dhx4.template(this.conf.tpl_str, conf);
	t._idd = id;
	this.side.firstChild.appendChild(t);
	
	t.ondragstart = function(){return false;}
	
	if (this.conf.single_cell == true) {
		var cell = this.conf.cell;
	} else {
		var cell = new dhtmlXSideBarCell(id, this);
		this.cont.appendChild(cell.cell);
	}
	
	this.t[id] = {
		item: t,
		cell: cell,
		init: conf,
		conf: {
			selected: false,
			visible: true,
			close: close
		}
	};
	
	// bubbles
	if (typeof(conf.bubble) != "undefined") {
		this._setItemBubble(id, conf.bubble);
	}
	
	// header text
	if (this.conf.header == true) cell.setHeaderText(window.dhx4.template(this.tpl_header, conf));
	
	cell = t = null;
	
	if (window.dhx4.s2b(conf.selected) == true) {
		this._setItemActive(id);
	} else {
		this._adjustCell(id);
	}
	
	this._checkHeight();
	
};

dhtmlXSideBar.prototype.addItem = function(items) {
	if (!(items instanceof Array)) items = [items];
	for (var q=0; q<items.length; q++) this._addItem(items[q]);
};

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// items opts

dhtmlXSideBar.prototype.items = dhtmlXSideBar.prototype.cells = function(id) {
	if (this.conf.single_cell == true) return this.conf.cell;
	if (this.t[id] != null) return this.t[id].cell;
	return null;
};

dhtmlXSideBar.prototype.forEachCell = dhtmlXSideBar.prototype.forEachItem = function(func) {
	if (this.conf.single_cell == true) {
		if (typeof(func) == "function") {
			func.apply(window, [this.conf.cell]);
		} else if (typeof(func) == "string" && typeof(window[func]) == "function") {
			window[func].apply(window, [this.conf.cell]);
		}
		return;
	}
	for (var a in this.t) {
		if (typeof(func) == "function") {
			func.apply(window, [this.t[a].cell]);
		} else if (typeof(func) == "string" && typeof(window[func]) == "function") {
			window[func].apply(window, [this.t[a].cell]);
		}
	}
};

dhtmlXSideBar.prototype.getAllItems = function() {
	var items = [];
	for (var a in this.t) items.push(a);
	return items;
};

dhtmlXSideBar.prototype.getNumberOfItems = function() {
	return this.getAllItems().length;
};

dhtmlXSideBar.prototype.clearAll = function() { // remove all items and separators
	for (var a in this.t) this._removeItem(a, false, true);
	for (var a in this.s) this.removeSep(a);
};

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// sizing

dhtmlXSideBar.prototype.setSizes = function() {
	this._adjustCont();
	this._adjustSide();
	this._checkHeight();
	this._adjustCell(this.conf.selected, true); // active cell
	this.callEvent("_onSetSizes", []);
};

dhtmlXSideBar.prototype.setSideWidth = function(w) {
	this.conf.width = w;
	this.setSizes();
};

dhtmlXSideBar.prototype._adjustSide = function() {
	
	if (this.conf.side_ofs == null) {
		this.conf.side_ofs = {};
		this.side.style.width = this.conf.width+"px";
		this.side.style.height = this.side.parentNode.offsetHeight+"px";
		this.conf.side_ofs.w = this.side.offsetWidth-parseInt(this.side.style.width);
		this.conf.side_ofs.h = this.side.offsetHeight-parseInt(this.side.style.height);
	}
	
	this.side.style.width = this.conf.width-this.conf.side_ofs.w+"px";
	this.side.style.height = this.side.parentNode.offsetHeight-this.arw.offsetHeight-this.conf.side_ofs.h+"px";
	
	this.arw.style.width = this.side.style.width;
	
	this._scrollSide(0); // fix top position
	
};

dhtmlXSideBar.prototype._checkHeight = function() {
	var arrowsHidden = (this.arw.className.match(/dhxsidebar_arrows_hidden/) != null);
	if (this.conf.side_hfix == null) {
		this.conf.side_hfix = this.side.offsetHeight - this.side.clientHeight;
	}
	if (this.side.firstChild.offsetHeight > this.side.parentNode.clientHeight-this.conf.side_hfix) {
		if (arrowsHidden == true) {
			this.arw.className = "dhxsidebar_arrows";
			this._adjustSide();
		}
	} else {
		if (arrowsHidden == false) {
			this.arw.className = "dhxsidebar_arrows dhxsidebar_arrows_hidden";
			this.side.firstChild.style.top = "0px";
			this._adjustSide();
		}
	}
};

dhtmlXSideBar.prototype.removeSep = function(id) {
	if (this.s[id] == null) return;
	this.side.firstChild.removeChild(this.s[id].sep);
	this.s[id].sep = null;
	this.s[id] = null;
	try { delete this.s[id]; } catch(e){};
};

// show/hide side, added in 4.5
dhtmlXSideBar.prototype.showSide = function() {
	if (this.conf.autohide != true) return;
	
	if (this.sideCover == null) this._sideCoverAttach();
	
	if (this.conf.animate_items == true) {
		
		var animate = function(item, tmTime, prop) {
			window.setTimeout(function(){
				item.style[prop] = "transform 0.3s";
				item.style.transform = "translate(0px,0px)";
				item = null;
			}, tmTime);
		};
		
		if (this.conf.transProp !== false) {
			var q = 100;
			for (var a in this.t) {
				this.t[a].item.style[this.conf.transProp] = "";
				this.t[a].item.style.transform = "translate(-"+(this.conf.width+20)+"px,0px)";
				animate(this.t[a].item, q+=50, this.conf.transProp);
			}
		}
		
	}
	
	var t = this;
	window.setTimeout(function(){
		t.arw.style.left = t.side.style.left = "0px";
		t.sideCover.className = "dhxsidebar_side_cover dhxsidebar_side_cover_actv";
		t = null;
	},50);
	
};

dhtmlXSideBar.prototype.hideSide = function(ef) {
	if (this.conf.autohide != true) return;
	
	this.arw.style.left = this.side.style.left = -this.conf.width-10+"px";
	
	if (this.sideCover != null) {
		if (this.conf.transProp !== false) {
			this.sideCover.className = "dhxsidebar_side_cover";
		} else {
			this._sideCoverDetach();
		}
	}
};

dhtmlXSideBar.prototype._sideCoverAttach = function() {
	
	var that = this;
	
	this.sideCover = document.createElement("DIV");
	this.sideCover.className = "dhxsidebar_side_cover";
	
	if (this.arw.nextSibling != null) {
		this.cont.insertBefore(this.sideCover, this.arw.nextSibling);
	} else {
		this.cont.appendChild(this.sideCover);
	}
	
	this._sideCoverOnTrEnd = function() {
		if (this.className.match(/dhxsidebar_side_cover_actv/) == null) {
			that._sideCoverDetach();
		}
	}
	
	this._sideCoverDetach = function() {
		if (this.sideCover == null) return;
		if (this.conf.transProp !== false) this.sideCover.removeEventListener(this.conf.transEv, this._sideCoverOnTrEnd, false);
		this.sideCover.parentNode.removeChild(this.sideCover);
		this.sideCover = null;
		that = null;
	}
	
	if (this.conf.transProp !== false) {
		this.sideCover.addEventListener(this.conf.transEv, this._sideCoverOnTrEnd, false);
	}
};

// selection
dhtmlXSideBar.prototype._setItemActive = function(id, callEvent) {
	
	if (this.conf.selected == id) {
		if (this.conf.autohide == true) this.hideSide();
		return;
	}
	
	if (typeof(callEvent) == "undefined") callEvent = false;
	
	if (callEvent == true && this.callEvent("onBeforeSelect", [id, this.conf.selected]) !== true) {
		return;
	}
	
	var lastSelected = null;
	if (this.conf.selected != null) {
		lastSelected = this.conf.selected;
		this._setItemInactive(this.conf.selected);
	}
	
	if (this.t[id] != null) {
		this.conf.selected = id;
		this.t[id].selected = true;
		this.t[id].item.className += " dhxsidebar_item_selected";
		if (this.conf.single_cell != true) {
			this.t[id].cell.cell.style.visibility = "visible";
			this.t[id].cell.cell.style.top = "0px";
			this.t[id].cell.cell.style.zIndex = 1;
		}
	} else {
		this.conf.selected = null;
	}
	
	this._adjustCell(id);
	
	if (callEvent == true) {
		this.callEvent("onSelect", [id, lastSelected]);
	}
	
	if (this.conf.autohide == true) {
		this.hideSide();
	}
	
};

dhtmlXSideBar.prototype._setItemInactive = function(id) {
	
	if (this.t[id] == null) return;
	
	this.t[id].selected = false;
	this.t[id].item.className = this.t[id].item.className.replace(/\s{0,}dhxsidebar_item_selected/gi,"");
	
	if (this.conf.single_cell != true) {
		this.t[id].cell.cell.style.visibility = "hidden";
		this.t[id].cell.cell.style.top = "-5000px";
		this.t[id].cell.cell.style.zIndex = 0;
	}
	
};

dhtmlXSideBar.prototype._isItemActive = function(id) {
	return (this.conf.selected == id);
};

dhtmlXSideBar.prototype._getNextVisible = function(id, getFirst) {
	return this._getNearVisible(id, getFirst, "next");
};

dhtmlXSideBar.prototype._getPrevVisible = function(id, getFirst) {
	return this._getNearVisible(id, getFirst, "previous");
};

dhtmlXSideBar.prototype._getFirstVisible = function() {
	return this._getNearVisible(null, false, "first");
};

dhtmlXSideBar.prototype._getNearVisible = function(id, getFirst, mode) {
	
	if (mode == "first") {
		var node = this.side.firstChild.firstChild; // 1st item
		mode = "next";
	} else {
		if (id == null || this.t[id] == null) return (getFirst?this._getFirstVisible():null);
		var node = this.t[id].item[mode+"Sibling"];
	}
	
	var itemId = null;
	
	while (node != null && itemId == null) {
		var k = node._idd;
		if (k != null && itemId == null && this.t[k].conf.visible) {
			itemId = k;
		} else {
			node = node[mode+"Sibling"];
		}
	}
	
	node = null;
	
	return itemId;
};

dhtmlXSideBar.prototype.goToNextItem = function(callEvent) {
	var id = this._getNextVisible(this.conf.selected, true);
	if (id != null) this._setItemActive(id, callEvent);
};

dhtmlXSideBar.prototype.goToPrevItem = function(callEvent) {
	var id = this._getPrevVisible(this.conf.selected, true);
	if (id != null) this._setItemActive(id, callEvent);
};

dhtmlXSideBar.prototype.getActiveItem = function() {
	return this.conf.selected;
};

// templates
dhtmlXSideBar.prototype.setTemplate = function(template, iconsPath) {
	// conf
	this.conf.tpl_name = (template!=null&&this.templates[template]!=null?template:"details");
	this.conf.tpl_str = this.templates[this.conf.tpl_name];
	// icons path if any
	if (iconsPath != null) this.conf.icons_path = iconsPath;
	// update loaded items
	for (var a in this.t) {
		this.t[a].init.icons_path = this.conf.icons_path;
		this.t[a].item.innerHTML = window.dhx4.template(this.conf.tpl_str, this.t[a].init);
	}
	// side area
	if (this.side != null) {
		this.side.className = "dhxsidebar_side dhxsidebar_tpl_"+this.conf.tpl_name;
	}
	if (this._scrollSide != null) {
		this._scrollSide(0); // fix top position
		this._checkHeight();
	}
};

dhtmlXSideBar.prototype.templates = {
	details:	"<img class='dhxsidebar_item_icon' src='#icons_path##icon#' border='0'><div class='dhxsidebar_item_text'>#text#</div>",
	tiles:		"<img class='dhxsidebar_item_icon' src='#icons_path##icon#' border='0'><div class='dhxsidebar_item_text'>#text#</div>",
	icons:		"<img class='dhxsidebar_item_icon' src='#icons_path##icon#' border='0'>",
	icons_text:	"<div class='dhxsidebar_item_icon'><img class='dhxsidebar_item_icon' src='#icons_path##icon#' border='0'></div><div class='dhxsidebar_item_text'>#text#</div>",
	text:		"<div class='dhxsidebar_item_text'>#text#</div>"
};

dhtmlXSideBar.prototype.tpl_bubble = "<div class='dhxsidebar_bubble'>#value#</div>";

dhtmlXSideBar.prototype.tpl_header = "#text#";
window.dhtmlXSideBarCell = function(id, sidebar) {
	
	dhtmlXCellObject.apply(this, [id, "_sidebar"]);
	
	var that = this;
	this.sidebar = sidebar;
	
	this.conf.skin = this.sidebar.conf.skin;
	
	// sidebar calls
	this.conf.sidebar_funcs = {
		show: "_showItem",
		hide: "_hideItem",
		isVisible: "_isItemVisible",
		setActive: "_setItemActive",
		isActive: "_isItemActive",
		setText: "_setItemText",
		getText: "_getItemText",
		remove: "_removeItem",
		setBubble: "_setItemBubble",
		getBubble: "_getItemBubble",
		clearBubble: "_clearItemBubble"
	};
	
	this._sidebarCall = function(name) {
		return function(){
			var t = [this._idd];
			for (var q=0; q<arguments.length; q++) t.push(arguments[q]);
			return this.sidebar[name].apply(this.sidebar, t);
		};
	};
	
	for (var a in this.conf.sidebar_funcs) {
		if (typeof(this[a]) != "function") this[a] = this._sidebarCall(this.conf.sidebar_funcs[a]);
	};
	
	// init header
	if (this.sidebar.conf.header == true) {
		this._initHeader();
		this.cell.childNodes[this.conf.idx.hdr].onclick = function(e) {
			e = e||event;
			var t = (e.target||e.srcElement);
			if (t.className.match(/dhx_cell_sidebar_hdr_icon/gi) != null) {
				that.sidebar.conf.clear_click = true;
				that.sidebar.showSide();
			}
			t = null;
		};
	}
	
	this.attachEvent("_onCellUnload", function(){
		
		// header
		if (this.conf.idx.hdr != null) {
			this.cell.childNodes[this.conf.idx.hdr].onclick = null;
		}
		
		this.sidebar = null;
		
		// sidebar calls
		for (var a in this.conf.sidebar_funcs) this[a] = this.conf.sidebar_funcs[a] = null;
		this.conf.sidebar_funcs = null;
		
		that = null;
	});
	
	this.attachEvent("_onContentLoaded", function() {
		this.sidebar.callEvent("onContentLoaded", arguments);
	});
	
	this.attachEvent("_onBeforeContentAttach", function(dataType) {
		if (dataType == "tabbar" || dataType == "layout" || dataType == "acc") {
			this._hideBorders();
		}
		if (dataType == "sidebar" && this.conf.skin != "dhx_skyblue") {
			this._hideBorders();
		}
		// clear top border for menu/toolbar/ribbon
		if ((this.conf.skin == "dhx_web" || this.conf.skin == "dhx_terrace") && (dataType == "menu" || dataType == "toolbar" || dataType == "ribbon")) {
			if (this.cell.className.match(/dhx_cell_cont_no_top/gi) == null) {
				this.cell.className += " dhx_cell_cont_no_top";
			}
		}
	});
	
};

dhtmlXSideBarCell.prototype = new dhtmlXCellObject();

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// item text

dhtmlXSideBar.prototype._setItemText = function(id, data) {
	if (this.t[id] != null) {
		for (var a in data) this.t[id].init[a] = data[a];
		this.t[id].init.icons_path = this.conf.icons_path;
		this.t[id].item.innerHTML = window.dhx4.template(this.conf.tpl_str, this.t[id].init);
		// bubble
		if (this.t[id].conf.bubble != null) {
			this.t[id].item.innerHTML += window.dhx4.template(this.tpl_bubble, {value: this.t[id].conf.bubble})
		}
		// header
		if (this.conf.header == true) {
			this.t[id].cell.setHeaderText(window.dhx4.template(this.tpl_header, this.t[id].init));
		}
	}
};

dhtmlXSideBar.prototype._getItemText = function(id) {
	var t = {};
	if (this.t[id] != null) {
		for (var a in this.t[id].init) t[a] = this.t[id].init[a];
	}
	return t;
}

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// remove item or separator

dhtmlXSideBar.prototype._removeItem = function(id, actvId, force) { // force w/o effect
	
	if (this.t[id] == null) return;
	
	if (force != true && this.t[id].conf.remove != true) {
		this.t[id].conf.remove = true;
		this._hideItem(id, actvId);
		return;
	}
	
	if (typeof(actvId) == "undefined") actvId = true;
	
	var next = this._getNextVisible(id);
	var prev = this._getPrevVisible(id);
	
	if (this.t[id].conf.transEv == true) {
		this.t[id].item.removeEventListener(this.conf.transEv, this._doOnTrEnd);
		this.t[id].conf.transEv = false;
	}
	
	if (this.conf.single_cell != true) {
		this.t[id].cell._unload();
		this.t[id].cell = null;
	}
	
	this.t[id].item.ondragstart = null;
	this.t[id].item.parentNode.removeChild(this.t[id].item);
	this.t[id].item = null;
	
	for (var a in this.t[id]) this.t[id][a] = null;
	this.t[id] = null;
	try { delete this.t[id]; } catch(e){};
	
	if (this.conf.selected == id && actvId != false) {
		this.conf.selected = null;
		var actvId = (actvId == true ? (next||prev||this._getFirstVisible()) : actvId);
		if (actvId != null) this._setItemActive(actvId);
	} else if (force != true) {
		this._checkHeight();
	}
	
};

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// show/hide

dhtmlXSideBar.prototype._showItem = function(id, actv) {
	
	if (this.t[id] == null || this.t[id].conf.visible == true || this.t[id].conf.transActv == true) return;
	
	if (this.conf.transProp !== false) {
		
		this.t[id].conf.transActv = true;
		this.t[id].conf.transMode = "show";
		this.t[id].conf.transProp = this.conf.transProp;
		this.t[id].conf.transActvId = (actv?id:null);
		
		if (this.t[id].conf.transEv != true) {
			this.t[id].item.addEventListener(this.conf.transEv, this._doOnTrEnd);
			this.t[id].conf.transEv = true;
		}
		
		this.t[id].conf.visible = true;
		this.t[id].item.style[this.conf.transProp] = this.conf.transValue;
		this.t[id].item.className = "dhxsidebar_item";
		
	} else {
		this.t[id].conf.visible = true;
		this.t[id].item.style.display = "";
		
		if (actv == true) {
			this._setItemActive(id);
		} else {
			this._checkHeight();
		}
	}
};

dhtmlXSideBar.prototype._hideItem = function(id, actvId) {
	
	if (this.t[id] == null || this.t[id].conf.visible != true || this.t[id].conf.transActv == true) return;
	
	var wasSelected = false;
	if (this.conf.selected == id) {
		this.conf.selected = null;
		this.t[id].conf.active = false;
		this.t[id].item.className = "dhxsidebar_item";
		wasSelected = true;
	}
	
	var prev = this._getPrevVisible(id);
	var next = this._getNextVisible(id);
	
	var actvId = (wasSelected && actvId !== false ? (actvId==true?null:actvId)||next||prev : null);
	
	if (this.conf.transProp !== false) {
		
		this.t[id].conf.transActv = true;
		this.t[id].conf.transMode = "hide";
		this.t[id].conf.transProp = this.conf.transProp;
		this.t[id].conf.transActvId = actvId;
		this.t[id].conf.visible = false;
		
		if (this.t[id].conf.transEv != true) {
			this.t[id].item.addEventListener(this.conf.transEv, this._doOnTrEnd);
			this.t[id].conf.transEv = true;
		}
		
		this.t[id].item.style[this.conf.transProp] = this.conf.transValue;
		this.t[id].item.className = "dhxsidebar_item dhxsidebar_item_hidden";
		
		
	} else {
		
		this.t[id].item.style.display = "none";
		this.t[id].conf.visible = false;
		
		// hide cell
		if (this.conf.single_cell != true) {
			this.t[id].cell.cell.style.visibility = "hidden";
			this.t[id].cell.cell.style.top = "-5000px";
		}
		
		if (actvId != null) this._setItemActive(actvId);
		this._checkHeight();
		
		if (this.t[id].conf.remove == true) this._removeItem(id);
	}
	
};

dhtmlXSideBar.prototype._isItemVisible = function(id) {
	return (this.t[id].conf.visible == true);
};

// bubbles
dhtmlXSideBar.prototype._setItemBubble = function(id, value) {
	if (this.t[id] == null) return;
	this.t[id].item.innerHTML = window.dhx4.template(this.conf.tpl_str, this.t[id].init)+window.dhx4.template(this.tpl_bubble, {value: String(value)});
	this.t[id].conf.bubble = value;
};
dhtmlXSideBar.prototype._getItemBubble = function(id) {
	if (this.t[id] == null) return null;
	return (typeof(this.t[id].conf.bubble)=="undefuned"?null:this.t[id].conf.bubble);
};

dhtmlXSideBar.prototype._clearItemBubble = function(id) {
	if (this.t[id] == null) return;
	this.t[id].item.innerHTML = window.dhx4.template(this.conf.tpl_str, this.t[id].init);
	this.t[id].conf.bubble = null;
};
// attach sidebar to cell
dhtmlXCellObject.prototype.attachSidebar = function(conf) {
	
	this.callEvent("_onBeforeContentAttach",["sidebar"]);
	
	if (conf == null) conf = {};
	
	var obj = document.createElement("DIV");
	obj.style.width = "100%";
	obj.style.height = "100%";
	obj.style.position = "relative";
	obj.style.overflow = "hidden";
	
	// all but window borderless
	if (typeof(window.dhtmlXWindowsCell) == "function" && this instanceof window.dhtmlXWindowsCell) {
		
	} else {
		// acc, layout, tabbar, sidebar
		if (this.conf.skin == "dhx_skyblue") obj._ofs = {t:-1,r:-1,b:-1,l:-1};
		if (this.conf.skin == "dhx_web") {
			if (typeof(window.dhtmlXSideBarCell) == "function" && this instanceof window.dhtmlXSideBarCell) obj._ofs = {l: 8};
			if (typeof(window.dhtmlXLayoutCell) == "function" && this instanceof window.dhtmlXLayoutCell) obj._ofs = {t: 2};
			if (typeof(window.dhtmlXTabBarCell) == "function" && this instanceof window.dhtmlXTabBarCell) obj._ofs = {t: 8};
			if (typeof(window.dhtmlXAccordionCell) == "function" && this instanceof window.dhtmlXAccordionCell) obj._ofs = {t: 2};
		}
		if (this.conf.skin == "dhx_terrace") {
			if (typeof(window.dhtmlXSideBarCell) == "function" && this instanceof window.dhtmlXSideBarCell) obj._ofs = {l:-1};
			if (typeof(window.dhtmlXLayoutCell) == "function" && this instanceof window.dhtmlXLayoutCell) obj._ofs = {t:-1,r:-1,b:-1,l:-1};
			if (typeof(window.dhtmlXTabBarCell) == "function" && this instanceof window.dhtmlXTabBarCell) obj._ofs = {t:-1};
			if (typeof(window.dhtmlXAccordionCell) == "function" && this instanceof window.dhtmlXAccordionCell) obj._ofs = {t:-1,r:-1,b:-1,l:-1};
		}
		if (this.conf.skin == "material") {
			if (typeof(window.dhtmlXAccordionCell) == "function" && this instanceof window.dhtmlXAccordionCell) obj._ofs = {t:-1,r:-1,b:-1,l:-1};
			if (typeof(window.dhtmlXTabBarCell) == "function" && this instanceof window.dhtmlXTabBarCell) obj._ofs = {t:-1,r:-1,b:-1,l:-1};
			if (typeof(window.dhtmlXSideBarCell) == "function" && this instanceof window.dhtmlXSideBarCell) obj._ofs = {l:-1};
		}
	}
	
	this._attachObject(obj);
	
	conf.skin = this.conf.skin;
	conf.parent = obj;
	
	this.dataType = "sidebar";
	this.dataObj = new dhtmlXSideBar(conf);
	
	conf.parent = obj = null;
	conf = null;
	
	this.callEvent("_onContentAttach",[]);
	
	return this.dataObj;
};
/* header */
dhtmlXSideBarCell.prototype._initHeader = function() {
	
	var t = document.createElement("DIV");
	t.className = "dhx_cell_sidebar_hdr";
	t.innerHTML = (this.sidebar.conf.autohide==true?"<div class='dhx_cell_sidebar_hdr_icon'></div>":"")+
			"<div class='dhx_cell_sidebar_hdr_text"+(this.sidebar.conf.autohide==true?" dhx_cell_sidebar_hdr_text_icon":"")+"'></div>";
	
	this.cell.insertBefore(t, this.cell.childNodes[this.conf.idx.cont]);
	t = null;
	
	// include into content top offset calculation
	this.conf.ofs_nodes.t._getHdrHeight = "func";
	
	// show/hide
	this.conf.hdr = {visible: true};
	
	// include into index
	this.conf.idx_data.hdr = "dhx_cell_sidebar_hdr";
	this._updateIdx();
	
};

dhtmlXSideBarCell.prototype._getHdrHeight = function() {
	return this.cell.childNodes[this.conf.idx.hdr].offsetHeight;
};

// visibility
dhtmlXSideBarCell.prototype.showHeader = function() {
	if (this.conf.hdr.visible == true) return;
	this.conf.hdr.visible = true;
	this.cell.childNodes[this.conf.idx.hdr].className = "dhx_cell_sidebar_hdr";
	this._adjustCont(this._idd);
};

dhtmlXSideBarCell.prototype.hideHeader = function() {
	if (this.conf.hdr.visible != true) return;
	this.conf.hdr.visible = false;
	this.cell.childNodes[this.conf.idx.hdr].className = "dhx_cell_sidebar_hdr dhx_cell_sidebar_hdr_hidden";
	this._adjustCont(this._idd);
};

dhtmlXSideBarCell.prototype.isHeaderVisible = function() {
	return (this.conf.hdr.visible==true);
};

// text
dhtmlXSideBarCell.prototype.setHeaderText = function(text) {
	this.conf.text = text;
	var t = this.cell.childNodes[this.conf.idx.hdr];
	t.childNodes[(t.firstChild.className=="dhx_cell_sidebar_hdr_icon"?1:0)].innerHTML = "<span>"+text+"</span>";
	t = null;
};

dhtmlXSideBarCell.prototype.getHeaderText = function() {
	return this.conf.text;
};


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXCarousel(conf, effect, skin) {
	
	if (typeof(conf) == "string" || (typeof(conf) == "object" && typeof(conf.tagName) != "undefined")) {
		conf = {
			parent: (typeof(conf)=="string"?document.getElementById(conf):conf),
			effect: effect,
			skin: skin,
			delete_conf: true
		};
	} else {
		// object-api
		if (typeof(conf) == "undefined" || conf == null) {
			conf = {};
		}
	}
	
	this.conf = {
		skin: (conf.skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxcarousel")||"material"),
		css: "dhxcarousel", // css prefix for topcell mtb
		// misc
		items_count: 0,
		selected: -1, // selected index
		// dimensions
		item_width: Number(conf.item_width)||"auto",
		item_height: Number(conf.item_height)||"auto",
		ofs_item: Number(conf.offset_item)||1,
		ofs_left: Number(conf.offset_left)||0,
		ofs_top: Number(conf.offset_top)||0,
		// controls
		buttons: (typeof(conf.buttons)=="undefined"?true:window.dhx4.s2b(conf.buttons)), // show left/right arrows
		drops: false, // show rectangle for each cell
		// keys and touch events
		keys: (typeof(conf.keys)=="undefined"?true:window.dhx4.s2b(conf.keys)), // enable crtl+left/right
		key_data: {left: 37, right: 39},
		touch_scroll: (typeof(conf.touch_scroll)!="undefined"?window.dhx4.s2b(conf.touch_scroll):true), // scroll cells with touch
		// arrows
		arw: ["&#9668;", "&#9658;"]
	};
	
	this.conf.autowidth = (this.conf.item_width=="auto");
	this.conf.autoheight = (this.conf.item_height=="auto");
	
	// check for transition support
	var k = window.dhx4.transDetect();
	this.conf.transProp = k.transProp;
	this.conf.transEv = k.transEv;
	
	// load effect
	this.conf.anim_type = (conf.effect||"slide");
	if (this.ef[this.conf.anim_type] == true) {
		var t = this["_"+this.conf.anim_type+"_init"]();
		if (t === false) {
			this.conf.anim_type = "slide";
			t = this["_"+this.conf.anim_type+"_init"]();
		}
		if (typeof(t) == "object") {
			for (var a in t) {
				if (typeof(this.conf[a]) == "undefined") this.conf[a] = t[a];
			};
		}
	}
	this.conf.anim_f = this["_"+this.conf.anim_type+"_f"]();
	
	
	var that = this;
	
	window.dhtmlXCellTop.apply(this, [conf.parent, conf.offsets]);
	
	this.area = document.createElement("DIV");
	this.area.className = "dhxcarousel_area";
	this.cont.appendChild(this.area);
	
	if (typeof(window.addEventListener) == "function" && that.conf.touch_scroll == true) {
		
		this._doOnTouchStart = function(e) {
			
			if (window.dhx4.dnd._mTouch(e) == true) return;
			
			if (that.conf.animating == true) return;
			
			if (e.preventDefault) e.preventDefault();
			
			that.area.className += " dhxcarousel_area_dnd";
			
			that.conf.touch_conf = {
				t: new Date().getTime(),
				dx: null,
				dy: null
			};
			
			if (e.type.match(/^touch/) != null) {
				that.conf.touch_conf.id = e.touches[0].identifier;
				that.conf.touch_conf.x = e.touches[0].clientX;
				that.conf.touch_conf.y = e.touches[0].clientY;
			} else {
				that.area.style.touchAction = that.area.style.msTouchAction = "none";
				that.conf.touch_conf.x = e.clientX;
				that.conf.touch_conf.y = e.clientY;
			}
			
			window.addEventListener(window.dhx4.dnd.evs.move, that._doOnTouchMove, false);
			window.addEventListener(window.dhx4.dnd.evs.end, that._doOnTouchEnd, false);
			
		}
		
		this._doOnTouchMove = function(e) {
			
		}
		
		this._doOnTouchEnd = function(e) {
			
			if (e.type.match(/^touch/) != null) {
				var ofsX = 0;
				for (var q=0; q<e.changedTouches.length; q++) {
					if (e.changedTouches[q].identifier == that.conf.touch_conf.id) {
						ofsX = that.conf.touch_conf.x-e.changedTouches[q].clientX;
					}
				}
			} else {
				var ofsX = that.conf.touch_conf.x-e.clientX;
			}
			
			window.removeEventListener(window.dhx4.dnd.evs.move, that._doOnTouchMove, false);
			window.removeEventListener(window.dhx4.dnd.evs.end, that._doOnTouchEnd, false);
			
			that.area.className = that.area.className.replace(/\s*dhxcarousel_area_dnd$/,"");
			
			if (ofsX == 0 || new Date().getTime() - that.conf.touch_conf.t > 400) return;
			
			var dir = ofsX/Math.abs(ofsX);
			that._animateStart(dir);
			
		}
		
		this.area.addEventListener(window.dhx4.dnd.evs.start, this._doOnTouchStart, false);
		
	}
	
	
	this.cdata = {}; // id -> data
	this.ind = {};   // index -> id
	
	this.addCell = function(id, index) {
		
		this.conf.items_count++;
		
		if (this.conf.selected == -1) this.conf.selected = 0; // force select 1st cell
		
		this.setSizes();
		this._checkControls();
		
		// detect index
		if (typeof(index) == "undefined" || index == null) {
			index = this.conf.items_count-1;
		} else if (index < 0) {
			index = 0;
		} else if (index > this.conf.items_count-1) {
			index = this.conf.items_count-1;
		}
		
		// middle-ins, move items after index to right and change position
		for (var a in this.cdata) {
			if (this.cdata[a].index >= index) {
				this.cdata[a].index++;
				this.ind[this.cdata[a].index] = a;
				this._adjustCell(a);
			}
		}
		
		// insert new
		if (id == null) id = String(window.dhx4.newId());
		while (this.cdata[id] != null) id = String(window.dhx4.newId());
		
		var cell = new dhtmlXCarouselCell(id, this);
		if (this.area.childNodes[index] != null) {
			this.area.insertBefore(cell.cell, this.area.childNodes[index]);
		} else {
			this.area.appendChild(cell.cell);
		}
		
		// add cell
		this.cdata[id] = {index: index, cell: cell};
		this.ind[index] = id;
		
		this._adjustCell(id);
		
		this._addBar();
		this._setBarIndex(this.conf.selected);
		
		cell = null;
		
		this[this.conf.anim_f.cell_added](id);
		
		return id;
		
	}
	
	this._removeCell = function(id) {
		
		var index = this.cdata[id].index;
		
		this.cdata[id].cell._unload();
		this.cdata[id].index = this.cdata[id].cell = null;
		this.cdata[id] = null;
		
		delete this.cdata[id];
		delete this.ind[index];
		
		this.conf.items_count--;
		
		if (this.conf.unloading == true) return;
		
		// recalc index for existing cells
		this.ind = {};
		var m = 0;
		for (var a in this.cdata) {
			if (this.cdata[a].index > index) this.cdata[a].index--;
			this.ind[this.cdata[a].index] = a;
		}
		
		// update selected index
		var upd = false; // update cell if index changed automaticaly
		if (this.conf.selected > index) {
			this.conf.selected--;
		} else if (this.conf.selected == index) {
			this.conf.selected = Math.min(this.conf.selected, this.conf.items_count-1);
			upd = true;
		} else {
			// do nothing
		}
		
		this._removeBar(false);
		this._setBarIndex(this.conf.selected);
		
		if (upd == true) {
			if (this.conf.selected >= 0) {
				this[this.conf.anim_f.update_selected](this.ind[this.conf.selected]); // cell became active, maybe some updates needed
			}
		}
		
		this.setSizes();
		this._checkControls();
	};
	
	this.setSizes = function() {
		
		// celltop
		this._adjustCont();
		
		var sizes = {};
		
		// if parent was resizes
		this.area.style.height = this.cont.offsetHeight-this.controls.offsetHeight+"px";
		
		this.conf.width =  (this.conf.autowidth?this.cont.offsetWidth-this.conf.ofs_left*2:this.conf.item_width);
		this.conf.height = (this.conf.autoheight?this.area.offsetHeight-this.conf.ofs_top*2:this.conf.item_height);
		this.conf.top = Math.max(0, (this.conf.autoheight?this.conf.ofs_top:Math.floor((this.area.offsetHeight-this.conf.height)/2)));
		
		this.area.style.width = this[this.conf.anim_f.detect_aw]()*(this.conf.width+this.conf.ofs_item)+this.conf.ofs_item+"px";
		this.area.style.left = Math.round(this.cont.offsetWidth/2-this.conf.width/2-this.conf.ofs_item)+"px";
		
		// items
		for (var a in this.cdata) {
			var s = {};
			for (var b in this.cdata[a].cell.conf.size) s[b] = this.cdata[a].cell.conf.size[b];
			//
			if (this.conf.autowidth == true) {
				s.w = this.conf.width;
				s.x = this[this.conf.anim_f.detect_x](a);
			}
			if (this.conf.autoheight == true) {
				s.h = this.conf.height;
			}
			//
			sizes[a] = s;
		}
		
		this.area.style.left = Math.round(this.cont.offsetWidth/2-this.conf.width/2-this.conf.ofs_item)-(this.conf.width+this.conf.ofs_item)*this.conf.selected+"px";
		
		// this.controls.style.left = Math.round(this.cont.offsetWidth/2-this.controls.offsetWidth/2)+"px";
		this._adjustControls();
		
		if (this.conf.autoheight != true) {
			this.conf.top = Math.max(0, Math.floor(this.area.offsetHeight-this.conf.height)/2);
			for (var a in sizes) sizes[a].y = this.conf.top;
		}
		
		// resize cells
		for (var a in sizes) {
			this.cdata[a].cell._setSize(sizes[a].x, sizes[a].y, sizes[a].w, sizes[a].h);
		}
		
		this.callEvent("_onSetSizes", []); // if mtb attached
		
	}
	
	this._adjustCell = function(id) {
		this.cdata[id].cell._setSize(this[this.conf.anim_f.detect_x](id), this.conf.top, this.conf.width, this.conf.height);
	}
	
	this._animateStart = function(dir, ef) {
		
		if ((this.conf.selected <= 0 && dir < 0) || (this.conf.selected >= this.conf.items_count-1 && dir > 0)) return;
		
		if (this.conf.animating == true) return;
		this.conf.animating = true;
		
		this[this.conf.anim_f.prepare](dir, ef);
		
	}
	
	this._animateTransEnd = function(e) {
		that[that.conf.anim_f.end](e||event, this);
	}
	
	this._animateEnd = function(dir) {
		
		this.conf.selected = this.conf.selected+dir;
		this._checkControls();
		this._setBarIndex(this.conf.selected);
		this.callEvent("onSelect", [this.ind[this.conf.selected]]);
		
		this.conf.animating = false;
		
	}
	
	this._initControls();
	
	this.setCellSize = function(w, h) {
		this.conf.item_width = (w==null?"auto":w);
		this.conf.item_height = (h==null?"auto":h);
		this.setSizes();
	}
	
	this.setOffset = function(left, top, item) {
		if (left != null) this.conf.ofs_left = left;
		if (top != null) this.conf.ofs_top = top;
		if (item != null) this.conf.ofs_item = item;
		this.setSizes();
	}
	
	this.enableHotKeys = function(mode) {
		this.conf.keys = window.dhx4.s2b(mode);
	}
	
	this.goFirst = function() {
		if (this.conf.selected == 0) return;
		this._animateStart(-this.conf.selected);
	}
	
	this.goLast = function() {
		if (this.conf.selected == this.conf.items_count-1) return;
		this._animateStart(this.conf.items_count-1-this.conf.selected);
	}
	
	this.goNext = function() {
		this._animateStart(1);
	}
	
	this.goPrev = function() {
		this._animateStart(-1);
	}
	
	this.getActiveIndex = function() {
		return this.conf.selected;
	}
	
	this.getActiveId = function() {
		return this.ind[this.conf.selected];
	}
	
	this.getActiveCell = function() {
		var id = this.getActiveId();
		if (id != null) return this.cdata[id].cell;
		return null;
	}
	
	this.unload = function() {
		
		this.conf.unloading = true;
		
		if (typeof(window.addEventListener) == "function") {
			window.removeEventListener("keydown", this._doOnWinKeyDown, false);
			if (this._doOnTouchStart != null) this.area.removeEventListener(window.dhx4.dnd.evs.start, this._doOnTouchStart, false);
		} else {
			document.body.detachEvent("onkeydown", this._doOnWinKeyDown);
		}
		
		// cells
		for (var a in this.cdata) this._removeCell(a);
		this.cdata[a] = null;
		
		// area
		this.area.parentNode.removeChild(this.area);
		this.area = null;
		
		// controls
		this._unloadControls();
		
		// celltop
		this._unloadTop();
		
		// events
		window.dhx4._eventable(this, "clear");
		
		// the rest
		for (var a in this) this[a] = null;
		
		that = null;
		
	}
	
	// events
	window.dhx4._eventable(this);
	this._callMainEvent = function(name, args) {
		this.callEvent(name, args);
	};
	this.conf.ev_coverclick = this.attachEvent("_cellCoverClick", function(index){
		var d = index-this.conf.selected;
		if (Math.abs(d) == 1) this._animateStart(d);
	});
	
	
	// keys
	this._doOnWinKeyDown = function(e) {
		e = e||event;
		if (that.conf.keys == true) {
			if (e.ctrlKey == true && e.shiftKey != true && e.altKey != true) {
				var code = e.keyCode;
				var k = that.conf.key_data;
				if (code == k.left || code == k.right) {
					if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
					that._animateStart(code==k.left?-1:1);
				}
			}
		}
	}
	
	if (typeof(window.addEventListener) == "function") {
		window.addEventListener("keydown", this._doOnWinKeyDown, false);
	} else {
		document.body.attachEvent("onkeydown", this._doOnWinKeyDown);
	}
	
	if (conf.delete_conf == true) {
		for (var a in conf) conf[a] = null;
		conf = null;
	}
	
	return this;
};

// top-level extensions
dhtmlXCarousel.prototype = new dhtmlXCellTop();

// enabled effects
dhtmlXCarousel.prototype.ef = {};

// cell access
dhtmlXCarousel.prototype.cells = function(id) {
	return this.cdata[id].cell;
};

// iterator
dhtmlXCarousel.prototype.forEachCell = function(handler) {
	for (var a in this.cdata) {
		if (typeof(handler) == "function") {
			handler.apply(window, [this.cdata[a].cell]);
		} else if (typeof(handler) == "string" && typeof(window[handler]) == "function") {
			window[handler].apply(window, [this.cdata[a].cell]);
		}
	}
};

dhtmlXCarousel.prototype._initControls = function() {
	
	var that = this;
	
	var a = (this.conf.skin=="material"?["",""]:this.conf.arw);
	
	this.controls = document.createElement("DIV");
	this.controls.className = "dhx_carousel_controls";
	this.controls.innerHTML = "<div class='dhx_carousel_bars'></div>"+
					"<div class='dhx_carousel_btn dhx_carousel_btn_prev'>"+a[0]+"</div>"+
					"<div class='dhx_carousel_btn dhx_carousel_btn_next'>"+a[1]+"</div>";
	
	this.cont.appendChild(this.controls);
	
	// events
	this._doOnControlClick = function(e) {
		if (that.conf.clear_click == true) {
			that.conf.clear_click = false;
			return;
		}
		e = e||event;
		if (window.dhx4.dnd.evs.start != null && e.type != "click" && that.conf.clear_click != true) { // force animation on touch devices by touch
			if (window.dhx4.dnd._mTouch(e) == true) return; // prevent pointer on desktop in IE
			that.conf.clear_click = true;
		}
		var t = e.target||e.srcElement;
		var anim = null;
		if (t.className != null) {
			if (t.className.match(/btn_prev/) != null) {
				anim = -1;
			} else if (t.className.match(/btn_next/) != null) {
				anim = 1;
			} else if (t.className.match(/dhx_carousel_onebar/) != null && t.className.match(/dhx_carousel_baractv/) == null) {
				for (var q=0; q<t.parentNode.childNodes.length; q++) {
					if (t.parentNode.childNodes[q] == t) anim = q-that.conf.selected;
				}
			}
		}
		if (anim != null) that._animateStart(anim);
		t = null;
	}
	if (typeof(window.addEventListener) == "function") {
		this.controls.addEventListener("click", this._doOnControlClick, false);
		if (window.dhx4.dnd.evs.start != null) this.controls.addEventListener(window.dhx4.dnd.evs.start, this._doOnControlClick, false);
	} else {
		this.controls.attachEvent("onclick", this._doOnControlClick);
		if (window.dhx4.isIE6 || window.dhx4.isIE7 || window.dhx4.isIE8) {
			this.controls.onselectstart = function(e) {
				e = e||event;
				if (e.preventDefault) e.preventDefault();
				e.returnValue = false;
				return false;
			}
		}
	}
	
	// api
	this.showControls = function() {
		this.controls.style.display = "";
		this.setSizes();
	}
	this.hideControls = function() {
		this.controls.style.display = "none";
		this.setSizes();
	}
	
	this._checkControls = function() {
		this.controls.childNodes[1].className = "dhx_carousel_btn dhx_carousel_btn_prev"+(this.conf.selected <= 0 ? "_dis":"");
		this.controls.childNodes[2].className = "dhx_carousel_btn dhx_carousel_btn_next"+(this.conf.selected >= this.conf.items_count-1 || this.conf.items_count == 0 ?"_dis":"");
	}
	
	this._adjustControls = function() {
		this.controls.firstChild.style.left = Math.round(this.cont.offsetWidth/2-this.controls.firstChild.offsetWidth/2)+"px";
	}
	
	this._addBar = function() {
		var t = document.createElement("DIV");
		t.className = "dhx_carousel_onebar";
		t.innerHTML = "<div class='dhx_carousel_barcore'>&nbsp;</div>";
		this.controls.firstChild.appendChild(t);
		t = null;
		this._adjustControls();
	}
	
	this._removeBar = function(adjust) {
		var t = this.controls.firstChild.lastChild;
		if (t != null) {
			t.parentNode.removeChild(t);
			t = null;
			if (adjust !== false) this._adjustControls();
		}
	}
	
	this._setBarIndex = function(i) {
		for (var q=0; q<this.controls.firstChild.childNodes.length; q++) {
			this.controls.firstChild.childNodes[q].className = "dhx_carousel_onebar"+(q==i?" dhx_carousel_baractv":"");
		}
	}
	
	this._unloadControls = function() {
		
		if (typeof(window.addEventListener) == "function") {
			this.controls.removeEventListener("click", this._doOnControlClick, false);
			if (window.dhx4.dnd.evs.start != null) this.controls.removeEventListener(window.dhx4.dnd.evs.start, this._doOnControlClick, false);
		} else {
			this.controls.detachEvent("onclick", this._doOnControlClick);
			if (window.dhx4.isIE6 || window.dhx4.isIE7 || window.dhx4.isIE8) this.controls.onselectstart = null;
		}
		
		// bars
		while (this.controls.firstChild.childNodes.length > 0) {
			this._removeBar(false);
		}
		
		// self
		this.cont.removeChild(this.controls);
		this.controls = null;
		
		that = null;
	}
	
	if (this.conf.buttons != true) this.hideControls();
	
	this._checkControls();
	
};
window.dhtmlXCarouselCell = function(id, carousel) {
	
	dhtmlXCellObject.apply(this, [id, "_carousel"]);
	
	var that = this;
	this.carousel = carousel;
	this.conf.skin = this.carousel.conf.skin;
	
	this.attachEvent("_onCellUnload", function(){
		this.carousel = null;
		that = null;
	});
	
	// onContentLoaded
	this.attachEvent("_onContentLoaded", function() {
		this.carousel._callMainEvent("onContentLoaded", [this._idd]);
	});
	
	// cell cover extended
	this._showCover = function() {
		if (this.conf.cover == true) return;
		this._showCellCover();
		// add click event
		var t = this.cell.childNodes[this.conf.idx.cover];
		t.onclick = function() {
			that.carousel._callMainEvent("_cellCoverClick", [that._idd]);
		};
		t = null;
	};
	this._hideCover = function() {
		if (this.conf.cover != true) return;
		this.cell.childNodes[this.conf.idx.cover].onclick = null;
		this._hideCellCover();
	};
	
	return this;
	
};

dhtmlXCarouselCell.prototype = new dhtmlXCellObject();

dhtmlXCarouselCell.prototype.getId = function() {
	return this._idd;
};

dhtmlXCarouselCell.prototype.getIndex = function() {
	return this.carousel.cdata[this._idd].index;
};

dhtmlXCarouselCell.prototype.setActive = function() {
	var ofs = this.getIndex() - this.carousel.conf.selected;
	if (ofs != 0) this.carousel._animateStart(ofs);
};

dhtmlXCarouselCell.prototype.remove = function() {
	this.carousel._removeCell(this._idd);
};
dhtmlXCellObject.prototype.attachCarousel = function(conf) {
	
	this.callEvent("_onBeforeContentAttach",["carousel"]);
	
	var obj = document.createElement("DIV");
	obj.style.width = "100%";
	obj.style.height = "100%";
	obj.style.position = "relative";
	obj.style.overflow = "hidden";
	this._attachObject(obj);
	
	if (typeof(window.dhtmlXSideBarCell) == "function" && this instanceof window.dhtmlXSideBarCell) {
		if (this.conf.skin == "dhx_terrace") {
			obj._ofs = {t:-1,r:-1,b:-1,l:-1};
		}
	}
	
	if (typeof(conf) == "undefined" || conf == null) conf = {};
	if (typeof(conf.skin) == "undefined") conf.skin = this.conf.skin;
	conf.parent = obj;
	
	this.dataType = "carousel";
	this.dataObj = new dhtmlXCarousel(conf);
	
	conf.parent = null;
	obj = conf = null;
	
	this.callEvent("_onContentAttach",[]);
	
	return this.dataObj;
	
};

// slide effect extension
// allow effect be used for any browser

dhtmlXCarousel.prototype.ef.slide = true;

dhtmlXCarousel.prototype.ef.slide_conf = {
	anim_step: 25,
	anim_timeout: 10,
	anim_slide: "left 0.3s" // for modern
};

dhtmlXCarousel.prototype.ef.slide_f = {
	prepare: "_slide_prepare",
	start: "_slide_start",
	end: "_slide_end",
	update_selected: "_slide_update_selected",
	detect_x: "_slide_detect_x",
	detect_aw: "_slide_detect_area_width",
	cell_added: "_slide_cell_added"
};

dhtmlXCarousel.prototype._slide_init = function() {
	return this.ef.slide_conf;
};

dhtmlXCarousel.prototype._slide_f = function() {
	return this.ef.slide_f;
};

dhtmlXCarousel.prototype._slide_prepare = function(dir, ef) {
	
	var step = this.conf.anim_step;
	var maxX = this.conf.width+this.conf.ofs_item;
	
	if (ef == false) step = maxX+1;
	
	this.area._init = parseInt(this.area.style.left);
	
	var nextId = this.ind[this.conf.selected+dir];
	this._slide_update_selected(nextId);
	
	if (this.conf.transProp !== false && ef != false) {
		if (this.conf.transEvInit != true) {
			this.area.addEventListener(this.conf.transEv, this._animateTransEnd, false);
			this.conf.transEvInit = true;
		}
		this.conf.current_dir = dir;
		this.area.style[this.conf.transProp] = this.conf.anim_slide;
		this.area.style.left = this.area._init+maxX*(-dir)+"px";
	} else {
		this._slide_start(step, 0, maxX, dir);
	}
};

dhtmlXCarousel.prototype._slide_start = function(step, curX, maxX, dir) {
	
	var stop = false;
	curX += step;
	
	if (curX >= maxX) {
		curX = maxX;
		stop = true;
	}
	
	this.area.style.left = this.area._init+curX*(-dir)+"px";
	if (stop != true) {
		var t = this;
		window.setTimeout(function(){t._slide_start(step, curX, maxX, dir); t = null;}, this.conf.anim_timeout);
	} else {
		this.cdata[this.ind[this.conf.selected]].cell._showCover();
		this._animateEnd(dir);
	}
};

dhtmlXCarousel.prototype._slide_end = function(e, obj) {
	if (e.type == this.conf.transEv && obj == this.area) {
		this.area.style[this.conf.transProp] = "";
		if (this.conf.transEvInit == true) {
			this.area.removeEventListener(this.conf.transEv, this._animateTransEnd, false);
			this.conf.transEvInit = false;
		}
		this.cdata[this.ind[this.conf.selected]].cell._showCover();
		this._animateEnd(this.conf.current_dir);
	}
};

dhtmlXCarousel.prototype._slide_update_selected = function(id) {
	this.cdata[id].cell._hideCover();
};

dhtmlXCarousel.prototype._slide_detect_x = function(id) {
	var i = this.cdata[id].index;
	var x = i*(this.conf.width+this.conf.ofs_item)+this.conf.ofs_item;
	return x;
};

dhtmlXCarousel.prototype._slide_cell_added = function(id) {
	if (this.conf.selected != this.cdata[id].index) {
		this.cdata[id].cell._showCover();
	}
	// item was inserted before selected, so selected was moved to right, move it back
	if (this.cdata[id].index <= this.conf.selected && this.conf.items_count > 1) {
		this._animateStart(1, false);
	}
};

dhtmlXCarousel.prototype._slide_detect_area_width = function() {
	return this.conf.items_count;
};
// flip effect extension
// works only for modern

/*

	----[L]----[L]----[S]----[R]----[R]----
	
	L   ietm on left    angle  -87
	S   selected ite    angle  0
	R   ietm on right   angle  87

*/


dhtmlXCarousel.prototype.ef.flip = true;

dhtmlXCarousel.prototype.ef.flip_conf = {
	anim_flip: "transform 0.3s ease-out",
	anim_flip_ang: -87,
	anim_flip_trstyle: "transform"
};

dhtmlXCarousel.prototype.ef.flip_f = {
	prepare: "_flip_prepare",
	start: "_flip_start",
	end: "_flip_end",
	update_selected: "_flip_update_selected",
	detect_x: "_flip_detect_x",
	detect_aw: "_flip_detect_area_width",
	cell_added: "_flip_cell_added"
};

dhtmlXCarousel.prototype._flip_init = function() {
	var t = (this.conf.transProp==false?false:this.ef.flip_conf);
	if (t !== false && window.dhx4.isKHTML == true && t.anim_flip.match("webkit") == null) { // Safari 5.1.7
		t.anim_flip = t.anim_flip.replace(/transform/,"-webkit-transform");
		t.anim_flip_trstyle = "webkitTransform";
	}
	return t;
};

dhtmlXCarousel.prototype._flip_f = function() {
	return this.ef.flip_f;
};

dhtmlXCarousel.prototype._flip_prepare = function(dir) {
	this.conf.flip_data = {
		fromIndex: this.conf.selected,
		toIndex: this.conf.selected+dir,
		mode: 0,
		dir: dir
	};
	this._flip_start();
};

dhtmlXCarousel.prototype._flip_start = function() {
	
	var cell = this.cdata[this.ind[this.conf.flip_data.mode==0?this.conf.flip_data.fromIndex:this.conf.flip_data.toIndex]].cell;
	
	if (this.area.className.match(/dhxcarousel_area_flip/) == null) {
		this.area.className += " dhxcarousel_area_flip";
	}
	
	if (cell.conf.tr_ev != true) {
		cell.cell.addEventListener(this.conf.transEv, this._animateTransEnd, false);
		cell.conf.tr_ev = true;
	}
	
	if (this.conf.flip_data.mode == 0) {
		cell.cell.style[this.conf.anim_flip_trstyle] = "rotateY("+String(this.conf.flip_data.dir>0?this.conf.anim_flip_ang:-this.conf.anim_flip_ang)+"deg)";
	} else {
		cell.cell.style.visibility = "visible";
		cell.cell.style[this.conf.anim_flip_trstyle] = "rotateY(0deg)";
	}
	
	cell.cell.style[this.conf.transProp] = this.conf.anim_flip;
	cell = null;
};

dhtmlXCarousel.prototype._flip_end = function(e, obj) {
	
	if (e.type == this.conf.transEv) {
		
		var cell = this.cdata[this.ind[this.conf.flip_data.mode==0?this.conf.flip_data.fromIndex:this.conf.flip_data.toIndex]].cell;
		
		if (obj == cell.cell) {
			
			cell.cell.removeEventListener(this.conf.transEv, this._animateTransEnd, false);
			cell.conf.tr_ev = false;
			
			if (this.conf.flip_data.mode == 0) {
				
				// step 2
				cell.cell.style[this.conf.transProp] = "";
				cell.cell.style.visibility = "hidden";
				this.conf.flip_data.mode = 1;
				this._flip_start();
				
			} else {
				
				var dir = this.conf.flip_data.dir;
				
				// check if animation jumped via several items,
				// index change can be required, see comment on top
				var m0 = Math.min(this.conf.flip_data.fromIndex, this.conf.flip_data.toIndex)+1;
				var m1 = Math.max(this.conf.flip_data.fromIndex, this.conf.flip_data.toIndex)-1;
				
				for (var q=m0; q<=m1; q++) {
					this.cdata[this.ind[q]].cell.cell.style[this.conf.anim_flip_trstyle] = "rotateY("+String(this.conf.anim_flip_ang*dir/Math.abs(dir))+"deg)";
				}
				
				if (this.area.className.match(/dhxcarousel_area_flip/) != null) {
					this.area.className = String(this.area.className).replace(/\s{0,}dhxcarousel_area_flip/gi, "");
				}
				
				// finish animation
				this.conf.flip_data = null;
				cell.cell.style[this.conf.transProp] = "";
				this._animateEnd(dir);
			}
		}
		cell = null;
	}
};

dhtmlXCarousel.prototype._flip_update_selected = function(id) {
	
};

dhtmlXCarousel.prototype._flip_detect_x = function(id) {
	var i = 0;
	var x = i*(this.conf.width+this.conf.ofs_item)+this.conf.ofs_item;
	return x;
};

dhtmlXCarousel.prototype._flip_cell_added = function(id) {
	if (this.conf.selected != this.cdata[id].index) {
		this.cdata[id].cell.cell.style[this.conf.anim_flip_trstyle] = "rotateY(" + String(this.cdata[id].index < this.conf.selected ? this.conf.anim_flip_ang : -this.conf.anim_flip_ang) + "deg)";
		this.cdata[id].cell.cell.style.visibility = "hidden";
	} else {
		this.cdata[id].cell.cell.style[this.conf.anim_flip_trstyle] = "rotateY(0deg)";
	}
};

dhtmlXCarousel.prototype._flip_detect_area_width = function() {
	return 1;
};
// cards effect extension

dhtmlXCarousel.prototype.ef.cards = true;

dhtmlXCarousel.prototype.ef.cards_conf = {
	anim_cards: "left 0.3s"
};

dhtmlXCarousel.prototype.ef.cards_f = {
	prepare: "_cards_prepare",
	start: "_cards_start",
	end: "_cards_end",
	update_selected: "_cards_update_selected",
	detect_x: "_cards_detect_x",
	detect_aw: "_cards_detect_area_width",
	cell_added: "_cards_cell_added"
};

dhtmlXCarousel.prototype._cards_init = function() {
	return (this.conf.transProp==false?false:this.ef.cards_conf);
};

dhtmlXCarousel.prototype._cards_f = function() {
	return this.ef.cards_f;
};

dhtmlXCarousel.prototype._cards_prepare = function(dir, ef) {
	
	if (dir > 0) {
		
		// move from right to left
		
		var id = this.ind[this.conf.selected+dir];
		var cell = this.cdata[id].cell;
		this._cards_update_selected(id);
		
		if (cell.conf.transEvInit != true) {
			cell.cell.addEventListener(this.conf.transEv, this._animateTransEnd, false);
			cell.conf.transEvInit = true;
		}
		
		this.conf.current_id = id;
		this.conf.current_dir = dir;
		
		cell.cell.style[this.conf.transProp] = this.conf.anim_cards;
		cell.cell.style.left = this._cards_detect_x(id, 0)+"px";
		
		cell = null;
		
	} else {
		
		// move cells to right, if jumped through several cells
		this._cards_adjust_middle(this.conf.selected+dir+1, this.conf.selected-1, 1);
		
		var id = this.ind[this.conf.selected];
		var cell = this.cdata[id].cell;
		cell._hideCover();
		
		if (cell.conf.transEvInit != true) {
			cell.cell.addEventListener(this.conf.transEv, this._animateTransEnd, false);
			cell.conf.transEvInit = true;
		}
		
		this.conf.current_id = id;
		this.conf.current_dir = dir;
		
		this.cdata[this.ind[this.conf.selected+dir]].cell._hideCover();
		
		cell.cell.style[this.conf.transProp] = this.conf.anim_cards;
		cell.cell.style.left = this._cards_detect_x(id, 1)+"px";
		
		cell = null;
		
	}
	
};

dhtmlXCarousel.prototype._cards_start = function(step, curX, maxX, dir) {
	// old browsers?
};

dhtmlXCarousel.prototype._cards_end = function(e, obj) {
	
	if (e.type == this.conf.transEv && this.conf.current_id != null && obj == this.cdata[this.conf.current_id].cell.cell) {
		
		var cell = this.cdata[this.conf.current_id].cell;
		
		cell.cell.style[this.conf.transProp] = "";
		if (cell.conf.transEvInit != true) {
			cell.cell.removeEventListener(this.conf.transEv, this._animateTransEnd, false);
			cell.conf.transEvInit = false;
		}
		
		this.conf.current_id = null;
		
		// move cells to left, if jumped through several cells
		if (this.conf.current_dir > 0) {
			this._cards_adjust_middle(this.conf.selected+1, this.conf.selected+this.conf.current_dir-1, 0);
		}
		
		this.cdata[this.ind[this.conf.selected]].cell._showCover();
		this._animateEnd(this.conf.current_dir);
		
	}
	
};

dhtmlXCarousel.prototype._cards_update_selected = function(id) {
	this.cdata[id].cell._hideCover();
};

dhtmlXCarousel.prototype._cards_adjust_middle = function(fromIndex, toIndex, i) {
	for (var q=fromIndex; q<=toIndex; q++) {
		var id = this.ind[q];
		var cell = this.cdata[id].cell;
		cell.conf.size.x = this._cards_detect_x(id, i);
		cell.cell.style.left = cell.conf.size.x+"px";
		cell = null;
	}
};

dhtmlXCarousel.prototype._cards_detect_x = function(id, i) {
	// i==0 -> item on left, i==1 => item on right
	if (typeof(i) == "undefined" || i == null) i = (this.cdata[id].index <= this.conf.selected ? 0:1);
	var x = i*(this.conf.width+this.conf.ofs_left+this.conf.ofs_item)+this.conf.ofs_item;
	return x;
};

dhtmlXCarousel.prototype._cards_cell_added = function(id) {
	
	this.cdata[id].cell.conf.size.x = this._cards_detect_x(id);
	this.cdata[id].cell.cell.style.left = this.cdata[id].cell.conf.size.x+"px";
	
	if (this.conf.selected != this.cdata[id].index) {
		this.cdata[id].cell._showCover();
	}
};

dhtmlXCarousel.prototype._cards_detect_area_width = function() {
	return 2;
};

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXWindows(params) {
	
	// console.log("context menu for top icon?");
	// console.log("resize with attached iframe - cover or cross events?");
	// console.log("resize allow while progress is on?");
	// console.log("deny resize for maxed window, but allow for partially maxed");
	// console.log("add cancelBubble for mousedown/click for modal cover?");
	
	var that = this;
	
	var conf = {};
	if (typeof(params) != "undefined") {
		for (var a in params) conf[a] = params[a];
	}
	params = null;
	
	this.conf = {
		skin: window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxwins")||"material",
		// viewport conf
		vp_pos_ofs: 20, // windows-veieport overlay (left, right, bottom) and 0 for top
		vp_custom: false,
		vp_of_auto: (conf.vp_overflow=="auto"), // overflow for body from layout init
		vp_of_id: window.dhx4.newId(),
		// window dinmension offset
		ofs_w: null,
		ofs_h: null,
		// button down/up state
		button_last: null,
		// hdr dblclick
		dblclick_tm: 300,
		dblclick_last: null,
		dblclick_id: null,
		dblclick_mode: "minmax", // "park", function(){}, "function_name"
		dblclick_active: false,
		dblclick_ev: (window.dhx4.isIE6||window.dhx4.isIE7||window.dhx4.isIE8),
		// fr cover render
		fr_cover: (navigator.userAgent.indexOf("MSIE 6.0")>=0) // iframe+select issue, ie6 only
	};
	
	var transData = window.dhx4.transDetect();
	this.conf.tr = {
		prop: transData.transProp, // false if not available
		ev: transData.transEv,
		height_open: "height 0.2s cubic-bezier(0.25,0.1,0.25,1)", // cell open/close by click
		height_close: "height 0.18s cubic-bezier(0.25,0.1,0.25,1)", // cell open/close by click
		op_open: "opacity 0.16s ease-in", // cell_cont on open
		op_close: "opacity 0.2s ease-out", // cell_cont on close
		op_v_open: "1", // opacity for opened cell
		op_v_close: "0.4" // opacity for closed cell
	};
	
	if (!conf.viewport) {
		this.attachViewportTo(document.body);
	} else {
		if (conf.viewport.object != null) {
			this.attachViewportTo(conf.viewport.object);
		} else if (conf.viewport.left != null && conf.viewport.top != null && conf.viewport.width != null && conf.viewport.height != null) {
			this.setViewport(conf.viewport.left, conf.viewport.top, conf.viewport.width, conf.viewport.height, conf.viewport.parent);
		} else {
			this.attachViewportTo(document.body);
		}
	}
	
	this.w = {};
	
	this.createWindow = function(id, x, y, width, height) {
		
		var r = {};
		if (arguments.length == 1 && typeof(id) == "object") {
			r = id;
		} else {
			r.id = id;
			r.left = x;
			r.top = y;
			r.width = width;
			r.height = height;
			if (typeof(r.id) == "undefined" || r.id == null) r.id = window.dhx4.newId();
			while (this.w[r.id] != null) r.id = window.dhx4.newId();
		}
		
		if (r.left == null) r.left = 0;
		if (r.top == null) r.top = 0;
		
		r.move = (r.move != null && window.dhx4.s2b(r.move) == false ? false : (r.deny_move != null && window.dhx4.s2b(r.deny_move) == true ? false : true));
		r.park = (r.park != null && window.dhx4.s2b(r.park) == false ? false : (r.deny_park != null && window.dhx4.s2b(r.deny_park) == true ? false : true));
		r.resize = (r.resize != null && window.dhx4.s2b(r.resize) == false ? false : (r.deny_resize != null && window.dhx4.s2b(r.deny_resize) == true ? false : true));
		r.keep_in_viewport = (r.keep_in_viewport != null && window.dhx4.s2b(r.keep_in_viewport));
		r.modal = (r.modal != null && window.dhx4.s2b(r.modal));
		r.center = (r.center != null && window.dhx4.s2b(r.center));
		r.text = (r.text != null ? r.text:(r.caption!=null?r.caption:"dhtmlxWindow"));
		r.header = (!(r.header != null && window.dhx4.s2b(r.header) == false));
		
		var t = document.createElement("DIV");
		t.className = "dhxwin_active";
		this.vp.appendChild(t);
		
		t._isWindow = true;
		t._idd = r.id;
		
		var h = document.createElement("DIV");
		h.className = "dhxwin_hdr";
		h.style.zIndex = 0;
		h.innerHTML = "<div class='dhxwin_icon'></div>"+
				"<div class='dhxwin_text'><div class='dhxwin_text_inside'>"+r.text+"</div></div>"+
				"<div class='dhxwin_btns'></div>";
		t.appendChild(h);
		
		h.onselectstart = function(e) {
			e = e||event;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			return false;
		}
		
		h.oncontextmenu = function(e) {
			e = e||event;
			e.cancelBubble = true;
			return false;
		}
		
		h._isWinHdr = true;
		h.firstChild._isWinIcon = true;
		
		var k = document.createElement("DIV");
		k.className = "dhxwin_brd";
		t.appendChild(k);
		
		var fr_cover = document.createElement("DIV");
		fr_cover.className = "dhxwin_fr_cover";
		fr_cover.innerHTML = "<iframe class='dhxwin_fr_cover_inner' frameborder='0' border='0'></iframe><div class='dhxwin_fr_cover_inner'></div>";
		t.appendChild(fr_cover);
		
		this.w[r.id] = {
			win: t,
			hdr: h,
			brd: k,
			fr_cover: fr_cover,
			b: {},
			conf: {
				z_id: window.dhx4.newId(),
				actv: false,
				modal: false,
				maxed: false,
				parked: false,
				sticked: false,
				visible: true,
				header: true,
				text: r.text,
				keep_in_vp: r.keep_in_viewport,
				allow_move: r.move,
				allow_park: r.park,
				allow_resize: r.resize,
				max_w: null,
				max_h: null,
				min_w: 80,
				min_h: 80
			}
		};
		
		// buttons, id=>visible
		var btns = {
			help: {title: "Help", visible: false},
			stick: {title: "Stick", visible: false},
			park: {title: "Park", visible: true},
			minmax: {title: "Min/Max", visible: true},
			close: {title: "Close", visible: true}
		};
		for (var a in btns) {
			var b = new dhtmlXWindowsButton(this, r.id, a, btns[a].title, false);
			if (btns[a].visible == false) b.hide();
			h.lastChild.appendChild(b.button);
			this.w[r.id].b[a] = b;
			b = null;
		}
		this._winAdjustTitle(r.id);
		
		this.w[r.id].win.style.zIndex = window.dhx4.zim.reserve(this.w[r.id].conf.z_id);
		
		var cell = new dhtmlXWindowsCell(r.id, this);
		this.w[r.id].win.insertBefore(cell.cell, fr_cover);
		this.w[r.id].cell = cell;
		
		if (typeof(window.addEventListener) == "function") {
			this.w[r.id].win.addEventListener("mousedown", this._winOnMouseDown, false);
			this.w[r.id].win.addEventListener("mouseup", this._winOnMouseDown, false);
			if (this.conf.dblclick_ev) this.w[r.id].win.addEventListener("dblclick", this._winOnMouseDown, false);
			// touch
			if (this.conf.dnd_enabled == true && window.dhx4.dnd.evs.start != null) {
				this.w[r.id].win.addEventListener(window.dhx4.dnd.evs.start, this._winOnMouseDown, false);
				if (window.dhx4.dnd.p_en != true) {
					this.w[r.id].win.addEventListener(window.dhx4.dnd.evs.start, this._winOnMouseDown, false);
					this.w[r.id].win.addEventListener(window.dhx4.dnd.evs.end, this._winOnMouseDown, false);
				}
			}
		} else {
			this.w[r.id].win.attachEvent("onmousedown", this._winOnMouseDown);
			this.w[r.id].win.attachEvent("onmouseup", this._winOnMouseDown);
			if (this.conf.dblclick_ev) this.w[r.id].win.attachEvent("ondblclick", this._winOnMouseDown);
		}
		
		// fr for IE6
		this._winInitFRM(r.id);
		
		this._winSetPosition(r.id, r.left, r.top);
		this._winSetSize(r.id, r.width, r.height);
		this._winMakeActive(r.id);
		
		if (r.center == true) this.w[r.id].cell.center();
		if (r.modal == true) this.w[r.id].cell.setModal(true);
		if (r.header == false) this.w[r.id].cell.hideHeader();
		
		f = t = h = k = fr_cover = cell = null;
		
		return this.w[r.id].cell;
	}
	
	this._winOnMouseDown = function(e) {
		
		e = e||event;
		
		var t = e.target||e.srcElement;
		var data = {press_type: e.type};
		
		if (e.type == "MSPointerDown" || e.type == "pointerdown") {
			that.conf.ev_skip = true;
		} else if (that.conf.ev_skip == true) {
			that.conf.ev_skip = false;
			t = null;
			return;
		}
		
		
		while (t != null && t._isWindow != true) {
			if (typeof(t.className) != "undefined" && data.mode == null) {
				if (typeof(t._buttonName) != "undefined") {
					data.mode = "button";
					data.button_name = t._buttonName;
				} else if (t._isWinHdr == true) {
					data.mode = "hdr";
				} else if (t._isWinIcon == true) {
					data.mode = "icon";
				}
			}
			t = t.parentNode;
		}
		if (data.mode == null) data.mode = "win";
		
		data.id = (t != null && t._isWindow == true ? t._idd:null);
		
		t = null;
		
		if (data.id != null && that.w[data.id] != null) that.callEvent("_winMouseDown",[e,data]); // window can be attached to anther window and unexisting ID can be here
	}
	
	this._winOnParkTrans = function(e) {
		if (e.stopPropagation) e.stopPropagation();
		var w = that.w[this._idd];
		if (e.propertyName == "opacity") {
			that._winCellClearOpacity(this._idd);
		}
		if (e.propertyName == "height" && w.conf.tr_mode == "park") {
			if (w.conf.tr_mode == "park") {
				w.win.style[that.conf.tr.prop] = "";
				if (!w.conf.parked) {
					that._winAdjustCell(this._idd);
					that._callMainEvent("onParkDown", this._idd);
					if (w.conf.keep_in_vp) that._winAdjustPosition(this._idd, w.conf.x, w.conf.y);
				} else {
					w.hdr.style.zIndex = 3;
					that._callMainEvent("onParkUp", this._idd);
				}
			}
			
		}
		w = null;
	}
	
	this.unload = function() {
		
		this.conf.unloading = true;
		
		// dnd
		if (this._dndInitModule) this._dndUnloadModule();
		
		// windows
		for (var a in this.w) this._winClose(a);
		this.w = null;
		
		// context menu
		if (this.cm != null && typeof(this._unloadContextMenu) == "function") this._unloadContextMenu();
		
		// events
		window.dhx4._eventable(this, "clear");
		
		// viewport
		this.attachViewportTo(null);
		
		// conf
		for (var a in this.conf) {
			this.conf[a] = null;
			delete this.conf[a];
		}
		
		for (var a in this) this[a] = null;
		
		that = a = null;
		
	}
	
	window.dhx4._eventable(this);
	
	this.attachEvent("_winMouseDown", this._winMouseDownHandler);
	
	if (this._dndInitModule) this._dndInitModule();
	
	if (conf.wins != null) {
		for (var q=0; q<conf.wins.length; q++) {
			var r = conf.wins[q];
			this.createWindow(r);
		}
	}
	conf = null;
	
	
	return this;
};

// common
dhtmlXWindows.prototype.forEachWindow = function(func) {
	for (var a in this.w) {
		func.apply(window, [this.w[a].cell]);
	}
};
dhtmlXWindows.prototype.window = function(id) {
	if (this.w[id] != null) return this.w[id].cell;
	return null;
};
dhtmlXWindows.prototype.isWindow = function(id) {
	return (this.w[id] != null);
};
dhtmlXWindows.prototype.findByText = function(text) {
	var p = [];
	for (var a in this.w) {
		if ((this.w[a].cell.getText()).indexOf(String(text)) >= 0) p.push(this.w[a]);
	}
	return p;
};
dhtmlXWindows.prototype.setSkin = function(skin) {
	if (skin == this.conf.skin) return;
	if (this.vp != null) {
		this.vp.className = String(this.vp.className).replace("dhxwins_vp_"+this.conf.skin," dhxwins_vp_"+skin);
	}
	for (var a in this.w) {
		this.w[a].cell._resetSizeState();
		this._winAdjustCell(a);
		this._winAdjustTitle(a);
	}
	this.conf.skin = skin;
};


// z-index
dhtmlXWindows.prototype.getBottommostWindow = function() {
	return this._getTopBottomWin(false);
};
dhtmlXWindows.prototype.getTopmostWindow = function() {
	return this._getTopBottomWin(true);
};
dhtmlXWindows.prototype._getTopBottomWin = function(mode) {
	var data = null;
	for (var a in this.w) {
		if (this.w[a].conf.visible) {
			var k = false;
			if (data != null) {
				k = data.z > this.w[a].win.style.zIndex;
				if (mode) k = !k;
			}
			if (data == null || k) data = {win: this.w[a].cell, z: this.w[a].win.style.zIndex};
		}
	}
	return (data?data.win:null);
};
dhtmlXWindows.prototype._winMakeActive = function(id, force) {
	
	// if id is null activate last z-index window
	
	if (id != null && force !== true && this.w[id].conf.actv == true) return;
	
	var all = [];
	
	var inList = {};
	
	for (var q=0; q<this._zOrder.length; q++) {
		
		var propName = this._zOrder[q].name;
		var propValue = this._zOrder[q].value;
		
		var st = [];
		
		// windows matched to prop but not with specified id
		for (var a in this.w) {
			var w = this.w[a];
			if (inList[a] == null && w.conf[propName] === propValue && w.conf.visible == true) {
				if (id != a) {
					window.dhx4.zim.clear(w.conf.z_id);
					st.push([a, Number(w.win.style.zIndex)]);
					inList[a] = true;
				}
			}
			w = null;
		}
		st.sort(function(a,b){
			return (a[1]<b[1]?1:-1);
		});
		
		// check windows which is specified to be active
		if (id != null && this.w[id].conf[propName] === propValue && inList[id] == null) {
			// clear zim
			window.dhx4.zim.clear(this.w[id].conf.z_id);
			var k = [[id, Number(this.w[id].win.style.zIndex)]];
			st = k.concat(st);
			inList[id] = true;
		}
		
		all = all.concat(st);
	}
	
	// change windows' z-index
	for (var q=all.length-1; q>=0; q--) {
		
		var a = all[q][0];
		var w = this.w[a];
		
		w.win.style.zIndex = window.dhx4.zim.reserve(w.conf.z_id);
		
		// adjust modal cover z-index
		if (w.conf.modal && this.mcover != null) {
			for (var b in this.mcover) this.mcover[b].style.zIndex = w.win.style.zIndex;
		}
		
		// ajust fr_cover if any
		this._winAdjustFRMZIndex(a);
		
		// if id not specified, make last z-index active, can be triggered from _winHide
		if (id == null && q == 0) id = a;
		
		w.conf.actv = (id==a);
		w.win.className = (w.conf.actv?"dhxwin_active":"dhxwin_inactive");
		
		w = null;
	}
	
	if (id != null && this.conf.last_active != id) this._callMainEvent("onFocus", id);
	
	this.conf.last_active = id;
	
};

// z-index order, from top to bottom,
// first modal, then sticked if any, then regular
dhtmlXWindows.prototype._zOrder = [
	{name: "modal",   value: true},
	{name: "sticked", value: true},
	{name: "sticked", value: false}
];

// viewports
dhtmlXWindows.prototype._vpPull = {};
dhtmlXWindows.prototype._vpOf = {};

dhtmlXWindows.prototype._vpPullAdd = function() {
	if (this.vp == null) return;
	var id = null;
	for (var a in this._vpPull) {
		if (this._vpPull[a].vp == this.vp) {
			this._vpPull[a].count++;
			id = a;
		}
	}
	if (id == null) {
		this._vpPull[window.dhx4.newId()] = {vp: this.vp, count: 1};
	}
	if (this.vp == document.body && this.conf.vp_of_auto == true) {
		// if window inited on behalf on layout, clear overflow from body to enable scroll)
		this._vpOfInit();
	}
	this._vpOfUpd();
};

dhtmlXWindows.prototype._vpPullRemove = function() {
	if (this.vp == null) return 0;
	var count = 0;
	for (var a in this._vpPull) {
		if (this._vpPull[a].vp == this.vp) {
			count = --this._vpPull[a].count;
			if (count == 0) {
				this._vpPull[a].vp = null;
				this._vpPull[a].count = null;
				delete this._vpPull[a];
			}
		}
	}
	this._vpOfClear();
	return count;
};

dhtmlXWindows.prototype._vpOfInit = function() {
	this._vpOf[this.conf.vp_of_id] = true;
};
dhtmlXWindows.prototype._vpOfClear = function() {
	this._vpOf[this.conf.vp_of_id] = false;
	delete this._vpOf[this.conf.vp_of_id];
	this._vpOfUpd();
};

dhtmlXWindows.prototype._vpOfUpd = function() {
	var auto = false;
	for (var a in this._vpOf) auto = auto||this._vpOf[a];
	if (auto == true) {
		if (document.body.className.match(/dhxwins_vp_auto/) == null) {
			document.body.className += " dhxwins_vp_auto";
		}
	} else {
		if (document.body.className.match(/dhxwins_vp_auto/) != null) {
			document.body.className = String(document.body.className).replace(/\s{0,}dhxwins_vp_auto/gi, "");
		}
	}
};

dhtmlXWindows.prototype.attachViewportTo = function(id) {
	
	// old one
	var vpCount = this._vpPullRemove();
	
	if (this.conf.vp_custom) {
		while (this.vp.childNodes.length > 0) this.vp.removeChild(this.vp.lastChild);
		this.vp.parentNode.removeChild(this.vp);
		this.vp = null;
	} else if (this.vp != null && vpCount == 0) {
		this.vp.className = String(this.vp.className).replace(new RegExp("\\s{1,}dhxwins_vp_"+this.conf.skin),""); // no more window instances attached to same object, clear css
	}
	
	// new if set
	if (id == null) {
		
		this.vp = null; // clear link
		
	} else {
		
		this.vp = (typeof(id)=="string"?document.getElementById(id):id);
		var skin = "dhxwins_vp_"+this.conf.skin;
		if (this.vp.className.indexOf(skin) < 0) this.vp.className += " "+skin;
		id = null;
		
		// windows
		for (var a in this.w) this.vp.appendChild(this.w[a].win);
		
		this.conf.vp_custom = false;
		
	}
	
	if (this.vp == document.body) {
		document.body.style.position = "static"; // abs-left/top broken for relative/absolute
	}
	
	this._vpPullAdd();
	
};

dhtmlXWindows.prototype.setViewport = function(x, y, width, height, parentObj) {
	
	var t = document.createElement("DIV");
	
	t.style.position = "absolute";
	t.style.left = x+"px";
	t.style.top = y+"px";
	t.style.width = width+"px";
	t.style.height = height+"px";
	
	if (typeof(parentObj) == "undefined" || parentObj == null) {
		parentObj = document.body;
	} else if (typeof(parentObj) == "string") {
		parentObj = document.getElementById(parentObj);
	}
	parentObj.appendChild(t);
	
	this.attachViewportTo(t);
	this.conf.vp_custom = true;
	
	parentObj = t = null;
	
};

// position
dhtmlXWindows.prototype._winSetPosition = function(id, x, y) {
	
	var w = this.w[id];
	
	if (w.conf.maxed) {
		// probably window have max_w/max_h set and dragable
		// adjust saved w/h
		w.conf.lastMX += (x-w.conf.x);
		w.conf.lastMY += (y-w.conf.y);
	}
	
	w.conf.x = x;
	w.conf.y = y;
	
	w.win.style.left = w.conf.x+"px";
	w.win.style.top = w.conf.y+"px";
	
	this._winAdjustFRMPosition(id);
	
	w = null;
};
dhtmlXWindows.prototype._winAdjustPosition = function(id, x, y) { // check if window out of viewport
	
	var w = this.w[id];
	
	// if called from cell's adjustPosition, just make sure window position is okey
	if (typeof(x) == "undefined") x = w.conf.x;
	if (typeof(y) == "undefined") y = w.conf.y;
	
	var minX = (w.conf.keep_in_vp?0:-w.conf.w+this.conf.vp_pos_ofs);
	var maxX = (w.conf.keep_in_vp?this.vp.clientWidth-w.conf.w:this.vp.clientWidth-this.conf.vp_pos_ofs);
	
	if (x < minX) {
		x = minX;
	} else if (x > maxX) {
		x = maxX;
	}
	
	var maxY = (w.conf.keep_in_vp?this.vp.clientHeight-w.conf.h:this.vp.clientHeight-this.conf.vp_pos_ofs);
	
	if (y < 0) {
		y = 0;
	} else if (y > maxY) {
		y = maxY;
	}
	
	if (x != w.conf.x || y != w.conf.y) {
		this._winSetPosition(id, x, y);
	}
	
	w = null;
};

// dimension
dhtmlXWindows.prototype._winSetSize = function(id, width, height, skipAdjust, fixPos) {
	
	var w = this.w[id];
	
	var w2 = (width != null ? width : w.conf.w);
	var h2 = (height != null ? height : w.conf.h);
	
	if (this.conf.ofs_w == null) {
		w.win.style.width = w2+"px";
		w.win.style.height = h2+"px";
		this.conf.ofs_w = w.win.offsetWidth-w2;
		this.conf.ofs_h = w.win.offsetHeight-h2;
	}
	
	if (w.conf.min_w != null && w2 < w.conf.min_w) w2 = w.conf.min_w;
	if (w.conf.max_w != null && w2 > w.conf.max_w) w2 = w.conf.max_w;
	
	if (!w.conf.parked && w.conf.min_h != null && h2 < w.conf.min_h) h2 = w.conf.min_h;
	if (w.conf.max_h != null && h2 > w.conf.max_h) h2 = w.conf.max_h;
	
	if (w.conf.keep_in_vp) {
		if (w2 > this.vp.clientWidth) w2 = this.vp.clientWidth;
		if (h2 > this.vp.clientHeight) h2 = this.vp.clientHeight;
	}
	
	w.win.style.width = w2-this.conf.ofs_w+"px";
	w.win.style.height = h2-this.conf.ofs_h+"px";
	
	w.conf.w = w2;
	w.conf.h = h2;
	
	this._winAdjustFRMSize(id);
	
	if (fixPos) this._winAdjustPosition(id, w.conf.x, w.conf.y);
	
	// adjust content
	if (!w.conf.parked && skipAdjust != true) this._winAdjustCell(id);
	
	w = null;
};

// minmax
dhtmlXWindows.prototype._winMinmax = function(id, mode) {
		
	if (typeof(mode) != "undefined" && this.w[id].conf.maxed == mode) return; // already requested state
	if (this.w[id].conf.allow_resize == false) return;
	
	var w = this.w[id];
	
	if (w.conf.parked) this._winPark(id, false);
	
	if (w.conf.maxed) {
		
		this._winSetSize(id, w.conf.lastMW, w.conf.lastMH);
		this._winAdjustPosition(id, w.conf.lastMX, w.conf.lastMY);
		w.conf.maxed = false;
		
	} else {
		
		var x = 0;
		var y = 0;
		
		// adjust position, if any max w/h values - do not allow win to be moved outside vp
		if (w.conf.max_w != null) x = w.conf.x + Math.round(w.conf.w-w.conf.max_w)/2;
		if (w.conf.max_h != null) y = Math.max(w.conf.y + Math.round(w.conf.h-w.conf.max_h)/2, 0);
		
		// save old coords and dim
		w.conf.lastMX = w.conf.x;
		w.conf.lastMY = w.conf.y;
		w.conf.lastMW = w.conf.w;
		w.conf.lastMH = w.conf.h;
		
		this._winSetSize(id, this.vp.clientWidth, this.vp.clientHeight);
		this._winAdjustPosition(id, x, y);
		
		
		w.conf.maxed = true;
		
	}
	
	w.b.minmax.setCss(w.conf.maxed?"minmaxed":"minmax");
	
	if (w.conf.maxed) {
		this._callMainEvent("onMaximize", id);
	} else {
		this._callMainEvent("onMinimize", id);
	}
	
	
	w = null;
};

// show/hide
dhtmlXWindows.prototype._winShow = function(id, makeActive) {
	
	if (this.w[id].conf.visible == true) return;
	
	this.w[id].win.style.display = "";
	this.w[id].conf.visible = true;
	
	// makeActive set to true or only this window is visible
	if (makeActive == true || this.conf.last_active == null) this._winMakeActive(id, true);
	
	this._callMainEvent("onShow", id);
};
dhtmlXWindows.prototype._winHide = function(id, actvId) {
	
	if (this.w[id].conf.visible == false) return;
	
	this.w[id].win.style.display = "none";
	this.w[id].conf.visible = false;
	
	if (this.w[id].conf.actv) {
		this.w[id].conf.actv = false;
		this.w[id].win.className = "dhxwin_inactive";
		this._winMakeActive(null, true);
	}
	
	this._callMainEvent("onHide", id);
};

// park
dhtmlXWindows.prototype._winPark = function(id, ef) {
		
	if (this.w[id].conf.allow_park == false) return;
	if (this.w[id].conf.header == false) return;
	
	var w = this.w[id];
	
	if (ef == true && this.conf.tr.prop !== false) {
		w.win.style[this.conf.tr.prop] = this.conf.tr[w.conf.parked?"height_open":"height_close"];
		if (!w.conf.tr_ev) {
			w.win.addEventListener(this.conf.tr.ev, this._winOnParkTrans, false);
			w.conf.tr_ev = true;
		}
	}
	
	if (w.conf.parked) {
		// restore
		w.hdr.className = String(w.hdr.className).replace(/\s{1,}dhxwin_hdr_parked/gi,"");
		w.hdr.style.zIndex = 0;
		w.conf.parked = false;
		w.conf.tr_mode = "park";
		this._winCellSetOpacity(id, "open", ef);
		this._winSetSize(id, w.conf.w, w.conf.lastPH, (ef==true && this.conf.tr.prop!==false)); // adjust cont if trans not available
		if (!(ef == true && this.conf.tr.prop !== false)) {
			this._callMainEvent("onParkDown", id);
			if (w.conf.keep_in_vp) this._winAdjustPosition(id, w.conf.x, w.conf.y);
		}
		// IE8 bottom-border fix
		if (window.dhx4.isIE8 == true && this.conf.tr.prop == false && w.cell.cell.className.match(/dhxwin_parked/) != null) {
			w.cell.cell.className = w.cell.cell.className.replace(/\s{0,}dhxwin_parked/gi,"");
		}
	} else {
		// park
		w.conf.lastPH = w.conf.h;
		w.hdr.className += " dhxwin_hdr_parked";
		if (ef == false || this.conf.tr.prop == false) w.hdr.style.zIndex = 3; // no-trans
		w.conf.parked = true;
		w.conf.tr_mode = "park";
		this._winCellSetOpacity(id, "close", ef);
		this._winSetSize(id, w.conf.w, w.hdr.offsetHeight+this.conf.ofs_h, (ef==true && this.conf.tr.prop!==false)); // adjust cont if trans not available
		if (!(ef == true && this.conf.tr.prop !== false)) this._callMainEvent("onParkUp", id);
		// IE8 bottom-border fix
		if (window.dhx4.isIE8 == true && this.conf.tr.prop == false && w.cell.cell.className.match(/dhxwin_parked/) == null) {
			w.cell.cell.className += " dhxwin_parked";
		}
	}
	
	w = null;
	
};
dhtmlXWindows.prototype._winCellSetOpacity = function(id, op, ef, mode) {
	var cell = this.w[id].cell;
	for (var a in cell.conf.idx) {
		if ({pr1:true,pr2:true}[a] != true) { // skip progress
			if (ef == true && this.conf.tr.prop != false) cell.cell.childNodes[cell.conf.idx[a]].style[this.conf.tr.prop] = this.conf.tr["op_"+op];
			cell.cell.childNodes[cell.conf.idx[a]].style.opacity = this.conf.tr["op_v_"+op];
		}
	}
	cell = null;
};
dhtmlXWindows.prototype._winCellClearOpacity = function(id) {
	var cell = this.w[id].cell;
	for (var a in cell.conf.idx) {
		if ({pr1:true,pr2:true}[a] != true) { // skip progress
			if (this.conf.tr.prop != false) cell.cell.childNodes[cell.conf.idx[a]].style[this.conf.tr.prop] = "";
		}
	}
	cell = null;
};

// stick
dhtmlXWindows.prototype._winStick = function(id, mode) {
	
	if (typeof(mode) != "undefined" && this.w[id].conf.sticked == mode) return; // already requested state
	
	this.w[id].conf.sticked = !this.w[id].conf.sticked;
	this.w[id].b.stick.setCss(this.w[id].conf.sticked?"sticked":"stick");
	
	this._winMakeActive(this.conf.last_active, true);
	if (this.w[id].conf.sticked) {
		this._callMainEvent("onStick", id);
	} else {
		this._callMainEvent("onUnStick", id);
	}
};

// close
dhtmlXWindows.prototype._winClose = function(id) {
	
	if (this._callMainEvent("onClose", id) !== true && this.conf.unloading != true) return;
	var w = this.w[id];
	
	if (w.conf.fs_mode) w.cell.setToFullScreen(false);
	if (w.conf.modal) this._winSetModal(id, false);
	
	// z-index clear
	window.dhx4.zim.clear(w.conf.z_id);
	
	// context menu
	if (this.cm != null && this.cm.icon[id] != null) {
		this._detachContextMenu("icon", id, null);
	}
	
	// header click/dblclick events
	if (typeof(window.addEventListener) == "function") {
		w.win.removeEventListener("mousedown", this._winOnMouseDown, false);
		w.win.removeEventListener("mouseup", this._winOnMouseDown, false);
		if (this.conf.dblclick_ev) w.win.removeEventListener("dblclick", this._winOnMouseDown, false);
		// touch
		if (this.conf.dnd_enabled == true && window.dhx4.dnd.evs.start != null) {
			w.win.removeEventListener(window.dhx4.dnd.evs.start, this._winOnMouseDown, false)
			if (window.dhx4.dnd.p_en != true) {
				w.win.removeEventListener(window.dhx4.dnd.evs.start, this._winOnMouseDown, false);
				w.win.removeEventListener(window.dhx4.dnd.evs.end, this._winOnMouseDown, false);
			}
		}
	} else {
		w.win.detachEvent("onmousedown", this._winOnMouseDown);
		w.win.detachEvent("onmouseup", this._winOnMouseDown);
		if (this.conf.dblclick_ev) w.win.attachEvent("ondblclick", this._winOnMouseDown);
	}
	
	// buttons
	for (var a in w.b) this._winRemoveButton(id, a, true);
	w.b = null;
	
	// cell
	w.cell._unload();
	w.cell = null;
	
	// border
	w.brd.parentNode.removeChild(w.brd);
	w.brd = null;
	
	// covers
	if (w.fr_cover != null) {
		w.fr_cover.parentNode.removeChild(w.fr_cover);
		w.fr_cover = null;
	}
	if (w.fr_m_cover != null) {
		w.fr_m_cover.parentNode.removeChild(w.fr_m_cover);
		w.fr_m_cover = null;
	}
	
	// hdr
	w.hdr._isWinHdr = true;
	w.hdr.firstChild._isWinIcon = true;
	w.hdr.onselectstart = null;
	w.hdr.parentNode.removeChild(w.hdr);
	w.hdr = null;
	
	// conf
	for (var a in w.conf) {
		w.conf[a] = null;
		delete w.conf[a];
	}
	w.conf = null;
	
	// win
	w.win._idd = null;
	w.win._isWindow = null;
	w.win.parentNode.removeChild(w.win);
	w.win = null;
	
	w = null;
	this.w[id] = null;
	delete this.w[id];
	
	// activate topmost window
	if (!this.conf.unloading) this._winMakeActive(null, true);
	
};

// modal
dhtmlXWindows.prototype._winSetModal = function(id, modal, removeCover) {
	
	if (this.w[id].conf.modal == modal) return; // already have specified modal state
	
	if (typeof(removeCover) == "undefined") removeCover = true;
	
	var w = this.w[id];
	
	if (modal == true && w.conf.modal == false) {
		
		// remove modality from prev window
		if (this.conf.last_modal != null) {
			this._winSetModal(this.conf.last_modal, false, false);
		}
		
		if (this.mcover == null) {
			
			// create a new one
			var d = document.createElement("DIV");
			d.className = "dhxwins_mcover";
			this.vp.insertBefore(d, w.fr_m_cover||w.win);
			this.mcover = {d:d};
			
			if (this.conf.fr_cover) {
				this.mcover.f = document.createElement("IFRAME");
				this.mcover.f.className = "dhxwins_mcover";
				this.mcover.f.border = 0;
				this.mcover.f.frameBorder = 0;
				this.vp.insertBefore(this.mcover.f,d);
			}
			
			d = null;
			
		} else if (this.mcover.d.nextSibling != (w.fr_m_cover||w.win)) {
			// move cover to place it before modal window
			this.vp.insertBefore(this.mcover.d, w.fr_m_cover||w.win);
			if (this.mcover.f != null) this.vp.insertBefore(this.mcover.f, this.mcover.d);
		}
		
		w.conf.modal = true;
		this.conf.last_modal = id;
		
		this._winMakeActive(id, true);
		
	} else if (modal == false && w.conf.modal == true) {
		
		// remove modality, clear cover
		
		w.conf.modal = false;
		this.conf.last_modal = null;
		
		if (removeCover && this.mcover != null) {
			for (var a in this.mcover) {
				
				this.vp.removeChild(this.mcover[a]);
				this.mcover[a] = null;
			}
			this.mcover = null;
		}
		
	}
	
	w = null;
};

// misc
dhtmlXWindows.prototype._winMouseDownHandler = function(e, data) {
	
	var t = e.target||e.srcElement;
	
	if (e.button >= 2) return;
	
	if (data.mode == "button") {
		if (data.press_type == "mousedown") {
			this.conf.button_last = data.button_name;
		} else if ((data.press_type == "mouseup" && data.button_name == this.conf.button_last) || data.press_type == "MSPointerDown" || data.press_type == "pointerdown") {
			this.conf.button_last = null;
			if (this._winButtonClick(data.id, data.button_name, e) !== true) return;
		}
	}
	//var inEdge = (data.press_type == "pointerdown" && window.dhx4.dnd._mTouch(e) == true);
	if ((data.press_type == "pointerdown" || data.press_type == "mousedown" || data.press_type == "dblclick") && data.mode == "hdr") {
		
		// dblclick
		this.conf.dblclick_active = false;
		if (this.conf.dblclick_ev == true) {
			// IE6, IE7, IE8 native dblclick event
			if (data.press_type == "dblclick") this.conf.dblclick_active = true;
		} else {
			
			if (this.conf.dblclick_last == null) {
				this.conf.dblclick_last = new Date().getTime();
				this.dblclick_id = data.id;
			} else {
				var t = new Date().getTime();
				if (this.conf.dblclick_last + this.conf.dblclick_tm > t && this.dblclick_id == data.id) {
					this.conf.dblclick_active = true;
					this.conf.dblclick_last = null;
					this.dblclick_id = null;
				} else {
					this.conf.dblclick_last = t;
					this.dblclick_id = data.id;
				}
			}
		}
		if (this.conf.dblclick_active) {
			this._winDoHeaderDblClick(data.id);
			return;
		}
	}
	
	// for all modes
	if (data.press_type == "mousedown" || (data.press_type == window.dhx4.dnd.evs.start)) {
		this._winMakeActive(data.id);
	}
	if (data.press_type == "touchend") {
		// if (e.preventDefault) e.preventDefault();
	}
	
};

dhtmlXWindows.prototype._winDoHeaderDblClick = function(id) {
	if (this.conf.dblclick_mode == "minmax") {
		this._winMinmax(id);
		return;
	}
	if (this.conf.dblclick_mode == "park") {
		this._winPark(id, true);
		return;
	}
	// use action if any
	if (typeof(this.conf.dblclick_mode) == "function") {
		this.conf.dblclick_mode.apply(window, [id]);
		return;
	}
	if (typeof(window[this.conf.dblclick_mode]) == "function") {
		window[this.conf.dblclick_mode].apply(window, [id]);
		return;
	}
};
dhtmlXWindows.prototype._winAdjustCell = function(id) {
	
	var w = this.w[id];
	
	if (this.conf.skin == "material") {
		var x = 0;
		var y = (w.conf.header?w.hdr.offsetHeight:1);
		var width = w.win.clientWidth;
		var height = w.win.clientHeight-y;
	} else {
		var x = 1;
		var y = (w.conf.header?w.hdr.offsetHeight:1);
		var width = w.win.clientWidth-2;
		var height = w.win.clientHeight-y-1;
	}
	
	w.brd.style.left = x+"px";
	w.brd.style.top = y+"px";
	if (w.conf.brd == null) {
		w.brd.style.width = width+"px";
		w.brd.style.height = height+"px";
		w.conf.brd = {
			w: width-w.brd.offsetWidth,
			h: height-w.brd.offsetHeight
		};
	}
	w.brd.style.width = width+w.conf.brd.w+"px";
	w.brd.style.height = height+w.conf.brd.h+"px";
	
	var p = 5; // cell_cont position
	if (this.conf.skin == "material") p = 1;
	
	var x2 = 1+p;
	var y2 = (w.conf.header?y:y+p);
	var w2 = w.brd.clientWidth;
	var h2 = w.brd.clientHeight;
	
	w.cell._setSize(x2, y2, w2, h2);
	
	w.fr_cover.style.left = x2+"px";
	w.fr_cover.style.top = y2+"px";
	w.fr_cover.style.width = w2+"px";
	w.fr_cover.style.height = h2+"px";
	
	w = null;
};
dhtmlXWindows.prototype._winAdjustTitle = function(id) {
	var icon = this.w[id].hdr.childNodes[0];
	var text = this.w[id].hdr.childNodes[1];
	var btns = this.w[id].hdr.childNodes[2];
	var x = (this.conf.skin=="material"?7:0);
	text.style.paddingLeft = icon.offsetWidth+12+x+"px";
	text.style.paddingRight = btns.offsetWidth+10+x+"px";
	text = btns = icon = null;
};
dhtmlXWindows.prototype._callMainEvent = function(name, id) {
	var w = this.w[id];
	if (w.cell.checkEvent(name)) {
		var r = w.cell._callMainEvent(name, [w.cell]);
	} else {
		var r = this.callEvent(name, [w.cell]);
	}
	w = null;
	return r;
};

// fr_m_cover
dhtmlXWindows.prototype._winInitFRM = function(id) {
	if (this.conf.fr_cover != true) return;
	var w = this.w[id];
	var f = document.createElement("IFRAME");
	f.className = "dhxwin_main_fr_cover";
	f.border = 0;
	f.frameBorder = 0;
	f.style.zIndex = w.win.style.zIndex;
	w.win.parentNode.insertBefore(f, w.win);
	w.fr_m_cover = f;
	f = null;
};
dhtmlXWindows.prototype._winAdjustFRMSize = function(id) {
	var w = this.w[id];
	if (w.fr_m_cover != null) {
		w.fr_m_cover.style.width = w.conf.w+"px";
		w.fr_m_cover.style.height = w.conf.h+"px";
	}
	w = null;
};
dhtmlXWindows.prototype._winAdjustFRMPosition = function(id) {
	var w = this.w[id];
	if (w.fr_m_cover != null) {
		w.fr_m_cover.style.left = w.win.style.left;
		w.fr_m_cover.style.top = w.win.style.top;
	}
	w = null;
};
dhtmlXWindows.prototype._winAdjustFRMZIndex = function(id) {
	var w = this.w[id];
	if (w.fr_m_cover != null) {
		w.fr_m_cover.style.zIndex = w.win.style.zIndex;
	}
	w = null;
};


function dhtmlXWindowsCell(id, wins) {
	
	dhtmlXCellObject.apply(this, [id, "_wins"]);
	
	this.wins = wins;
	
	this.cell._winId = id;
	this.conf.skin = this.wins.conf.skin;
	
	this.attachEvent("_onCellUnload", function(){
		
		if (this._unloadResize) {
			this._unloadResize();
		}
		
		window.dhx4._eventable(this.cell, "clear");
		
		this.cell._winId = null;
		this.wins = null;
		
		this.setText = null;
		this.getText = null;
		this.allowMove = null;
		this.denyMove = null;
		this.isMovable = null;
		this.allowResize = null;
		this.denyResize = null;
		this.isResizable = null;
		this.maximize = null;
		this.minimize = null;
		this.isMaximized = null;
		this.setPosition = null;
		this.getPosition = null;
		this.adjustPosition = null;
		this.park = null;
		this.isParked = null;
		this.allowPark = null;
		this.denyPark = null;
		this.isParkable = null;
		this.show = null;
		this.hide = null;
		this.isHidden = null;
		this.stick = null;
		this.unstick = null;
		this.isSticked = null;
		this.setDimension = null;
		this.getDimension = null;
		this.setMinDimension = null;
		this.getMinDimension = null;
		this.setMaxDimension = null;
		this.getMaxDimension = null;
		this.keepInViewport = null;
		this.center = null;
		this.centerOnScreen = null;
		this.bringToTop = null;
		this.bringToBottom = null;
		this.isOnTop = null;
		this.isOnBottom = null;
		this.showHeader = null;
		this.hideHeader = null;
		this.setModal = null;
		this.isModal = null;
		this.close = null;
		
		this._adjustByCont = null;
		
		this.button = null;
		this.addUserButton = null;
		this.removeUserButton = null;
		
		that = null;
	});
	
	this.attachEvent("_onContentLoaded", function() {
		this.wins._callMainEvent("onContentLoaded", this._idd);
	});
	this.attachEvent("_onContentMouseDown", function(id,e) {
		this.wins.callEvent("_winMouseDown",[e,{id:id,mode:"win"}]);
	});
	
	this._callMainEvent = function(name, args) {
		return this.callEvent(name, args);
	}
	
	// open/close, check trans-effects
	
	this.conf.tr = {};
	for (var a in this.wins.conf.tr) this.conf.tr[a] = this.wins.conf.tr[a];
	
	if (this.conf.tr.prop != false) {
		/* 
		this.attachEvent("_onIdxUpdated", function(){
			// if cell hidden - update opacity for menu/toolbar/status which attached to parked window
			if (this.wins.w[this._idd].conf.parked) {
				for (var a in this.conf.idx) {
					if ({hdr:true,pr1:true,pr2:true}[a] != true) { // skip hdr and progress
						this.wins._winCellSetOpacity(this._idd, "close", false);
					}
				}
			}
		});
		*/
	}
	
	
	if (this._initResize) this._initResize();
	
	// personal window events,
	// dhxWins.window(id).attachEvent()
	window.dhx4._eventable(this.cell);
	
	// adjustParentSize (for form)
	var that = this;
	this.cell.attachEvent("_setCellSize", function(w, h){
		var w0 = that.wins.w[this._winId].conf.w-that.conf.size.w;
		var h0 = that.wins.w[this._winId].conf.h-that.conf.size.h;
		that.setDimension(w+w0, h+h0);
	});
	
	return this;
	
};

dhtmlXWindowsCell.prototype = new dhtmlXCellObject();

// text
dhtmlXWindowsCell.prototype.setText = function(text) {
	this.wins.w[this._idd].conf.text = text;
	this.wins.w[this._idd].hdr.childNodes[1].firstChild.innerHTML = text;
};
dhtmlXWindowsCell.prototype.getText = function() {
	return this.wins.w[this._idd].conf.text;
};

// move/dnd
dhtmlXWindowsCell.prototype.allowMove = function() {
	this.wins.w[this._idd].conf.allow_move = true;
};
dhtmlXWindowsCell.prototype.denyMove = function() {
	this.wins.w[this._idd].conf.allow_move = false;
};
dhtmlXWindowsCell.prototype.isMovable = function() {
	return (this.wins.w[this._idd].conf.allow_move == true);
};

// resize
dhtmlXWindowsCell.prototype.allowResize = function() {
	this.wins.w[this._idd].conf.allow_resize = true;
	this.wins.w[this._idd].b.minmax.enable();
};
dhtmlXWindowsCell.prototype.denyResize = function() {
	this.wins.w[this._idd].conf.allow_resize = false;
	this.wins.w[this._idd].b.minmax.disable();
};
dhtmlXWindowsCell.prototype.isResizable = function() {
	return (this.wins.w[this._idd].conf.allow_resize == true);
};

// min/max
dhtmlXWindowsCell.prototype.maximize = function() {
	this.wins._winMinmax(this._idd, true);
};
dhtmlXWindowsCell.prototype.minimize = function() {
	this.wins._winMinmax(this._idd, false);
};
dhtmlXWindowsCell.prototype.isMaximized = function() {
	return (this.wins.w[this._idd].conf.maxed == true);
};

// position
dhtmlXWindowsCell.prototype.setPosition = function(x, y) {
	this.wins._winSetPosition(this._idd, x, y);
};
dhtmlXWindowsCell.prototype.getPosition = function() {
	var w = this.wins.w[this._idd];
	var p = [w.conf.x,w.conf.y];
	w = null;
	return p;
};
dhtmlXWindowsCell.prototype.adjustPosition = function() {
	this.wins._winAdjustPosition(this._idd);
};

// parking
dhtmlXWindowsCell.prototype.park = function() {
	this.wins._winPark(this._idd, true); // with effect
};
dhtmlXWindowsCell.prototype.isParked = function() {
	return (this.wins.w[this._idd].conf.parked == true);
};
dhtmlXWindowsCell.prototype.allowPark = function() {
	this.wins.w[this._idd].conf.allow_park = true;
	this.wins.w[this._idd].b.park.enable();
};
dhtmlXWindowsCell.prototype.denyPark = function() {
	this.wins.w[this._idd].conf.allow_park = false;
	this.wins.w[this._idd].b.park.disable();
};
dhtmlXWindowsCell.prototype.isParkable = function() {
	return (this.wins.w[this._idd].conf.allow_park == true);
};

// show/hide
dhtmlXWindowsCell.prototype.show = function(makeActive) {
	this.wins._winShow(this._idd, window.dhx4.s2b(makeActive));
};
dhtmlXWindowsCell.prototype.hide = function() {
	this.wins._winHide(this._idd);
};
dhtmlXWindowsCell.prototype.isHidden = function() {
	return (this.wins.w[this._idd].conf.visible != true);
};

// sticking
dhtmlXWindowsCell.prototype.stick = function() {
	this.wins._winStick(this._idd, true);
};
dhtmlXWindowsCell.prototype.unstick = function() {
	this.wins._winStick(this._idd, false);
};
dhtmlXWindowsCell.prototype.isSticked = function() {
	return (this.wins.w[this._idd].conf.sticked == true);
};

// dimension
dhtmlXWindowsCell.prototype.setDimension = function(width, height) {
	var w = this.wins.w[this._idd];
	if (w.conf.parked) this.wins._winPark(this._idd, false);
	if (w.conf.maxed) {
		if (width != null) w.conf.lastMW = width;
		if (height != null) w.conf.lastMH = height;
		this.wins._winMinmax(this._idd);
	} else {
		this.wins._winSetSize(this._idd, width, height, false, true);
	}
	w = null;
};
dhtmlXWindowsCell.prototype.getDimension = function() {
	var w = this.wins.w[this._idd];
	var d = [w.conf.w, w.conf.h];
	w = null;
	return d;
};
dhtmlXWindowsCell.prototype.setMinDimension = function(width, height) {
	var w = this.wins.w[this._idd];
	w.conf.min_w = width;
	w.conf.min_h = height;
	// parked and maxed will ajusted in _winSetSize
	this.wins._winSetSize(this._idd, w.conf.w, w.conf.h);
	w = null;
};
dhtmlXWindowsCell.prototype.getMinDimension = function() {
	var w = this.wins.w[this._idd];
	var d = [w.conf.min_w, w.conf.min_h];
	w = null;
	return d;
};
dhtmlXWindowsCell.prototype.setMaxDimension = function(width, height) {
	var w = this.wins.w[this._idd];
	w.conf.max_w = width;
	w.conf.max_h = height;
	// parked and maxed will ajusted in _winSetSize
	this.wins._winSetSize(this._idd, w.conf.w, w.conf.h);
	w = null;
};
dhtmlXWindowsCell.prototype.getMaxDimension = function() {
	var w = this.wins.w[this._idd];
	var d = [w.conf.max_w, w.conf.max_h];
	w = null;
	return d;
};

// viewport
dhtmlXWindowsCell.prototype.keepInViewport = function(mode) {
	this.wins.w[this._idd].conf.keep_in_vp = window.dhx4.s2b(mode);
};
dhtmlXWindowsCell.prototype.center = function() {
	
	var vp = this.wins.vp;
	var w = this.wins.w[this._idd];
	
	var x = Math.round((vp.clientWidth-w.conf.w)/2);
	var y = Math.round((vp.clientHeight-w.conf.h)/2);
	
	this.wins._winSetPosition(this._idd, x, y);
	vp = w = null;
};
dhtmlXWindowsCell.prototype.centerOnScreen = function() {
	
	var w = this.wins.w[this._idd];
	var dim = window.dhx4.screenDim();
	
	// viewport correction
	var vx = window.dhx4.absLeft(this.wins.vp);
	var vy = window.dhx4.absTop(this.wins.vp);
	var k = this.wins.vp.parentNode;
	while (k != null) {
		if (k.scrollLeft) vx = vx-k.scrollLeft;
		if (k.scrollTop) vy = vy-k.scrollTop;
		k = k.parentNode;
	}
	
	var x = Math.round((dim.right-dim.left-w.conf.w)/2);
	var y = Math.round((dim.bottom-dim.top-w.conf.h)/2);
	
	this.wins._winAdjustPosition(this._idd, x-vx, y-vy);
	d = w = null;
	
};

// z-index
dhtmlXWindowsCell.prototype.bringToTop = function() {
	this.wins._winMakeActive(this._idd, true);
};
dhtmlXWindowsCell.prototype.bringToBottom = function() {
	var actv = (this.wins.w[this._idd].conf.actv?null:this.wins.conf.last_active);
	window.dhx4.zim.clear(this.wins.w[this._idd].conf.z_id);
	this.wins.w[this._idd].win.style.zIndex = 0;
	this.wins._winMakeActive(actv, true);
};
dhtmlXWindowsCell.prototype.isOnTop = function() {
	return (this.wins.w[this._idd].conf.actv == true);
};
dhtmlXWindowsCell.prototype.isOnBottom = function() {
	var data = {id: null, z:+Infinity};
	for (var a in this.wins.w) {
		if (this.wins.w[a].conf.visible && this.wins.w[a].win.style.zIndex < data.z) {
			data.id = a;
			data.z = this.wins.w[a].win.style.zIndex;
		}
	}
	return (data.id==this._idd);
};

// header
dhtmlXWindowsCell.prototype.showHeader = function() {
	var w = this.wins.w[this._idd];
	if (w.conf.header == false) {
		w.hdr.className = String(w.hdr.className).replace(/\s{0,}dhxwin_hdr_hidden/gi,"");
		w.brd.className = String(w.brd.className).replace(/\s{0,}dhxwin_hdr_hidden/gi,"");
		this.conf.cells_cont = null; // reset saved borders
		w.conf.brd = null; // reset brd
		w.conf.header = true;
		this.wins._winAdjustCell(this._idd);
	}
	w = null;
};
dhtmlXWindowsCell.prototype.hideHeader = function() {
	var w = this.wins.w[this._idd];
	if (w.conf.header == true) {
		if (w.conf.parked) this.wins._winPark(this._idd, false);
		w.hdr.className += " dhxwin_hdr_hidden";
		w.brd.className += " dhxwin_hdr_hidden";
		this.conf.cells_cont = null; // reset saved borders
		w.conf.brd = null; // reset brd
		w.conf.header = false;
		this.wins._winAdjustCell(this._idd);
	}
	w = null;
};

// modality
dhtmlXWindowsCell.prototype.setModal = function(modal) {
	this.wins._winSetModal(this._idd, window.dhx4.s2b(modal));
};
dhtmlXWindowsCell.prototype.isModal = function() {
	return (this.wins.w[this._idd].conf.modal==true);
};

// adjust cell to content
dhtmlXWindowsCell.prototype._adjustByCont = function(w, h) {
	w += this.wins.w[this._idd].conf.w-this.conf.size.w;
	h += this.wins.w[this._idd].conf.h-this.conf.size.h;
	this.wins._winSetSize(this._idd, w, h);
};

// closing
dhtmlXWindowsCell.prototype.close = function() {
	this.wins._winClose(this._idd);
};

// icon
dhtmlXWindowsCell.prototype.setIconCss = function(css) {
	this.wins.w[this._idd].hdr.firstChild.className = "dhxwin_icon "+css;
	this.wins._winAdjustTitle(this._idd);
};

// fullscreen mode
dhtmlXWindowsCell.prototype.setToFullScreen = function(mode) {
	
	mode = window.dhx4.s2b(mode);
	
	var w = this.wins.w[this._idd];
	
	if (w.conf.fs_mode == mode) {
		w = null;
		return;
	}
	
	if (this.wins.fsn == null) {
		this.wins.fsn = document.createElement("DIV");
		this.wins.fsn.className = this.wins.vp.className+" dhxwins_vp_fs";
		document.body.appendChild(this.wins.fsn);
	}
	
	if (mode) {
		this.wins.fsn.appendChild(w.win);
		this.maximize();
		this.hideHeader();
	} else {
		this.wins.vp.appendChild(w.win);
		this.minimize();
		this.showHeader();
		
		if (this.wins.fsn.childNodes.length == 0) {
			this.wins.fsn.parentNode.removeChild(this.wins.fsn);
			this.wins.fsn = null;
		}
	}
	
	w.conf.fs_mode = mode;
	w = null;
	
};

// buttons

dhtmlXWindowsCell.prototype.button = function(id) {
	if (id == "minmax1" || id == "minmax2") { // deprecated
		// console.warn("windows: minmax1/minmax2 buttons are deprecated, from 4.0 there is single button minmax");
		id = "minmax";
	}
	return this.wins.w[this._idd].b[id];
};

dhtmlXWindowsCell.prototype.addUserButton = function(id, pos, title) {
	var b = new dhtmlXWindowsButton(this.wins, this._idd, id, title, true);
	var n = null;
	var h = this.wins.w[this._idd].hdr.lastChild;
	if (isNaN(pos)) pos = 0; else if (pos < 0) pos = 0;
	if (h.childNodes[pos] != null) n = h.childNodes[pos];
	if (n != null) h.insertBefore(b.button, n); else h.appendChild(b.button);
	this.wins.w[this._idd].b[id] = b;
	b = n = h = null;
	this.wins._winAdjustTitle(this._idd);
};

dhtmlXWindowsCell.prototype.removeUserButton = function(id) {
	if (this.wins.w[this._idd].b[id] == null || this.wins.w[this._idd].b[id].conf.custom != true) return;
	this.wins._winRemoveButton(this._idd, id);
};


window.dhtmlXWindowsButton = function(wins, winId, name, title, custom) {
	
	this.conf = {
		wins: wins,
		winId: winId,
		name: name,
		enabled: true,
		visible: true,
		custom:  true
	};
	
	this.button = document.createElement("DIV");
	this.button._buttonName = name;
	this.button.title = title;
	
	this.enable = function() {
		this.conf.enabled = true;
		this.setCss(this.conf.css);
	}
	this.disable = function() {
		this.conf.enabled = false;
		this.setCss(this.conf.css);
	}
	this.isEnabled = function() {
		return (this.conf.enabled==true);
	}
	//
	this.show = function() {
		this.button.style.display = "";
		this.conf.visible = true;
		this.conf.wins._winAdjustTitle(this.conf.winId);
	}
	this.hide = function() {
		this.button.style.display = "none";
		this.conf.visible = false;
		this.conf.wins._winAdjustTitle(this.conf.winId);
	}
	this.isHidden = function() {
		return (this.conf.visible==false);
	}
	//
	this.setCss = function(css) {
		this.conf.css = css;
		var dis = (this.conf.enabled?"":"_dis");
		this.button.className = "dhxwin_button"+dis+" dhxwin_button_"+this.conf.css+dis;
	}
	
	this._doOnClick = function(ev) {
		return this.callEvent("onClick", [this.conf.wins.w[this.conf.winId].cell, this]);
	}
	
	this.unload = function(winClosing) {
		//
		dhx4._eventable(this, "clear");
		this.button._buttonName = null;
		this.button.parentNode.removeChild(this.button);
		
		// context context menu if any
		if (this.conf.wins.cm != null && this.conf.wins.cm.button[this.conf.winId] != null && this.conf.wins.cm.button[this.conf.winId][this.conf.name] != null) {
			this.conf.wins._detachContextMenu("button", this.conf.winId, this.conf.name);
		}
		
		this.button = null;
		this.enable = null;
		this.disable = null;
		this.isEnabled = null;
		this.show = null;
		this.hide = null;
		this.isHidden = null;
		this.setCss = null;
		this.unload = null;
		//
		if (winClosing != true) this.conf.wins._winAdjustTitle(this.conf.winId);
		//
		this.conf.wins = null;
		this.conf.winId = null;
		this.conf = null;
		
	}
	
	this.setCss(name);
	dhx4._eventable(this);
	
	return this;
};

dhtmlXWindows.prototype._winButtonClick = function(id, button, ev) {
	
	if (!this.w[id].b[button].isEnabled()) return true;
	
	if (this.w[id].b[button]._doOnClick() !== true) return;
	
	if (button == "help") {
		this._callMainEvent("onHelp", id);
	}
	
	if (button == "park") {
		this._winPark(id, true);
	}
	
	if (button == "minmax") {
		this._winMinmax(id);
	}
	
	if (button == "stick") {
		this._winStick(id);
		return false;
	}

	if (button == "close") {
		this._winClose(id);
		return false;
	}
	return true; // allow default action
};

dhtmlXWindows.prototype._winRemoveButton = function(wId, bId, winClosing) {
	this.w[wId].b[bId].unload(winClosing);
	this.w[wId].b[bId] = null;
	delete this.w[wId].b[bId];
};



/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXWindows.prototype._dndInitModule = function() {
	
	var that = this;
	
	this.conf.dnd_enabled = true;
	this.conf.dnd_tm = null;
	this.conf.dnd_time = 0; // 400 or 0
	
	this._dndOnMouseDown = function(e, id) {
		
		if (that.conf.dblclick_active) return;
		
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		
		if (that._callMainEvent("onBeforeMoveStart", id) !== true) return;
		
		
		that.conf.dnd = {
			id: id,
			x: that._dndPos(e,"X"),
			y: that._dndPos(e,"Y"),
			ready: true,
			css: false,
			css_touch: false,
			css_vp: false,
			tr: null,
			mode: "def", //"def" - move win, "tr" - for translate, "rect" - move rectange
			moved: false,
			prevent: false
		};
		
		if (that.w[id].conf.keep_in_vp) {
			that.conf.dnd.minX = 0;
			that.conf.dnd.maxX = that.vp.clientWidth-that.w[id].conf.w;
			that.conf.dnd.minY = 0;
			that.conf.dnd.maxY = that.vp.clientHeight-that.w[id].conf.h;
		} else {
			that.conf.dnd.minX = -that.w[id].conf.w+that.conf.vp_pos_ofs;
			that.conf.dnd.maxX = that.vp.clientWidth-that.conf.vp_pos_ofs;
			that.conf.dnd.minY = 0;
			that.conf.dnd.maxY = that.vp.clientHeight-that.conf.vp_pos_ofs;
		}
		
		var k = [
			"MozTransform",
			"WebkitTransform",
			"OTransform",
			"msTransform",
			"transform"
		];
		
		for (var q=0; q<k.length; q++) {
			if (document.documentElement.style[k[q]] != null && that.conf.dnd.tr == null) {
				that.conf.dnd.tr = k[q];
				that.conf.dnd.mode = "tr";
			}
		}
		
		// that.conf.dnd.mode = "def";
		// console.log("dnd ready, mode: "+that.conf.dnd.mode);
		
		if (that.conf.dnd.mode == "tr") {
			that.w[id].win.style[that.conf.dnd.tr] = "translate(0px,0px)";
			if (that.w[id].fr_m_cover != null) that.w[id].fr_m_cover.style[that.conf.dnd.tr] = that.w[id].win.style[that.conf.dnd.tr];
		}
		
		// touch indicator
		if (window.dhx4.dnd._mTouch(e) == false && e.type == window.dhx4.dnd.evs.start) {
			if (that.conf.dnd.css_touch == false) {
				that.w[id].win.className += " dhxwin_dnd_touch";
				that.conf.dnd.css_touch = true;
			}
			if (that.conf.dnd.css_vp == false) {
				that.vp.className += " dhxwins_vp_dnd";
				that.conf.dnd.css_vp = true;
			}
		} else {
			// init events
			that._dndInitEvents();
		}
	}
	
	this._dndOnMouseMove = function(e) {
		
		// dhtmlx.message({text: "a", expire: 100});
		e = e||event;
		
		var dnd = that.conf.dnd;
		
		var x = that._dndPos(e,"X")-dnd.x;
		var y = that._dndPos(e,"Y")-dnd.y;
		
		// check if user will move body while timer is active, allow 10px interval from touch point
		if (e.type == window.dhx4.dnd.evs.move) {
			
			if (dnd.moved != true && (Math.abs(x) > 20 || Math.abs(y) > 20)) {
				
				if (that.conf.dnd_tm != null) {
					window.clearTimeout(that.conf.dnd_tm);
					that.conf.dnd_tm = null;
				}
				window.removeEventListener(window.dhx4.dnd.evs.start, that._dndOnMouseMove, false);
				
				return;
			}
		}
		
		
		if (dnd.ready != true) return;
		
		var w = that.w[dnd.id];
		
		// dhtmlx.message({text:x+","+y,expire:100});
		
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		
		
		if (dnd.css != true) {
			if (dnd.css_touch == false) w.win.className += " dhxwin_dnd";
			w.fr_cover.className += " dhxwin_fr_cover_dnd";
			dnd.css = true;
		}
		if (dnd.css_vp != true) {
			that.vp.className += " dhxwins_vp_dnd";
			dnd.css_vp = true;
		}
		
		dnd.newX = w.conf.x+x;
		dnd.newY = w.conf.y+y;
		
		if (dnd.mode == "tr") {
			
			dnd.newX = Math.min(Math.max(dnd.newX, dnd.minX), dnd.maxX);
			x = dnd.newX-w.conf.x;
			
			dnd.newY = Math.min(Math.max(dnd.newY, dnd.minY), dnd.maxY);
			y = dnd.newY-w.conf.y;
			
			w.win.style[dnd.tr] = "translate("+x+"px,"+y+"px)";
			if (w.fr_m_cover != null) w.fr_m_cover.style[dnd.tr] = w.win.style[dnd.tr];
				
		} else {
			
			if (dnd.newX < dnd.minX || dnd.newX > dnd.maxX) {
				dnd.newX = Math.min(Math.max(dnd.newX, dnd.minX), dnd.maxX);
			} else {
				dnd.x = that._dndPos(e,"X");
			}
			
			if (dnd.newY < dnd.minY || dnd.newY > dnd.maxY) {
				dnd.newY = Math.min(Math.max(dnd.newY, dnd.minY), dnd.maxY);
			} else {
				dnd.y = that._dndPos(e,"Y");
			}
			
			that._winSetPosition(dnd.id, dnd.newX, dnd.newY);
			
		}
		
		dnd.moved = true;
		
		w = dnd = null;
	}
	
	this._dndOnMouseUp = function(e) {
		
		e = e||event;
		that._dndUnloadEvents();
		
		if (that.conf.dnd != null && that.conf.dnd.id != null) {
			
			var dnd = that.conf.dnd;
			var w = that.w[dnd.id];
			
			if (dnd.newX != null) {
				if (dnd.mode == "tr") {
					that._winSetPosition(dnd.id, dnd.newX, dnd.newY);
					w.win.style[dnd.tr] = "translate(0px,0px)";
					if (w.fr_m_cover != null) w.fr_m_cover.style[dnd.tr] = w.win.style[dnd.tr];
				}
			}
			if (dnd.css == true) {
				if (dnd.css_touch == false) w.win.className = String(w.win.className).replace(/\s{0,}dhxwin_dnd/gi,"");
				w.fr_cover.className = String(w.fr_cover.className).replace(/\s{0,}dhxwin_fr_cover_dnd/gi,"");
			}
			if (dnd.css_touch == true) {
				w.win.className = String(w.win.className).replace(/\s{0,}dhxwin_dnd_touch/gi,"");
			}
			if (dnd.css_vp == true) {
				that.vp.className = String(that.vp.className).replace(/\s{0,}dhxwins_vp_dnd/gi,"");
			}
			
			if (dnd.moved == true) {
				that._callMainEvent("onMoveFinish", dnd.id);
			} else {
				that._callMainEvent("onMoveCancel", dnd.id);
			}
			
			w = dnd = that.conf.dnd = null;
			
		}
		
		if (window.dhx4.dnd.p_en == true && e.type == window.dhx4.dnd.evs.end) {
			window.dhx4.dnd._touchOn();
			window.removeEventListener(window.dhx4.dnd.evs.end, that._dndOnMouseUp, false);
			window.removeEventListener(window.dhx4.dnd.evs.move, that._dndOnMouseMove, false);
			if (that.conf.dnd_tm != null) window.clearTimeout(that.conf.dnd_tm);
			that.conf.dnd_tm = null;
		}
	}
	
	this._dndOnSelectStart = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		return false;
	}
	
	this._dndInitEvents = function() {
		if (typeof(window.addEventListener) == "function") {
			window.addEventListener("mousemove", this._dndOnMouseMove, false);
			window.addEventListener("mouseup", this._dndOnMouseUp, false);
			window.addEventListener("selectstart", this._dndOnSelectStart, false);
		} else {
			document.body.attachEvent("onmousemove", this._dndOnMouseMove);
			document.body.attachEvent("onmouseup", this._dndOnMouseUp);
			document.body.attachEvent("onselectstart", this._dndOnSelectStart);
		}
	}
	
	this._dndUnloadEvents = function() {
		if (typeof(window.addEventListener) == "function") {
			window.removeEventListener("mousemove", this._dndOnMouseMove, false);
			window.removeEventListener("mouseup", this._dndOnMouseUp, false);
			window.removeEventListener("selectstart", this._dndOnSelectStart, false);
		} else {
			document.body.detachEvent("onmousemove", this._dndOnMouseMove);
			document.body.detachEvent("onmouseup", this._dndOnMouseUp);
			document.body.detachEvent("onselectstart", this._dndOnSelectStart);
		}
	}
	
	this._dndUnloadModule = function() {
		
		this.detachEvent(this.conf.dnd_evid);
		this.conf.dnd_evid = null;
		
		this._dndOnMouseDown = null;
		this._dndOnMouseMove = null;
		this._dndOnMouseUp = null;
		this._dndOnSelectStart = null;
		this._dndInitEvents = null;
		this._dndUnloadEvents = null;
		this._dndInitModule = null;
		this._dndUnloadModule = null;
		
		that = null;
	}
	
	this._dndPos = function(ev, type) {
		var pos = ev[this.conf.dnd_ev_prefix+type];
		if ((pos == null || pos == 0) && ev.touches != null) pos = ev.touches[0][this.conf.dnd_ev_prefix+type];
		return pos;
	}
	
	this.conf.dnd_evid = this.attachEvent("_winMouseDown", function(e, data){
		
		if (this.w[data.id] == null || this.w[data.id].conf.allow_move != true) return;
		
		if (typeof(e.button) != "undefined" && e.button >= 2) return;
		
		if (e.type == window.dhx4.dnd.evs.start) {
			
			if (data.mode == "hdr") {
				
				if (this.w[data.id].conf.maxed && this.w[data.id].conf.max_w == null && this.w[data.id].conf.max_h == null) return;
				
				this.conf.dnd_ev_prefix = "page";
				this.conf.dnd = {
					x: this._dndPos(e,"X"),
					y: this._dndPos(e,"Y")
				};
				
				if (this.conf.dnd_time < 1) {
					this._dndOnMouseDown(e, data.id);
				} else {
					if (this.conf.dnd_tm != null) window.clearTimeout(this.conf.dnd_tm);
					this.conf.dnd_tm = window.setTimeout(function(){that._dndOnMouseDown(e,data.id);}, this.conf.dnd_time);
				}
				
				if (window.dhx4.dnd.p_en == true) {
					window.dhx4.dnd._touchOff();
					window.addEventListener(window.dhx4.dnd.evs.end, this._dndOnMouseUp, false);
				}
				
				window.addEventListener(window.dhx4.dnd.evs.move, this._dndOnMouseMove, false);
				
			}
			
			return false;
		}
		
		if (e.type == window.dhx4.dnd.evs.end) {
			
			if (this.conf.dnd_tm != null) {
				window.clearTimeout(this.conf.dnd_tm);
				this.conf.dnd_tm = null;
			}
			
			this._dndOnMouseUp(e);
			window.removeEventListener(window.dhx4.dnd.evs.move, this._dndOnMouseMove, false);
			
			return false;
		}
		
		this.conf.dnd_ev_prefix = "client";
		if (!(data.mode == "hdr" && e.type == "mousedown")) return;
		if (this.w[data.id].conf.maxed && this.w[data.id].conf.max_w == null && this.w[data.id].conf.max_h == null) return;
		
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		this._dndOnMouseDown(e, data.id);
		return false;
		
	});
	
};


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXWindowsCell.prototype._initResize = function() {
	
	var that = this;
	var n = navigator.userAgent;
	
	this.conf.resize = {
		b_width: 6,
		c_type: (n.indexOf("MSIE 10.0")>0||n.indexOf("MSIE 9.0")>0||n.indexOf("MSIE 8.0")>0||n.indexOf("MSIE 7.0")>0||n.indexOf("MSIE 6.0")>0),
		btn_left: ((window.dhx4.isIE6||window.dhx4.isIE7||window.dhx4.isIE8) && typeof(window.addEventListener) == "undefined" ? 1:0)
	};
	
	this._rOnCellMouseMove = function(e) {
		
		if (that.wins.conf.resize_actv == true || that.wins.w[that._idd].conf.allow_resize == false || that.conf.progress == true || that.wins.w[that._idd].conf.maxed == true || that.wins.w[that._idd].conf.fs_mode == true) {
			var k = that.wins.w[that._idd].brd;
			if (k.style.cursor != "default") k.style.cursor = "default";
			k = null;
			return;
		}
		
		
		e = e||event;
		
		var cont = that.wins.w[that._idd].brd;
		var r = that.conf.resize;
		
		var no_header = (that.wins.w[that._idd].conf.header==false);
		
		var x = e.clientX;
		var y = e.clientY;
		
		// body/html scrolls
		x += (document.documentElement.scrollLeft||document.body.scrollLeft||0);
		y += (document.documentElement.scrollTop||document.body.scrollTop||0);
		
		var x0 = window.dhx4.absLeft(cont);
		var y0 = window.dhx4.absTop(cont);
		
		var mode = "";
		if (x <= x0+r.b_width) { // left
			mode = "w";
		} else if (x >= x0+cont.offsetWidth-r.b_width) { // right
			mode = "e";
		}
		if (y >= y0+cont.offsetHeight-r.b_width) { // bottom
			mode = "s"+mode;
		} else if (no_header && y <= y0+r.b_width) { // top (only for no_header mode)
			mode = "n"+mode;
		}
		
		if (mode == "") mode = false;
		if (r.mode != mode) {
			r.mode = mode;
			if (mode == false) {
				cont.style.cursor = "default";
			} else {
				cont.style.cursor = mode+"-resize";
			}
		}
		
		cont = r = null;
	};
	
	this._rOnCellMouseDown = function(e) {
		
		e = e||event;
		if (typeof(e.button) != "undefined" && e.button != that.conf.resize.btn_left) return;
		
		if (that.conf.resize.mode == false) return;
		if (that.conf.progress == true) return; // if progress is on - deny
		if (that.wins.w[that._idd].conf.allow_resize == false) return;
		if (that.wins.w[that._idd].conf.fs_mode == true) return; // fullscreened window
		
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		
		if (that.wins._callMainEvent("onBeforeResizeStart", that._idd) !== true) return;
		
		var w = that.wins.w[that._idd];
		var r = that.conf.resize;
		
		that.wins.conf.resize_actv = true;
		
		r.min_w = w.conf.min_w;
		r.min_h = w.conf.min_h;
		r.max_w = w.conf.max_w||+Infinity;
		r.max_h = w.conf.max_h||+Infinity;
		
		// if layout attached - check custom min w/h
		if (w.cell.dataType == "layout" && w.cell.dataObj != null && typeof(w.cell.dataObj._getWindowMinDimension) == "function") {
			var t = w.cell.dataObj._getWindowMinDimension(w.cell);
			r.min_w = Math.max(t.w, r.min_w);
			r.min_h = Math.max(t.h, r.min_h);
		}
		
		r.vp_l = that.wins.conf.vp_pos_ofs;
		r.vp_r = that.wins.vp.clientWidth-that.wins.conf.vp_pos_ofs;
		r.vp_b = that.wins.vp.clientHeight-that.wins.conf.vp_pos_ofs;
		
		r.x = e.clientX;
		r.y = e.clientY;
		
		// start resize
		if (typeof(window.addEventListener) == "function") {
			window.addEventListener("mousemove", that._rOnWinMouseMove, false);
			window.addEventListener("mouseup", that._rOnWinMouseUp, false);
			window.addEventListener("selectstart", that._rOnSelectStart, false);
		} else {
			document.body.attachEvent("onmousemove", that._rOnWinMouseMove);
			document.body.attachEvent("onmouseup", that._rOnWinMouseUp);
			document.body.attachEvent("onselectstart", that._rOnSelectStart);
		}
		
		r.resized = false;
		
		r.vp_cursor = that.wins.vp.style.cursor;
		that.wins.vp.style.cursor = r.mode+"-resize";
		
		w = r = null;
	};
	
	this._rOnCellContextMenu = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		return false;
	};
	
	this._rOnWinMouseMove = function(e) {
		
		// resize in progress
		e = e||event;
		
		var w = that.wins.w[that._idd];
		var r = that.conf.resize;
		
		if (!r.resized) {
			w.fr_cover.className += " dhxwin_fr_cover_resize";
			r.resized = true;
		}
		
		var x = e.clientX-r.x;
		var y = e.clientY-r.y;
		
		if (r.mode.indexOf("e") >= 0) { // right win side dragged
			
			r.rw = Math.min(Math.max(w.conf.w+x, r.min_w), r.max_w);
			r.rx = null;
			
			if (w.conf.x+r.rw < r.vp_l) { // check overflow to left
				r.rw = r.vp_l-w.conf.x;
			} else if (w.conf.x+r.rw > that.wins.vp.clientWidth) { // and right
				r.rw = that.wins.vp.clientWidth-w.conf.x;
			}
			
		} else if (r.mode.indexOf("w") >= 0) { // left win side dragged
			
			r.rw = Math.min(Math.max(w.conf.w-x,r.min_w),r.max_w);
			r.rx = w.conf.x+w.conf.w-r.rw;
			
			if (r.rx < 0) { // check overflow to left
				r.rw = r.rw+r.rx;
				r.rx = 0;
			} else if (r.rx > r.vp_r) { // and right
				r.rw = r.rw-r.vp_r;
				r.rx = r.vp_r;
			}
			
		}
		
		if (r.mode.indexOf("s") >= 0) { // bottom win side (can be together with left or right)
			
			r.rh = Math.min(Math.max(w.conf.h+y, r.min_h),r.max_h);
			r.ry = null;
			
			if (w.conf.y+r.rh > that.wins.vp.clientHeight) { // bottom overflow
				r.rh = that.wins.vp.clientHeight-w.conf.y;
			}
			
		} else if (r.mode.indexOf("n") >= 0) { // top win side (can be together with left or right) (only for no_header mode)
			
			r.rh = Math.min(Math.max(w.conf.h-y, r.min_h),r.max_h);
			r.ry = w.conf.y+w.conf.h-r.rh;
			
			if (r.ry < 0) { // top overflow
				r.rh = r.rh+r.ry;
				r.ry = 0;
			} else if (r.ry > r.vp_b) { // and bottom
				r.rh = r.rh-r.vp_b;
				r.ry = r.vp_b;
			}
		}
		
		that._rAdjustSizer();
		
		w = r = null;
	}
	this._rOnWinMouseUp = function() {
		
		// stop resize
		
		var r = that.conf.resize;
		var w = that.wins.w[that._idd];
		
		that.wins.conf.resize_actv = false;
		that.wins.vp.style.cursor = r.vp_cursor;
		
		w.fr_cover.className = String(w.fr_cover.className).replace(/\s{0,}dhxwin_fr_cover_resize/gi,"");
		
		if (r.resized) {
			that.wins._winSetSize(that._idd, r.rw, r.rh);
			if (r.rx == null) r.rx = w.conf.x;
			if (r.ry == null) r.ry = w.conf.y;
			if (r.rx != w.conf.x || r.ry != w.conf.y) that.wins._winSetPosition(that._idd, r.rx, r.ry);
		}
		
		if (r.obj != null) {
			r.obj.parentNode.removeChild(r.obj);
			r.obj = null;
		}
		if (r.objFR != null) {
			r.objFR.parentNode.removeChild(r.objFR);
			r.objFR = null;
		}
		
		if (typeof(window.addEventListener) == "function") {
			window.removeEventListener("mousemove", that._rOnWinMouseMove, false);
			window.removeEventListener("mouseup", that._rOnWinMouseUp, false);
			window.removeEventListener("selectstart", that._rOnSelectStart, false);
		} else {
			document.body.detachEvent("onmousemove", that._rOnWinMouseMove);
			document.body.detachEvent("onmouseup", that._rOnWinMouseUp);
			document.body.detachEvent("onselectstart", that._rOnSelectStart);
		}
		
		if (r.resized == true) {
			if (that.dataType == "layout" && that.dataObj != null) that.dataObj.callEvent("onResize",[]); // deprecated, 3.6 compat
			that.wins._callMainEvent("onResizeFinish", that._idd);
		} else {
			that.wins._callMainEvent("onResizeCancel", that._idd);
		}
		
		r.mode = "";
		
		w = r = null;
	}
	
	this._rOnSelectStart = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		return false;
	}
	
	this._rInitSizer = function() {
		
		var r = that.conf.resize;
		var w = that.wins.w[that._idd];
		
		r.obj = document.createElement("DIV");
		r.obj.className = "dhxwin_resize";
		r.obj.style.zIndex = w.win.style.zIndex;
		r.obj.style.cursor = r.mode+"-resize";
		that.wins.vp.appendChild(r.obj);
		
		if (that.wins.conf.fr_cover == true) {
			r.objFR = document.createElement("IFRAME");
			r.objFR.className = "dhxwin_resize_fr_cover";
			r.objFR.style.zIndex = r.obj.style.zIndex;
			that.wins.vp.insertBefore(r.objFR, r.obj);
		}
		
		r.rx = w.conf.x;
		r.ry = w.conf.y;
		r.rw = w.conf.w;
		r.rh = w.conf.h;
		r = null;
	}
	
	this._rAdjustSizer = function() {
		var r = that.conf.resize;
		if (!r.obj) this._rInitSizer();
		// dim
		r.obj.style.width = r.rw+"px";
		r.obj.style.height = r.rh+"px";
		
		// pos, optional
		if (r.rx != null) r.obj.style.left = r.rx+"px";
		if (r.ry != null) r.obj.style.top = r.ry+"px";
		
		if (r.objFR != null) {
			r.objFR.style.width = r.obj.style.width;
			r.objFR.style.height = r.obj.style.height;
			if (r.rx != null) r.objFR.style.left = r.obj.style.left;
			if (r.ry != null) r.objFR.style.top = r.obj.style.top;
		}
		
		r = null;
	}
	
	if (typeof(window.addEventListener) == "function") {
		this.wins.w[this._idd].brd.addEventListener("mousemove", this._rOnCellMouseMove, false);
		this.wins.w[this._idd].brd.addEventListener("mousedown", this._rOnCellMouseDown, false);
		this.wins.w[this._idd].brd.addEventListener("contextmenu", this._rOnCellContextMenu, false);
	} else {
		this.wins.w[this._idd].brd.attachEvent("onmousemove", this._rOnCellMouseMove);
		this.wins.w[this._idd].brd.attachEvent("onmousedown", this._rOnCellMouseDown);
		this.wins.w[this._idd].brd.attachEvent("oncontextmenu", this._rOnCellContextMenu);
	}
	
	this._unloadResize = function() {
		
		if (typeof(window.addEventListener) == "function") {
			this.wins.w[this._idd].brd.removeEventListener("mousemove", this._rOnCellMouseMove, false);
			this.wins.w[this._idd].brd.removeEventListener("mousedown", this._rOnCellMouseDown, false);
			this.wins.w[this._idd].brd.removeEventListener("contextmenu", this._rOnCellContextMenu, false);
		} else {
			this.wins.w[this._idd].brd.detachEvent("onmousemove", this._rOnCellMouseMove);
			this.wins.w[this._idd].brd.detachEvent("onmousedown", this._rOnCellMouseDown);
			this.wins.w[this._idd].brd.detachEvent("oncontextmenu", this._rOnCellContextMenu);
		}
		
		this._initResize = null;
		this._rOnCellMouseMove = null;
		this._rOnCellMouseDown = null;
		this._rOnWinMouseMove = null;
		this._rOnWinMouseUp = null;
		this._rOnSelectStart = null;
		this._rInitSizer = null;
		this._rAdjustSizer = null;
		this._unloadResize = null;
		
		this.conf.resize = null;
		that = null;
	};

};


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

// global context menu
dhtmlXWindows.prototype.attachContextMenu = function(conf) {
	return this._renderContextMenu("icon", null, null, conf);
};
dhtmlXWindows.prototype.getContextMenu = function() {
	if (this.cm != null && this.cm.global != null) return this.cm.global;
	return null;
};
dhtmlXWindows.prototype.detachContextMenu = function() {
	this._detachContextMenu("icon", null, null);
};

// custom menu
dhtmlXWindowsCell.prototype.attachContextMenu = function(conf) {
	return this.wins._renderContextMenu("icon", this._idd, null, conf);
};
dhtmlXWindowsCell.prototype.getContextMenu = function() {
	if (this.wins.cm != null && this.wins.cm.icon[this._idd] != null) return this.wins.cm.icon[this._idd];
	return null;
};
dhtmlXWindowsCell.prototype.detachContextMenu = function() {
	this.wins._detachContextMenu("icon", this._idd, null);
};

// menu for button
dhtmlXWindowsButton.prototype.attachContextMenu = function(conf) {
	return this.conf.wins._renderContextMenu("button", this.conf.winId, this.conf.name, conf);
};
dhtmlXWindowsButton.prototype.getContextMenu = function() {
	if (this.conf.wins.cm == null || this.conf.wins.cm.button[this.conf.winId] == null) return null;
	if (this.conf.wins.cm.button[this.conf.winId][this.conf.name] != null) return this.conf.wins.cm.button[this.conf.winId][this.conf.name];
	return null;
};
dhtmlXWindowsButton.prototype.detachContextMenu = function() {
	this.conf.wins._detachContextMenu("button", this.conf.winId, this.conf.name);
};

dhtmlXWindows.prototype._renderContextMenu = function(mode, wId, bId, conf) {
	
	var that = this;
	var firstInit = false;
	
	if (this.cm == null) {
		this.cm = {
			global:	null,	// global context menu for icon
			icon:	{},	// custom for icon, {winId:menuInst, winId2:menuInst2}
			button: {}	// custom foc button, {winId:{buttonId:menuInst, buttonId2:menuInst2}, winId2:{..}}
		};
		firstInit = true;
	}
	
	// check if already attached
	if (wId == null) {
		if (this.cm.global != null) return;
	} else if (mode == "icon") {
		if (this.cm.icon[wId] != null) return;
	} else if (mode == "button") {
		if (this.cm.button[wId] != null && this.cm.button[wId][bId] != null) return;
	}
	
	
	// init
	if (conf == null) conf = {};
	conf.parent = null;
	conf.context = true;
	
	var menu = new dhtmlXMenuObject(conf);
	menu.setAutoHideMode(false);
	
	menu.attachEvent("onShow", function() {
		this.conf.wins_menu_open = true;
	});
	
	menu.attachEvent("onHide", function() {
		this.conf.wins_menu_open = false;
		that.conf.opened_menu = null;
	});
	
	if (wId == null) {
		this.cm.global = menu;
	} else if (mode == "icon") {
		this.cm.icon[wId] = menu;
	} else if (mode == "button") {
		if (this.cm.button[wId] == null) this.cm.button[wId] = {};
		this.cm.button[wId][bId] = menu;
	}
	
	if (firstInit) {
		
		this._showContextMenu = function(e, data) {
			
			if (e.button >= 2) return;
			
			if (data.mode == "icon" && data.id != null && data.press_type == "mousedown") {
				
				var menu = this.cm.icon[data.id]||this.cm.global;
				if (menu == null) return;
				
				e.cancelBubble = true;
				
				var icon = this.w[data.id].hdr.firstChild;
				
				if (menu.conf.wins_menu_open && this.conf.opened_menu == data.id) {
					menu.hideContextMenu();
				} else {
					this._hideContextMenu();
					menu.showContextMenu(window.dhx4.absLeft(icon), window.dhx4.absTop(icon)+icon.offsetHeight);
					this.conf.opened_menu = data.id;
				}
				menu = icon = null;
				
			}
			
			if (data.mode == "button" && data.id != null && data.press_type == "mousedown") {
				
				if (this.cm.button[data.id] == null || this.cm.button[data.id][data.button_name] == null) return;
				
				e.cancelBubble = true;
				
				this.conf.button_last = null; // cancel button click
				
				var menu = this.cm.button[data.id][data.button_name];
				var button = this.w[data.id].b[data.button_name].button;
				
				if (menu.conf.wins_menu_open && this.conf.opened_menu == data.id) {
					menu.hideContextMenu();
				} else {
					this._hideContextMenu();
					menu.showContextMenu(window.dhx4.absLeft(button), window.dhx4.absTop(button)+button.offsetHeight);
					this.conf.opened_menu = data.id;
				}
				menu = button = null;
				
			}
			
		}
		
		this._hideContextMenu = function(e) {
			
			if (e != null) {
				e = e||event;
				if (e.type == "keydown" && e.keyCode != 27) return;
				
				var t = e.target||e.srcElement;
				var m = true;
				while (t != null && m == true) {
					if (t.className != null && t.className.search(/SubLevelArea_Polygon/) >= 0) {
						m = false;
					} else {
						t = t.parentNode;
					}
				}
			}
			
			if (m || e == null) {
				if (that.cm.global != null) that.cm.global.hideContextMenu();
				for (var a in that.cm.icon) {
					if (that.cm.icon[a] != null) that.cm.icon[a].hideContextMenu();
				}
				for (var a in that.cm.button) {
					for (var b in that.cm.button[a]) {
						if (that.cm.button[a][b] != null) that.cm.button[a][b].hideContextMenu();
					}
				}
			}
			
		}
		
		this._detachContextMenu = function(mode, wId, bId) {
			if (this.cm == null) return;
			if (wId == null) {
				if (this.cm.global != null) {
					this.cm.global.unload();
					this.cm.global = null;
				}
			} else if (mode == "icon") {
				if (this.cm.icon[wId] != null) {
					this.cm.icon[wId].unload();
					this.cm.icon[wId] = null;
				}
			} else if (mode == "button") {
				if (this.cm.button[wId] != null && this.cm.button[wId][bId] != null) {
					this.cm.button[wId][bId].unload();
					this.cm.button[wId][bId] = null;
				}
			}
			
		}
		
		this.attachEvent("_winMouseDown", this._showContextMenu);
		
		if (typeof(window.addEventListener) == "function") {
			window.addEventListener("mousedown", this._hideContextMenu, false);
			window.addEventListener("keydown", this._hideContextMenu, false);
		} else {
			document.body.attachEvent("onmousedown", this._hideContextMenu);
			document.body.attachEvent("onkeydown", this._hideContextMenu);
		}
		
		this._unloadContextMenu = function() {
			
			// remove only global menu if any, other will removed from win/button unload
			this._detachContextMenu("icon", null, null);
			this.cm = null;
			
			if (typeof(window.addEventListener) == "function") {
				window.removeEventListener("mousedown", this._hideContextMenu, false);
				window.removeEventListener("keydown", this._hideContextMenu, false);
			} else {
				document.body.detachEvent("onmousedown", this._hideContextMenu);
				document.body.detachEvent("onkeydown", this._hideContextMenu);
			}
			
			that = null;
		}
		
	}
	
	return menu;
};


/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

if(!window.dhtmlx)
	window.dhtmlx = {};

(function(){
	var _dhx_msg_cfg = null;
	function callback(config, result){
			var usercall = config.callback;
			modality(false);
			config.box.parentNode.removeChild(config.box);
			_dhx_msg_cfg = config.box = null;
			if (usercall)
				usercall(result);
	}
	function modal_key(e){
		if (_dhx_msg_cfg){
			e = e||event;
			var code = e.which||event.keyCode;
			if (dhtmlx.message.keyboard){
				if (code == 13 || code == 32)
					callback(_dhx_msg_cfg, true);
				if (code == 27)
					callback(_dhx_msg_cfg, false);
			}
			if (e.preventDefault)
				e.preventDefault();
			return !(e.cancelBubble = true);
		}
	}
	if (document.attachEvent)
		document.attachEvent("onkeydown", modal_key);
	else
		document.addEventListener("keydown", modal_key, true);
		
	function modality(mode){
		if(!modality.cover){
			modality.cover = document.createElement("DIV");
			//necessary for IE only
			modality.cover.onkeydown = modal_key;
			modality.cover.className = "dhx_modal_cover";
			document.body.appendChild(modality.cover);
		}
		var height =  document.body.scrollHeight;
		modality.cover.style.display = mode?"inline-block":"none";
	}

	function button(text, result){
		return "<div class='dhtmlx_popup_button' result='"+result+"' ><div>"+text+"</div></div>";
	}

	function info(text){
		if (!t.area){
			t.area = document.createElement("DIV");
			t.area.className = "dhtmlx_message_area";
			t.area.style[t.position]="15px";
			document.body.appendChild(t.area);
		}

		t.hide(text.id);
		var message = document.createElement("DIV");
		message.innerHTML = "<div>"+text.text+"</div>";
		message.className = "dhtmlx-info dhtmlx-" + text.type;
		message.onclick = function(){
			if (text) t.hide(text.id);
			text = null;
		};

		if (t.position == "bottom" && t.area.firstChild)
			t.area.insertBefore(message,t.area.firstChild);
		else
			t.area.appendChild(message);
		
		if (text.expire > 0)
			t.timers[text.id]=window.setTimeout(function(){
				t.hide(text.id);
			}, text.expire);

		t.pull[text.id] = message;
		message = null;

		return text.id;
	}
	function _boxStructure(config, ok, cancel){
		var box = document.createElement("DIV");
		box.className = " dhtmlx_modal_box dhtmlx-"+config.type;
		box.setAttribute("dhxbox", 1);
			
		var inner = '';

		if (config.width)
			box.style.width = config.width;
		if (config.height)
			box.style.height = config.height;
		if (config.title)
			inner+='<div class="dhtmlx_popup_title">'+config.title+'</div>';
		inner+='<div class="dhtmlx_popup_text"><span>'+(config.content?'':config.text)+'</span></div><div  class="dhtmlx_popup_controls">';
		if (ok)
			inner += button(config.ok || "OK", true);
		if (cancel)
			inner += button(config.cancel || "Cancel", false);
		if (config.buttons){
			for (var i=0; i<config.buttons.length; i++)
				inner += button(config.buttons[i],i);
		}
		inner += '</div>';
		box.innerHTML = inner;

		if (config.content){
			var node = config.content;
			if (typeof node == "string") 
				node = document.getElementById(node);
			if (node.style.display == 'none')
				node.style.display = "";
			box.childNodes[config.title?1:0].appendChild(node);
		}

		box.onclick = function(e){
			e = e ||event;
			var source = e.target || e.srcElement;
			if (!source.className) source = source.parentNode;
			if (source.className == "dhtmlx_popup_button"){
				var result = source.getAttribute("result");
				result = (result == "true")||(result == "false"?false:result);
				callback(config, result);
			}
		};
		config.box = box;
		if (ok||cancel)
			_dhx_msg_cfg = config;

		return box;
	}
	function _createBox(config, ok, cancel){
		var box = config.tagName ? config : _boxStructure(config, ok, cancel);
		
		if (!config.hidden)
			modality(true);
		document.body.appendChild(box);
		var x = config.left||Math.abs(Math.floor(((window.innerWidth||document.documentElement.offsetWidth) - box.offsetWidth)/2));
		var y = config.top||Math.abs(Math.floor(((window.innerHeight||document.documentElement.offsetHeight) - box.offsetHeight)/2));
		if (config.position == "top")
			box.style.top = "-3px";
		else
			box.style.top = y+'px';
		box.style.left = x+'px';
		//necessary for IE only
		box.onkeydown = modal_key;

		box.focus();
		if (config.hidden)
			dhtmlx.modalbox.hide(box);

		return box;
	}

	function alertPopup(config){
		return _createBox(config, true, false);
	}
	function confirmPopup(config){
		return _createBox(config, true, true);
	}
	function boxPopup(config){
		return _createBox(config);
	}
	function box_params(text, type, callback){
		if (typeof text != "object"){
			if (typeof type == "function"){
				callback = type;
				type = "";
			}
			text = {text:text, type:type, callback:callback };
		}
		return text;
	}
	function params(text, type, expire, id){
		if (typeof text != "object" || !text)
			text = {text:text, type:type, expire:expire, id:id};
		text.id = text.id||t.uid();
		text.expire = text.expire||t.expire;
		return text;
	}
	dhtmlx.alert = function(){
		var text = box_params.apply(this, arguments);
		text.type = text.type || "confirm";
		return alertPopup(text);
	};
	dhtmlx.confirm = function(){
		var text = box_params.apply(this, arguments);
		text.type = text.type || "alert";
		return confirmPopup(text);
	};
	dhtmlx.modalbox = function(){
		var text = box_params.apply(this, arguments);
		text.type = text.type || "alert";
		return boxPopup(text);
	};
	dhtmlx.modalbox.hide = function(node){
		while (node && node.getAttribute && !node.getAttribute("dhxbox"))
			node = node.parentNode;
		if (node){
			node.parentNode.removeChild(node);
			modality(false);
			_dhx_msg_cfg = null;
		}
	};
	var t = dhtmlx.message = function(text, type, expire, id){
		text = params.apply(this, arguments);
		text.type = text.type||"info";

		var subtype = text.type.split("-")[0];
		switch (subtype){
			case "alert":
				return alertPopup(text);
			case "confirm":
				return confirmPopup(text);
			case "modalbox":
				return boxPopup(text);
			default:
				return info(text);
			break;
		}
	};

	t.seed = (new Date()).valueOf();
	t.uid = function(){return t.seed++;};
	t.expire = 4000;
	t.keyboard = true;
	t.position = "top";
	t.pull = {};
	t.timers = {};

	t.hideAll = function(){
		for (var key in t.pull)
			t.hide(key);
	};
	t.hide = function(id){
		var obj = t.pull[id];
		if (obj && obj.parentNode){
			window.setTimeout(function(){
				obj.parentNode.removeChild(obj);
				obj = null;
			},2000);
			obj.className+=" hidden";
			
			if(t.timers[id])
				window.clearTimeout(t.timers[id]);
			delete t.pull[id];
		}
	};
})();

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

(function(){

var dhx = {};

//check some rule, show message as error if rule is not correct
dhx.assert = function(test, message){
	if (!test){
		dhx.assert_error(message);
	}
};

dhx.assert_error = function(message){
	dhx.log("error",message);
	if (dhx.message && typeof message == "string")
		dhx.message({ type:"debug", text:message, expire:-1 });
	if (dhx.debug !== false)
		eval("debugger;");
};

//entry point for analitic scripts
dhx.assert_core_ready = function(){
	if (window.dhx_on_core_ready)	
		dhx_on_core_ready();
};

/*
	Common helpers
*/
dhx.codebase="./";
dhx.name = "Core";

//coding helpers
dhx.clone = function(source){
	var f = dhx.clone._function;
	f.prototype = source;
	return new f();
};
dhx.clone._function = function(){};

//copies methods and properties from source to the target
dhx.extend = function(base, source, force){
	dhx.assert(base,"Invalid mixing target");
	dhx.assert(source,"Invalid mixing source");

	if (base._dhx_proto_wait){
		dhx.PowerArray.insertAt.call(base._dhx_proto_wait, source,1);
		return base;
	}
	
	//copy methods, overwrite existing ones in case of conflict
	for (var method in source)
		if (!base[method] || force)
			base[method] = source[method];
		
	//in case of defaults - preffer top one
	if (source.defaults)
		dhx.extend(base.defaults, source.defaults);
	
	//if source object has init code - call init against target
	if (source.$init)	
		source.$init.call(base);
				
	return base;	
};

//copies methods and properties from source to the target from all levels
dhx.copy = function(source){
	dhx.assert(source,"Invalid mixing target");
	if(arguments.length>1){
		var target = arguments[0];
		source = arguments[1];
	} else 
		var target =  (dhx.isArray(source)?[]:{});

	for (var method in source){
		if(source[method] && typeof source[method] == "object" && !dhx.isDate(source[method])){
			target[method] = (dhx.isArray(source[method])?[]:{});
			dhx.copy(target[method],source[method]);
		}else{
			target[method] = source[method];
		}
	}

	return target;	
};


dhx.single = function(source){ 
	var instance = null;
	var t = function(config){
		if (!instance)
			instance = new source({});
			
		if (instance._reinit)
			instance._reinit.apply(instance, arguments);
		return instance;
	};
	return t;
};

dhx.protoUI = function(){
	if (dhx.debug_proto)
		dhx.log("UI registered: "+arguments[0].name);
		
	var origins = arguments;
	var selfname = origins[0].name;
	
	var t = function(data){
		if (!t)
			return dhx.ui[selfname].prototype;

		var origins = t._dhx_proto_wait;
		if (origins){
			var params = [origins[0]];
			
			for (var i=1; i < origins.length; i++){
				params[i] = origins[i];
				
				if (params[i]._dhx_proto_wait)
					params[i] = params[i].call(dhx, params[i].name);

				if (params[i].prototype && params[i].prototype.name)
					dhx.ui[params[i].prototype.name] = params[i];
			}
			dhx.ui[selfname] = dhx.proto.apply(dhx, params);
			if (t._dhx_type_wait)	
				for (var i=0; i < t._dhx_type_wait.length; i++)
					dhx.Type(dhx.ui[selfname], t._dhx_type_wait[i]);
				
			t = origins = null;	
		}
			
		if (this != dhx)
			return new dhx.ui[selfname](data);
		else 
			return dhx.ui[selfname];
	};
	t._dhx_proto_wait = Array.prototype.slice.call(arguments, 0);
	return dhx.ui[selfname]=t;
};

dhx.proto = function(){
	 
	if (dhx.debug_proto)
		dhx.log("Proto chain:"+arguments[0].name+"["+arguments.length+"]");

	var origins = arguments;
	var compilation = origins[0];
	var has_constructor = !!compilation.$init;
	var construct = [];
	
	dhx.assert(compilation,"Invalid mixing target");
		
	for (var i=origins.length-1; i>0; i--) {
		dhx.assert(origins[i],"Invalid mixing source");
		if (typeof origins[i]== "function")
			origins[i]=origins[i].prototype;
		if (origins[i].$init) 
			construct.push(origins[i].$init);
		if (origins[i].defaults){ 
			var defaults = origins[i].defaults;
			if (!compilation.defaults)
				compilation.defaults = {};
			for (var def in defaults)
				if (dhx.isUndefined(compilation.defaults[def]))
					compilation.defaults[def] = defaults[def];
		}
		if (origins[i].type && compilation.type){
			for (var def in origins[i].type)
				if (!compilation.type[def])
					compilation.type[def] = origins[i].type[def];
		}
			
		for (var key in origins[i]){
			if (!compilation[key])
				compilation[key] = origins[i][key];
		}
	}
	
	if (has_constructor)
		construct.push(compilation.$init);
	
	
	compilation.$init = function(){
		for (var i=0; i<construct.length; i++)
			construct[i].apply(this, arguments);
	};
	var result = function(config){
		this.$ready=[];
		dhx.assert(this.$init,"object without init method");
		this.$init(config);
		if (this._parseSettings)
			this._parseSettings(config, this.defaults);
		for (var i=0; i < this.$ready.length; i++)
			this.$ready[i].call(this);
	};
	result.prototype = compilation;
	
	compilation = origins = null;
	return result;
};
//creates function with specified "this" pointer
dhx.bind=function(functor, object){ 
	return function(){ return functor.apply(object,arguments); };  
};

//loads module from external js file
dhx.require=function(module, callback, master){
	if (typeof module != "string"){
		var count = module.length||0;
		var callback_origin = callback;

		if (!count){
			for (var file in module) count++;
			callback = function(){ count--; if (count === 0) callback_origin.apply(this, arguments); };
			for (var file in module)
				dhx.require(file, callback, master);
		} else {
			callback = function(){
				if (count){
					count--;
					dhx.require(module[module.length - count - 1], callback, master);
				} else 
					return callback_origin.apply(this, arguments);
				
			};
			callback();
		}
		return;
	}

	if (dhx._modules[module] !== true){
		if (module.substr(-4) == ".css") {
			var link = dhx.html.create("LINK",{  type:"text/css", rel:"stylesheet", href:dhx.codebase+module});
			document.head.appendChild(link);
			if (callback)
				callback.call(master||window);
			return;
		}

		var step = arguments[4];

		//load and exec the required module
		if (!callback){
			//sync mode
			dhx.exec( dhx.ajax().sync().get(dhx.codebase+module).responseText );
			dhx._modules[module]=true;
		} else {

			if (!dhx._modules[module]){	//first call
				dhx._modules[module] = [[callback, master]];

				dhx.ajax(dhx.codebase+module, function(text){
					dhx.exec(text);	//evaluate code
					var calls = dhx._modules[module];	//callbacks
					dhx._modules[module] = true;
					for (var i=0; i<calls.length; i++)
						calls[i][0].call(calls[i][1]||window, !i);	//first callback get true as parameter
				});
			} else	//module already loading
				dhx._modules[module].push([callback, master]);
		}
		
	}
};
dhx._modules = {};	//hash of already loaded modules

//evaluate javascript code in the global scoope
dhx.exec=function(code){
	if (window.execScript)	//special handling for IE
		window.execScript(code);
	else window.eval(code);
};

dhx.wrap = function(code, wrap){
	if (!code) return wrap;
	return function(){
		var result = code.apply(this, arguments);
		wrap.apply(this,arguments);
		return result;
	};
};

//check === undefined
dhx.isUndefined=function(a){
	return typeof a == "undefined";
};
//delay call to after-render time
dhx.delay=function(method, obj, params, delay){
	return window.setTimeout(function(){
		var ret = method.apply(obj,(params||[]));
		method = obj = params = null;
		return ret;
	},delay||1);
};

//common helpers

//generates unique ID (unique per window, nog GUID)
dhx.uid = function(){
	if (!this._seed) this._seed=(new Date).valueOf();	//init seed with timestemp
	this._seed++;
	return this._seed;
};
//resolve ID as html object
dhx.toNode = function(node){
	if (typeof node == "string") return document.getElementById(node);
	return node;
};
//adds extra methods for the array
dhx.toArray = function(array){ 
	return dhx.extend((array||[]),dhx.PowerArray, true);
};
//resolve function name
dhx.toFunctor=function(str){ 
	return (typeof(str)=="string") ? eval(str) : str; 
};
/*checks where an object is instance of Array*/
dhx.isArray = function(obj) {
	return Array.isArray?Array.isArray(obj):(Object.prototype.toString.call(obj) === '[object Array]');
};
dhx.isDate = function(obj){
	return obj instanceof Date;
};

//dom helpers

//hash of attached events
dhx._events = {};
//attach event to the DOM element
dhx.event=function(node,event,handler,master){
	node = dhx.toNode(node);
	
	var id = dhx.uid();
	if (master) 
		handler=dhx.bind(handler,master);	
		
	dhx._events[id]=[node,event,handler];	//store event info, for detaching
		
	//use IE's of FF's way of event's attaching
	if (node.addEventListener)
		node.addEventListener(event, handler, false);
	else if (node.attachEvent)
		node.attachEvent("on"+event, handler);

	return id;	//return id of newly created event, can be used in eventRemove
};

//remove previously attached event
dhx.eventRemove=function(id){
	
	if (!id) return;
	dhx.assert(this._events[id],"Removing non-existing event");
		
	var ev = dhx._events[id];
	//browser specific event removing
	if (ev[0].removeEventListener)
		ev[0].removeEventListener(ev[1],ev[2],false);
	else if (ev[0].detachEvent)
		ev[0].detachEvent("on"+ev[1],ev[2]);
		
	delete this._events[id];	//delete all traces
};


//debugger helpers
//anything starting from error or log will be removed during code compression

//add message in the log
dhx.log = function(type,message,details){
	if (arguments.length == 1){
		message = type;
		type = "log";
	}
	/*jsl:ignore*/
	if (window.console && console.log){
		type=type.toLowerCase();
		if (window.console[type])
			window.console[type](message||"unknown error");
		else
			window.console.log(type +": "+message);

		if (details) 
			window.console.log(details);
	}	
	/*jsl:end*/
};
//register rendering time from call point 
dhx.log_full_time = function(name){
	dhx._start_time_log = new Date();
	dhx.log("Timing start ["+name+"]");
	window.setTimeout(function(){
		var time = new Date();
		dhx.log("Timing end ["+name+"]:"+(time.valueOf()-dhx._start_time_log.valueOf())/1000+"s");
	},1);
};
//register execution time from call point
dhx.log_time = function(name){
	var fname = "_start_time_log"+name;
	if (!dhx[fname]){
		dhx[fname] = new Date();
		dhx.log("Info","Timing start ["+name+"]");
	} else {
		var time = new Date();
		dhx.log("Info","Timing end ["+name+"]:"+(time.valueOf()-dhx[fname].valueOf())/1000+"s");
		dhx[fname] = null;
	}
};
dhx.debug_code = function(code){
	code.call(dhx);
};
//event system
dhx.EventSystem={
	$init:function(){
		if (!this._evs_events){
			this._evs_events = {};		//hash of event handlers, name => handler
			this._evs_handlers = {};	//hash of event handlers, ID => handler
			this._evs_map = {};
		}
	},
	//temporary block event triggering
	blockEvent : function(){
		this._evs_events._block = true;
	},
	//re-enable event triggering
	unblockEvent : function(){
		this._evs_events._block = false;
	},
	mapEvent:function(map){
		dhx.extend(this._evs_map, map, true);
	},
	on_setter:function(config){
		if(config){
			for(var i in config){
				if(typeof config[i] == 'function')
					this.attachEvent(i, config[i]);
			}
		}
	},
	//trigger event
	callEvent:function(type,params){
		if (this._evs_events._block) return true;
		
		type = type.toLowerCase();
		var event_stack =this._evs_events[type.toLowerCase()];	//all events for provided name
		var return_value = true;

		if (dhx.debug)	//can slowdown a lot
			dhx.log("info","["+this.name+"] event:"+type,params);
		
		if (event_stack)
			for(var i=0; i<event_stack.length; i++){
				/*
					Call events one by one
					If any event return false - result of whole event will be false
					Handlers which are not returning anything - counted as positive
				*/
				if (event_stack[i].apply(this,(params||[]))===false) return_value=false;
			}
		if (this._evs_map[type] && !this._evs_map[type].callEvent(type,params))
			return_value =	false;
			
		return return_value;
	},
	//assign handler for some named event
	attachEvent:function(type,functor,id){
		dhx.assert(functor, "Invalid event handler for "+type);

		type=type.toLowerCase();
		
		id=id||dhx.uid(); //ID can be used for detachEvent
		functor = dhx.toFunctor(functor);	//functor can be a name of method

		var event_stack=this._evs_events[type]||dhx.toArray();
		//save new event handler
		event_stack.push(functor);
		this._evs_events[type]=event_stack;
		this._evs_handlers[id]={ f:functor,t:type };
		
		return id;
	},
	//remove event handler
	detachEvent:function(id){
		if(!this._evs_handlers[id]){
			return;
		}
		var type=this._evs_handlers[id].t;
		var functor=this._evs_handlers[id].f;
		
		//remove from all collections
		var event_stack=this._evs_events[type];
		event_stack.remove(functor);
		delete this._evs_handlers[id];
	},
	hasEvent:function(type){
		type=type.toLowerCase();
		return this._evs_events[type]?true:false;
	}
};

dhx.extend(dhx, dhx.EventSystem);

//array helper
//can be used by dhx.toArray()
dhx.PowerArray={
	//remove element at specified position
	removeAt:function(pos,len){
		if (pos>=0) this.splice(pos,(len||1));
	},
	//find element in collection and remove it 
	remove:function(value){
		this.removeAt(this.find(value));
	},	
	//add element to collection at specific position
	insertAt:function(data,pos){
		if (!pos && pos!==0) 	//add to the end by default
			this.push(data);
		else {	
			var b = this.splice(pos,(this.length-pos));
  			this[pos] = data;
  			this.push.apply(this,b); //reconstruct array without loosing this pointer
  		}
  	},  	
  	//return index of element, -1 if it doesn't exists
  	find:function(data){ 
  		for (var i=0; i<this.length; i++) 
  			if (data==this[i]) return i; 	
  		return -1; 
  	},
  	//execute some method for each element of array
  	each:function(functor,master){
		for (var i=0; i < this.length; i++)
			functor.call((master||this),this[i]);
	},
	//create new array from source, by using results of functor 
	map:function(functor,master){
		for (var i=0; i < this.length; i++)
			this[i]=functor.call((master||this),this[i]);
		return this;
	}, 
	filter:function(functor, master){
		for (var i=0; i < this.length; i++)
			if (!functor.call((master||this),this[i])){
				this.splice(i,1);
				i--;
			}
		return this;
	}
};

dhx.env = {};

// dhx.env.transform 
// dhx.env.transition
(function(){
	if (navigator.userAgent.indexOf("Mobile")!=-1) 
		dhx.env.mobile = true;
	if (dhx.env.mobile || navigator.userAgent.indexOf("iPad")!=-1 || navigator.userAgent.indexOf("Android")!=-1)
		dhx.env.touch = true;
	if (navigator.userAgent.indexOf('Opera')!=-1)
		dhx.env.isOpera=true;
	else{
		//very rough detection, but it is enough for current goals
		dhx.env.isIE=!!document.all;
		dhx.env.isFF=!document.all;
		dhx.env.isWebKit=(navigator.userAgent.indexOf("KHTML")!=-1);
		dhx.env.isSafari=dhx.env.isWebKit && (navigator.userAgent.indexOf('Mac')!=-1);
	}
	if(navigator.userAgent.toLowerCase().indexOf("android")!=-1)
		dhx.env.isAndroid = true;
	dhx.env.transform = false;
	dhx.env.transition = false;
	var options = {};
	options.names = ['transform', 'transition'];
	options.transform = ['transform', 'WebkitTransform', 'MozTransform', 'OTransform', 'msTransform'];
	options.transition = ['transition', 'WebkitTransition', 'MozTransition', 'OTransition', 'msTransition'];
	
	var d = document.createElement("DIV");
	for(var i=0; i<options.names.length; i++) {
		var coll = options[options.names[i]];
		
		for (var j=0; j < coll.length; j++) {
			if(typeof d.style[coll[j]] != 'undefined'){
				dhx.env[options.names[i]] = coll[j];
				break;
			}
		}
	}
    d.style[dhx.env.transform] = "translate3d(0,0,0)";
    dhx.env.translate = (d.style[dhx.env.transform])?"translate3d":"translate";

	var prefix = ''; // default option
	var cssprefix = false;
	if(dhx.env.isOpera){
		prefix = '-o-';
		cssprefix = "O";
	}
	if(dhx.env.isFF)
		prefix = '-Moz-';
	if(dhx.env.isWebKit)
		prefix = '-webkit-';
	if(dhx.env.isIE)
		prefix = '-ms-';

    dhx.env.transformCSSPrefix = prefix;

	dhx.env.transformPrefix = cssprefix||(dhx.env.transformCSSPrefix.replace(/-/gi, ""));
	dhx.env.transitionEnd = ((dhx.env.transformCSSPrefix == '-Moz-')?"transitionend":(dhx.env.transformPrefix+"TransitionEnd"));
})();


dhx.env.svg = (function(){
		return document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
})();


//html helpers
dhx.html={
	_native_on_selectstart:0,
	denySelect:function(){
		if (!dhx._native_on_selectstart)
			dhx._native_on_selectstart = document.onselectstart;
		document.onselectstart = dhx.html.stopEvent;
	},
	allowSelect:function(){
		if (dhx._native_on_selectstart !== 0){
			document.onselectstart = dhx._native_on_selectstart||null;
		}
		dhx._native_on_selectstart = 0;

	},
	index:function(node){
		var k=0;
		//must be =, it is not a comparation!
		/*jsl:ignore*/
		while (node = node.previousSibling) k++;
		/*jsl:end*/
		return k;
	},
	_style_cache:{},
	createCss:function(rule){
		var text = "";
		for (var key in rule)
			text+= key+":"+rule[key]+";";
		
		var name = this._style_cache[text];
		if (!name){
			name = "s"+dhx.uid();
			this.addStyle("."+name+"{"+text+"}");
			this._style_cache[text] = name;
		}
		return name;
	},
	addStyle:function(rule){
		var style = document.createElement("style");
		style.setAttribute("type", "text/css");
		style.setAttribute("media", "screen"); 
		/*IE8*/
		if (style.styleSheet)
			style.styleSheet.cssText = rule;
		else
			style.appendChild(document.createTextNode(rule));
		document.getElementsByTagName("head")[0].appendChild(style);
	},
	create:function(name,attrs,html){
		attrs = attrs || {};
		var node = document.createElement(name);
		for (var attr_name in attrs)
			node.setAttribute(attr_name, attrs[attr_name]);
		if (attrs.style)
			node.style.cssText = attrs.style;
		if (attrs["class"])
			node.className = attrs["class"];
		if (html)
			node.innerHTML=html;
		return node;
	},
	//return node value, different logic for different html elements
	getValue:function(node){
		node = dhx.toNode(node);
		if (!node) return "";
		return dhx.isUndefined(node.value)?node.innerHTML:node.value;
	},
	//remove html node, can process an array of nodes at once
	remove:function(node){
		if (node instanceof Array)
			for (var i=0; i < node.length; i++)
				this.remove(node[i]);
		else
			if (node && node.parentNode)
				node.parentNode.removeChild(node);
	},
	//insert new node before sibling, or at the end if sibling doesn't exist
	insertBefore: function(node,before,rescue){
		if (!node) return;
		if (before && before.parentNode)
			before.parentNode.insertBefore(node, before);
		else
			rescue.appendChild(node);
	},
	//return custom ID from html element 
	//will check all parents starting from event's target
	locate:function(e,id){
		if (e.tagName)
			var trg = e;
		else {
			e=e||event;
			var trg=e.target||e.srcElement;
		}
		
		while (trg){
			if (trg.getAttribute){	//text nodes has not getAttribute
				var test = trg.getAttribute(id);
				if (test) return test;
			}
			trg=trg.parentNode;
		}	
		return null;
	},
	//returns position of html element on the page
	offset:function(elem) {
		if (elem.getBoundingClientRect) { //HTML5 method
			var box = elem.getBoundingClientRect();
			var body = document.body;
			var docElem = document.documentElement;
			var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
			var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
			var clientTop = docElem.clientTop || body.clientTop || 0;
			var clientLeft = docElem.clientLeft || body.clientLeft || 0;
			var top  = box.top +  scrollTop - clientTop;
			var left = box.left + scrollLeft - clientLeft;
			return { y: Math.round(top), x: Math.round(left) };
		} else { //fallback to naive approach
			var top=0, left=0;
			while(elem) {
				top = top + parseInt(elem.offsetTop,10);
				left = left + parseInt(elem.offsetLeft,10);
				elem = elem.offsetParent;
			}
			return {y: top, x: left};
		}
	},
	//returns relative position of event
	posRelative:function(ev){
		ev = ev || event;
		if (!dhx.isUndefined(ev.offsetX))
			return { x:ev.offsetX, y:ev.offsetY };	//ie, webkit
		else
			return { x:ev.layerX, y:ev.layerY };	//firefox
	},
	//returns position of event
	pos:function(ev){
		ev = ev || event;
        if(ev.pageX || ev.pageY)	//FF, KHTML
            return {x:ev.pageX, y:ev.pageY};
        //IE
        var d  =  ((dhx.env.isIE)&&(document.compatMode != "BackCompat"))?document.documentElement:document.body;
        return {
                x:ev.clientX + d.scrollLeft - d.clientLeft,
                y:ev.clientY + d.scrollTop  - d.clientTop
        };
	},
	//prevent event action
	preventEvent:function(e){
		if (e && e.preventDefault) e.preventDefault();
		return dhx.html.stopEvent(e);
	},
	//stop event bubbling
	stopEvent:function(e){
		(e||event).cancelBubble=true;
		return false;
	},
	//add css class to the node
	addCss:function(node,name){
        node.className+=" "+name;
    },
    //remove css class from the node
    removeCss:function(node,name){
        node.className=node.className.replace(RegExp(" "+name,"g"),"");
    }
};

dhx.ready = function(code){
	if (this._ready) code.call();
	else this._ready_code.push(code);
};
dhx._ready_code = [];

//autodetect codebase folder
(function(){
	var temp = document.getElementsByTagName("SCRIPT");	//current script, most probably
	dhx.assert(temp.length,"Can't locate codebase");
	if (temp.length){
		//full path to script
		temp = (temp[temp.length-1].getAttribute("src")||"").split("/");
		//get folder name
		temp.splice(temp.length-1, 1);
		dhx.codebase = temp.slice(0, temp.length).join("/")+"/";
	}
	dhx.event(window, "load", function(){
		dhx4.callEvent("onReady",[]);
		dhx.delay(function(){
			dhx._ready = true;
			for (var i=0; i < dhx._ready_code.length; i++)
				dhx._ready_code[i].call();
			dhx._ready_code=[];
		});
	});
	
})();

dhx.locale=dhx.locale||{};


dhx.assert_core_ready();


dhx.ready(function(){
	dhx.event(document.body,"click", function(e){
		dhx4.callEvent("onClick",[e||event]);
	});
});


/*DHX:Depend core/bind.js*/
/*DHX:Depend core/dhx.js*/
/*DHX:Depend core/config.js*/
/*
	Behavior:Settings
	
	@export
		customize
		config
*/

/*DHX:Depend core/template.js*/
/*
	Template - handles html templates
*/

/*DHX:Depend core/dhx.js*/

(function(){

var _cache = {};
var newlines = new RegExp("(\\r\\n|\\n)","g");
var quotes = new RegExp("(\\\")","g");

dhx.Template = function(str){
	if (typeof str == "function") return str;
	if (_cache[str])
		return _cache[str];
		
	str=(str||"").toString();			
	if (str.indexOf("->")!=-1){
		str = str.split("->");
		switch(str[0]){
			case "html": 	//load from some container on the page
				str = dhx.html.getValue(str[1]);
				break;
			default:
				//do nothing, will use template as is
				break;
		}
	}
		
	//supported idioms
	// {obj.attr} => named attribute or value of sub-tag in case of xml
	str=(str||"").toString();		
	str=str.replace(newlines,"\\n");
	str=str.replace(quotes,"\\\"");

	str=str.replace(/\{obj\.([^}?]+)\?([^:]*):([^}]*)\}/g,"\"+(obj.$1?\"$2\":\"$3\")+\"");
	str=str.replace(/\{common\.([^}\(]*)\}/g,"\"+(common.$1||'')+\"");
	str=str.replace(/\{common\.([^\}\(]*)\(\)\}/g,"\"+(common.$1?common.$1.apply(this, arguments):\"\")+\"");
	str=str.replace(/\{obj\.([^}]*)\}/g,"\"+(obj.$1)+\"");
	str=str.replace("{obj}","\"+obj+\"");
	str=str.replace(/#([^#'";, ]+)#/gi,"\"+(obj.$1)+\"");

	try {
		_cache[str] = Function("obj","common","return \""+str+"\";");
	} catch(e){
		dhx.assert_error("Invalid template:"+str);
	}

	return _cache[str];
};


dhx.Template.empty=function(){	return "";	};
dhx.Template.bind =function(value){	return dhx.bind(dhx.Template(value),this); };


	/*
		adds new template-type
		obj - object to which template will be added
		data - properties of template
	*/
dhx.Type=function(obj, data){ 
	if (obj._dhx_proto_wait){
		if (!obj._dhx_type_wait)
			obj._dhx_type_wait = [];
				obj._dhx_type_wait.push(data);
		return;
	}
		
	//auto switch to prototype, if name of class was provided
	if (typeof obj == "function")
		obj = obj.prototype;
	if (!obj.types){
		obj.types = { "default" : obj.type };
		obj.type.name = "default";
	}
	
	var name = data.name;
	var type = obj.type;
	if (name)
		type = obj.types[name] = dhx.clone(data.baseType?obj.types[data.baseType]:obj.type);
	
	for(var key in data){
		if (key.indexOf("template")===0)
			type[key] = dhx.Template(data[key]);
		else
			type[key]=data[key];
	}

	return name;
};

})();
/*DHX:Depend core/dhx.js*/

dhx.Settings={
	$init:function(){
		/* 
			property can be accessed as this.config.some
			in same time for inner call it have sense to use _settings
			because it will be minified in final version
		*/
		this._settings = this.config= {}; 
	},
	define:function(property, value){
		if (typeof property == "object")
			return this._parseSeetingColl(property);
		return this._define(property, value);
	},
	_define:function(property,value){
		//method with name {prop}_setter will be used as property setter
		//setter is optional
		var setter = this[property+"_setter"];
		return this._settings[property]=setter?setter.call(this,value,property):value;
	},
	//process configuration object
	_parseSeetingColl:function(coll){
		if (coll){
			for (var a in coll)				//for each setting
				this._define(a,coll[a]);		//set value through config
		}
	},
	//helper for object initialization
	_parseSettings:function(obj,initial){
		//initial - set of default values
		var settings = {}; 
		if (initial)
			settings = dhx.extend(settings,initial);
					
		//code below will copy all properties over default one
		if (typeof obj == "object" && !obj.tagName)
			dhx.extend(settings,obj, true);	
		//call config for each setting
		this._parseSeetingColl(settings);
	},
	_mergeSettings:function(config, defaults){
		for (var key in defaults)
			switch(typeof config[key]){
				case "object": 
					config[key] = this._mergeSettings((config[key]||{}), defaults[key]);
					break;
				case "undefined":
					config[key] = defaults[key];
					break;
				default:	//do nothing
					break;
			}
		return config;
	},

	debug_freid_c_id:true,
	debug_freid_a_name:true
};
/*DHX:Depend core/datastore.js*/
/*DHX:Depend core/load.js*/
/* 
	ajax operations 
	
	can be used for direct loading as
		dhx.ajax(ulr, callback)
	or
		dhx.ajax().item(url)
		dhx.ajax().post(url)

*/

/*DHX:Depend core/dhx.js*/

dhx.ajax = function(url,call,master){
	//if parameters was provided - made fast call
	if (arguments.length!==0){
		var http_request = new dhx.ajax();
		if (master) http_request.master=master;
		return http_request.get(url,null,call);
	}
	if (!this.getXHR) return new dhx.ajax(); //allow to create new instance without direct new declaration
	
	return this;
};
dhx.ajax.count = 0;
dhx.ajax.prototype={
	master:null,
	//creates xmlHTTP object
	getXHR:function(){
		if (dhx.env.isIE)
		 return new ActiveXObject("Microsoft.xmlHTTP");
		else 
		 return new XMLHttpRequest();
	},
	/*
		send data to the server
		params - hash of properties which will be added to the url
		call - callback, can be an array of functions
	*/
	send:function(url,params,call){
		var x=this.getXHR();
		if (!dhx.isArray(call))
			call = [call];
		//add extra params to the url
		if (typeof params == "object"){
			var t=[];
			for (var a in params){
				var value = params[a];
				if (value === null || value === dhx.undefined)
					value = "";
				t.push(a+"="+encodeURIComponent(value));// utf-8 escaping
		 	}
			params=t.join("&");
		}
		if (params && this.request==='GET'){
			url=url+(url.indexOf("?")!=-1 ? "&" : "?")+params;
			params=null;
		}
		
		x.open(this.request,url,!this._sync);
		if (this.request === 'POST')
			x.setRequestHeader('Content-type','application/x-www-form-urlencoded');
		 
		//async mode, define loading callback
		 var self=this;
		 x.onreadystatechange= function(){
			if (!x.readyState || x.readyState == 4){
				if (dhx.debug_time) dhx.log_full_time("data_loading");	//log rendering time
				dhx.ajax.count++;
				if (call && self){
					for (var i=0; i < call.length; i++)	//there can be multiple callbacks
						if (call[i]){
							var method = (call[i].success||call[i]);
							if (x.status >= 400 || (!x.status && !x.responseText))
								method = call[i].error;
							if (method)
								method.call((self.master||self),x.responseText,x.responseXML,x);
						}
				}
				if (self) self.master=null;
				call=self=null;	//anti-leak
			}
		 };
		
		x.send(params||null);
		return x; //return XHR, which can be used in case of sync. mode
	},
	//GET request
	get:function(url,params,call){
		if (arguments.length == 2){
			call = params;
			params = null;
		}
		this.request='GET';
		return this.send(url,params,call);
	},
	//POST request
	post:function(url,params,call){
		this.request='POST';
		return this.send(url,params,call);
	},
	//PUT request
	put:function(url,params,call){
		this.request='PUT';
		return this.send(url,params,call);
	},
	//POST request
	del:function(url,params,call){
		this.request='DELETE';
		return this.send(url,params,call);
	}, 
	sync:function(){
		this._sync = true;
		return this;
	},
	bind:function(master){
		this.master = master;
		return this;
	}
};
/*submits values*/
dhx.send = function(url, values, method, target){
	var form = dhx.html.create("FORM",{
		"target":(target||"_self"),
		"action":url,
		"method":(method||"POST")
	},"");
	for (var k in values) {
		var field = dhx.html.create("INPUT",{"type":"hidden","name": k,"value": values[k]},"");
		form.appendChild(field);
	}
	form.style.display = "none";
	document.body.appendChild(form);
	form.submit();
	document.body.removeChild(form);
};


dhx.AtomDataLoader={
	$init:function(config){
		//prepare data store
		this.data = {}; 
		if (config){
			this._settings.datatype = config.datatype||"json";
			this.$ready.push(this._load_when_ready);
		}
	},
	_load_when_ready:function(){
		this._ready_for_data = true;
		
		if (this._settings.url)
			this.url_setter(this._settings.url);
		if (this._settings.data)
			this.data_setter(this._settings.data);
	},
	url_setter:function(value){
		if (!this._ready_for_data) return value;
		this.load(value, this._settings.datatype);	
		return value;
	},
	data_setter:function(value){
		if (!this._ready_for_data) return value;
		this.parse(value, this._settings.datatype);
		return true;
	},
	debug_freid_c_datatype:true,
	debug_freid_c_dataFeed:true,

	//loads data from external URL
	load:function(url,call){
		if (url.$proxy) {
			url.load(this, typeof call == "string" ? call : "json");
			return;
		}

		this.callEvent("onXLS",[]);
		if (typeof call == "string"){	//second parameter can be a loading type or callback
			//we are not using setDriver as data may be a non-datastore here
			this.data.driver = dhx.DataDriver[call];
			call = arguments[2];
		} else if (!this.data.driver)
			this.data.driver = dhx.DataDriver.json;

		//load data by async ajax call
		//loading_key - can be set by component, to ignore data from old async requests
		var callback = [{
			success: this._onLoad,
			error: this._onLoadError
		}];
		
		if (call){
			if (dhx.isArray(call))
				callback.push.apply(callback,call);
			else
				callback.push(call);
		}
			

		return dhx.ajax(url,callback,this);
	},
	//loads data from object
	parse:function(data,type){
		this.callEvent("onXLS",[]);
		this.data.driver = dhx.DataDriver[type||"json"];
		this._onLoad(data,null);
	},
	//default after loading callback
	_onLoad:function(text,xml,loader,key){
		var driver = this.data.driver;
		var data = driver.toObject(text,xml);
		if (data){
			var top = driver.getRecords(data)[0];
			this.data=(driver?driver.getDetails(top):text);
		} else 
			this._onLoadError(text,xml,loader);

		this.callEvent("onXLE",[]);
	},
	_onLoadError:function(text, xml, xhttp){
		this.callEvent("onXLE",[]);
		this.callEvent("onLoadError",arguments);
		dhx4.callEvent("onLoadError", [text, xml, xhttp, this]);
	},
	_check_data_feed:function(data){
		if (!this._settings.dataFeed || this._ignore_feed || !data) return true;
		var url = this._settings.dataFeed;
		if (typeof url == "function")
			return url.call(this, (data.id||data), data);
		url = url+(url.indexOf("?")==-1?"?":"&")+"action=get&id="+encodeURIComponent(data.id||data);
		this.callEvent("onXLS",[]);
		dhx.ajax(url, function(text,xml,loader){
			this._ignore_feed=true;
			var data = dhx.DataDriver.toObject(text, xml);
			if (data)
				this.setValues(data.getDetails(data.getRecords()[0]));
			else
				this._onLoadError(text,xml,loader);
			this._ignore_feed=false;
			this.callEvent("onXLE",[]);
		}, this);
		return false;
	}
};

/*
	Abstraction layer for different data types
*/

dhx.DataDriver={};
dhx.DataDriver.json={
	//convert json string to json object if necessary
	toObject:function(data){
		if (!data) data="[]";
		if (typeof data == "string"){
			try{
				eval ("dhx.temp="+data);
			} catch(e){
				dhx.assert_error(e);
				return null;
			}
			data = dhx.temp;
		}

		if (data.data){ 
			var t = data.data.config = {};
			for (var key in data)
				if (key!="data")
					t[key] = data[key];
			data = data.data;
		}
			
		return data;
	},
	//get array of records
	getRecords:function(data){
		if (data && !dhx.isArray(data))
		 return [data];
		return data;
	},
	//get hash of properties for single record
	getDetails:function(data){
		if (typeof data == "string")
			return { id:dhx.uid(), value:data };
		return data;
	},
	//get count of data and position at which new data need to be inserted
	getInfo:function(data){
		var cfg = data.config;
		if (!cfg) return {};

		return { 
		 _size:(cfg.total_count||0),
		 _from:(cfg.pos||0),
		 _parent:(cfg.parent||0),
		 _config:(cfg.config),
		 _key:(cfg.dhx_security)
		};
	},
	child:"data"
};

dhx.DataDriver.html={
	/*
		incoming data can be
		 - collection of nodes
		 - ID of parent container
		 - HTML text
	*/
	toObject:function(data){
		if (typeof data == "string"){
		 var t=null;
		 if (data.indexOf("<")==-1)	//if no tags inside - probably its an ID
			t = dhx.toNode(data);
		 if (!t){
			t=document.createElement("DIV");
			t.innerHTML = data;
		 }
		 
		 return t.getElementsByTagName(this.tag);
		}
		return data;
	},
	//get array of records
	getRecords:function(node){
		var data = [];
		for (var i=0; i<node.childNodes.length; i++){
			var child = node.childNodes[i];
			if (child.nodeType == 1)
				data.push(child);
		}
		return data;
	},
	//get hash of properties for single record
	getDetails:function(data){
		return dhx.DataDriver.xml.tagToObject(data);
	},
	//dyn loading is not supported by HTML data source
	getInfo:function(data){
		return { 
		 _size:0,
		 _from:0
		};
	},
	tag: "LI"
};

dhx.DataDriver.jsarray={
	//eval jsarray string to jsarray object if necessary
	toObject:function(data){
		if (typeof data == "string"){
		 eval ("dhx.temp="+data);
		 return dhx.temp;
		}
		return data;
	},
	//get array of records
	getRecords:function(data){
		return data;
	},
	//get hash of properties for single record, in case of array they will have names as "data{index}"
	getDetails:function(data){
		var result = {};
		for (var i=0; i < data.length; i++) 
		 result["data"+i]=data[i];
		 
		return result;
	},
	//dyn loading is not supported by js-array data source
	getInfo:function(data){
		return { 
		 _size:0,
		 _from:0
		};
	}
};

dhx.DataDriver.csv={
	//incoming data always a string
	toObject:function(data){
		return data;
	},
	//get array of records
	getRecords:function(data){
		return data.split(this.row);
	},
	//get hash of properties for single record, data named as "data{index}"
	getDetails:function(data){
		data = this.stringToArray(data);
		var result = {};
		for (var i=0; i < data.length; i++) 
		 result["data"+i]=data[i];
		 
		return result;
	},
	//dyn loading is not supported by csv data source
	getInfo:function(data){
		return { 
		 _size:0,
		 _from:0
		};
	},
	//split string in array, takes string surrounding quotes in account
	stringToArray:function(data){
		data = data.split(this.cell);
		for (var i=0; i < data.length; i++)
		 data[i] = data[i].replace(/^[ \t\n\r]*(\"|)/g,"").replace(/(\"|)[ \t\n\r]*$/g,"");
		return data;
	},
	row:"\n",	//default row separator
	cell:","	//default cell separator
};

dhx.DataDriver.xml={
	_isValidXML:function(data){
		if (!data || !data.documentElement)
			return null;
		if (data.getElementsByTagName("parsererror").length)
			return null;
		return data;
	},
	//convert xml string to xml object if necessary
	toObject:function(text,xml){
		if (this._isValidXML(data))
			return data;
		if (typeof text == "string")
			var data = this.fromString(text.replace(/^[\s]+/,""));
		else
			data = text;

		if (this._isValidXML(data))
			return data;
		return null;
	},
	//get array of records
	getRecords:function(data){
		return this.xpath(data,this.records);
	},
	records:"/*/item",
	child:"item",
	config:"/*/config",
	//get hash of properties for single record
	getDetails:function(data){
		return this.tagToObject(data,{});
	},
	//get count of data and position at which new data_loading need to be inserted
	getInfo:function(data){
		
		var config = this.xpath(data, this.config);
		if (config.length)
			config = this.assignTypes(this.tagToObject(config[0],{}));
		else 
			config = null;

		return { 
		 _size:(data.documentElement.getAttribute("total_count")||0),
		 _from:(data.documentElement.getAttribute("pos")||0),
		 _parent:(data.documentElement.getAttribute("parent")||0),
		 _config:config,
		 _key:(data.documentElement.getAttribute("dhx_security")||null)
		};
	},
	//xpath helper
	xpath:function(xml,path){
		if (window.XPathResult){	//FF, KHTML, Opera
		 var node=xml;
		 if(xml.nodeName.indexOf("document")==-1)
		 xml=xml.ownerDocument;
		 var res = [];
		 var col = xml.evaluate(path, node, null, XPathResult.ANY_TYPE, null);
		 var temp = col.iterateNext();
		 while (temp){ 
			res.push(temp);
			temp = col.iterateNext();
		}
		return res;
		}	
		else {
			var test = true;
			try {
				if (typeof(xml.selectNodes)=="undefined")
					test = false;
			} catch(e){ /*IE7 and below can't operate with xml object*/ }
			//IE
			if (test)
				return xml.selectNodes(path);
			else {
				//Google hate us, there is no interface to do XPath
				//use naive approach
				var name = path.split("/").pop();
				return xml.getElementsByTagName(name);
			}
		}
	},
	assignTypes:function(obj){
		for (var k in obj){
			var test = obj[k];
			if (typeof test == "object")
				this.assignTypes(test);
			else if (typeof test == "string"){
				if (test === "") 
					continue;
				if (test == "true")
					obj[k] = true;
				else if (test == "false")
					obj[k] = false;
				else if (test == test*1)
					obj[k] = obj[k]*1;
			}
		}
		return obj;
	},
	//convert xml tag to js object, all subtags and attributes are mapped to the properties of result object
	tagToObject:function(tag,z){
		z=z||{};
		var flag=false;
				
		//map attributes
		var a=tag.attributes;
		if(a && a.length){
			for (var i=0; i<a.length; i++)
		 		z[a[i].name]=a[i].value;
		 	flag = true;
	 	}
		//map subtags
		
		var b=tag.childNodes;
		var state = {};
		for (var i=0; i<b.length; i++){
			if (b[i].nodeType==1){
				var name = b[i].tagName;
				if (typeof z[name] != "undefined"){
					if (!dhx.isArray(z[name]))
						z[name]=[z[name]];
					z[name].push(this.tagToObject(b[i],{}));
				}
				else
					z[b[i].tagName]=this.tagToObject(b[i],{});	//sub-object for complex subtags
				flag=true;
			}
		}
		
		if (!flag)
			return this.nodeValue(tag);
		//each object will have its text content as "value" property
		z.value = z.value||this.nodeValue(tag);
		return z;
	},
	//get value of xml node 
	nodeValue:function(node){
		if (node.firstChild)
		 return node.firstChild.data;	//FIXME - long text nodes in FF not supported for now
		return "";
	},
	//convert XML string to XML object
	fromString:function(xmlString){
		try{
			if (window.DOMParser)		// FF, KHTML, Opera
				return (new DOMParser()).parseFromString(xmlString,"text/xml");
			if (window.ActiveXObject){	// IE, utf-8 only 
				var temp=new ActiveXObject("Microsoft.xmlDOM");
				temp.loadXML(xmlString);
				return temp;
			}
		} catch(e){
			dhx.assert_error(e);
			return null;
		}
		dhx.assert_error("Load from xml string is not supported");
	}
};

/*DHX:Depend core/dhx.js*/

/*
	Behavior:DataLoader - load data in the component
	
	@export
		load
		parse
*/
dhx.DataLoader=dhx.proto({
	$init:function(config){
		//prepare data store
		config = config || "";
		
		//list of all active ajax requests
		this._ajax_queue = dhx.toArray();

		this.data = new dhx.DataStore();
		this.data.attachEvent("onClearAll",dhx.bind(this._call_onclearall,this));
		this.data.attachEvent("onServerConfig", dhx.bind(this._call_on_config, this));
		this.data.feed = this._feed;

	},

	_feed:function(from,count,callback){
				//allow only single request at same time
				if (this._load_count)
					return this._load_count=[from,count,callback];	//save last ignored request
				else
					this._load_count=true;
				this._feed_last = [from, count];
				this._feed_common.call(this, from, count, callback);
	},
	_feed_common:function(from, count, callback){
		var url = this.data.url;
		if (from<0) from = 0;
		this.load(url+((url.indexOf("?")==-1)?"?":"&")+(this.dataCount()?("continue=true&"):"")+"start="+from+"&count="+count,[
			this._feed_callback,
			callback
		]);
	},
	_feed_callback:function(){
		//after loading check if we have some ignored requests
		var temp = this._load_count;
		var last = this._feed_last;
		this._load_count = false;
		if (typeof temp =="object" && (temp[0]!=last[0] || temp[1]!=last[1]))
			this.data.feed.apply(this, temp);	//load last ignored request
	},
	//loads data from external URL
	load:function(url,call){
		var ajax = dhx.AtomDataLoader.load.apply(this, arguments);
		this._ajax_queue.push(ajax);

		//prepare data feed for dyn. loading
		if (!this.data.url)
			this.data.url = url;
	},
	//load next set of data rows
	loadNext:function(count, start, callback, url, now){
		if (this._settings.datathrottle && !now){
			if (this._throttle_request)
				window.clearTimeout(this._throttle_request);
			this._throttle_request = dhx.delay(function(){
				this.loadNext(count, start, callback, url, true);
			},this, 0, this._settings.datathrottle);
			return;
		}

		if (!start && start !== 0) start = this.dataCount();
		this.data.url = this.data.url || url;

		if (this.callEvent("onDataRequest", [start,count,callback,url]) && this.data.url)
			this.data.feed.call(this, start, count, callback);
	},
	_maybe_loading_already:function(count, from){
		var last = this._feed_last;
		if(this._load_count && last){
			if (last[0]<=from && (last[1]+last[0] >= count + from )) return true;
		}
		return false;
	},
	//default after loading callback
	_onLoad:function(text,xml,loader){
		//ignore data loading command if data was reloaded 
		this._ajax_queue.remove(loader);

		var data = this.data.driver.toObject(text,xml);
		if (data) 
			this.data._parse(data);
		else
			return this._onLoadError(text, xml, loader);
		
		//data loaded, view rendered, call onready handler
		this._call_onready();

		this.callEvent("onXLE",[]);
	},
	removeMissed_setter:function(value){
		return this.data._removeMissed = value;
	},
	scheme_setter:function(value){
		this.data.scheme(value);
	},	
	dataFeed_setter:function(value){
		this.data.attachEvent("onBeforeFilter", dhx.bind(function(text, value){
			if (this._settings.dataFeed){

				var filter = {};				
				if (!text && !value) return;
				if (typeof text == "function"){
					if (!value) return;
					text(value, filter);
				} else 
					filter = { text:value };

				this.clearAll();
				var url = this._settings.dataFeed;
				var urldata = [];
				if (typeof url == "function")
					return url.call(this, value, filter);
				for (var key in filter)
					urldata.push("dhx_filter["+key+"]="+encodeURIComponent(filter[key]));
				this.load(url+(url.indexOf("?")<0?"?":"&")+urldata.join("&"), this._settings.datatype);
				return false;
			}
		},this));
		return value;
	},

	debug_freid_c_ready:true,
	debug_freid_c_datathrottle:true,
	
	_call_onready:function(){
		if (this._settings.ready && !this._ready_was_used){
			var code = dhx.toFunctor(this._settings.ready);
			if (code)
				dhx.delay(code, this, arguments);
			this._ready_was_used = true;
		}
	},
	_call_onclearall:function(){
		for (var i = 0; i < this._ajax_queue.length; i++)
			this._ajax_queue[i].abort();

		this._ajax_queue = dhx.toArray();
	},
	_call_on_config:function(config){
		this._parseSeetingColl(config);
	}
},dhx.AtomDataLoader);


/*
	DataStore is not a behavior, it standalone object, which represents collection of data.
	Call provideAPI to map data API

	@export
		exists
		idByIndex
		indexById
		get
		set
		refresh
		dataCount
		sort
		filter
		next
		previous
		clearAll
		first
		last
*/
dhx.DataStore = function(){
	this.name = "DataStore";
	
	dhx.extend(this, dhx.EventSystem);

	this.setDriver("json");	//default data source is an
	this.pull = {};						//hash of IDs
	this.order = dhx.toArray();		//order of IDs
	this._marks = {};
};

dhx.DataStore.prototype={
	//defines type of used data driver
	//data driver is an abstraction other different data formats - xml, json, csv, etc.
	setDriver:function(type){
		dhx.assert(dhx.DataDriver[type],"incorrect DataDriver");
		this.driver = dhx.DataDriver[type];
	},
	//process incoming raw data
	_parse:function(data,master){
		this.callEvent("onParse", [this.driver, data]);
		if (this._filter_order)
			this.filter();
			
		//get size and position of data
		var info = this.driver.getInfo(data);
		if (info._key)
			dhx.securityKey = info._key;
		if (info._config)
			this.callEvent("onServerConfig",[info._config]);

		//get array of records
		var recs = this.driver.getRecords(data);

		this._inner_parse(info, recs);

		//in case of tree store we may want to group data
		if (this._scheme_group && this._group_processing)
			this._group_processing(this._scheme_group);

		//optional data sorting
		if (this._scheme_sort){
			this.blockEvent();
			this.sort(this._scheme_sort);
			this.unblockEvent();
		}
		this.callEvent("onStoreLoad",[this.driver, data]);
		//repaint self after data loading
		this.refresh();
	},
	_inner_parse:function(info, recs){
		var from = (info._from||0)*1;
		var subload = true;
		var marks = false;

		if (from === 0 && this.order[0]){ //update mode
			if (this._removeMissed){
				//update mode, create kill list
				marks = {};
				for (var i=0; i<this.order.length; i++)
					marks[this.order[i]]=true;
			}
			
			subload = false;
			from = this.order.length;
		}

		var j=0;
		for (var i=0; i<recs.length; i++){
			//get hash of details for each record
			var temp = this.driver.getDetails(recs[i]);
			var id = this.id(temp); 	//generate ID for the record
			if (!this.pull[id]){		//if such ID already exists - update instead of insert
				this.order[j+from]=id;	
				j++;
			} else if (subload && this.order[j+from])
				j++;

			if(this.pull[id]){
				dhx.extend(this.pull[id],temp,true);//add only new properties
				if (this._scheme_update)
					this._scheme_update(this.pull[id]);
				//update mode, remove item from kill list
				if (marks)
					delete marks[id];
			} else{
				this.pull[id] = temp;
				if (this._scheme_init)
					this._scheme_init(temp);
			}
			
		}

		//update mode, delete items which are not existing in the new xml
		if (marks){
			this.blockEvent();
			for (var delid in marks)
				this.remove(delid);
			this.unblockEvent();
		}

		if (!this.order[info._size-1])
			this.order[info._size-1] = dhx.undefined;
	},
	//generate id for data object
	id:function(data){
		return data.id||(data.id=dhx.uid());
	},
	changeId:function(old, newid){
		//dhx.assert(this.pull[old],"Can't change id, for non existing item: "+old);
		if(this.pull[old])
			this.pull[newid] = this.pull[old];
		this.pull[newid].id = newid;
		this.order[this.order.find(old)]=newid;
		if (this._filter_order)
			this._filter_order[this._filter_order.find(old)]=newid;
		if (this._marks[old]){
			this._marks[newid] = this._marks[old];
			delete this._marks[old];
		}


		this.callEvent("onIdChange", [old, newid]);
		if (this._render_change_id)
			this._render_change_id(old, newid);
		delete this.pull[old];
	},
	//get data from hash by id
	item:function(id){
		return this.pull[id];
	},
	//assigns data by id
	update:function(id,data){
		if (dhx.isUndefined(data)) data = this.item(id);
		if (this._scheme_update)
			this._scheme_update(data);
		if (this.callEvent("onBeforeUpdate", [id, data]) === false) return false;
		this.pull[id]=data;
		this.callEvent("onStoreUpdated",[id, data, "update"]);
	},
	//sends repainting signal
	refresh:function(id){
		if (this._skip_refresh) return; 
		
		if (id)
			this.callEvent("onStoreUpdated",[id, this.pull[id], "paint"]);
		else
			this.callEvent("onStoreUpdated",[null,null,null]);
	},
	silent:function(code, master){
		this._skip_refresh = true;
		code.call(master||this);
		this._skip_refresh = false;
	},
	//converts range IDs to array of all IDs between them
	getRange:function(from,to){		
		//if some point is not defined - use first or last id
		//BEWARE - do not use empty or null ID
		if (from)
			from = this.indexById(from);
		else 
			from = (this.$min||this.startOffset)||0;
		if (to)
			to = this.indexById(to);
		else {
			to = Math.min(((this.$max||this.endOffset)||Infinity),(this.dataCount()-1));
			if (to<0) to = 0; //we have not data in the store
		}

		if (from>to){ //can be in case of backward shift-selection
			var a=to; to=from; from=a;
		}

		return this.getIndexRange(from,to);
	},
	//converts range of indexes to array of all IDs between them
	getIndexRange:function(from,to){
		to=Math.min((to||Infinity),this.dataCount()-1);
		
		var ret=dhx.toArray(); //result of method is rich-array
		for (var i=(from||0); i <= to; i++)
			ret.push(this.item(this.order[i]));
		return ret;
	},
	//returns total count of elements
	dataCount:function(){
		return this.order.length;
	},
	//returns truy if item with such ID exists
	exists:function(id){
		return !!(this.pull[id]);
	},
	//nextmethod is not visible on component level, check DataMove.move
	//moves item from source index to the target index
	move:function(sindex,tindex){
		dhx.assert(sindex>=0 && tindex>=0, "DataStore::move","Incorrect indexes");

		var id = this.idByIndex(sindex);
		var obj = this.item(id);
		
		this.order.removeAt(sindex);	//remove at old position
		//if (sindex<tindex) tindex--;	//correct shift, caused by element removing
		this.order.insertAt(id,Math.min(this.order.length, tindex));	//insert at new position
		
		//repaint signal
		this.callEvent("onStoreUpdated",[id,obj,"move"]);
	},
	scheme:function(config){
		this._scheme = {};
		this._scheme_init = config.$init;
		this._scheme_update = config.$update;
		this._scheme_serialize = config.$serialize;
		this._scheme_group = config.$group;
		this._scheme_sort = config.$sort;

		//ignore $-starting properties, as they have special meaning
		for (var key in config)
			if (key.substr(0,1) != "$")
				this._scheme[key] = config[key];
	},
	sync:function(source, filter, silent){
		if (typeof source == "string")
			source = $$("source");

		if (typeof filter != "function"){
			silent = filter;
			filter = null;
		}
		
		if (dhx.debug_bind){
			this.debug_sync_master = source; 
			dhx.log("[sync] "+this.debug_bind_master.name+"@"+this.debug_bind_master._settings.id+" <= "+this.debug_sync_master.name+"@"+this.debug_sync_master._settings.id);
		}

		this._backbone_source = false;
		if (source.name != "DataStore"){
			if (source.data && source.data.name == "DataStore")
				source = source.data;
			else
				this._backbone_source = true;
		}

		
		var	sync_logic = dhx.bind(function(mode, record, data){
			if (this._backbone_source){
				//ignore first call for backbone sync
				if (!mode) return; 
				//data changing
				if (mode.indexOf("change") === 0){
					if (mode == "change"){
						this.pull[record.id] = record.attributes;
						this.refresh(record.id);
						return;
					} else return;	//ignoring property change event
				}

				//we need to access global model, it has different position for different events
				if (mode == "reset")
					data = record;
				//fill data collections from backbone model
				this.order = []; this.pull = {};
				this._filter_order = null;
				for (var i=0; i<data.models.length; i++){
					var id = data.models[i].id;
					this.order.push(id);
					this.pull[id] = data.models[i].attributes;
				}
			} else {
				this._filter_order = null;
				this.order = dhx.toArray([].concat(source.order));
				this.pull = source.pull;
			}
			
			
			if (filter)
				this.silent(filter);
			
			if (this._on_sync)
				this._on_sync();
			if (dhx.debug_bind)
				dhx.log("[sync:request] "+this.debug_sync_master.name+"@"+this.debug_sync_master._settings.id + " <= "+this.debug_bind_master.name+"@"+this.debug_bind_master._settings.id);
			this.callEvent("onSyncApply",[]);
			if (!silent) 
				this.refresh();
			else
				silent = false;
		}, this);

		if (this._backbone_source)
			source.bind('all', sync_logic);
		else
			this._sync_events = [
				source.attachEvent("onStoreUpdated", sync_logic),
				source.attachEvent("onIdChange", dhx.bind(function(old, nid){ this.changeId(old, nid); }, this))
			];

		sync_logic();
	},
	//adds item to the store
	add:function(obj,index){
		//default values		
		if (this._scheme)
			for (var key in this._scheme)
				if (dhx.isUndefined(obj[key]))
					obj[key] = this._scheme[key];
		
		if (this._scheme_init)
			this._scheme_init(obj);
		
		//generate id for the item
		var id = this.id(obj);

		//in case of treetable order is sent as 3rd parameter
		var order = arguments[2]||this.order;
		
		//by default item is added to the end of the list
		var data_size = order.length;
		
		if (dhx.isUndefined(index) || index < 0)
			index = data_size; 
		//check to prevent too big indexes			
		if (index > data_size){
			dhx.log("Warning","DataStore:add","Index of out of bounds");
			index = Math.min(order.length,index);
		}
		if (this.callEvent("onBeforeAdd", [id, obj, index]) === false) return false;

		dhx.assert(!this.exists(id), "Not unique ID");
		
		this.pull[id]=obj;
		order.insertAt(id,index);
		if (this._filter_order){	//adding during filtering
			//we can't know the location of new item in full dataset, making suggestion
			//put at end by default
			var original_index = this._filter_order.length;
			//put at start only if adding to the start and some data exists
			if (!index && this.order.length)
				original_index = 0;

			this._filter_order.insertAt(id,original_index);
		}
		this.callEvent("onAfterAdd",[id,index]);
		//repaint signal
		this.callEvent("onStoreUpdated",[id,obj,"add"]);
		return id;
	},
	
	//removes element from datastore
	remove:function(id){
		//id can be an array of IDs - result of getSelect, for example
		if (dhx.isArray(id)){
			for (var i=0; i < id.length; i++)
				this.remove(id[i]);
			return;
		}
		if (this.callEvent("onBeforeDelete",[id]) === false) return false;
		
		dhx.assert(this.exists(id), "Not existing ID in remove command"+id);

		var obj = this.item(id);	//save for later event
		//clear from collections
		this.order.remove(id);
		if (this._filter_order) 
			this._filter_order.remove(id);
			
		delete this.pull[id];
		if (this._marks[id])
			delete this._marks[id];

		this.callEvent("onAfterDelete",[id]);
		//repaint signal
		this.callEvent("onStoreUpdated",[id,obj,"delete"]);
	},
	//deletes all records in datastore
	clearAll:function(){
		//instead of deleting one by one - just reset inner collections
		this.pull = {};
		this.order = dhx.toArray();
		//this.feed = null;
		this._filter_order = this.url = null;
		this.callEvent("onClearAll",[]);
		this.refresh();
	},
	//converts id to index
	idByIndex:function(index){
		if (index>=this.order.length || index<0)
			dhx.log("Warning","DataStore::idByIndex Incorrect index");
			
		return this.order[index];
	},
	//converts index to id
	indexById:function(id){
		var res = this.order.find(id);	//slower than idByIndex
		
		if (!this.pull[id])
			dhx.log("Warning","DataStore::indexById Non-existing ID: "+ id);
			
		return res;
	},
	//returns ID of next element
	next:function(id,step){
		return this.order[this.indexById(id)+(step||1)];
	},
	//returns ID of first element
	first:function(){
		return this.order[0];
	},
	//returns ID of last element
	last:function(){
		return this.order[this.order.length-1];
	},
	//returns ID of previous element
	previous:function(id,step){
		return this.order[this.indexById(id)-(step||1)];
	},
	/*
		sort data in collection
			by - settings of sorting
		
		or
		
			by - sorting function
			dir - "asc" or "desc"
			
		or
		
			by - property
			dir - "asc" or "desc"
			as - type of sortings
		
		Sorting function will accept 2 parameters and must return 1,0,-1, based on desired order
	*/
	sort:function(by, dir, as){
		var sort = by;	
		if (typeof by == "function")
			sort = {as:by, dir:dir};
		else if (typeof by == "string")
			sort = {by:by.replace(/#/g,""), dir:dir, as:as};

		
		var parameters = [sort.by, sort.dir, sort.as];
		if (!this.callEvent("onBeforeSort",parameters)) return;	
		
		this._sort_core(sort);
		
		//repaint self
		this.refresh();
		
		this.callEvent("onAfterSort",parameters);
	},
	_sort_core:function(sort){
		if (this.order.length){
			var sorter = this._sort._create(sort);
			//get array of IDs
			var neworder = this.getRange(this.first(), this.last());
			neworder.sort(sorter);
			this.order = neworder.map(function(obj){ 
				dhx.assert(obj, "Client sorting can't be used with dynamic loading");
				return this.id(obj);
			},this);
		}
	},
	/*
		Filter datasource
		
		text - property, by which filter
		value - filter mask
		
		or
		
		text  - filter method
		
		Filter method will receive data object and must return true or false
	*/
	_filter_reset:function(preserve){
		//remove previous filtering , if any
		if (this._filter_order && !preserve){
			this.order = this._filter_order;
			delete this._filter_order;
		}
	},
	_filter_core:function(filter, value, preserve){
		var neworder = dhx.toArray();
		for (var i=0; i < this.order.length; i++){
			var id = this.order[i];
			if (filter(this.item(id),value))
				neworder.push(id);
		}
		//set new order of items, store original
		if (!preserve ||  !this._filter_order)
			this._filter_order = this.order;
		this.order = neworder;
	},
	filter:function(text,value,preserve){
		if (!this.callEvent("onBeforeFilter", [text, value])) return;
		
		this._filter_reset(preserve);
		if (!this.order.length) return;
		
		//if text not define -just unfilter previous state and exit
		if (text){
			var filter = text;
			value = value||"";
			if (typeof text == "string"){
				text = text.replace(/#/g,"");
				if (typeof value == "function")
					filter = function(obj){
						return value(obj[text]);
					};
				else{
					value = value.toString().toLowerCase();
					filter = function(obj,value){	//default filter - string start from, case in-sensitive
						dhx.assert(obj, "Client side filtering can't be used with dynamic loading");
						return (obj[text]||"").toString().toLowerCase().indexOf(value)!=-1;
					};
				}
			}
			
			this._filter_core(filter, value, preserve, this._filterMode);
		}
		//repaint self
		this.refresh();
		
		this.callEvent("onAfterFilter", []);
	},
	/*
		Iterate through collection
	*/
	each:function(method,master){
		for (var i=0; i<this.order.length; i++)
			method.call((master||this), this.item(this.order[i]));
	},
	_methodPush:function(object,method){
		return function(){ return object[method].apply(object,arguments); };
	},

	addMark:function(id, mark, css, value){
		var obj = this._marks[id]||{};
		this._marks[id] = obj;
		if (!obj[mark]){
			obj[mark] = value||true;	
			if (css){
				this.item(id).$css = (this.item(id).$css||"")+" "+mark;
				this.refresh(id);
			}
		}
		return obj[mark];
	},
	removeMark:function(id, mark, css){
		var obj = this._marks[id];
		if (obj && obj[mark])
			delete obj[mark];
		if (css){
			var current_css = this.item(id).$css;
			if (current_css){
				this.item(id).$css = current_css.replace(mark, "");
				this.refresh(id);
			}
		}
	},
	hasMark:function(id, mark){
		var obj = this._marks[id];
		return (obj && obj[mark]);
	},
	/*
		map inner methods to some distant object
	*/
	provideApi:function(target,eventable){
		this.debug_bind_master = target;
			
		if (eventable){
			this.mapEvent({
				onbeforesort:	target,
				onaftersort:	target,
				onbeforeadd:	target,
				onafteradd:		target,
				onbeforedelete:	target,
				onafterdelete:	target,
				onbeforeupdate: target/*,
				onafterfilter:	target,
				onbeforefilter:	target*/
			});
		}
			
		var list = ["sort","add","remove","exists","idByIndex","indexById","item","update","refresh","dataCount","filter","next","previous","clearAll","first","last","serialize","sync","addMark","removeMark","hasMark"];
		for (var i=0; i < list.length; i++)
			target[list[i]] = this._methodPush(this,list[i]);
			
	},
	/*
		serializes data to a json object
	*/
	serialize: function(){
		var ids = this.order;
		var result = [];
		for(var i=0; i< ids.length;i++) {
			var el = this.pull[ids[i]];
			if (this._scheme_serialize){
				el = this._scheme_serialize(el);
				if (el===false) continue;
			}
			result.push(el);
		}
		return result;
	},

	_sort:{
		_create:function(config){
			return this._dir(config.dir, this._by(config.by, config.as));
		},
		_as:{
			"date":function(a,b){
				a=a-0; b=b-0;
				return a>b?1:(a<b?-1:0);
			},
			"int":function(a,b){
				a = a*1; b=b*1;
				return a>b?1:(a<b?-1:0);
			},
			"string_strict":function(a,b){
				a = a.toString(); b=b.toString();
				return a>b?1:(a<b?-1:0);
			},
			"string":function(a,b){
				if (!b) return 1;
				if (!a) return -1;
				
				a = a.toString().toLowerCase(); b=b.toString().toLowerCase();
				return a>b?1:(a<b?-1:0);
			}
		},
		_by:function(prop, method){
			if (!prop)
				return method;
			if (typeof method != "function")
				method = this._as[method||"string"];

			dhx.assert(method, "Invalid sorting method");
			return function(a,b){
				return method(a[prop],b[prop]);
			};
		},
		_dir:function(prop, method){
			if (prop == "asc" || !prop)
				return method;
			return function(a,b){
				return method(a,b)*-1;
			};
		}
	}
};




//UI interface
dhx.BaseBind = {
	debug_freid_ignore:{
		"id":true
	},
	
	bind:function(target, rule, format){
		if (typeof target == 'string')
			target = dhx.ui.get(target);
			
		if (target._initBindSource) target._initBindSource();
		if (this._initBindSource) this._initBindSource();

		
			
		if (!target.getBindData)
			dhx.extend(target, dhx.BindSource);
		if (!this._bind_ready){
			var old_render = this.render;
			if (this.filter){
				var key = this._settings.id;
				this.data._on_sync = function(){
					target._bind_updated[key] = false;
				};
			}
			this.render = function(){
				if (this._in_bind_processing) return;
				
				this._in_bind_processing = true;
				var result = this.callEvent("onBindRequest");
				this._in_bind_processing = false;
				
				return old_render.apply(this, ((result === false)?arguments:[]));
			};
			if (this.getValue||this.getValues)
				this.save = function(){
					if (this.validate && !this.validate()) return;
					target.setBindData((this.getValue?this.getValue:this.getValues()),this._settings.id);
				};
			this._bind_ready = true;
		}
		target.addBind(this._settings.id, rule, format);
		
		if (dhx.debug_bind)
			dhx.log("[bind] "+this.name+"@"+this._settings.id+" <= "+target.name+"@"+target._settings.id);

		var target_id = this._settings.id;
		//FIXME - check for touchable is not the best solution, to detect necessary event
		this.attachEvent(this.touchable?"onAfterRender":"onBindRequest", function(){
			return target.getBindData(target_id);
		});
		//we want to refresh list after data loading if it has master link
		//in same time we do not want such operation for dataFeed components
		//as they are reloading data as response to the master link
		if (!this._settings.dataFeed && this.loadNext)
			this.data.attachEvent("onStoreLoad", function(){
				target._bind_updated[target_id] = false;
			});

		if (this.isVisible(this._settings.id))
			this.refresh();
	},
	unbind:function(target){
		return this._unbind(target);
	},
	_unbind:function(target){
		target.removeBind(this._settings.id);
		var events = (this._sync_events||(this.data?this.data._sync_events:0));
		if (events && target.data)
			for (var i=0; i<events.length; i++)
				target.data.detachEvent(events[i]);
	}
};

//bind interface
dhx.BindSource = {
	$init:function(){
		this._bind_hash = {};		//rules per target
		this._bind_updated = {};	//update flags
		this._ignore_binds = {};
		
		//apply specific bind extension
		this._bind_specific_rules(this);
	},
	saveBatch:function(code){
		this._do_not_update_binds = true;
		code.call(this);
		this._do_not_update_binds = false;
		this._update_binds();
	},
	setBindData:function(data, key){
		if (key)
			this._ignore_binds[key] = true;

		if (dhx.debug_bind)
				dhx.log("[bind:save] "+this.name+"@"+this._settings.id+" <= "+"@"+key);
		if (this.setValue)
			this.setValue(data);
		else if (this.setValues)
			this.setValues(data);
		else {
			var id = this.getCursor();
			if (id){
				data = dhx.extend(this.item(id), data, true);
				this.update(id, data);
			}
		}
		this.callEvent("onBindUpdate", [data, key, id]);
		if (this.save)
			this.save();
		
		if (key)
			this._ignore_binds[key] = false;
	},
	//fill target with data
	getBindData:function(key, update){
		//fire only if we have data updates from the last time
		if (this._bind_updated[key]) return false;
		var target = dhx.ui.get(key);
		//fill target only when it visible
		if (target.isVisible(target._settings.id)){
			this._bind_updated[key] = true;
			if (dhx.debug_bind)
				dhx.log("[bind:request] "+this.name+"@"+this._settings.id+" => "+target.name+"@"+target._settings.id);
			this._bind_update(target, this._bind_hash[key][0], this._bind_hash[key][1]); //trigger component specific updating logic
			if (update && target.filter)
				target.refresh();
		}
	},
	//add one more bind target
	addBind:function(source, rule, format){
		this._bind_hash[source] = [rule, format];
	},
	removeBind:function(source){
		delete this._bind_hash[source];
		delete this._bind_updated[source];
		delete this._ignore_binds[source];
	},
	//returns true if object belong to "collection" type
	_bind_specific_rules:function(obj){
		if (obj.filter)
			dhx.extend(this, dhx.CollectionBind);
		else if (obj.setValue)
			dhx.extend(this, dhx.ValueBind);
		else
			dhx.extend(this, dhx.RecordBind);
	},
	//inform all binded objects, that source data was updated
	_update_binds:function(){
		if (!this._do_not_update_binds)
			for (var key in this._bind_hash){
				if (this._ignore_binds[key]) continue;
				this._bind_updated[key] = false;
				this.getBindData(key, true);
			}
	},
	//copy data from source to the target
	_bind_update_common:function(target, rule, data){
		if (target.setValue)
			target.setValue(data?data[rule]:data);
		else if (!target.filter){
			if (!data && target.clear)
				target.clear();
			else {
				if (target._check_data_feed(data))
					target.setValues(dhx.clone(data));
			}
		} else {
			target.data.silent(function(){
				this.filter(rule,data);
			});
		}
		target.callEvent("onBindApply", [data,rule,this]);
	}
};


//pure data objects
dhx.DataValue = dhx.proto({
	name:"DataValue",
	isVisible:function(){ return true; },
	$init:function(config){ 
		this.data = ""||config; 
		var id = (config&&config.id)?config.id:dhx.uid();
		this._settings = { id:id };
		dhx.ui.views[id] = this;
	},
	setValue:function(value){
		this.data = value;
		this.callEvent("onChange", [value]);
	},
	getValue:function(){
		return this.data;
	},
	refresh:function(){ this.callEvent("onBindRequest"); }
}, dhx.EventSystem, dhx.BaseBind);

dhx.DataRecord = dhx.proto({
	name:"DataRecord",
	isVisible:function(){ return true; },
	$init:function(config){
		this.data = config||{}; 
		var id = (config&&config.id)?config.id:dhx.uid();
		this._settings = { id:id };
		dhx.ui.views[id] = this;
	},
	getValues:function(){
		return this.data;
	},
	setValues:function(data){
		this.data = data;
		this.callEvent("onChange", [data]);
	},
	refresh:function(){ this.callEvent("onBindRequest"); }
}, dhx.EventSystem, dhx.BaseBind, dhx.AtomDataLoader, dhx.Settings);


dhx.DataCollection = dhx.proto({
	name:"DataCollection",
	isVisible:function(){ 
		if (!this.data.order.length && !this.data._filter_order && !this._settings.dataFeed) return false;
		return true; 
	},
	$init:function(config){
		this.data.provideApi(this, true);
		var id = (config&&config.id)?config.id:dhx.uid();
		this._settings.id =id;
		dhx.ui.views[id] = this;
		this.data.attachEvent("onStoreLoad", dhx.bind(function(){
			this.callEvent("onBindRequest",[]);
		}, this));
	},
	refresh:function(){ this.callEvent("onBindRequest",[]); }
}, dhx.DataLoader, dhx.EventSystem, dhx.BaseBind, dhx.Settings);




dhx.ValueBind={
	$init:function(){
		this.attachEvent("onChange", this._update_binds);
	},
	_bind_update:function(target, rule, format){
		var data = this.getValue()||"";
		if (format) data = format(data);
		
		if (target.setValue)
			target.setValue(data);
		else if (!target.filter){
			var pod = {}; pod[rule] = data;
			if (target._check_data_feed(data))
				target.setValues(pod);
		} else{
			target.data.silent(function(){
				this.filter(rule,data);
			});
		}
		target.callEvent("onBindApply", [data,rule,this]);
	}
};

dhx.RecordBind={
	$init:function(){
		this.attachEvent("onChange", this._update_binds);		
	},
	_bind_update:function(target, rule){
		var data = this.getValues()||null;
		this._bind_update_common(target, rule, data);
	}
};

dhx.CollectionBind={
	$init:function(){
		this._cursor = null;
		this.attachEvent("onSelectChange", function(data){
			var sel = this.getSelected();
			this.setCursor(sel?(sel.id||sel):null);
		});
		this.attachEvent("onAfterCursorChange", this._update_binds);		
		this.data.attachEvent("onStoreUpdated", dhx.bind(function(id, data, mode){
			if (id && id == this.getCursor() && mode != "paint")
				this._update_binds();
		},this));
		this.data.attachEvent("onClearAll", dhx.bind(function(){
			this._cursor = null;
		},this));
		this.data.attachEvent("onIdChange", dhx.bind(function(oldid, newid){
			if (this._cursor == oldid)
				this._cursor = newid;
		},this));
	},
	setCursor:function(id){
		if (id == this._cursor || (id !== null && !this.item(id))) return;
		
		this.callEvent("onBeforeCursorChange", [this._cursor]);
		this._cursor = id;
		this.callEvent("onAfterCursorChange",[id]);
	},
	getCursor:function(){
		return this._cursor;
	},
	_bind_update:function(target, rule){ 
		var data = this.item(this.getCursor())|| this._settings.defaultData || null;
		this._bind_update_common(target, rule, data);
	}
};	
/*DHX:Depend core/legacy_bind.js*/
/*DHX:Depend core/dhx.js*/
/*DHX:Depend core/bind.js*/

/*jsl:ignore*/

if (!dhx.ui)
	dhx.ui = {};

if (!dhx.ui.views){
	dhx.ui.views = {};
	dhx.ui.get = function(id){
		if (id._settings) return id;
		return dhx.ui.views[id];
	};
}

if (window.dhtmlx)
	dhtmlx.BaseBind = dhx.BaseBind;

dhtmlXDataStore = function(config){
	var obj = new dhx.DataCollection(config);
	var name = "_dp_init";
	obj[name]=function(dp){
		//map methods
		var varname = "_methods";
		dp[varname]=["dummy","dummy","changeId","dummy"];
		
		this.data._old_names = {
			"add":"inserted",
			"update":"updated",
			"delete":"deleted"
		};
		this.data.attachEvent("onStoreUpdated",function(id,data,mode){
			if (id && !dp._silent)
				dp.setUpdated(id,true,this._old_names[mode]);
		});
		
		
		varname = "_getRowData";
		//serialize item's data in URL
		dp[varname]=function(id,pref){
			var ev=this.obj.data.item(id);
			var data = { id:id };
			data[this.action_param] = this.obj.getUserData(id);
			if (ev)
				for (var a in ev){
						data[a]=ev[a];
				}
			
			return data;
		};

		this.changeId = function(oldid, newid){ 
			this.data.changeId(oldid, newid);	
			dp._silent = true;
			this.data.callEvent("onStoreUpdated", [newid, this.item(newid), "update"]);
			dp._silent = false;
		};	

		varname = "_clearUpdateFlag";
		dp[varname]=function(){};
		this._userdata = {};

	};
	obj.dummy = function(){};
	obj.setUserData=function(id,name,value){
		this._userdata[id]=value;
	};
	obj.getUserData=function(id,name){
		return this._userdata[id];
	};
	obj.dataFeed=function(obj){
		this.define("dataFeed", obj);
	};
	dhx.extend(obj, dhx.BindSource);
	return obj;
};

if (window.dhtmlXDataView)
	dhtmlXDataView.prototype._initBindSource=function(){
		this.isVisible = function(){
			if (!this.data.order.length && !this.data._filter_order && !this._settings.dataFeed) return false;
			return true;
		};
		var settings = "_settings";
		this._settings = this._settings || this[settings];
		if (!this._settings.id)
			this._settings.id = dhx.uid();
		this.unbind = dhx.BaseBind.unbind;
		this.unsync = dhx.BaseBind.unsync;
		dhx.ui.views[this._settings.id] = this;
	};

if (window.dhtmlXChart)
	dhtmlXChart.prototype._initBindSource=function(){
		this.isVisible = function(){
			if (!this.data.order.length && !this.data._filtered_state && !this._settings.dataFeed) return false;
			return true;
		};
		var settings = "_settings";
		this._settings = this._settings || this[settings];
		if (!this._settings.id)
			this._settings.id = dhx.uid();
		this.unbind = dhx.BaseBind.unbind;
		this.unsync = dhx.BaseBind.unsync;
		dhx.ui.views[this._settings.id] = this;
	};
	

dhx.BaseBind.unsync = function(target){
	return dhx.BaseBind._unbind.call(this, target);
}
dhx.BaseBind.unbind = function(target){
	return dhx.BaseBind._unbind.call(this, target);
}
dhx.BaseBind.legacyBind = function(){
	return dhx.BaseBind.bind.apply(this, arguments);
};
dhx.BaseBind.legacySync = function(source, rule){
	if (this._initBindSource) this._initBindSource();
	if (source._initBindSource) source._initBindSource();

	this.attachEvent("onAfterEditStop", function(id){
		this.save(id);
		return true;
	});

		
		

	this.attachEvent("onDataRequest", function(start, count){
		for (var i=start; i<start+count; i++)
			if (!source.data.order[i]){
				source.loadNext(count, start);
				return false;
			}
	});



	this.save = function(id){
		if (!id) id = this.getCursor();
		var sobj = this.item(id);
		var tobj = source.item(id);
		for (var key in sobj)
			if (key.indexOf("$")!==0)
				tobj[key] = sobj[key];
		source.refresh(id);
	};

	if (source && source.name == "DataCollection")
		return source.data.sync.apply(this.data, arguments);
	else
		return this.data.sync.apply(this.data, arguments);
};

if (window.dhtmlXForm){
	
	dhtmlXForm.prototype.bind = function(target){
		dhx.BaseBind.bind.apply(this, arguments);
		target.getBindData(this._settings.id);
	};
	dhtmlXForm.prototype.unbind = function(target){
		dhx.BaseBind._unbind.call(this,target);
	};

	dhtmlXForm.prototype._initBindSource = function(){
		if (dhx.isUndefined(this._settings)){
			this._settings = {
				id: dhx.uid(),
				dataFeed:this._server_feed
			};
			dhx.ui.views[this._settings.id] = this;
		}
	};
	dhtmlXForm.prototype._check_data_feed = function(data){
		if (!this._settings.dataFeed || this._ignore_feed || !data) return true;
		var url = this._settings.dataFeed;
		if (typeof url == "function")
			return url.call(this, (data.id||data), data);
		url = url+(url.indexOf("?")==-1?"?":"&")+"action=get&id="+encodeURIComponent(data.id||data);
		this.load(url);
		return false;
	};
	dhtmlXForm.prototype.setValues = dhtmlXForm.prototype.setFormData;
	dhtmlXForm.prototype.getValues = function(){
		return this.getFormData(false, true);
	};

	dhtmlXForm.prototype.dataFeed = function(value){
		if (this._settings)
			this._settings.dataFeed = value;
		else
			this._server_feed = value;
	};

	dhtmlXForm.prototype.refresh = dhtmlXForm.prototype.isVisible = function(value){
		return true;
	};
}
 
if (window.scheduler){
	if (!window.Scheduler)
		window.Scheduler = {};
	Scheduler.$syncFactory=function(scheduler){
		scheduler.sync = function(source, rule){
			if (this._initBindSource) this._initBindSource();
			if (source._initBindSource) source._initBindSource();

			var process = "_process_loading";
			var insync = function(ignore){
					scheduler.clearAll();
					var order = source.data.order;
					var pull = source.data.pull;
					var evs = [];
					for (var i=0; i<order.length; i++){
						if (rule && rule.copy)
							evs[i]=dhx.clone(pull[order[i]]);
						else
							evs[i]=pull[order[i]];
					}
					scheduler[process](evs);
					scheduler.callEvent("onSyncApply",[]);
			};
			this.save = function(id){
				if (!id) id = this.getCursor();
				var data = this.item(id);
				var olddat = source.item(id);

				if (this.callEvent("onStoreSave", [id, data, olddat])){
					dhx.extend(source.item(id),data, true);
					source.update(id);
				}
			};
			this.item = function(id){
				return this.getEvent(id);
			};
			this._sync_events=[
				source.data.attachEvent("onStoreUpdated", function(id, data, mode){ 
					insync.call(this);
				}),
				source.data.attachEvent("onIdChange", function(oldid, newid){
					combo.changeOptionId(oldid, newid);
				})
			];
			this.attachEvent("onEventChanged", function(id){
				this.save(id);
			});
			this.attachEvent("onEventAdded", function(id, data){
				if (!source.data.pull[id])
				source.add(data);
			});
			this.attachEvent("onEventDeleted", function(id){
				if (source.data.pull[id])
					source.remove(id);
			});
			insync();
		};
		scheduler.unsync = function(target){
			dhx.BaseBind._unbind.call(this,target);
		}
		scheduler._initBindSource = function(){
			if (!this._settings)
				this._settings = { id:dhx.uid() };
		}
	}
	Scheduler.$syncFactory(window.scheduler);
}
if (window.dhtmlXCombo){
	dhtmlXCombo.prototype.bind = function(){
		dhx.BaseBind.bind.apply(this, arguments);
	};
	dhtmlXCombo.prototype.unbind = function(target){
		dhx.BaseBind._unbind.call(this,target);
	}
	dhtmlXCombo.prototype.unsync = function(target){
		dhx.BaseBind._unbind.call(this,target);
	}

	dhtmlXCombo.prototype.dataFeed = function(value){
		if (this._settings)
			this._settings.dataFeed = value;
		else
			this._server_feed = value;
	};

	dhtmlXCombo.prototype.sync = function(source, rule){
		if (this._initBindSource) this._initBindSource();
		if (source._initBindSource) source._initBindSource();


		var combo = this;

		var insync = function(ignore){
			combo.clearAll();
			combo.addOption(this.serialize());

			combo.callEvent("onSyncApply",[]);
		};

		//source.data.attachEvent("onStoreLoad", insync);
		this._sync_events=[
			source.data.attachEvent("onStoreUpdated", function(id, data, mode){ 
				insync.call(this);
			}),
			source.data.attachEvent("onIdChange", function(oldid, newid){
				combo.changeOptionId(oldid, newid);
			})
		];


		insync.call(source);
	};

	dhtmlXCombo.prototype._initBindSource = function() { 
		if (dhx.isUndefined(this._settings)){
			this._settings = {
				id: dhx.uid(),
				dataFeed:this._server_feed
			};
			dhx.ui.views[this._settings.id] = this;

			this.data = { silent:dhx.bind(function(code){
				code.call(this);
			},this)};

			dhx4._eventable(this.data);

			this.attachEvent("onChange", function() {
				this.callEvent("onSelectChange", [this.getSelectedValue()]);
			});
			this.attachEvent("onXLE", function(){
				this.callEvent("onBindRequest",[]);
			});
		}
	};

	dhtmlXCombo.prototype.item = function(id) {
		return this.getOption(id);
	};

	dhtmlXCombo.prototype.getSelected = function() {
		return this.getSelectedValue();
	};
	dhtmlXCombo.prototype.isVisible = function() {
		if (!this.optionsArr.length && !this._settings.dataFeed) return false;
		return true;
	};
	dhtmlXCombo.prototype.refresh = function() {
		this.render(true);
	};
}

if (window.dhtmlXGridObject){
	dhtmlXGridObject.prototype.bind = function(source, rule, format) {
		dhx.BaseBind.bind.apply(this, arguments);
	};
	dhtmlXGridObject.prototype.unbind = function(target){
		dhx.BaseBind._unbind.call(this,target);
	}
	dhtmlXGridObject.prototype.unsync = function(target){
		dhx.BaseBind._unbind.call(this,target);
	}
	
	dhtmlXGridObject.prototype.dataFeed = function(value){
		if (this._settings)
			this._settings.dataFeed = value;
		else
			this._server_feed = value;
	};

	dhtmlXGridObject.prototype.sync = function(source, rule){
		if (this._initBindSource) this._initBindSource();
		if (source._initBindSource) source._initBindSource();

		var grid = this;
		var parsing = "_parsing";
		var parser = "_parser";
		var locator = "_locator";
		var parser_func = "_process_store_row";
		var locator_func = "_get_store_data";

		this.save = function(id){
			if (!id) id = this.getCursor();
			dhx.extend(source.item(id),this.item(id), true);
			source.update(id);
		};
		var insync = function(ignore){
			var cursor = grid.getCursor?grid.getCursor():null;

			var from = 0; 
			if (grid._legacy_ignore_next){
				from  = grid._legacy_ignore_next;
				grid._legacy_ignore_next = false;
			} else {
				grid.clearAll();
			}

			var count = this.dataCount();
			if (count){
				grid[parsing]=true;
				for (var i = from; i < count; i++){
					var id = this.order[i];
					if (!id) continue;
					if (from && grid.rowsBuffer[i]) continue;
					grid.rowsBuffer[i]={
						idd: id,
						data: this.pull[id]
					};
					grid.rowsBuffer[i][parser] = grid[parser_func];
					grid.rowsBuffer[i][locator] = grid[locator_func];
					grid.rowsAr[id]=this.pull[id];
				}
				if (!grid.rowsBuffer[count-1]){
					grid.rowsBuffer[count-1] = dhtmlx.undefined;
					grid.xmlFileUrl = grid.xmlFileUrl||this.url;
				}

				if (grid.pagingOn)
					grid.changePage();
				else {
					if (grid._srnd && grid._fillers)
						grid._update_srnd_view();
					else{
						grid.render_dataset();
						grid.callEvent("onXLE",[]);
					}
				}
				grid[parsing]=false;
			}

			if (cursor && grid.setCursor)
				grid.setCursor(grid.rowsAr[cursor]?cursor:null);

			grid.callEvent("onSyncApply",[]);
		};

		//source.data.attachEvent("onStoreLoad", insync);
		this._sync_events=[
			source.data.attachEvent("onStoreUpdated", function(id, data, mode){ 
				if (mode == "delete"){
					grid.deleteRow(id);
					grid.data.callEvent("onStoreUpdated",[id, data, mode]);
				} else if (mode == "update"){
					grid.callEvent("onSyncUpdate", [data, mode]);
					grid.update(id, data);
					grid.data.callEvent("onStoreUpdated",[id, data, mode]);
				} else if (mode == "add"){
					grid.callEvent("onSyncUpdate", [data, mode]);
					grid.add(id, data, this.indexById(id));
					grid.data.callEvent("onStoreUpdated",[id,data,mode]);
				} else insync.call(this);

			}),
			source.data.attachEvent("onStoreLoad", function(driver, data){
				grid.xmlFileUrl = source.data.url;
				grid._legacy_ignore_next = driver.getInfo(data)._from;
			}),
			source.data.attachEvent("onIdChange", function(oldid, newid){
				grid.changeRowId(oldid, newid);
			})
		];
		
		grid.attachEvent("onDynXLS", function(start, count){
			for (var i=start; i<start+count; i++)
				if (!source.data.order[i]){
					source.loadNext(count, start);
					return false;
				}
			grid._legacy_ignore_next = start;
			insync.call(source.data);
		});

		insync.call(source.data);
		grid.attachEvent("onEditCell", function(stage, id, ind, value, oldvalue){
			if (stage==2 && value != oldvalue)
				this.save(id);
			return true;
		});
		grid.attachEvent("onClearAll",function(){
			var name = "_f_rowsBuffer";
	    	this[name]=null; 
	    });
	
		if (rule && rule.sort)	
			grid.attachEvent("onBeforeSorting", function(ind, type, dir){
				if (type == "connector") return false;
				var id = this.getColumnId(ind);
				source.sort("#"+id+"#", (dir=="asc"?"asc":"desc"), (type=="int"?type:"string"));
				grid.setSortImgState(true, ind, dir);
				return false;
			});

		if (rule && rule.filter){
			grid.attachEvent("onFilterStart", function(cols, values){
				var name = "_con_f_used";
				if (grid[name] && grid[name].length)
					return false;

				source.data.silent(function(){
					source.filter();
					for (var i=0; i<cols.length; i++){
						if (values[i] == "") continue;
						var id = grid.getColumnId(cols[i]);
						source.filter("#"+id+"#", values[i], i!=0);
					}
				});

				source.refresh();
				return false;
			});
			grid.collectValues = function(index){
				var id = this.getColumnId(index);
				return (function(id){
					var values = [];
					var checks = {};
					this.data.each(function(obj){
						var value = obj[id];
						if (!checks[value]){
							checks[value] = true;
							values.push(value);
						}
					});
					values.sort();
					return values;
				}).call(source, id);
			};
		}

		if (rule && rule.select)
			grid.attachEvent("onRowSelect", function(id){
				source.setCursor(id);
			});

		grid.clearAndLoad = function(url){
			source.clearAll();
			source.load(url);
		};
		

				    
	};

	dhtmlXGridObject.prototype._initBindSource = function() { 
		if (dhx.isUndefined(this._settings)){
			this._settings = {
				id: dhx.uid(),
				dataFeed:this._server_feed
			};
			dhx.ui.views[this._settings.id] = this;

			this.data = { silent:dhx.bind(function(code){
				code.call(this);
			},this)};

			dhx4._eventable(this.data);
			var name = "_cCount";
			for (var i=0; i<this[name]; i++)
				if (!this.columnIds[i])
					this.columnIds[i] = "cell"+i;

			this.attachEvent("onSelectStateChanged", function(id) {
				this.callEvent("onSelectChange", [id]);
			});
			this.attachEvent("onSelectionCleared", function() {
				this.callEvent("onSelectChange", [null]);
			});
			this.attachEvent("onEditCell", function(stage,rId) {
				if (stage === 2 && this.getCursor) {
					if (rId && rId == this.getCursor())
						this._update_binds();
				}
				return true;
			});
			this.attachEvent("onXLE", function(){
				this.callEvent("onBindRequest",[]);
			});
		}
	};

	dhtmlXGridObject.prototype.item = function(id) {
		if (id === null) return null;
		var source = this.getRowById(id);
		if (!source) return null;
		
		var name = "_attrs";
		var data = dhx.copy(source[name]);
			data.id = id;
		var length = this.getColumnsNum();
		for (var i = 0; i < length; i++) {
			data[this.columnIds[i]] = this.cells(id, i).getValue();
		}
		return data;
	};

	dhtmlXGridObject.prototype.update = function(id,data){
		for (var i=0; i<this.columnIds.length; i++){
			var key = this.columnIds[i];
			if (!dhx.isUndefined(data[key]))
				this.cells(id, i).setValue(data[key]);
		}
		var name = "_attrs";
		var attrs = this.getRowById(id)[name];
		for (var key in data)
			attrs[key] = data[key];
		this.callEvent("onBindUpdate",[data, null, id]);
	};

	dhtmlXGridObject.prototype.add = function(id,data,index){
		var ar_data = [];
		for (var i=0; i<this.columnIds.length; i++){
			var key = this.columnIds[i];
			ar_data[i] = dhx.isUndefined(data[key])?"":data[key];
		}
		this.addRow(id, ar_data, index);
		var name = "_attrs";
		this.getRowById(id)[name] = dhx.copy(data);
	};

	dhtmlXGridObject.prototype.getSelected = function() {
		return this.getSelectedRowId();
	};
	dhtmlXGridObject.prototype.isVisible = function() {
		var name = "_f_rowsBuffer";
		if (!this.rowsBuffer.length && !this[name] && !this._settings.dataFeed) return false;
		return true;
	};
	dhtmlXGridObject.prototype.refresh = function() {
		this.render_dataset();
	};

	dhtmlXGridObject.prototype.filter = function(callback, master){
		//if (!this.rowsBuffer.length && !this._f_rowsBuffer) return;
		if (this._settings.dataFeed){
			var filter = {};
			if (!callback && !master) return;
			if (typeof callback == "function"){
				if (!master) return;
				callback(master, filter);
			} else  if (dhx.isUndefined(callback))
				filter = master;
			else
				filter[callback] = master;

			this.clearAll(); 
			var url = this._settings.dataFeed;
			if (typeof url == "function")
				return url.call(this, master, filter);

			var urldata = [];
			for (var key in filter)
				urldata.push("dhx_filter["+key+"]="+encodeURIComponent(filter[key]));

			this.load(url+(url.indexOf("?")<0?"?":"&")+urldata.join("&"));
			return false;
		}

		if (master === null) {
			return this.filterBy(0, function(){ return false; });
		}

		this.filterBy(0, function(value, id){
			return callback.call(this, id, master);
		});
	};
}


if (window.dhtmlXTreeObject){
	dhtmlXTreeObject.prototype.bind = function() {
		dhx.BaseBind.bind.apply(this, arguments);
	};
	dhtmlXTreeObject.prototype.unbind = function(target){
		dhx.BaseBind._unbind.call(this,target);
	}

	

	dhtmlXTreeObject.prototype.dataFeed = function(value){
		if (this._settings)
			this._settings.dataFeed = value;
		else
			this._server_feed = value;
	};

	dhtmlXTreeObject.prototype._initBindSource = function() {
		if (dhx.isUndefined(this._settings)){
			this._settings = {
				id: dhx.uid(),
				dataFeed:this._server_feed
			};
			dhx.ui.views[this._settings.id] = this;

			this.data = { silent:dhx.bind(function(code){
				code.call(this);
			},this)};

			dhx4._eventable(this.data);

			this.attachEvent("onSelect", function(id) {
				this.callEvent("onSelectChange", [id]);
			});
			this.attachEvent("onEdit", function(stage,rId) {
				if (stage === 2) {
					if (rId && rId == this.getCursor())
						this._update_binds();
				}
				return true;
			});
		}
	};

	dhtmlXTreeObject.prototype.item = function(id) {
		if (id === null) return null;
		return { id: id, text:this.getItemText(id)};
	};

	dhtmlXTreeObject.prototype.getSelected = function() {
		return this.getSelectedItemId();
	};
	dhtmlXTreeObject.prototype.isVisible = function() {
		return true;
	};
	dhtmlXTreeObject.prototype.refresh = function() {
		//dummy placeholder
	};

	dhtmlXTreeObject.prototype.filter = function(callback, master){
		//dummy placeholder, because tree doesn't support filtering
		if (this._settings.dataFeed){
			var filter = {};
			if (!callback && !master) return;
			if (typeof callback == "function"){
				if (!master) return;
				callback(master, filter);
			} else  if (dhx.isUndefined(callback))
				filter = master;
			else
				filter[callback] = master;

			this.deleteChildItems(0); 
			var url = this._settings.dataFeed;
			if (typeof url == "function")
				return url.call(this, [(data.id||data), data]);
			var urldata = [];
			for (var key in filter)
				urldata.push("dhx_filter["+key+"]="+encodeURIComponent(filter[key]));

			this.loadXML(url+(url.indexOf("?")<0?"?":"&")+urldata.join("&"));
			return false;
		}
	};

	dhtmlXTreeObject.prototype.update = function(id,data){
		if (!dhx.isUndefined(data.text))
			this.setItemText(id, data.text);
	};
}

/*jsl:end*/


})();

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
	* 	@desc: constructor, data processor object 
	*	@param: serverProcessorURL - url used for update
	*	@type: public
	*/
function dataProcessor(serverProcessorURL){
    this.serverProcessor = serverProcessorURL;
    this.action_param="!nativeeditor_status";
    
	this.object = null;
	this.updatedRows = []; //ids of updated rows
	
	this.autoUpdate = true;
	this.updateMode = "cell";
	this._tMode="GET"; 
	this._headers = null;
	this._payload = null;
	this.post_delim = "_";
	
    this._waitMode=0;
    this._in_progress={};//?
    this._invalid={};
    this.mandatoryFields=[];
    this.messages=[];
    
    this.styles={
    	updated:"font-weight:bold;",
    	inserted:"font-weight:bold;",
    	deleted:"text-decoration : line-through;",
    	invalid:"background-color:FFE0E0;",
    	invalid_cell:"border-bottom:2px solid red;",
    	error:"color:red;",
    	clear:"font-weight:normal;text-decoration:none;"
    };
    
    this.enableUTFencoding(true);
    dhx4._eventable(this);

    if (this.connector_init){
    	this.setTransactionMode("POST",true);
		this.serverProcessor+=(this.serverProcessor.indexOf("?")!=-1?"&":"?")+"editing=true";
	};

    return this;
    }

dataProcessor.prototype={
	url:function(str){
		if (str.indexOf("?") != -1)
			return "&";
		else
			return "?";
	},
	setTransactionMode:function(mode,total){
		if (typeof mode == "object"){
			this._tMode = mode.mode || this._tMode;
			this._headers = this._headers || mode.headers;
			this._payload = this._payload || mode.payload;
		} else {
     	    this._tMode=mode;
			this._tSend=total;
		}

		if (this._tMode == "REST"){
			this._tSend = false;
			this._endnm = true;
		}
    },
    escape:function(data){
    	if (this._utf)
    		return encodeURIComponent(data);
    	else
        	return escape(data);
	},
    /**
	* 	@desc: allows to set escaping mode
	*	@param: true - utf based escaping, simple - use current page encoding
	*	@type: public
	*/	
	enableUTFencoding:function(mode){
        this._utf=dhx4.s2b(mode);
    },
    /**
	* 	@desc: allows to define, which column may trigger update
	*	@param: val - array or list of true/false values
	*	@type: public
	*/
	setDataColumns:function(val){
		this._columns=(typeof val == "string")?val.split(","):val;
    },
    /**
	* 	@desc: get state of updating
	*	@returns:   true - all in sync with server, false - some items not updated yet.
	*	@type: public
	*/
	getSyncState:function(){
		return !this.updatedRows.length;
	},
	/**
	* 	@desc: enable/disable named field for data syncing, will use column ids for grid
	*	@param:   mode - true/false
	*	@type: public
	*/
	enableDataNames:function(mode){
		this._endnm=dhx4.s2b(mode);
	},
	/**
	* 	@desc: enable/disable mode , when only changed fields and row id send to the server side, instead of all fields in default mode
	*	@param:   mode - true/false
	*	@type: public
	*/
	enablePartialDataSend:function(mode){
		this._changed=dhx4.s2b(mode);
	},
	/**
	* 	@desc: set if rows should be send to server automaticaly
	*	@param: mode - "row" - based on row selection changed, "cell" - based on cell editing finished, "off" - manual data sending
	*	@type: public
	*/
	setUpdateMode:function(mode,dnd){
		this.autoUpdate = (mode=="cell");
		this.updateMode = mode;
		this.dnd=dnd;
	},
	ignore:function(code,master){
		this._silent_mode=true;
		code.call(master||window);
		this._silent_mode=false;
	},
	/**
	* 	@desc: mark row as updated/normal. check mandatory fields,initiate autoupdate (if turned on)
	*	@param: rowId - id of row to set update-status for
	*	@param: state - true for "updated", false for "not updated"
	*	@param: mode - update mode name
	*	@type: public
	*/
	setUpdated:function(rowId,state,mode){
		this._log("item "+rowId+" "+(state?"marked":"unmarked")+" ["+(mode||"updated")+"]");

		if (this._silent_mode) return;
		var ind=this.findRow(rowId);
		
		mode=mode||"updated";
		var existing = this.obj.getUserData(rowId,this.action_param);
		if (existing && mode == "updated") mode=existing;
		if (state){
			this.set_invalid(rowId,false); //clear previous error flag
			this.updatedRows[ind]=rowId;
			this.obj.setUserData(rowId,this.action_param,mode);
			if (this._in_progress[rowId]) 
				this._in_progress[rowId]="wait";
		} else{
			if (!this.is_invalid(rowId)){
				this.updatedRows.splice(ind,1);
				this.obj.setUserData(rowId,this.action_param,"");
			}
		}

		//clear changed flag
		if (!state)
			this._clearUpdateFlag(rowId);
     			
		this.markRow(rowId,state,mode);
		if (state && this.autoUpdate) this.sendData(rowId);
	},
	_clearUpdateFlag:function(id){},
	markRow:function(id,state,mode){ 
		var str="";
		var invalid=this.is_invalid(id);
		if (invalid){
        	str=this.styles[invalid];
        	state=true;
    	}
		if (this.callEvent("onRowMark",[id,state,mode,invalid])){
			//default logic
			str=this.styles[state?mode:"clear"]+str;
			
        	this.obj[this._methods[0]](id,str);

			if (invalid && invalid.details){
				str+=this.styles[invalid+"_cell"];
				for (var i=0; i < invalid.details.length; i++)
					if (invalid.details[i])
        				this.obj[this._methods[1]](id,i,str);
			}
		}
	},
	getState:function(id){
		return this.obj.getUserData(id,this.action_param);
	},
	is_invalid:function(id){
		return this._invalid[id];
	},
	set_invalid:function(id,mode,details){ 
		if (details) mode={value:mode, details:details, toString:function(){ return this.value.toString(); }};
		this._invalid[id]=mode;
	},
	/**
	* 	@desc: check mandatory fields and varify values of cells, initiate update (if specified)
	*	@param: rowId - id of row to set update-status for
	*	@type: public
	*/
	checkBeforeUpdate:function(rowId){ 
		return true;
	},
	/**
	* 	@desc: send row(s) values to server
	*	@param: rowId - id of row which data to send. If not specified, then all "updated" rows will be send
	*	@type: public
	*/
	sendData:function(rowId){
		if (rowId)
			this._log("Sending: "+rowId);

		if (this._waitMode && (this.obj.mytype=="tree" || this.obj._h2)) return;
		if (this.obj.editStop) this.obj.editStop();
	
		
		if(typeof rowId == "undefined" || this._tSend) return this.sendAllData();
		if (this._in_progress[rowId]) return false;
		
		this.messages=[];
		if (this.getState(rowId) !== "deleted")
			if (!this.checkBeforeUpdate(rowId) && this.callEvent("onValidationError",[rowId,this.messages])) return false;

		this._beforeSendData(this._getRowData(rowId),rowId);
    },
    _beforeSendData:function(data,rowId){
    	if (!this.callEvent("onBeforeUpdate",[rowId,this.getState(rowId),data])) return false;	
		this._sendData(data,rowId);
    },
    serialize:function(data, id){
    	if (typeof data == "string")
    		return data;
    	if (typeof id != "undefined")
    		return this.serialize_one(data,"");
    	else{
    		var stack = [];
    		var keys = [];
    		for (var key in data)
    			if (data.hasOwnProperty(key)){
    				stack.push(this.serialize_one(data[key],key+this.post_delim));
    				keys.push(key);
				}
    		stack.push("ids="+this.escape(keys.join(",")));
    		if (window.dhtmlx && dhtmlx.security_key)
				stack.push("dhx_security="+dhtmlx.security_key);
    		return stack.join("&");
    	}
    },
    serialize_one:function(data, pref){
    	if (typeof data == "string")
    		return data;
    	var stack = [];
    	for (var key in data)
    		if (data.hasOwnProperty(key)){
    			if ((key == "id" || key == this.action_param) && this._tMode == "REST") continue;
    			stack.push(this.escape((pref||"")+key)+"="+this.escape(data[key]));
    		}
		return stack.join("&");
    },
    _applyPayload:function(url){
    	if (this._payload)
      		for (var key in this._payload)
       			url = url + (url.indexOf("?") === -1 ? "?" : "&" ) + this.escape(key) + "=" + this.escape(this._payload[key]);
       	return url;
    },
    _sendData:function(a1,rowId){
    
    	this._log("url: "+this.serverProcessor);
    	this._log(a1)

    	if (!a1) return; //nothing to send
		if (!this.callEvent("onBeforeDataSending",rowId?[rowId,this.getState(rowId),a1]:[null, null, a1])) return false;				
		
    	if (rowId)
			this._in_progress[rowId]=(new Date()).valueOf();

		var that = this;
		var back = function(xml){
			var ids = [];
			if (rowId)
				ids.push(rowId);
			else if (a1)
				for (var key in a1)
					ids.push(key);

			return that.afterUpdate(that,xml,ids);
		};
		
		var a3 = this.serverProcessor+(this._user?(this.url(this.serverProcessor)+["dhx_user="+this._user,"dhx_version="+this.obj.getUserData(0,"version")].join("&")):"");
        var a4 = this._applyPayload(a3);

		if (this._tMode=="GET"){
	     	dhx4.ajax.query({
        		url:a4+((a4.indexOf("?")!=-1)?"&":"?")+this.serialize(a1,rowId),
        		method:"GET",
        		headers:this._headers,
        		callback:back
        	});
		}
		else if (this._tMode == "POST"){
			dhx4.ajax.query({
        		url:a4,
        		method:"POST",
        		headers:this._headers,
        		callback:back,
        		data:this.serialize(a1,rowId)
        	});
		}
        else if (this._tMode == "REST"){
        	var state = this.getState(rowId);
        	var url = a3.replace(/(\&|\?)editing\=true/,"");
        	var parts = url.split("?");
        	if (parts[1])
        		parts[1] = "?"+parts[1];

        	var data = "";
        	var method = "post";

        	if (state == "inserted"){
        		data = this.serialize(a1, rowId);
        	} else if (state == "deleted"){
        		method = "DELETE";
        		url = parts[0]+rowId+(parts[1]||"");
        	} else {
        		method = "PUT";
        		data = this.serialize(a1, rowId);
        		url = parts[0]+rowId+(parts[1]||"");
        	}

        	this._applyPayload(url);
        	dhx4.ajax.query({
        		url:url,
        		method:method,
        		headers:this._headers,
        		data:data,
        		callback:back
        	});
        }

		this._waitMode++;
    },
	sendAllData:function(){
		this._log("Sending all updated items");
		if (!this.updatedRows.length) return;			

		this.messages=[]; var valid=true;
		for (var i=0; i<this.updatedRows.length; i++)
			if (this.getState(this.updatedRows[i]) !== "deleted")
				valid&=this.checkBeforeUpdate(this.updatedRows[i]);

		if (!valid && !this.callEvent("onValidationError",["",this.messages])) return false;
	
		if (this._tSend) 
			this._sendData(this._getAllData());
		else
			for (var i=0; i<this.updatedRows.length; i++)
				if (!this._in_progress[this.updatedRows[i]]){
					if (this.is_invalid(this.updatedRows[i])) continue;
					this._beforeSendData(this._getRowData(this.updatedRows[i]),this.updatedRows[i]);
					if (this._waitMode && (this.obj.mytype=="tree" || this.obj._h2)) return; //block send all for tree
				}
	},
    
	
	
	
	
	
	
	
	_getAllData:function(rowId){
		var out={};
		var has_one = false;
		for(var i=0;i<this.updatedRows.length;i++){
			var id=this.updatedRows[i];
			if (this._in_progress[id] || this.is_invalid(id)) continue;
			if (!this.callEvent("onBeforeUpdate",[id,this.getState(id), this._getRowData(id)])) continue;
			out[id]=this._getRowData(id,id+this.post_delim);
			has_one = true;
			this._in_progress[id]=(new Date()).valueOf();
		}
		return has_one?out:null;
	},
	
	
	/**
	* 	@desc: specify column which value should be varified before sending to server
	*	@param: ind - column index (0 based)
	*	@param: verifFunction - function (object) which should verify cell value (if not specified, then value will be compared to empty string). Two arguments will be passed into it: value and column name
	*	@type: public
	*/
	setVerificator:function(ind,verifFunction){
		this.mandatoryFields[ind] = verifFunction||(function(value){return (value!=="");});
	},
	/**
	* 	@desc: remove column from list of those which should be verified
	*	@param: ind - column Index (0 based)
	*	@type: public
	*/
	clearVerificator:function(ind){
		this.mandatoryFields[ind] = false;
	},
	
	
	
	
	
	findRow:function(pattern){
		var i=0;
    	for(i=0;i<this.updatedRows.length;i++)
		    if(pattern==this.updatedRows[i]) break;
	    return i;
    },

   
	


    





	/**
	* 	@desc: define custom actions
	*	@param: name - name of action, same as value of action attribute
	*	@param: handler - custom function, which receives a XMl response content for action
	*	@type: private
	*/
	defineAction:function(name,handler){
        if (!this._uActions) this._uActions=[];
            this._uActions[name]=handler;
	},




	/**
*     @desc: used in combination with setOnBeforeUpdateHandler to create custom client-server transport system
*     @param: sid - id of item before update
*     @param: tid - id of item after up0ate
*     @param: action - action name
*     @type: public
*     @topic: 0
*/
	afterUpdateCallback:function(sid, tid, action, btag) {
		this._log("Action: "+action+" SID:"+sid+" TID:"+tid, btag);
		var marker = sid;
		var correct=(action!="error" && action!="invalid");
		if (!correct) this.set_invalid(sid,action);
		if ((this._uActions)&&(this._uActions[action])&&(!this._uActions[action](btag))) 
			return (delete this._in_progress[marker]);
			
		if (this._in_progress[marker]!="wait")
	    	this.setUpdated(sid, false);
	    	
	    var soid = sid;
	
	    switch (action) {
	    case "inserted":
	    case "insert":
	        if (tid != sid) {
	            this.obj[this._methods[2]](sid, tid);
	            sid = tid;
	        }
	        break;
	    case "delete":
	    case "deleted":
	    	this.obj.setUserData(sid, this.action_param, "true_deleted");
	        this.obj[this._methods[3]](sid);
	        delete this._in_progress[marker];
	        return this.callEvent("onAfterUpdate", [sid, action, tid, btag]);
	        break;
	    }
	    
	    if (this._in_progress[marker]!="wait"){
	    	if (correct) this.obj.setUserData(sid, this.action_param,'');
	    	delete this._in_progress[marker];
    	} else {
    		delete this._in_progress[marker];
    		this.setUpdated(tid,true,this.obj.getUserData(sid,this.action_param));
		}
	    
	    this.callEvent("onAfterUpdate", [soid, action, tid, btag]);
	},
	enableDebug:function(){
		this._debug = true;
	},
	_log:function(){
		if (this._debug && window.console && window.console.info)
			window.console.info.apply(window.console, arguments);
	},
	/**
	* 	@desc: response from server
	*	@param: xml - XMLLoader object with response XML
	*	@type: private
	*/
	afterUpdate:function(that,xml,id){
		this._log("Server response received");
		//try to use json first
		if (window.JSON){
			try{
				var tag = JSON.parse(xml.xmlDoc.responseText);
				var action = tag.action || this.getState(id) || "updated";
				var sid = tag.sid || id[0];
				var tid = tag.tid || id[0];
				that.afterUpdateCallback(sid, tid, action, tag);
				that.finalizeUpdate();
				return;
			} catch(e){
			}
		}
		//xml response
		var top = dhx4.ajax.xmltop("data", xml.xmlDoc); //fix incorrect content type in IE
		if (!top || top.tagName == "DIV") return this.cleanUpdate(id);
		var atag=dhx4.ajax.xpath("//data/action", top);
		if (!atag.length) return this.cleanUpdate(id);

		for (var i=0; i<atag.length; i++){
        	var btag=atag[i];
			var action = btag.getAttribute("type");
			var sid = btag.getAttribute("sid");
			var tid = btag.getAttribute("tid");
			
			that.afterUpdateCallback(sid,tid,action,btag);
		}
		that.finalizeUpdate();
	},
	cleanUpdate:function(id){
		if (id)
			for (var i = 0; i < id.length; i++)
				delete this._in_progress[id[i]];
	},
	finalizeUpdate:function(){
		if (this._waitMode) this._waitMode--;
		
		if ((this.obj.mytype=="tree" || this.obj._h2) && this.updatedRows.length) 
			this.sendData();
		this.callEvent("onAfterUpdateFinish",[]);
		if (!this.updatedRows.length)
			this.callEvent("onFullSync",[]);
	},




	
	/**
	* 	@desc: initializes data-processor
	*	@param: anObj - dhtmlxGrid object to attach this data-processor to
	*	@type: public
	*/
	init:function(anObj){
		this.obj = anObj;
		if (anObj._dp_init) 
			anObj._dp_init(this);
		if (this.connector_init)
			anObj._dataprocessor=this;
	},
	
	
	setOnAfterUpdate:function(ev){
		this.attachEvent("onAfterUpdate",ev);
	},
	setOnBeforeUpdateHandler:function(func){  
		this.attachEvent("onBeforeDataSending",func);
	},



	/* starts autoupdate mode
		@param interval
			time interval for sending update requests
	*/
	setAutoUpdate: function(interval, user) {
		interval = interval || 2000;
		
		this._user = user || (new Date()).valueOf();
		this._need_update = false;
		this._update_busy = false;
		
		this.attachEvent("onAfterUpdate",function(sid,action,tid,xml_node){
			this.afterAutoUpdate(sid, action, tid, xml_node);
		});
		this.attachEvent("onFullSync",function(){
			this.fullSync();
		});
		
		var self = this;
		window.setInterval(function(){
			self.loadUpdate();
		}, interval);
	},


	/* process updating request answer
		if status == collision version is depricated
		set flag for autoupdating immidiatly
	*/
	afterAutoUpdate: function(sid, action, tid, xml_node) {
		if (action == 'collision') {
			this._need_update = true;
			return false;
		} else {
			return true;
		}
	},


	/* callback function for onFillSync event
		call update function if it's need
	*/
	fullSync: function() {
		if (this._need_update == true) {
			this._need_update = false;
			this.loadUpdate();
		}
		return true;
	},


	/* sends query to the server and call callback function
	*/
	getUpdates: function(url,callback){
		if (this._update_busy) 
			return false;
		else
			this._update_busy = true;
		
		dhx4.ajax.get(url, callback);
	},


	/* returns xml node value
		@param node
			xml node
	*/
	_v: function(node) {
		if (node.firstChild) return node.firstChild.nodeValue;
		return "";
	},


	/* returns values array of xml nodes array
		@param arr
			array of xml nodes
	*/
	_a: function(arr) {
		var res = [];
		for (var i=0; i < arr.length; i++) {
			res[i]=this._v(arr[i]);
		};
		return res;
	},


	/* loads updates and processes them
	*/
	loadUpdate: function(){
		var self = this;
		var version = this.obj.getUserData(0,"version");
		var url = this.serverProcessor+this.url(this.serverProcessor)+["dhx_user="+this._user,"dhx_version="+version].join("&");
		url = url.replace("editing=true&","");
		this.getUpdates(url, function(r){
			var top = dhx4.ajax.xmltop("updates", r.xmlDoc);
			var vers = dhx4.ajax.xpath("//userdata", top);
			self.obj.setUserData(0,"version",self._v(vers[0]));
			
			var upds = dhx4.ajax.xpath("//update", top);
			if (upds.length){
				self._silent_mode = true;
				
				for (var i=0; i<upds.length; i++) {
					var status = upds[i].getAttribute('status');
					var id = upds[i].getAttribute('id');
					var parent = upds[i].getAttribute('parent');
					switch (status) {
						case 'inserted':
							self.callEvent("insertCallback",[upds[i], id, parent]);
							break;
						case 'updated':
							self.callEvent("updateCallback",[upds[i], id, parent]);
							break;
						case 'deleted':
							self.callEvent("deleteCallback",[upds[i], id, parent]);
							break;
					}
				}
				
				self._silent_mode = false;
			}
			
			self._update_busy = false;
			self = null;
		});
	}

};

//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxSuite 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*
	@author dhtmlx.com
	@license GPL, see license.txt
*/

if (window.dataProcessor && !dataProcessor.prototype.init_original)
	dataProcessor.prototype.connector_init=true;


